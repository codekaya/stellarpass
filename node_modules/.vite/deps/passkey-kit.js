import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer5;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer5.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer5.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer5.prototype);
      return buf;
    }
    function Buffer5(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer5.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer5.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer5.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer5.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer5, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer5.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer5.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer5.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer5.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer5.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer5.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer5.alloc(+length);
    }
    Buffer5.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer5.prototype;
    };
    Buffer5.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer5.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer5.from(b, b.offset, b.byteLength);
      if (!Buffer5.isBuffer(a) || !Buffer5.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer5.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer5.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer5.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer5.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer5.isBuffer(buf)) buf = Buffer5.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer5.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer5.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer5.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer5.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer5.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer5.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
    Buffer5.prototype.equals = function equals(b) {
      if (!Buffer5.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer5.compare(this, b) === 0;
    };
    Buffer5.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
    }
    Buffer5.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer5.from(target, target.offset, target.byteLength);
      }
      if (!Buffer5.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer5.from(val, encoding);
      }
      if (Buffer5.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer5.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer5.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer5.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer5.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer5.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer5.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer5.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer5.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer5.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer5.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer5.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer5.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer5.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer5.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer5.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer5.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer5.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer5.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer5.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer5.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer5.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer5.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer5.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer5.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer5.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer5.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer5.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer5.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer5.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer5.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer5.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@stellar/js-xdr/dist/xdr.js
var require_xdr = __commonJS({
  "node_modules/@stellar/js-xdr/dist/xdr.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.XDR = e() : t.XDR = e();
    }(exports, () => (() => {
      var t = { 616: (t2, e2, r2) => {
        "use strict";
        r2.d(e2, { A: () => i });
        var n = r2(287);
        n.hp.alloc(1).subarray(0, 1) instanceof n.hp || (n.hp.prototype.subarray = function(t3, e3) {
          const r3 = Uint8Array.prototype.subarray.call(this, t3, e3);
          return Object.setPrototypeOf(r3, n.hp.prototype), r3;
        });
        const i = n.hp;
      }, 281: (t2, e2, r2) => {
        const n = r2(164);
        t2.exports = n;
      }, 164: (t2, e2, r2) => {
        "use strict";
        r2.r(e2), r2.d(e2, { Array: () => F, Bool: () => S, Double: () => L, Enum: () => q, Float: () => O, Hyper: () => U, Int: () => v, LargeInt: () => x, Opaque: () => D, Option: () => X, Quadruple: () => N, Reference: () => G, String: () => M, Struct: () => Y, Union: () => W, UnsignedHyper: () => T, UnsignedInt: () => R, VarArray: () => P, VarOpaque: () => z, Void: () => k, XdrReader: () => f, XdrWriter: () => c, config: () => it });
        class n extends TypeError {
          constructor(t3) {
            super(`XDR Write Error: ${t3}`);
          }
        }
        class i extends TypeError {
          constructor(t3) {
            super(`XDR Read Error: ${t3}`);
          }
        }
        class o extends TypeError {
          constructor(t3) {
            super(`XDR Type Definition Error: ${t3}`);
          }
        }
        class s extends o {
          constructor() {
            super("method not implemented, it should be overloaded in the descendant class.");
          }
        }
        var u = r2(616).A;
        class f {
          constructor(t3) {
            __publicField(this, "_buffer");
            __publicField(this, "_length");
            __publicField(this, "_index");
            if (!u.isBuffer(t3)) {
              if (!(t3 instanceof Array || Array.isArray(t3) || ArrayBuffer.isView(t3))) throw new i(`source invalid: ${t3}`);
              t3 = u.from(t3);
            }
            this._buffer = t3, this._length = t3.length, this._index = 0;
          }
          get eof() {
            return this._index === this._length;
          }
          advance(t3) {
            const e3 = this._index;
            if (this._index += t3, this._length < this._index) throw new i("attempt to read outside the boundary of the buffer");
            const r3 = 4 - (t3 % 4 || 4);
            if (r3 > 0) {
              for (let t4 = 0; t4 < r3; t4++) if (0 !== this._buffer[this._index + t4]) throw new i("invalid padding");
              this._index += r3;
            }
            return e3;
          }
          rewind() {
            this._index = 0;
          }
          read(t3) {
            const e3 = this.advance(t3);
            return this._buffer.subarray(e3, e3 + t3);
          }
          readInt32BE() {
            return this._buffer.readInt32BE(this.advance(4));
          }
          readUInt32BE() {
            return this._buffer.readUInt32BE(this.advance(4));
          }
          readBigInt64BE() {
            return this._buffer.readBigInt64BE(this.advance(8));
          }
          readBigUInt64BE() {
            return this._buffer.readBigUInt64BE(this.advance(8));
          }
          readFloatBE() {
            return this._buffer.readFloatBE(this.advance(4));
          }
          readDoubleBE() {
            return this._buffer.readDoubleBE(this.advance(8));
          }
          ensureInputConsumed() {
            if (this._index !== this._length) throw new i("invalid XDR contract typecast - source buffer not entirely consumed");
          }
        }
        var a = r2(616).A;
        const h = 8192;
        class c {
          constructor(t3) {
            __publicField(this, "_buffer");
            __publicField(this, "_length");
            __publicField(this, "_index", 0);
            "number" == typeof t3 ? t3 = a.allocUnsafe(t3) : t3 instanceof a || (t3 = a.allocUnsafe(h)), this._buffer = t3, this._length = t3.length;
          }
          alloc(t3) {
            const e3 = this._index;
            return this._index += t3, this._length < this._index && this.resize(this._index), e3;
          }
          resize(t3) {
            const e3 = Math.ceil(t3 / h) * h, r3 = a.allocUnsafe(e3);
            this._buffer.copy(r3, 0, 0, this._length), this._buffer = r3, this._length = e3;
          }
          finalize() {
            return this._buffer.subarray(0, this._index);
          }
          toArray() {
            return [...this.finalize()];
          }
          write(t3, e3) {
            if ("string" == typeof t3) {
              const r4 = this.alloc(e3);
              this._buffer.write(t3, r4, "utf8");
            } else {
              t3 instanceof a || (t3 = a.from(t3));
              const r4 = this.alloc(e3);
              t3.copy(this._buffer, r4, 0, e3);
            }
            const r3 = 4 - (e3 % 4 || 4);
            if (r3 > 0) {
              const t4 = this.alloc(r3);
              this._buffer.fill(0, t4, this._index);
            }
          }
          writeInt32BE(t3) {
            const e3 = this.alloc(4);
            this._buffer.writeInt32BE(t3, e3);
          }
          writeUInt32BE(t3) {
            const e3 = this.alloc(4);
            this._buffer.writeUInt32BE(t3, e3);
          }
          writeBigInt64BE(t3) {
            const e3 = this.alloc(8);
            this._buffer.writeBigInt64BE(t3, e3);
          }
          writeBigUInt64BE(t3) {
            const e3 = this.alloc(8);
            this._buffer.writeBigUInt64BE(t3, e3);
          }
          writeFloatBE(t3) {
            const e3 = this.alloc(4);
            this._buffer.writeFloatBE(t3, e3);
          }
          writeDoubleBE(t3) {
            const e3 = this.alloc(8);
            this._buffer.writeDoubleBE(t3, e3);
          }
        }
        __publicField(c, "bufferChunkSize", h);
        var l = r2(616).A;
        class p {
          toXDR(t3 = "raw") {
            if (!this.write) return this.constructor.toXDR(this, t3);
            const e3 = new c();
            return this.write(this, e3), w(e3.finalize(), t3);
          }
          fromXDR(t3, e3 = "raw") {
            if (!this.read) return this.constructor.fromXDR(t3, e3);
            const r3 = new f(m(t3, e3)), n2 = this.read(r3);
            return r3.ensureInputConsumed(), n2;
          }
          validateXDR(t3, e3 = "raw") {
            try {
              return this.fromXDR(t3, e3), true;
            } catch (t4) {
              return false;
            }
          }
          static toXDR(t3, e3 = "raw") {
            const r3 = new c();
            return this.write(t3, r3), w(r3.finalize(), e3);
          }
          static fromXDR(t3, e3 = "raw") {
            const r3 = new f(m(t3, e3)), n2 = this.read(r3);
            return r3.ensureInputConsumed(), n2;
          }
          static validateXDR(t3, e3 = "raw") {
            try {
              return this.fromXDR(t3, e3), true;
            } catch (t4) {
              return false;
            }
          }
        }
        class d extends p {
          static read(t3) {
            throw new s();
          }
          static write(t3, e3) {
            throw new s();
          }
          static isValid(t3) {
            return false;
          }
        }
        class g extends p {
          isValid(t3) {
            return false;
          }
        }
        class y extends TypeError {
          constructor(t3) {
            super(`Invalid format ${t3}, must be one of "raw", "hex", "base64"`);
          }
        }
        function w(t3, e3) {
          switch (e3) {
            case "raw":
              return t3;
            case "hex":
              return t3.toString("hex");
            case "base64":
              return t3.toString("base64");
            default:
              throw new y(e3);
          }
        }
        function m(t3, e3) {
          switch (e3) {
            case "raw":
              return t3;
            case "hex":
              return l.from(t3, "hex");
            case "base64":
              return l.from(t3, "base64");
            default:
              throw new y(e3);
          }
        }
        function b(t3, e3) {
          return null != t3 && (t3 instanceof e3 || _(t3, e3) && "function" == typeof t3.constructor.read && "function" == typeof t3.constructor.write && _(t3, "XdrType"));
        }
        function _(t3, e3) {
          do {
            if (t3.constructor.name === e3) return true;
          } while (t3 = Object.getPrototypeOf(t3));
          return false;
        }
        const B = 2147483647, E = -2147483648;
        class v extends d {
          static read(t3) {
            return t3.readInt32BE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3) throw new n("not a number");
            if ((0 | t3) !== t3) throw new n("invalid i32 value");
            e3.writeInt32BE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3 && (0 | t3) === t3 && (t3 >= E && t3 <= B);
          }
        }
        function A(t3, e3, r3) {
          if ("bigint" != typeof t3) throw new TypeError("Expected bigint 'value', got " + typeof t3);
          const n2 = e3 / r3;
          if (1 === n2) return [t3];
          if (r3 < 32 || r3 > 128 || 2 !== n2 && 4 !== n2 && 8 !== n2) throw new TypeError(`invalid bigint (${t3}) and slice size (${e3} -> ${r3}) combination`);
          const i2 = BigInt(r3), o2 = new Array(n2);
          for (let e4 = 0; e4 < n2; e4++) o2[e4] = BigInt.asIntN(r3, t3), t3 >>= i2;
          return o2;
        }
        function I(t3, e3) {
          if (e3) return [0n, (1n << BigInt(t3)) - 1n];
          const r3 = 1n << BigInt(t3 - 1);
          return [0n - r3, r3 - 1n];
        }
        v.MAX_VALUE = B, v.MIN_VALUE = 2147483648;
        class x extends d {
          constructor(t3) {
            super(), this._value = function(t4, e3, r3) {
              t4 instanceof Array ? t4.length && t4[0] instanceof Array && (t4 = t4[0]) : t4 = [t4];
              const n2 = e3 / t4.length;
              switch (n2) {
                case 32:
                case 64:
                case 128:
                case 256:
                  break;
                default:
                  throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${t4}`);
              }
              try {
                for (let e4 = 0; e4 < t4.length; e4++) "bigint" != typeof t4[e4] && (t4[e4] = BigInt(t4[e4].valueOf()));
              } catch (e4) {
                throw new TypeError(`expected bigint-like values, got: ${t4} (${e4})`);
              }
              if (r3 && 1 === t4.length && t4[0] < 0n) throw new RangeError(`expected a positive value, got: ${t4}`);
              let i2 = BigInt.asUintN(n2, t4[0]);
              for (let e4 = 1; e4 < t4.length; e4++) i2 |= BigInt.asUintN(n2, t4[e4]) << BigInt(e4 * n2);
              r3 || (i2 = BigInt.asIntN(e3, i2));
              const [o2, s2] = I(e3, r3);
              if (i2 >= o2 && i2 <= s2) return i2;
              throw new TypeError(`bigint values [${t4}] for ${function(t5, e4) {
                return `${e4 ? "u" : "i"}${t5}`;
              }(e3, r3)} out of range [${o2}, ${s2}]: ${i2}`);
            }(t3, this.size, this.unsigned);
          }
          get unsigned() {
            throw new s();
          }
          get size() {
            throw new s();
          }
          slice(t3) {
            return A(this._value, this.size, t3);
          }
          toString() {
            return this._value.toString();
          }
          toJSON() {
            return { _value: this._value.toString() };
          }
          toBigInt() {
            return BigInt(this._value);
          }
          static read(t3) {
            const { size: e3 } = this.prototype;
            return 64 === e3 ? new this(t3.readBigUInt64BE()) : new this(...Array.from({ length: e3 / 64 }, () => t3.readBigUInt64BE()).reverse());
          }
          static write(t3, e3) {
            if (t3 instanceof this) t3 = t3._value;
            else if ("bigint" != typeof t3 || t3 > this.MAX_VALUE || t3 < this.MIN_VALUE) throw new n(`${t3} is not a ${this.name}`);
            const { unsigned: r3, size: i2 } = this.prototype;
            if (64 === i2) r3 ? e3.writeBigUInt64BE(t3) : e3.writeBigInt64BE(t3);
            else for (const n2 of A(t3, i2, 64).reverse()) r3 ? e3.writeBigUInt64BE(n2) : e3.writeBigInt64BE(n2);
          }
          static isValid(t3) {
            return "bigint" == typeof t3 || t3 instanceof this;
          }
          static fromString(t3) {
            return new this(t3);
          }
          static defineIntBoundaries() {
            const [t3, e3] = I(this.prototype.size, this.prototype.unsigned);
            this.MIN_VALUE = t3, this.MAX_VALUE = e3;
          }
        }
        __publicField(x, "MAX_VALUE", 0n);
        __publicField(x, "MIN_VALUE", 0n);
        class U extends x {
          constructor(...t3) {
            super(t3);
          }
          get low() {
            return Number(0xffffffffn & this._value) | 0;
          }
          get high() {
            return Number(this._value >> 32n) | 0;
          }
          get size() {
            return 64;
          }
          get unsigned() {
            return false;
          }
          static fromBits(t3, e3) {
            return new this(t3, e3);
          }
        }
        U.defineIntBoundaries();
        const $ = 4294967295;
        class R extends d {
          static read(t3) {
            return t3.readUInt32BE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3 || !(t3 >= 0 && t3 <= $) || t3 % 1 != 0) throw new n("invalid u32 value");
            e3.writeUInt32BE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3 && t3 % 1 == 0 && (t3 >= 0 && t3 <= $);
          }
        }
        R.MAX_VALUE = $, R.MIN_VALUE = 0;
        class T extends x {
          constructor(...t3) {
            super(t3);
          }
          get low() {
            return Number(0xffffffffn & this._value) | 0;
          }
          get high() {
            return Number(this._value >> 32n) | 0;
          }
          get size() {
            return 64;
          }
          get unsigned() {
            return true;
          }
          static fromBits(t3, e3) {
            return new this(t3, e3);
          }
        }
        T.defineIntBoundaries();
        class O extends d {
          static read(t3) {
            return t3.readFloatBE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3) throw new n("not a number");
            e3.writeFloatBE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3;
          }
        }
        class L extends d {
          static read(t3) {
            return t3.readDoubleBE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3) throw new n("not a number");
            e3.writeDoubleBE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3;
          }
        }
        class N extends d {
          static read() {
            throw new o("quadruple not supported");
          }
          static write() {
            throw new o("quadruple not supported");
          }
          static isValid() {
            return false;
          }
        }
        class S extends d {
          static read(t3) {
            const e3 = v.read(t3);
            switch (e3) {
              case 0:
                return false;
              case 1:
                return true;
              default:
                throw new i(`got ${e3} when trying to read a bool`);
            }
          }
          static write(t3, e3) {
            const r3 = t3 ? 1 : 0;
            v.write(r3, e3);
          }
          static isValid(t3) {
            return "boolean" == typeof t3;
          }
        }
        var V = r2(616).A;
        class M extends g {
          constructor(t3 = R.MAX_VALUE) {
            super(), this._maxLength = t3;
          }
          read(t3) {
            const e3 = R.read(t3);
            if (e3 > this._maxLength) throw new i(`saw ${e3} length String, max allowed is ${this._maxLength}`);
            return t3.read(e3);
          }
          readString(t3) {
            return this.read(t3).toString("utf8");
          }
          write(t3, e3) {
            const r3 = "string" == typeof t3 ? V.byteLength(t3, "utf8") : t3.length;
            if (r3 > this._maxLength) throw new n(`got ${t3.length} bytes, max allowed is ${this._maxLength}`);
            R.write(r3, e3), e3.write(t3, r3);
          }
          isValid(t3) {
            return "string" == typeof t3 ? V.byteLength(t3, "utf8") <= this._maxLength : !!(t3 instanceof Array || V.isBuffer(t3)) && t3.length <= this._maxLength;
          }
        }
        var C = r2(616).A;
        class D extends g {
          constructor(t3) {
            super(), this._length = t3;
          }
          read(t3) {
            return t3.read(this._length);
          }
          write(t3, e3) {
            const { length: r3 } = t3;
            if (r3 !== this._length) throw new n(`got ${t3.length} bytes, expected ${this._length}`);
            e3.write(t3, r3);
          }
          isValid(t3) {
            return C.isBuffer(t3) && t3.length === this._length;
          }
        }
        var j = r2(616).A;
        class z extends g {
          constructor(t3 = R.MAX_VALUE) {
            super(), this._maxLength = t3;
          }
          read(t3) {
            const e3 = R.read(t3);
            if (e3 > this._maxLength) throw new i(`saw ${e3} length VarOpaque, max allowed is ${this._maxLength}`);
            return t3.read(e3);
          }
          write(t3, e3) {
            const { length: r3 } = t3;
            if (t3.length > this._maxLength) throw new n(`got ${t3.length} bytes, max allowed is ${this._maxLength}`);
            R.write(r3, e3), e3.write(t3, r3);
          }
          isValid(t3) {
            return j.isBuffer(t3) && t3.length <= this._maxLength;
          }
        }
        class F extends g {
          constructor(t3, e3) {
            super(), this._childType = t3, this._length = e3;
          }
          read(t3) {
            const e3 = new r2.g.Array(this._length);
            for (let r3 = 0; r3 < this._length; r3++) e3[r3] = this._childType.read(t3);
            return e3;
          }
          write(t3, e3) {
            if (!r2.g.Array.isArray(t3)) throw new n("value is not array");
            if (t3.length !== this._length) throw new n(`got array of size ${t3.length}, expected ${this._length}`);
            for (const r3 of t3) this._childType.write(r3, e3);
          }
          isValid(t3) {
            if (!(t3 instanceof r2.g.Array) || t3.length !== this._length) return false;
            for (const e3 of t3) if (!this._childType.isValid(e3)) return false;
            return true;
          }
        }
        class P extends g {
          constructor(t3, e3 = R.MAX_VALUE) {
            super(), this._childType = t3, this._maxLength = e3;
          }
          read(t3) {
            const e3 = R.read(t3);
            if (e3 > this._maxLength) throw new i(`saw ${e3} length VarArray, max allowed is ${this._maxLength}`);
            const r3 = new Array(e3);
            for (let n2 = 0; n2 < e3; n2++) r3[n2] = this._childType.read(t3);
            return r3;
          }
          write(t3, e3) {
            if (!(t3 instanceof Array)) throw new n("value is not array");
            if (t3.length > this._maxLength) throw new n(`got array of size ${t3.length}, max allowed is ${this._maxLength}`);
            R.write(t3.length, e3);
            for (const r3 of t3) this._childType.write(r3, e3);
          }
          isValid(t3) {
            if (!(t3 instanceof Array) || t3.length > this._maxLength) return false;
            for (const e3 of t3) if (!this._childType.isValid(e3)) return false;
            return true;
          }
        }
        class X extends d {
          constructor(t3) {
            super(), this._childType = t3;
          }
          read(t3) {
            if (S.read(t3)) return this._childType.read(t3);
          }
          write(t3, e3) {
            const r3 = null != t3;
            S.write(r3, e3), r3 && this._childType.write(t3, e3);
          }
          isValid(t3) {
            return null == t3 || this._childType.isValid(t3);
          }
        }
        class k extends d {
          static read() {
          }
          static write(t3) {
            if (void 0 !== t3) throw new n("trying to write value to a void slot");
          }
          static isValid(t3) {
            return void 0 === t3;
          }
        }
        class q extends d {
          constructor(t3, e3) {
            super(), this.name = t3, this.value = e3;
          }
          static read(t3) {
            const e3 = v.read(t3), r3 = this._byValue[e3];
            if (void 0 === r3) throw new i(`unknown ${this.enumName} member for value ${e3}`);
            return r3;
          }
          static write(t3, e3) {
            if (!this.isValid(t3)) throw new n(`${t3} has enum name ${t3 == null ? void 0 : t3.enumName}, not ${this.enumName}: ${JSON.stringify(t3)}`);
            v.write(t3.value, e3);
          }
          static isValid(t3) {
            var _a;
            return ((_a = t3 == null ? void 0 : t3.constructor) == null ? void 0 : _a.enumName) === this.enumName || b(t3, this);
          }
          static members() {
            return this._members;
          }
          static values() {
            return Object.values(this._members);
          }
          static fromName(t3) {
            const e3 = this._members[t3];
            if (!e3) throw new TypeError(`${t3} is not a member of ${this.enumName}`);
            return e3;
          }
          static fromValue(t3) {
            const e3 = this._byValue[t3];
            if (void 0 === e3) throw new TypeError(`${t3} is not a value of any member of ${this.enumName}`);
            return e3;
          }
          static create(t3, e3, r3) {
            const n2 = class extends q {
            };
            n2.enumName = e3, t3.results[e3] = n2, n2._members = {}, n2._byValue = {};
            for (const [t4, e4] of Object.entries(r3)) {
              const r4 = new n2(t4, e4);
              n2._members[t4] = r4, n2._byValue[e4] = r4, n2[t4] = () => r4;
            }
            return n2;
          }
        }
        class G extends d {
          resolve() {
            throw new o('"resolve" method should be implemented in the descendant class');
          }
        }
        class Y extends g {
          constructor(t3) {
            super(), this._attributes = t3 || {};
          }
          static read(t3) {
            const e3 = {};
            for (const [r3, n2] of this._fields) e3[r3] = n2.read(t3);
            return new this(e3);
          }
          static write(t3, e3) {
            var _a;
            if (!this.isValid(t3)) throw new n(`${t3} has struct name ${(_a = t3 == null ? void 0 : t3.constructor) == null ? void 0 : _a.structName}, not ${this.structName}: ${JSON.stringify(t3)}`);
            for (const [r3, n2] of this._fields) {
              const i2 = t3._attributes[r3];
              n2.write(i2, e3);
            }
          }
          static isValid(t3) {
            var _a;
            return ((_a = t3 == null ? void 0 : t3.constructor) == null ? void 0 : _a.structName) === this.structName || b(t3, this);
          }
          static create(t3, e3, r3) {
            const n2 = class extends Y {
            };
            n2.structName = e3, t3.results[e3] = n2;
            const i2 = new Array(r3.length);
            for (let e4 = 0; e4 < r3.length; e4++) {
              const o2 = r3[e4], s2 = o2[0];
              let u2 = o2[1];
              u2 instanceof G && (u2 = u2.resolve(t3)), i2[e4] = [s2, u2], n2.prototype[s2] = J(s2);
            }
            return n2._fields = i2, n2;
          }
        }
        function J(t3) {
          return function(e3) {
            return void 0 !== e3 && (this._attributes[t3] = e3), this._attributes[t3];
          };
        }
        class W extends g {
          constructor(t3, e3) {
            super(), this.set(t3, e3);
          }
          set(t3, e3) {
            "string" == typeof t3 && (t3 = this.constructor._switchOn.fromName(t3)), this._switch = t3;
            const r3 = this.constructor.armForSwitch(this._switch);
            this._arm = r3, this._armType = r3 === k ? k : this.constructor._arms[r3], this._value = e3;
          }
          get(t3 = this._arm) {
            if (this._arm !== k && this._arm !== t3) throw new TypeError(`${t3} not set`);
            return this._value;
          }
          switch() {
            return this._switch;
          }
          arm() {
            return this._arm;
          }
          armType() {
            return this._armType;
          }
          value() {
            return this._value;
          }
          static armForSwitch(t3) {
            const e3 = this._switches.get(t3);
            if (void 0 !== e3) return e3;
            if (this._defaultArm) return this._defaultArm;
            throw new TypeError(`Bad union switch: ${t3}`);
          }
          static armTypeForArm(t3) {
            return t3 === k ? k : this._arms[t3];
          }
          static read(t3) {
            const e3 = this._switchOn.read(t3), r3 = this.armForSwitch(e3), n2 = r3 === k ? k : this._arms[r3];
            let i2;
            return i2 = void 0 !== n2 ? n2.read(t3) : r3.read(t3), new this(e3, i2);
          }
          static write(t3, e3) {
            if (!this.isValid(t3)) throw new n(`${t3} has union name ${t3 == null ? void 0 : t3.unionName}, not ${this.unionName}: ${JSON.stringify(t3)}`);
            this._switchOn.write(t3.switch(), e3), t3.armType().write(t3.value(), e3);
          }
          static isValid(t3) {
            var _a;
            return ((_a = t3 == null ? void 0 : t3.constructor) == null ? void 0 : _a.unionName) === this.unionName || b(t3, this);
          }
          static create(t3, e3, r3) {
            const n2 = class extends W {
            };
            n2.unionName = e3, t3.results[e3] = n2, r3.switchOn instanceof G ? n2._switchOn = r3.switchOn.resolve(t3) : n2._switchOn = r3.switchOn, n2._switches = /* @__PURE__ */ new Map(), n2._arms = {};
            let i2 = r3.defaultArm;
            i2 instanceof G && (i2 = i2.resolve(t3)), n2._defaultArm = i2;
            for (const [t4, e4] of r3.switches) {
              const r4 = "string" == typeof t4 ? n2._switchOn.fromName(t4) : t4;
              n2._switches.set(r4, e4);
            }
            if (void 0 !== n2._switchOn.values) for (const t4 of n2._switchOn.values()) n2[t4.name] = function(e4) {
              return new n2(t4, e4);
            }, n2.prototype[t4.name] = function(e4) {
              return this.set(t4, e4);
            };
            if (r3.arms) for (const [e4, i3] of Object.entries(r3.arms)) n2._arms[e4] = i3 instanceof G ? i3.resolve(t3) : i3, i3 !== k && (n2.prototype[e4] = function() {
              return this.get(e4);
            });
            return n2;
          }
        }
        class H extends G {
          constructor(t3) {
            super(), this.name = t3;
          }
          resolve(t3) {
            return t3.definitions[this.name].resolve(t3);
          }
        }
        class Q extends G {
          constructor(t3, e3, r3 = false) {
            super(), this.childReference = t3, this.length = e3, this.variable = r3;
          }
          resolve(t3) {
            let e3 = this.childReference, r3 = this.length;
            return e3 instanceof G && (e3 = e3.resolve(t3)), r3 instanceof G && (r3 = r3.resolve(t3)), this.variable ? new P(e3, r3) : new F(e3, r3);
          }
        }
        class Z extends G {
          constructor(t3) {
            super(), this.childReference = t3, this.name = t3.name;
          }
          resolve(t3) {
            let e3 = this.childReference;
            return e3 instanceof G && (e3 = e3.resolve(t3)), new X(e3);
          }
        }
        class K extends G {
          constructor(t3, e3) {
            super(), this.sizedType = t3, this.length = e3;
          }
          resolve(t3) {
            let e3 = this.length;
            return e3 instanceof G && (e3 = e3.resolve(t3)), new this.sizedType(e3);
          }
        }
        class tt {
          constructor(t3, e3, r3) {
            this.constructor = t3, this.name = e3, this.config = r3;
          }
          resolve(t3) {
            return this.name in t3.results ? t3.results[this.name] : this.constructor(t3, this.name, this.config);
          }
        }
        function et(t3, e3, r3) {
          return r3 instanceof G && (r3 = r3.resolve(t3)), t3.results[e3] = r3, r3;
        }
        function rt(t3, e3, r3) {
          return t3.results[e3] = r3, r3;
        }
        class nt {
          constructor(t3) {
            this._destination = t3, this._definitions = {};
          }
          enum(t3, e3) {
            const r3 = new tt(q.create, t3, e3);
            this.define(t3, r3);
          }
          struct(t3, e3) {
            const r3 = new tt(Y.create, t3, e3);
            this.define(t3, r3);
          }
          union(t3, e3) {
            const r3 = new tt(W.create, t3, e3);
            this.define(t3, r3);
          }
          typedef(t3, e3) {
            const r3 = new tt(et, t3, e3);
            this.define(t3, r3);
          }
          const(t3, e3) {
            const r3 = new tt(rt, t3, e3);
            this.define(t3, r3);
          }
          void() {
            return k;
          }
          bool() {
            return S;
          }
          int() {
            return v;
          }
          hyper() {
            return U;
          }
          uint() {
            return R;
          }
          uhyper() {
            return T;
          }
          float() {
            return O;
          }
          double() {
            return L;
          }
          quadruple() {
            return N;
          }
          string(t3) {
            return new K(M, t3);
          }
          opaque(t3) {
            return new K(D, t3);
          }
          varOpaque(t3) {
            return new K(z, t3);
          }
          array(t3, e3) {
            return new Q(t3, e3);
          }
          varArray(t3, e3) {
            return new Q(t3, e3, true);
          }
          option(t3) {
            return new Z(t3);
          }
          define(t3, e3) {
            if (void 0 !== this._destination[t3]) throw new o(`${t3} is already defined`);
            this._definitions[t3] = e3;
          }
          lookup(t3) {
            return new H(t3);
          }
          resolve() {
            for (const t3 of Object.values(this._definitions)) t3.resolve({ definitions: this._definitions, results: this._destination });
          }
        }
        function it(t3, e3 = {}) {
          if (t3) {
            const r3 = new nt(e3);
            t3(r3), r3.resolve();
          }
          return e3;
        }
      }, 526: (t2, e2) => {
        "use strict";
        e2.byteLength = function(t3) {
          var e3 = u(t3), r3 = e3[0], n2 = e3[1];
          return 3 * (r3 + n2) / 4 - n2;
        }, e2.toByteArray = function(t3) {
          var e3, r3, o2 = u(t3), s2 = o2[0], f2 = o2[1], a = new i(function(t4, e4, r4) {
            return 3 * (e4 + r4) / 4 - r4;
          }(0, s2, f2)), h = 0, c = f2 > 0 ? s2 - 4 : s2;
          for (r3 = 0; r3 < c; r3 += 4) e3 = n[t3.charCodeAt(r3)] << 18 | n[t3.charCodeAt(r3 + 1)] << 12 | n[t3.charCodeAt(r3 + 2)] << 6 | n[t3.charCodeAt(r3 + 3)], a[h++] = e3 >> 16 & 255, a[h++] = e3 >> 8 & 255, a[h++] = 255 & e3;
          2 === f2 && (e3 = n[t3.charCodeAt(r3)] << 2 | n[t3.charCodeAt(r3 + 1)] >> 4, a[h++] = 255 & e3);
          1 === f2 && (e3 = n[t3.charCodeAt(r3)] << 10 | n[t3.charCodeAt(r3 + 1)] << 4 | n[t3.charCodeAt(r3 + 2)] >> 2, a[h++] = e3 >> 8 & 255, a[h++] = 255 & e3);
          return a;
        }, e2.fromByteArray = function(t3) {
          for (var e3, n2 = t3.length, i2 = n2 % 3, o2 = [], s2 = 16383, u2 = 0, a = n2 - i2; u2 < a; u2 += s2) o2.push(f(t3, u2, u2 + s2 > a ? a : u2 + s2));
          1 === i2 ? (e3 = t3[n2 - 1], o2.push(r2[e3 >> 2] + r2[e3 << 4 & 63] + "==")) : 2 === i2 && (e3 = (t3[n2 - 2] << 8) + t3[n2 - 1], o2.push(r2[e3 >> 10] + r2[e3 >> 4 & 63] + r2[e3 << 2 & 63] + "="));
          return o2.join("");
        };
        for (var r2 = [], n = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s) r2[s] = o[s], n[o.charCodeAt(s)] = s;
        function u(t3) {
          var e3 = t3.length;
          if (e3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var r3 = t3.indexOf("=");
          return -1 === r3 && (r3 = e3), [r3, r3 === e3 ? 0 : 4 - r3 % 4];
        }
        function f(t3, e3, n2) {
          for (var i2, o2, s2 = [], u2 = e3; u2 < n2; u2 += 3) i2 = (t3[u2] << 16 & 16711680) + (t3[u2 + 1] << 8 & 65280) + (255 & t3[u2 + 2]), s2.push(r2[(o2 = i2) >> 18 & 63] + r2[o2 >> 12 & 63] + r2[o2 >> 6 & 63] + r2[63 & o2]);
          return s2.join("");
        }
        n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
      }, 287: (t2, e2, r2) => {
        "use strict";
        const n = r2(526), i = r2(251), o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        e2.hp = f, e2.IS = 50;
        const s = 2147483647;
        function u(t3) {
          if (t3 > s) throw new RangeError('The value "' + t3 + '" is invalid for option "size"');
          const e3 = new Uint8Array(t3);
          return Object.setPrototypeOf(e3, f.prototype), e3;
        }
        function f(t3, e3, r3) {
          if ("number" == typeof t3) {
            if ("string" == typeof e3) throw new TypeError('The "string" argument must be of type string. Received type number');
            return c(t3);
          }
          return a(t3, e3, r3);
        }
        function a(t3, e3, r3) {
          if ("string" == typeof t3) return function(t4, e4) {
            "string" == typeof e4 && "" !== e4 || (e4 = "utf8");
            if (!f.isEncoding(e4)) throw new TypeError("Unknown encoding: " + e4);
            const r4 = 0 | g(t4, e4);
            let n3 = u(r4);
            const i3 = n3.write(t4, e4);
            i3 !== r4 && (n3 = n3.slice(0, i3));
            return n3;
          }(t3, e3);
          if (ArrayBuffer.isView(t3)) return function(t4) {
            if (W(t4, Uint8Array)) {
              const e4 = new Uint8Array(t4);
              return p(e4.buffer, e4.byteOffset, e4.byteLength);
            }
            return l(t4);
          }(t3);
          if (null == t3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t3);
          if (W(t3, ArrayBuffer) || t3 && W(t3.buffer, ArrayBuffer)) return p(t3, e3, r3);
          if ("undefined" != typeof SharedArrayBuffer && (W(t3, SharedArrayBuffer) || t3 && W(t3.buffer, SharedArrayBuffer))) return p(t3, e3, r3);
          if ("number" == typeof t3) throw new TypeError('The "value" argument must not be of type number. Received type number');
          const n2 = t3.valueOf && t3.valueOf();
          if (null != n2 && n2 !== t3) return f.from(n2, e3, r3);
          const i2 = function(t4) {
            if (f.isBuffer(t4)) {
              const e4 = 0 | d(t4.length), r4 = u(e4);
              return 0 === r4.length || t4.copy(r4, 0, 0, e4), r4;
            }
            if (void 0 !== t4.length) return "number" != typeof t4.length || H(t4.length) ? u(0) : l(t4);
            if ("Buffer" === t4.type && Array.isArray(t4.data)) return l(t4.data);
          }(t3);
          if (i2) return i2;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t3[Symbol.toPrimitive]) return f.from(t3[Symbol.toPrimitive]("string"), e3, r3);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t3);
        }
        function h(t3) {
          if ("number" != typeof t3) throw new TypeError('"size" argument must be of type number');
          if (t3 < 0) throw new RangeError('The value "' + t3 + '" is invalid for option "size"');
        }
        function c(t3) {
          return h(t3), u(t3 < 0 ? 0 : 0 | d(t3));
        }
        function l(t3) {
          const e3 = t3.length < 0 ? 0 : 0 | d(t3.length), r3 = u(e3);
          for (let n2 = 0; n2 < e3; n2 += 1) r3[n2] = 255 & t3[n2];
          return r3;
        }
        function p(t3, e3, r3) {
          if (e3 < 0 || t3.byteLength < e3) throw new RangeError('"offset" is outside of buffer bounds');
          if (t3.byteLength < e3 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let n2;
          return n2 = void 0 === e3 && void 0 === r3 ? new Uint8Array(t3) : void 0 === r3 ? new Uint8Array(t3, e3) : new Uint8Array(t3, e3, r3), Object.setPrototypeOf(n2, f.prototype), n2;
        }
        function d(t3) {
          if (t3 >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
          return 0 | t3;
        }
        function g(t3, e3) {
          if (f.isBuffer(t3)) return t3.length;
          if (ArrayBuffer.isView(t3) || W(t3, ArrayBuffer)) return t3.byteLength;
          if ("string" != typeof t3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t3);
          const r3 = t3.length, n2 = arguments.length > 2 && true === arguments[2];
          if (!n2 && 0 === r3) return 0;
          let i2 = false;
          for (; ; ) switch (e3) {
            case "ascii":
            case "latin1":
            case "binary":
              return r3;
            case "utf8":
            case "utf-8":
              return G(t3).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r3;
            case "hex":
              return r3 >>> 1;
            case "base64":
              return Y(t3).length;
            default:
              if (i2) return n2 ? -1 : G(t3).length;
              e3 = ("" + e3).toLowerCase(), i2 = true;
          }
        }
        function y(t3, e3, r3) {
          let n2 = false;
          if ((void 0 === e3 || e3 < 0) && (e3 = 0), e3 > this.length) return "";
          if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
          if ((r3 >>>= 0) <= (e3 >>>= 0)) return "";
          for (t3 || (t3 = "utf8"); ; ) switch (t3) {
            case "hex":
              return T(this, e3, r3);
            case "utf8":
            case "utf-8":
              return x(this, e3, r3);
            case "ascii":
              return $(this, e3, r3);
            case "latin1":
            case "binary":
              return R(this, e3, r3);
            case "base64":
              return I(this, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return O(this, e3, r3);
            default:
              if (n2) throw new TypeError("Unknown encoding: " + t3);
              t3 = (t3 + "").toLowerCase(), n2 = true;
          }
        }
        function w(t3, e3, r3) {
          const n2 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n2;
        }
        function m(t3, e3, r3, n2, i2) {
          if (0 === t3.length) return -1;
          if ("string" == typeof r3 ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), H(r3 = +r3) && (r3 = i2 ? 0 : t3.length - 1), r3 < 0 && (r3 = t3.length + r3), r3 >= t3.length) {
            if (i2) return -1;
            r3 = t3.length - 1;
          } else if (r3 < 0) {
            if (!i2) return -1;
            r3 = 0;
          }
          if ("string" == typeof e3 && (e3 = f.from(e3, n2)), f.isBuffer(e3)) return 0 === e3.length ? -1 : b(t3, e3, r3, n2, i2);
          if ("number" == typeof e3) return e3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(t3, e3, r3) : Uint8Array.prototype.lastIndexOf.call(t3, e3, r3) : b(t3, [e3], r3, n2, i2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function b(t3, e3, r3, n2, i2) {
          let o2, s2 = 1, u2 = t3.length, f2 = e3.length;
          if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
            if (t3.length < 2 || e3.length < 2) return -1;
            s2 = 2, u2 /= 2, f2 /= 2, r3 /= 2;
          }
          function a2(t4, e4) {
            return 1 === s2 ? t4[e4] : t4.readUInt16BE(e4 * s2);
          }
          if (i2) {
            let n3 = -1;
            for (o2 = r3; o2 < u2; o2++) if (a2(t3, o2) === a2(e3, -1 === n3 ? 0 : o2 - n3)) {
              if (-1 === n3 && (n3 = o2), o2 - n3 + 1 === f2) return n3 * s2;
            } else -1 !== n3 && (o2 -= o2 - n3), n3 = -1;
          } else for (r3 + f2 > u2 && (r3 = u2 - f2), o2 = r3; o2 >= 0; o2--) {
            let r4 = true;
            for (let n3 = 0; n3 < f2; n3++) if (a2(t3, o2 + n3) !== a2(e3, n3)) {
              r4 = false;
              break;
            }
            if (r4) return o2;
          }
          return -1;
        }
        function _(t3, e3, r3, n2) {
          r3 = Number(r3) || 0;
          const i2 = t3.length - r3;
          n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
          const o2 = e3.length;
          let s2;
          for (n2 > o2 / 2 && (n2 = o2 / 2), s2 = 0; s2 < n2; ++s2) {
            const n3 = parseInt(e3.substr(2 * s2, 2), 16);
            if (H(n3)) return s2;
            t3[r3 + s2] = n3;
          }
          return s2;
        }
        function B(t3, e3, r3, n2) {
          return J(G(e3, t3.length - r3), t3, r3, n2);
        }
        function E(t3, e3, r3, n2) {
          return J(function(t4) {
            const e4 = [];
            for (let r4 = 0; r4 < t4.length; ++r4) e4.push(255 & t4.charCodeAt(r4));
            return e4;
          }(e3), t3, r3, n2);
        }
        function v(t3, e3, r3, n2) {
          return J(Y(e3), t3, r3, n2);
        }
        function A(t3, e3, r3, n2) {
          return J(function(t4, e4) {
            let r4, n3, i2;
            const o2 = [];
            for (let s2 = 0; s2 < t4.length && !((e4 -= 2) < 0); ++s2) r4 = t4.charCodeAt(s2), n3 = r4 >> 8, i2 = r4 % 256, o2.push(i2), o2.push(n3);
            return o2;
          }(e3, t3.length - r3), t3, r3, n2);
        }
        function I(t3, e3, r3) {
          return 0 === e3 && r3 === t3.length ? n.fromByteArray(t3) : n.fromByteArray(t3.slice(e3, r3));
        }
        function x(t3, e3, r3) {
          r3 = Math.min(t3.length, r3);
          const n2 = [];
          let i2 = e3;
          for (; i2 < r3; ) {
            const e4 = t3[i2];
            let o2 = null, s2 = e4 > 239 ? 4 : e4 > 223 ? 3 : e4 > 191 ? 2 : 1;
            if (i2 + s2 <= r3) {
              let r4, n3, u2, f2;
              switch (s2) {
                case 1:
                  e4 < 128 && (o2 = e4);
                  break;
                case 2:
                  r4 = t3[i2 + 1], 128 == (192 & r4) && (f2 = (31 & e4) << 6 | 63 & r4, f2 > 127 && (o2 = f2));
                  break;
                case 3:
                  r4 = t3[i2 + 1], n3 = t3[i2 + 2], 128 == (192 & r4) && 128 == (192 & n3) && (f2 = (15 & e4) << 12 | (63 & r4) << 6 | 63 & n3, f2 > 2047 && (f2 < 55296 || f2 > 57343) && (o2 = f2));
                  break;
                case 4:
                  r4 = t3[i2 + 1], n3 = t3[i2 + 2], u2 = t3[i2 + 3], 128 == (192 & r4) && 128 == (192 & n3) && 128 == (192 & u2) && (f2 = (15 & e4) << 18 | (63 & r4) << 12 | (63 & n3) << 6 | 63 & u2, f2 > 65535 && f2 < 1114112 && (o2 = f2));
              }
            }
            null === o2 ? (o2 = 65533, s2 = 1) : o2 > 65535 && (o2 -= 65536, n2.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | 1023 & o2), n2.push(o2), i2 += s2;
          }
          return function(t4) {
            const e4 = t4.length;
            if (e4 <= U) return String.fromCharCode.apply(String, t4);
            let r4 = "", n3 = 0;
            for (; n3 < e4; ) r4 += String.fromCharCode.apply(String, t4.slice(n3, n3 += U));
            return r4;
          }(n2);
        }
        f.TYPED_ARRAY_SUPPORT = function() {
          try {
            const t3 = new Uint8Array(1), e3 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(t3, e3), 42 === t3.foo();
          } catch (t3) {
            return false;
          }
        }(), f.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(f.prototype, "parent", { enumerable: true, get: function() {
          if (f.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(f.prototype, "offset", { enumerable: true, get: function() {
          if (f.isBuffer(this)) return this.byteOffset;
        } }), f.poolSize = 8192, f.from = function(t3, e3, r3) {
          return a(t3, e3, r3);
        }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array), f.alloc = function(t3, e3, r3) {
          return function(t4, e4, r4) {
            return h(t4), t4 <= 0 ? u(t4) : void 0 !== e4 ? "string" == typeof r4 ? u(t4).fill(e4, r4) : u(t4).fill(e4) : u(t4);
          }(t3, e3, r3);
        }, f.allocUnsafe = function(t3) {
          return c(t3);
        }, f.allocUnsafeSlow = function(t3) {
          return c(t3);
        }, f.isBuffer = function(t3) {
          return null != t3 && true === t3._isBuffer && t3 !== f.prototype;
        }, f.compare = function(t3, e3) {
          if (W(t3, Uint8Array) && (t3 = f.from(t3, t3.offset, t3.byteLength)), W(e3, Uint8Array) && (e3 = f.from(e3, e3.offset, e3.byteLength)), !f.isBuffer(t3) || !f.isBuffer(e3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (t3 === e3) return 0;
          let r3 = t3.length, n2 = e3.length;
          for (let i2 = 0, o2 = Math.min(r3, n2); i2 < o2; ++i2) if (t3[i2] !== e3[i2]) {
            r3 = t3[i2], n2 = e3[i2];
            break;
          }
          return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
        }, f.isEncoding = function(t3) {
          switch (String(t3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, f.concat = function(t3, e3) {
          if (!Array.isArray(t3)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t3.length) return f.alloc(0);
          let r3;
          if (void 0 === e3) for (e3 = 0, r3 = 0; r3 < t3.length; ++r3) e3 += t3[r3].length;
          const n2 = f.allocUnsafe(e3);
          let i2 = 0;
          for (r3 = 0; r3 < t3.length; ++r3) {
            let e4 = t3[r3];
            if (W(e4, Uint8Array)) i2 + e4.length > n2.length ? (f.isBuffer(e4) || (e4 = f.from(e4)), e4.copy(n2, i2)) : Uint8Array.prototype.set.call(n2, e4, i2);
            else {
              if (!f.isBuffer(e4)) throw new TypeError('"list" argument must be an Array of Buffers');
              e4.copy(n2, i2);
            }
            i2 += e4.length;
          }
          return n2;
        }, f.byteLength = g, f.prototype._isBuffer = true, f.prototype.swap16 = function() {
          const t3 = this.length;
          if (t3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let e3 = 0; e3 < t3; e3 += 2) w(this, e3, e3 + 1);
          return this;
        }, f.prototype.swap32 = function() {
          const t3 = this.length;
          if (t3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let e3 = 0; e3 < t3; e3 += 4) w(this, e3, e3 + 3), w(this, e3 + 1, e3 + 2);
          return this;
        }, f.prototype.swap64 = function() {
          const t3 = this.length;
          if (t3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let e3 = 0; e3 < t3; e3 += 8) w(this, e3, e3 + 7), w(this, e3 + 1, e3 + 6), w(this, e3 + 2, e3 + 5), w(this, e3 + 3, e3 + 4);
          return this;
        }, f.prototype.toString = function() {
          const t3 = this.length;
          return 0 === t3 ? "" : 0 === arguments.length ? x(this, 0, t3) : y.apply(this, arguments);
        }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(t3) {
          if (!f.isBuffer(t3)) throw new TypeError("Argument must be a Buffer");
          return this === t3 || 0 === f.compare(this, t3);
        }, f.prototype.inspect = function() {
          let t3 = "";
          const r3 = e2.IS;
          return t3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (t3 += " ... "), "<Buffer " + t3 + ">";
        }, o && (f.prototype[o] = f.prototype.inspect), f.prototype.compare = function(t3, e3, r3, n2, i2) {
          if (W(t3, Uint8Array) && (t3 = f.from(t3, t3.offset, t3.byteLength)), !f.isBuffer(t3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t3);
          if (void 0 === e3 && (e3 = 0), void 0 === r3 && (r3 = t3 ? t3.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), e3 < 0 || r3 > t3.length || n2 < 0 || i2 > this.length) throw new RangeError("out of range index");
          if (n2 >= i2 && e3 >= r3) return 0;
          if (n2 >= i2) return -1;
          if (e3 >= r3) return 1;
          if (this === t3) return 0;
          let o2 = (i2 >>>= 0) - (n2 >>>= 0), s2 = (r3 >>>= 0) - (e3 >>>= 0);
          const u2 = Math.min(o2, s2), a2 = this.slice(n2, i2), h2 = t3.slice(e3, r3);
          for (let t4 = 0; t4 < u2; ++t4) if (a2[t4] !== h2[t4]) {
            o2 = a2[t4], s2 = h2[t4];
            break;
          }
          return o2 < s2 ? -1 : s2 < o2 ? 1 : 0;
        }, f.prototype.includes = function(t3, e3, r3) {
          return -1 !== this.indexOf(t3, e3, r3);
        }, f.prototype.indexOf = function(t3, e3, r3) {
          return m(this, t3, e3, r3, true);
        }, f.prototype.lastIndexOf = function(t3, e3, r3) {
          return m(this, t3, e3, r3, false);
        }, f.prototype.write = function(t3, e3, r3, n2) {
          if (void 0 === e3) n2 = "utf8", r3 = this.length, e3 = 0;
          else if (void 0 === r3 && "string" == typeof e3) n2 = e3, r3 = this.length, e3 = 0;
          else {
            if (!isFinite(e3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r3, r3 = void 0);
          }
          const i2 = this.length - e3;
          if ((void 0 === r3 || r3 > i2) && (r3 = i2), t3.length > 0 && (r3 < 0 || e3 < 0) || e3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          n2 || (n2 = "utf8");
          let o2 = false;
          for (; ; ) switch (n2) {
            case "hex":
              return _(this, t3, e3, r3);
            case "utf8":
            case "utf-8":
              return B(this, t3, e3, r3);
            case "ascii":
            case "latin1":
            case "binary":
              return E(this, t3, e3, r3);
            case "base64":
              return v(this, t3, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return A(this, t3, e3, r3);
            default:
              if (o2) throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), o2 = true;
          }
        }, f.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const U = 4096;
        function $(t3, e3, r3) {
          let n2 = "";
          r3 = Math.min(t3.length, r3);
          for (let i2 = e3; i2 < r3; ++i2) n2 += String.fromCharCode(127 & t3[i2]);
          return n2;
        }
        function R(t3, e3, r3) {
          let n2 = "";
          r3 = Math.min(t3.length, r3);
          for (let i2 = e3; i2 < r3; ++i2) n2 += String.fromCharCode(t3[i2]);
          return n2;
        }
        function T(t3, e3, r3) {
          const n2 = t3.length;
          (!e3 || e3 < 0) && (e3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
          let i2 = "";
          for (let n3 = e3; n3 < r3; ++n3) i2 += Q[t3[n3]];
          return i2;
        }
        function O(t3, e3, r3) {
          const n2 = t3.slice(e3, r3);
          let i2 = "";
          for (let t4 = 0; t4 < n2.length - 1; t4 += 2) i2 += String.fromCharCode(n2[t4] + 256 * n2[t4 + 1]);
          return i2;
        }
        function L(t3, e3, r3) {
          if (t3 % 1 != 0 || t3 < 0) throw new RangeError("offset is not uint");
          if (t3 + e3 > r3) throw new RangeError("Trying to access beyond buffer length");
        }
        function N(t3, e3, r3, n2, i2, o2) {
          if (!f.isBuffer(t3)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (e3 > i2 || e3 < o2) throw new RangeError('"value" argument is out of bounds');
          if (r3 + n2 > t3.length) throw new RangeError("Index out of range");
        }
        function S(t3, e3, r3, n2, i2) {
          P(e3, n2, i2, t3, r3, 7);
          let o2 = Number(e3 & BigInt(4294967295));
          t3[r3++] = o2, o2 >>= 8, t3[r3++] = o2, o2 >>= 8, t3[r3++] = o2, o2 >>= 8, t3[r3++] = o2;
          let s2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
          return t3[r3++] = s2, s2 >>= 8, t3[r3++] = s2, s2 >>= 8, t3[r3++] = s2, s2 >>= 8, t3[r3++] = s2, r3;
        }
        function V(t3, e3, r3, n2, i2) {
          P(e3, n2, i2, t3, r3, 7);
          let o2 = Number(e3 & BigInt(4294967295));
          t3[r3 + 7] = o2, o2 >>= 8, t3[r3 + 6] = o2, o2 >>= 8, t3[r3 + 5] = o2, o2 >>= 8, t3[r3 + 4] = o2;
          let s2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
          return t3[r3 + 3] = s2, s2 >>= 8, t3[r3 + 2] = s2, s2 >>= 8, t3[r3 + 1] = s2, s2 >>= 8, t3[r3] = s2, r3 + 8;
        }
        function M(t3, e3, r3, n2, i2, o2) {
          if (r3 + n2 > t3.length) throw new RangeError("Index out of range");
          if (r3 < 0) throw new RangeError("Index out of range");
        }
        function C(t3, e3, r3, n2, o2) {
          return e3 = +e3, r3 >>>= 0, o2 || M(t3, 0, r3, 4), i.write(t3, e3, r3, n2, 23, 4), r3 + 4;
        }
        function D(t3, e3, r3, n2, o2) {
          return e3 = +e3, r3 >>>= 0, o2 || M(t3, 0, r3, 8), i.write(t3, e3, r3, n2, 52, 8), r3 + 8;
        }
        f.prototype.slice = function(t3, e3) {
          const r3 = this.length;
          (t3 = ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), (e3 = void 0 === e3 ? r3 : ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), e3 < t3 && (e3 = t3);
          const n2 = this.subarray(t3, e3);
          return Object.setPrototypeOf(n2, f.prototype), n2;
        }, f.prototype.readUintLE = f.prototype.readUIntLE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = this[t3], i2 = 1, o2 = 0;
          for (; ++o2 < e3 && (i2 *= 256); ) n2 += this[t3 + o2] * i2;
          return n2;
        }, f.prototype.readUintBE = f.prototype.readUIntBE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = this[t3 + --e3], i2 = 1;
          for (; e3 > 0 && (i2 *= 256); ) n2 += this[t3 + --e3] * i2;
          return n2;
        }, f.prototype.readUint8 = f.prototype.readUInt8 = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 1, this.length), this[t3];
        }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 2, this.length), this[t3] | this[t3 + 1] << 8;
        }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 2, this.length), this[t3] << 8 | this[t3 + 1];
        }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), (this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16) + 16777216 * this[t3 + 3];
        }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), 16777216 * this[t3] + (this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3]);
        }, f.prototype.readBigUInt64LE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = e3 + 256 * this[++t3] + 65536 * this[++t3] + this[++t3] * 2 ** 24, i2 = this[++t3] + 256 * this[++t3] + 65536 * this[++t3] + r3 * 2 ** 24;
          return BigInt(n2) + (BigInt(i2) << BigInt(32));
        }), f.prototype.readBigUInt64BE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = e3 * 2 ** 24 + 65536 * this[++t3] + 256 * this[++t3] + this[++t3], i2 = this[++t3] * 2 ** 24 + 65536 * this[++t3] + 256 * this[++t3] + r3;
          return (BigInt(n2) << BigInt(32)) + BigInt(i2);
        }), f.prototype.readIntLE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = this[t3], i2 = 1, o2 = 0;
          for (; ++o2 < e3 && (i2 *= 256); ) n2 += this[t3 + o2] * i2;
          return i2 *= 128, n2 >= i2 && (n2 -= Math.pow(2, 8 * e3)), n2;
        }, f.prototype.readIntBE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = e3, i2 = 1, o2 = this[t3 + --n2];
          for (; n2 > 0 && (i2 *= 256); ) o2 += this[t3 + --n2] * i2;
          return i2 *= 128, o2 >= i2 && (o2 -= Math.pow(2, 8 * e3)), o2;
        }, f.prototype.readInt8 = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 1, this.length), 128 & this[t3] ? -1 * (255 - this[t3] + 1) : this[t3];
        }, f.prototype.readInt16LE = function(t3, e3) {
          t3 >>>= 0, e3 || L(t3, 2, this.length);
          const r3 = this[t3] | this[t3 + 1] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, f.prototype.readInt16BE = function(t3, e3) {
          t3 >>>= 0, e3 || L(t3, 2, this.length);
          const r3 = this[t3 + 1] | this[t3] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, f.prototype.readInt32LE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16 | this[t3 + 3] << 24;
        }, f.prototype.readInt32BE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), this[t3] << 24 | this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3];
        }, f.prototype.readBigInt64LE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = this[t3 + 4] + 256 * this[t3 + 5] + 65536 * this[t3 + 6] + (r3 << 24);
          return (BigInt(n2) << BigInt(32)) + BigInt(e3 + 256 * this[++t3] + 65536 * this[++t3] + this[++t3] * 2 ** 24);
        }), f.prototype.readBigInt64BE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = (e3 << 24) + 65536 * this[++t3] + 256 * this[++t3] + this[++t3];
          return (BigInt(n2) << BigInt(32)) + BigInt(this[++t3] * 2 ** 24 + 65536 * this[++t3] + 256 * this[++t3] + r3);
        }), f.prototype.readFloatLE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), i.read(this, t3, true, 23, 4);
        }, f.prototype.readFloatBE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), i.read(this, t3, false, 23, 4);
        }, f.prototype.readDoubleLE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 8, this.length), i.read(this, t3, true, 52, 8);
        }, f.prototype.readDoubleBE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 8, this.length), i.read(this, t3, false, 52, 8);
        }, f.prototype.writeUintLE = f.prototype.writeUIntLE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, r3 >>>= 0, !n2) {
            N(this, t3, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
          }
          let i2 = 1, o2 = 0;
          for (this[e3] = 255 & t3; ++o2 < r3 && (i2 *= 256); ) this[e3 + o2] = t3 / i2 & 255;
          return e3 + r3;
        }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, r3 >>>= 0, !n2) {
            N(this, t3, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
          }
          let i2 = r3 - 1, o2 = 1;
          for (this[e3 + i2] = 255 & t3; --i2 >= 0 && (o2 *= 256); ) this[e3 + i2] = t3 / o2 & 255;
          return e3 + r3;
        }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 1, 255, 0), this[e3] = 255 & t3, e3 + 1;
        }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 65535, 0), this[e3] = 255 & t3, this[e3 + 1] = t3 >>> 8, e3 + 2;
        }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 65535, 0), this[e3] = t3 >>> 8, this[e3 + 1] = 255 & t3, e3 + 2;
        }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 4294967295, 0), this[e3 + 3] = t3 >>> 24, this[e3 + 2] = t3 >>> 16, this[e3 + 1] = t3 >>> 8, this[e3] = 255 & t3, e3 + 4;
        }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 4294967295, 0), this[e3] = t3 >>> 24, this[e3 + 1] = t3 >>> 16, this[e3 + 2] = t3 >>> 8, this[e3 + 3] = 255 & t3, e3 + 4;
        }, f.prototype.writeBigUInt64LE = Z(function(t3, e3 = 0) {
          return S(this, t3, e3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), f.prototype.writeBigUInt64BE = Z(function(t3, e3 = 0) {
          return V(this, t3, e3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), f.prototype.writeIntLE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, !n2) {
            const n3 = Math.pow(2, 8 * r3 - 1);
            N(this, t3, e3, r3, n3 - 1, -n3);
          }
          let i2 = 0, o2 = 1, s2 = 0;
          for (this[e3] = 255 & t3; ++i2 < r3 && (o2 *= 256); ) t3 < 0 && 0 === s2 && 0 !== this[e3 + i2 - 1] && (s2 = 1), this[e3 + i2] = (t3 / o2 | 0) - s2 & 255;
          return e3 + r3;
        }, f.prototype.writeIntBE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, !n2) {
            const n3 = Math.pow(2, 8 * r3 - 1);
            N(this, t3, e3, r3, n3 - 1, -n3);
          }
          let i2 = r3 - 1, o2 = 1, s2 = 0;
          for (this[e3 + i2] = 255 & t3; --i2 >= 0 && (o2 *= 256); ) t3 < 0 && 0 === s2 && 0 !== this[e3 + i2 + 1] && (s2 = 1), this[e3 + i2] = (t3 / o2 | 0) - s2 & 255;
          return e3 + r3;
        }, f.prototype.writeInt8 = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 1, 127, -128), t3 < 0 && (t3 = 255 + t3 + 1), this[e3] = 255 & t3, e3 + 1;
        }, f.prototype.writeInt16LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 32767, -32768), this[e3] = 255 & t3, this[e3 + 1] = t3 >>> 8, e3 + 2;
        }, f.prototype.writeInt16BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 32767, -32768), this[e3] = t3 >>> 8, this[e3 + 1] = 255 & t3, e3 + 2;
        }, f.prototype.writeInt32LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 2147483647, -2147483648), this[e3] = 255 & t3, this[e3 + 1] = t3 >>> 8, this[e3 + 2] = t3 >>> 16, this[e3 + 3] = t3 >>> 24, e3 + 4;
        }, f.prototype.writeInt32BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 2147483647, -2147483648), t3 < 0 && (t3 = 4294967295 + t3 + 1), this[e3] = t3 >>> 24, this[e3 + 1] = t3 >>> 16, this[e3 + 2] = t3 >>> 8, this[e3 + 3] = 255 & t3, e3 + 4;
        }, f.prototype.writeBigInt64LE = Z(function(t3, e3 = 0) {
          return S(this, t3, e3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), f.prototype.writeBigInt64BE = Z(function(t3, e3 = 0) {
          return V(this, t3, e3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), f.prototype.writeFloatLE = function(t3, e3, r3) {
          return C(this, t3, e3, true, r3);
        }, f.prototype.writeFloatBE = function(t3, e3, r3) {
          return C(this, t3, e3, false, r3);
        }, f.prototype.writeDoubleLE = function(t3, e3, r3) {
          return D(this, t3, e3, true, r3);
        }, f.prototype.writeDoubleBE = function(t3, e3, r3) {
          return D(this, t3, e3, false, r3);
        }, f.prototype.copy = function(t3, e3, r3, n2) {
          if (!f.isBuffer(t3)) throw new TypeError("argument should be a Buffer");
          if (r3 || (r3 = 0), n2 || 0 === n2 || (n2 = this.length), e3 >= t3.length && (e3 = t3.length), e3 || (e3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3) return 0;
          if (0 === t3.length || 0 === this.length) return 0;
          if (e3 < 0) throw new RangeError("targetStart out of bounds");
          if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
          if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
          n2 > this.length && (n2 = this.length), t3.length - e3 < n2 - r3 && (n2 = t3.length - e3 + r3);
          const i2 = n2 - r3;
          return this === t3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e3, r3, n2) : Uint8Array.prototype.set.call(t3, this.subarray(r3, n2), e3), i2;
        }, f.prototype.fill = function(t3, e3, r3, n2) {
          if ("string" == typeof t3) {
            if ("string" == typeof e3 ? (n2 = e3, e3 = 0, r3 = this.length) : "string" == typeof r3 && (n2 = r3, r3 = this.length), void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
            if ("string" == typeof n2 && !f.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
            if (1 === t3.length) {
              const e4 = t3.charCodeAt(0);
              ("utf8" === n2 && e4 < 128 || "latin1" === n2) && (t3 = e4);
            }
          } else "number" == typeof t3 ? t3 &= 255 : "boolean" == typeof t3 && (t3 = Number(t3));
          if (e3 < 0 || this.length < e3 || this.length < r3) throw new RangeError("Out of range index");
          if (r3 <= e3) return this;
          let i2;
          if (e3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, t3 || (t3 = 0), "number" == typeof t3) for (i2 = e3; i2 < r3; ++i2) this[i2] = t3;
          else {
            const o2 = f.isBuffer(t3) ? t3 : f.from(t3, n2), s2 = o2.length;
            if (0 === s2) throw new TypeError('The value "' + t3 + '" is invalid for argument "value"');
            for (i2 = 0; i2 < r3 - e3; ++i2) this[i2 + e3] = o2[i2 % s2];
          }
          return this;
        };
        const j = {};
        function z(t3, e3, r3) {
          j[t3] = class extends r3 {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: e3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t3}]`, this.stack, delete this.name;
            }
            get code() {
              return t3;
            }
            set code(t4) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: t4, writable: true });
            }
            toString() {
              return `${this.name} [${t3}]: ${this.message}`;
            }
          };
        }
        function F(t3) {
          let e3 = "", r3 = t3.length;
          const n2 = "-" === t3[0] ? 1 : 0;
          for (; r3 >= n2 + 4; r3 -= 3) e3 = `_${t3.slice(r3 - 3, r3)}${e3}`;
          return `${t3.slice(0, r3)}${e3}`;
        }
        function P(t3, e3, r3, n2, i2, o2) {
          if (t3 > r3 || t3 < e3) {
            const n3 = "bigint" == typeof e3 ? "n" : "";
            let i3;
            throw i3 = o2 > 3 ? 0 === e3 || e3 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (o2 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (o2 + 1) - 1}${n3}) and < 2 ** ${8 * (o2 + 1) - 1}${n3}` : `>= ${e3}${n3} and <= ${r3}${n3}`, new j.ERR_OUT_OF_RANGE("value", i3, t3);
          }
          !function(t4, e4, r4) {
            X(e4, "offset"), void 0 !== t4[e4] && void 0 !== t4[e4 + r4] || k(e4, t4.length - (r4 + 1));
          }(n2, i2, o2);
        }
        function X(t3, e3) {
          if ("number" != typeof t3) throw new j.ERR_INVALID_ARG_TYPE(e3, "number", t3);
        }
        function k(t3, e3, r3) {
          if (Math.floor(t3) !== t3) throw X(t3, r3), new j.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", t3);
          if (e3 < 0) throw new j.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new j.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${e3}`, t3);
        }
        z("ERR_BUFFER_OUT_OF_BOUNDS", function(t3) {
          return t3 ? `${t3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), z("ERR_INVALID_ARG_TYPE", function(t3, e3) {
          return `The "${t3}" argument must be of type number. Received type ${typeof e3}`;
        }, TypeError), z("ERR_OUT_OF_RANGE", function(t3, e3, r3) {
          let n2 = `The value of "${t3}" is out of range.`, i2 = r3;
          return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i2 = F(String(r3)) : "bigint" == typeof r3 && (i2 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i2 = F(i2)), i2 += "n"), n2 += ` It must be ${e3}. Received ${i2}`, n2;
        }, RangeError);
        const q = /[^+/0-9A-Za-z-_]/g;
        function G(t3, e3) {
          let r3;
          e3 = e3 || 1 / 0;
          const n2 = t3.length;
          let i2 = null;
          const o2 = [];
          for (let s2 = 0; s2 < n2; ++s2) {
            if (r3 = t3.charCodeAt(s2), r3 > 55295 && r3 < 57344) {
              if (!i2) {
                if (r3 > 56319) {
                  (e3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                if (s2 + 1 === n2) {
                  (e3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                i2 = r3;
                continue;
              }
              if (r3 < 56320) {
                (e3 -= 3) > -1 && o2.push(239, 191, 189), i2 = r3;
                continue;
              }
              r3 = 65536 + (i2 - 55296 << 10 | r3 - 56320);
            } else i2 && (e3 -= 3) > -1 && o2.push(239, 191, 189);
            if (i2 = null, r3 < 128) {
              if ((e3 -= 1) < 0) break;
              o2.push(r3);
            } else if (r3 < 2048) {
              if ((e3 -= 2) < 0) break;
              o2.push(r3 >> 6 | 192, 63 & r3 | 128);
            } else if (r3 < 65536) {
              if ((e3 -= 3) < 0) break;
              o2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            } else {
              if (!(r3 < 1114112)) throw new Error("Invalid code point");
              if ((e3 -= 4) < 0) break;
              o2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            }
          }
          return o2;
        }
        function Y(t3) {
          return n.toByteArray(function(t4) {
            if ((t4 = (t4 = t4.split("=")[0]).trim().replace(q, "")).length < 2) return "";
            for (; t4.length % 4 != 0; ) t4 += "=";
            return t4;
          }(t3));
        }
        function J(t3, e3, r3, n2) {
          let i2;
          for (i2 = 0; i2 < n2 && !(i2 + r3 >= e3.length || i2 >= t3.length); ++i2) e3[i2 + r3] = t3[i2];
          return i2;
        }
        function W(t3, e3) {
          return t3 instanceof e3 || null != t3 && null != t3.constructor && null != t3.constructor.name && t3.constructor.name === e3.name;
        }
        function H(t3) {
          return t3 != t3;
        }
        const Q = function() {
          const t3 = "0123456789abcdef", e3 = new Array(256);
          for (let r3 = 0; r3 < 16; ++r3) {
            const n2 = 16 * r3;
            for (let i2 = 0; i2 < 16; ++i2) e3[n2 + i2] = t3[r3] + t3[i2];
          }
          return e3;
        }();
        function Z(t3) {
          return "undefined" == typeof BigInt ? K : t3;
        }
        function K() {
          throw new Error("BigInt not supported");
        }
      }, 251: (t2, e2) => {
        e2.read = function(t3, e3, r2, n, i) {
          var o, s, u = 8 * i - n - 1, f = (1 << u) - 1, a = f >> 1, h = -7, c = r2 ? i - 1 : 0, l = r2 ? -1 : 1, p = t3[e3 + c];
          for (c += l, o = p & (1 << -h) - 1, p >>= -h, h += u; h > 0; o = 256 * o + t3[e3 + c], c += l, h -= 8) ;
          for (s = o & (1 << -h) - 1, o >>= -h, h += n; h > 0; s = 256 * s + t3[e3 + c], c += l, h -= 8) ;
          if (0 === o) o = 1 - a;
          else {
            if (o === f) return s ? NaN : 1 / 0 * (p ? -1 : 1);
            s += Math.pow(2, n), o -= a;
          }
          return (p ? -1 : 1) * s * Math.pow(2, o - n);
        }, e2.write = function(t3, e3, r2, n, i, o) {
          var s, u, f, a = 8 * o - i - 1, h = (1 << a) - 1, c = h >> 1, l = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, d = n ? 1 : -1, g = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
          for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (u = isNaN(e3) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e3) / Math.LN2), e3 * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), (e3 += s + c >= 1 ? l / f : l * Math.pow(2, 1 - c)) * f >= 2 && (s++, f /= 2), s + c >= h ? (u = 0, s = h) : s + c >= 1 ? (u = (e3 * f - 1) * Math.pow(2, i), s += c) : (u = e3 * Math.pow(2, c - 1) * Math.pow(2, i), s = 0)); i >= 8; t3[r2 + p] = 255 & u, p += d, u /= 256, i -= 8) ;
          for (s = s << i | u, a += i; a > 0; t3[r2 + p] = 255 & s, p += d, s /= 256, a -= 8) ;
          t3[r2 + p - d] |= 128 * g;
        };
      } }, e = {};
      function r(n) {
        var i = e[n];
        if (void 0 !== i) return i.exports;
        var o = e[n] = { exports: {} };
        return t[n](o, o.exports, r), o.exports;
      }
      return r.d = (t2, e2) => {
        for (var n in e2) r.o(e2, n) && !r.o(t2, n) && Object.defineProperty(t2, n, { enumerable: true, get: e2[n] });
      }, r.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (t2) {
          if ("object" == typeof window) return window;
        }
      }(), r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, r(281);
    })());
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js
var require_curr_generated = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var XDR = _interopRequireWildcard(require_xdr());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    var types = XDR.config(function(xdr3) {
      var SCSYMBOL_LIMIT = 32;
      var SC_SPEC_DOC_LIMIT = 1024;
      xdr3.typedef("Value", xdr3.varOpaque());
      xdr3.struct("ScpBallot", [["counter", xdr3.lookup("Uint32")], ["value", xdr3.lookup("Value")]]);
      xdr3["enum"]("ScpStatementType", {
        scpStPrepare: 0,
        scpStConfirm: 1,
        scpStExternalize: 2,
        scpStNominate: 3
      });
      xdr3.struct("ScpNomination", [["quorumSetHash", xdr3.lookup("Hash")], ["votes", xdr3.varArray(xdr3.lookup("Value"), 2147483647)], ["accepted", xdr3.varArray(xdr3.lookup("Value"), 2147483647)]]);
      xdr3.struct("ScpStatementPrepare", [["quorumSetHash", xdr3.lookup("Hash")], ["ballot", xdr3.lookup("ScpBallot")], ["prepared", xdr3.option(xdr3.lookup("ScpBallot"))], ["preparedPrime", xdr3.option(xdr3.lookup("ScpBallot"))], ["nC", xdr3.lookup("Uint32")], ["nH", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScpStatementConfirm", [["ballot", xdr3.lookup("ScpBallot")], ["nPrepared", xdr3.lookup("Uint32")], ["nCommit", xdr3.lookup("Uint32")], ["nH", xdr3.lookup("Uint32")], ["quorumSetHash", xdr3.lookup("Hash")]]);
      xdr3.struct("ScpStatementExternalize", [["commit", xdr3.lookup("ScpBallot")], ["nH", xdr3.lookup("Uint32")], ["commitQuorumSetHash", xdr3.lookup("Hash")]]);
      xdr3.union("ScpStatementPledges", {
        switchOn: xdr3.lookup("ScpStatementType"),
        switchName: "type",
        switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
        arms: {
          prepare: xdr3.lookup("ScpStatementPrepare"),
          confirm: xdr3.lookup("ScpStatementConfirm"),
          externalize: xdr3.lookup("ScpStatementExternalize"),
          nominate: xdr3.lookup("ScpNomination")
        }
      });
      xdr3.struct("ScpStatement", [["nodeId", xdr3.lookup("NodeId")], ["slotIndex", xdr3.lookup("Uint64")], ["pledges", xdr3.lookup("ScpStatementPledges")]]);
      xdr3.struct("ScpEnvelope", [["statement", xdr3.lookup("ScpStatement")], ["signature", xdr3.lookup("Signature")]]);
      xdr3.struct("ScpQuorumSet", [["threshold", xdr3.lookup("Uint32")], ["validators", xdr3.varArray(xdr3.lookup("NodeId"), 2147483647)], ["innerSets", xdr3.varArray(xdr3.lookup("ScpQuorumSet"), 2147483647)]]);
      xdr3.typedef("Thresholds", xdr3.opaque(4));
      xdr3.typedef("String32", xdr3.string(32));
      xdr3.typedef("String64", xdr3.string(64));
      xdr3.typedef("SequenceNumber", xdr3.lookup("Int64"));
      xdr3.typedef("DataValue", xdr3.varOpaque(64));
      xdr3.typedef("PoolId", xdr3.lookup("Hash"));
      xdr3.typedef("AssetCode4", xdr3.opaque(4));
      xdr3.typedef("AssetCode12", xdr3.opaque(12));
      xdr3["enum"]("AssetType", {
        assetTypeNative: 0,
        assetTypeCreditAlphanum4: 1,
        assetTypeCreditAlphanum12: 2,
        assetTypePoolShare: 3
      });
      xdr3.union("AssetCode", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
        arms: {
          assetCode4: xdr3.lookup("AssetCode4"),
          assetCode12: xdr3.lookup("AssetCode12")
        }
      });
      xdr3.struct("AlphaNum4", [["assetCode", xdr3.lookup("AssetCode4")], ["issuer", xdr3.lookup("AccountId")]]);
      xdr3.struct("AlphaNum12", [["assetCode", xdr3.lookup("AssetCode12")], ["issuer", xdr3.lookup("AccountId")]]);
      xdr3.union("Asset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12")
        }
      });
      xdr3.struct("Price", [["n", xdr3.lookup("Int32")], ["d", xdr3.lookup("Int32")]]);
      xdr3.struct("Liabilities", [["buying", xdr3.lookup("Int64")], ["selling", xdr3.lookup("Int64")]]);
      xdr3["enum"]("ThresholdIndices", {
        thresholdMasterWeight: 0,
        thresholdLow: 1,
        thresholdMed: 2,
        thresholdHigh: 3
      });
      xdr3["enum"]("LedgerEntryType", {
        account: 0,
        trustline: 1,
        offer: 2,
        data: 3,
        claimableBalance: 4,
        liquidityPool: 5,
        contractData: 6,
        contractCode: 7,
        configSetting: 8,
        ttl: 9
      });
      xdr3.struct("Signer", [["key", xdr3.lookup("SignerKey")], ["weight", xdr3.lookup("Uint32")]]);
      xdr3["enum"]("AccountFlags", {
        authRequiredFlag: 1,
        authRevocableFlag: 2,
        authImmutableFlag: 4,
        authClawbackEnabledFlag: 8
      });
      xdr3["const"]("MASK_ACCOUNT_FLAGS", 7);
      xdr3["const"]("MASK_ACCOUNT_FLAGS_V17", 15);
      xdr3["const"]("MAX_SIGNERS", 20);
      xdr3.typedef("SponsorshipDescriptor", xdr3.option(xdr3.lookup("AccountId")));
      xdr3.struct("AccountEntryExtensionV3", [["ext", xdr3.lookup("ExtensionPoint")], ["seqLedger", xdr3.lookup("Uint32")], ["seqTime", xdr3.lookup("TimePoint")]]);
      xdr3.union("AccountEntryExtensionV2Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [3, "v3"]],
        arms: {
          v3: xdr3.lookup("AccountEntryExtensionV3")
        }
      });
      xdr3.struct("AccountEntryExtensionV2", [["numSponsored", xdr3.lookup("Uint32")], ["numSponsoring", xdr3.lookup("Uint32")], ["signerSponsoringIDs", xdr3.varArray(xdr3.lookup("SponsorshipDescriptor"), xdr3.lookup("MAX_SIGNERS"))], ["ext", xdr3.lookup("AccountEntryExtensionV2Ext")]]);
      xdr3.union("AccountEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [2, "v2"]],
        arms: {
          v2: xdr3.lookup("AccountEntryExtensionV2")
        }
      });
      xdr3.struct("AccountEntryExtensionV1", [["liabilities", xdr3.lookup("Liabilities")], ["ext", xdr3.lookup("AccountEntryExtensionV1Ext")]]);
      xdr3.union("AccountEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("AccountEntryExtensionV1")
        }
      });
      xdr3.struct("AccountEntry", [["accountId", xdr3.lookup("AccountId")], ["balance", xdr3.lookup("Int64")], ["seqNum", xdr3.lookup("SequenceNumber")], ["numSubEntries", xdr3.lookup("Uint32")], ["inflationDest", xdr3.option(xdr3.lookup("AccountId"))], ["flags", xdr3.lookup("Uint32")], ["homeDomain", xdr3.lookup("String32")], ["thresholds", xdr3.lookup("Thresholds")], ["signers", xdr3.varArray(xdr3.lookup("Signer"), xdr3.lookup("MAX_SIGNERS"))], ["ext", xdr3.lookup("AccountEntryExt")]]);
      xdr3["enum"]("TrustLineFlags", {
        authorizedFlag: 1,
        authorizedToMaintainLiabilitiesFlag: 2,
        trustlineClawbackEnabledFlag: 4
      });
      xdr3["const"]("MASK_TRUSTLINE_FLAGS", 1);
      xdr3["const"]("MASK_TRUSTLINE_FLAGS_V13", 3);
      xdr3["const"]("MASK_TRUSTLINE_FLAGS_V17", 7);
      xdr3["enum"]("LiquidityPoolType", {
        liquidityPoolConstantProduct: 0
      });
      xdr3.union("TrustLineAsset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12"),
          liquidityPoolId: xdr3.lookup("PoolId")
        }
      });
      xdr3.union("TrustLineEntryExtensionV2Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", xdr3.lookup("Int32")], ["ext", xdr3.lookup("TrustLineEntryExtensionV2Ext")]]);
      xdr3.union("TrustLineEntryV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [2, "v2"]],
        arms: {
          v2: xdr3.lookup("TrustLineEntryExtensionV2")
        }
      });
      xdr3.struct("TrustLineEntryV1", [["liabilities", xdr3.lookup("Liabilities")], ["ext", xdr3.lookup("TrustLineEntryV1Ext")]]);
      xdr3.union("TrustLineEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("TrustLineEntryV1")
        }
      });
      xdr3.struct("TrustLineEntry", [["accountId", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("TrustLineAsset")], ["balance", xdr3.lookup("Int64")], ["limit", xdr3.lookup("Int64")], ["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("TrustLineEntryExt")]]);
      xdr3["enum"]("OfferEntryFlags", {
        passiveFlag: 1
      });
      xdr3["const"]("MASK_OFFERENTRY_FLAGS", 1);
      xdr3.union("OfferEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("OfferEntry", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")], ["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("OfferEntryExt")]]);
      xdr3.union("DataEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("DataEntry", [["accountId", xdr3.lookup("AccountId")], ["dataName", xdr3.lookup("String64")], ["dataValue", xdr3.lookup("DataValue")], ["ext", xdr3.lookup("DataEntryExt")]]);
      xdr3["enum"]("ClaimPredicateType", {
        claimPredicateUnconditional: 0,
        claimPredicateAnd: 1,
        claimPredicateOr: 2,
        claimPredicateNot: 3,
        claimPredicateBeforeAbsoluteTime: 4,
        claimPredicateBeforeRelativeTime: 5
      });
      xdr3.union("ClaimPredicate", {
        switchOn: xdr3.lookup("ClaimPredicateType"),
        switchName: "type",
        switches: [["claimPredicateUnconditional", xdr3["void"]()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
        arms: {
          andPredicates: xdr3.varArray(xdr3.lookup("ClaimPredicate"), 2),
          orPredicates: xdr3.varArray(xdr3.lookup("ClaimPredicate"), 2),
          notPredicate: xdr3.option(xdr3.lookup("ClaimPredicate")),
          absBefore: xdr3.lookup("Int64"),
          relBefore: xdr3.lookup("Int64")
        }
      });
      xdr3["enum"]("ClaimantType", {
        claimantTypeV0: 0
      });
      xdr3.struct("ClaimantV0", [["destination", xdr3.lookup("AccountId")], ["predicate", xdr3.lookup("ClaimPredicate")]]);
      xdr3.union("Claimant", {
        switchOn: xdr3.lookup("ClaimantType"),
        switchName: "type",
        switches: [["claimantTypeV0", "v0"]],
        arms: {
          v0: xdr3.lookup("ClaimantV0")
        }
      });
      xdr3["enum"]("ClaimableBalanceIdType", {
        claimableBalanceIdTypeV0: 0
      });
      xdr3.union("ClaimableBalanceId", {
        switchOn: xdr3.lookup("ClaimableBalanceIdType"),
        switchName: "type",
        switches: [["claimableBalanceIdTypeV0", "v0"]],
        arms: {
          v0: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ClaimableBalanceFlags", {
        claimableBalanceClawbackEnabledFlag: 1
      });
      xdr3["const"]("MASK_CLAIMABLE_BALANCE_FLAGS", 1);
      xdr3.union("ClaimableBalanceEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("ClaimableBalanceEntryExtensionV1", [["ext", xdr3.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", xdr3.lookup("Uint32")]]);
      xdr3.union("ClaimableBalanceEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("ClaimableBalanceEntryExtensionV1")
        }
      });
      xdr3.struct("ClaimableBalanceEntry", [["balanceId", xdr3.lookup("ClaimableBalanceId")], ["claimants", xdr3.varArray(xdr3.lookup("Claimant"), 10)], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["ext", xdr3.lookup("ClaimableBalanceEntryExt")]]);
      xdr3.struct("LiquidityPoolConstantProductParameters", [["assetA", xdr3.lookup("Asset")], ["assetB", xdr3.lookup("Asset")], ["fee", xdr3.lookup("Int32")]]);
      xdr3.struct("LiquidityPoolEntryConstantProduct", [["params", xdr3.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", xdr3.lookup("Int64")], ["reserveB", xdr3.lookup("Int64")], ["totalPoolShares", xdr3.lookup("Int64")], ["poolSharesTrustLineCount", xdr3.lookup("Int64")]]);
      xdr3.union("LiquidityPoolEntryBody", {
        switchOn: xdr3.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr3.lookup("LiquidityPoolEntryConstantProduct")
        }
      });
      xdr3.struct("LiquidityPoolEntry", [["liquidityPoolId", xdr3.lookup("PoolId")], ["body", xdr3.lookup("LiquidityPoolEntryBody")]]);
      xdr3["enum"]("ContractDataDurability", {
        temporary: 0,
        persistent: 1
      });
      xdr3.struct("ContractDataEntry", [["ext", xdr3.lookup("ExtensionPoint")], ["contract", xdr3.lookup("ScAddress")], ["key", xdr3.lookup("ScVal")], ["durability", xdr3.lookup("ContractDataDurability")], ["val", xdr3.lookup("ScVal")]]);
      xdr3.struct("ContractCodeCostInputs", [["ext", xdr3.lookup("ExtensionPoint")], ["nInstructions", xdr3.lookup("Uint32")], ["nFunctions", xdr3.lookup("Uint32")], ["nGlobals", xdr3.lookup("Uint32")], ["nTableEntries", xdr3.lookup("Uint32")], ["nTypes", xdr3.lookup("Uint32")], ["nDataSegments", xdr3.lookup("Uint32")], ["nElemSegments", xdr3.lookup("Uint32")], ["nImports", xdr3.lookup("Uint32")], ["nExports", xdr3.lookup("Uint32")], ["nDataSegmentBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("ContractCodeEntryV1", [["ext", xdr3.lookup("ExtensionPoint")], ["costInputs", xdr3.lookup("ContractCodeCostInputs")]]);
      xdr3.union("ContractCodeEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("ContractCodeEntryV1")
        }
      });
      xdr3.struct("ContractCodeEntry", [["ext", xdr3.lookup("ContractCodeEntryExt")], ["hash", xdr3.lookup("Hash")], ["code", xdr3.varOpaque()]]);
      xdr3.struct("TtlEntry", [["keyHash", xdr3.lookup("Hash")], ["liveUntilLedgerSeq", xdr3.lookup("Uint32")]]);
      xdr3.union("LedgerEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerEntryExtensionV1", [["sponsoringId", xdr3.lookup("SponsorshipDescriptor")], ["ext", xdr3.lookup("LedgerEntryExtensionV1Ext")]]);
      xdr3.union("LedgerEntryData", {
        switchOn: xdr3.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr3.lookup("AccountEntry"),
          trustLine: xdr3.lookup("TrustLineEntry"),
          offer: xdr3.lookup("OfferEntry"),
          data: xdr3.lookup("DataEntry"),
          claimableBalance: xdr3.lookup("ClaimableBalanceEntry"),
          liquidityPool: xdr3.lookup("LiquidityPoolEntry"),
          contractData: xdr3.lookup("ContractDataEntry"),
          contractCode: xdr3.lookup("ContractCodeEntry"),
          configSetting: xdr3.lookup("ConfigSettingEntry"),
          ttl: xdr3.lookup("TtlEntry")
        }
      });
      xdr3.union("LedgerEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerEntryExtensionV1")
        }
      });
      xdr3.struct("LedgerEntry", [["lastModifiedLedgerSeq", xdr3.lookup("Uint32")], ["data", xdr3.lookup("LedgerEntryData")], ["ext", xdr3.lookup("LedgerEntryExt")]]);
      xdr3.struct("LedgerKeyAccount", [["accountId", xdr3.lookup("AccountId")]]);
      xdr3.struct("LedgerKeyTrustLine", [["accountId", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("TrustLineAsset")]]);
      xdr3.struct("LedgerKeyOffer", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("LedgerKeyData", [["accountId", xdr3.lookup("AccountId")], ["dataName", xdr3.lookup("String64")]]);
      xdr3.struct("LedgerKeyClaimableBalance", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", xdr3.lookup("PoolId")]]);
      xdr3.struct("LedgerKeyContractData", [["contract", xdr3.lookup("ScAddress")], ["key", xdr3.lookup("ScVal")], ["durability", xdr3.lookup("ContractDataDurability")]]);
      xdr3.struct("LedgerKeyContractCode", [["hash", xdr3.lookup("Hash")]]);
      xdr3.struct("LedgerKeyConfigSetting", [["configSettingId", xdr3.lookup("ConfigSettingId")]]);
      xdr3.struct("LedgerKeyTtl", [["keyHash", xdr3.lookup("Hash")]]);
      xdr3.union("LedgerKey", {
        switchOn: xdr3.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr3.lookup("LedgerKeyAccount"),
          trustLine: xdr3.lookup("LedgerKeyTrustLine"),
          offer: xdr3.lookup("LedgerKeyOffer"),
          data: xdr3.lookup("LedgerKeyData"),
          claimableBalance: xdr3.lookup("LedgerKeyClaimableBalance"),
          liquidityPool: xdr3.lookup("LedgerKeyLiquidityPool"),
          contractData: xdr3.lookup("LedgerKeyContractData"),
          contractCode: xdr3.lookup("LedgerKeyContractCode"),
          configSetting: xdr3.lookup("LedgerKeyConfigSetting"),
          ttl: xdr3.lookup("LedgerKeyTtl")
        }
      });
      xdr3["enum"]("EnvelopeType", {
        envelopeTypeTxV0: 0,
        envelopeTypeScp: 1,
        envelopeTypeTx: 2,
        envelopeTypeAuth: 3,
        envelopeTypeScpvalue: 4,
        envelopeTypeTxFeeBump: 5,
        envelopeTypeOpId: 6,
        envelopeTypePoolRevokeOpId: 7,
        envelopeTypeContractId: 8,
        envelopeTypeSorobanAuthorization: 9
      });
      xdr3["enum"]("BucketListType", {
        live: 0,
        hotArchive: 1,
        coldArchive: 2
      });
      xdr3["enum"]("BucketEntryType", {
        metaentry: -1,
        liveentry: 0,
        deadentry: 1,
        initentry: 2
      });
      xdr3["enum"]("HotArchiveBucketEntryType", {
        hotArchiveMetaentry: -1,
        hotArchiveArchived: 0,
        hotArchiveLive: 1,
        hotArchiveDeleted: 2
      });
      xdr3["enum"]("ColdArchiveBucketEntryType", {
        coldArchiveMetaentry: -1,
        coldArchiveArchivedLeaf: 0,
        coldArchiveDeletedLeaf: 1,
        coldArchiveBoundaryLeaf: 2,
        coldArchiveHash: 3
      });
      xdr3.union("BucketMetadataExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "bucketListType"]],
        arms: {
          bucketListType: xdr3.lookup("BucketListType")
        }
      });
      xdr3.struct("BucketMetadata", [["ledgerVersion", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("BucketMetadataExt")]]);
      xdr3.union("BucketEntry", {
        switchOn: xdr3.lookup("BucketEntryType"),
        switchName: "type",
        switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
        arms: {
          liveEntry: xdr3.lookup("LedgerEntry"),
          deadEntry: xdr3.lookup("LedgerKey"),
          metaEntry: xdr3.lookup("BucketMetadata")
        }
      });
      xdr3.union("HotArchiveBucketEntry", {
        switchOn: xdr3.lookup("HotArchiveBucketEntryType"),
        switchName: "type",
        switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]],
        arms: {
          archivedEntry: xdr3.lookup("LedgerEntry"),
          key: xdr3.lookup("LedgerKey"),
          metaEntry: xdr3.lookup("BucketMetadata")
        }
      });
      xdr3.struct("ColdArchiveArchivedLeaf", [["index", xdr3.lookup("Uint32")], ["archivedEntry", xdr3.lookup("LedgerEntry")]]);
      xdr3.struct("ColdArchiveDeletedLeaf", [["index", xdr3.lookup("Uint32")], ["deletedKey", xdr3.lookup("LedgerKey")]]);
      xdr3.struct("ColdArchiveBoundaryLeaf", [["index", xdr3.lookup("Uint32")], ["isLowerBound", xdr3.bool()]]);
      xdr3.struct("ColdArchiveHashEntry", [["index", xdr3.lookup("Uint32")], ["level", xdr3.lookup("Uint32")], ["hash", xdr3.lookup("Hash")]]);
      xdr3.union("ColdArchiveBucketEntry", {
        switchOn: xdr3.lookup("ColdArchiveBucketEntryType"),
        switchName: "type",
        switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]],
        arms: {
          metaEntry: xdr3.lookup("BucketMetadata"),
          archivedLeaf: xdr3.lookup("ColdArchiveArchivedLeaf"),
          deletedLeaf: xdr3.lookup("ColdArchiveDeletedLeaf"),
          boundaryLeaf: xdr3.lookup("ColdArchiveBoundaryLeaf"),
          hashEntry: xdr3.lookup("ColdArchiveHashEntry")
        }
      });
      xdr3.typedef("UpgradeType", xdr3.varOpaque(128));
      xdr3["enum"]("StellarValueType", {
        stellarValueBasic: 0,
        stellarValueSigned: 1
      });
      xdr3.struct("LedgerCloseValueSignature", [["nodeId", xdr3.lookup("NodeId")], ["signature", xdr3.lookup("Signature")]]);
      xdr3.union("StellarValueExt", {
        switchOn: xdr3.lookup("StellarValueType"),
        switchName: "v",
        switches: [["stellarValueBasic", xdr3["void"]()], ["stellarValueSigned", "lcValueSignature"]],
        arms: {
          lcValueSignature: xdr3.lookup("LedgerCloseValueSignature")
        }
      });
      xdr3.struct("StellarValue", [["txSetHash", xdr3.lookup("Hash")], ["closeTime", xdr3.lookup("TimePoint")], ["upgrades", xdr3.varArray(xdr3.lookup("UpgradeType"), 6)], ["ext", xdr3.lookup("StellarValueExt")]]);
      xdr3["const"]("MASK_LEDGER_HEADER_FLAGS", 7);
      xdr3["enum"]("LedgerHeaderFlags", {
        disableLiquidityPoolTradingFlag: 1,
        disableLiquidityPoolDepositFlag: 2,
        disableLiquidityPoolWithdrawalFlag: 4
      });
      xdr3.union("LedgerHeaderExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerHeaderExtensionV1", [["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("LedgerHeaderExtensionV1Ext")]]);
      xdr3.union("LedgerHeaderExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerHeaderExtensionV1")
        }
      });
      xdr3.struct("LedgerHeader", [["ledgerVersion", xdr3.lookup("Uint32")], ["previousLedgerHash", xdr3.lookup("Hash")], ["scpValue", xdr3.lookup("StellarValue")], ["txSetResultHash", xdr3.lookup("Hash")], ["bucketListHash", xdr3.lookup("Hash")], ["ledgerSeq", xdr3.lookup("Uint32")], ["totalCoins", xdr3.lookup("Int64")], ["feePool", xdr3.lookup("Int64")], ["inflationSeq", xdr3.lookup("Uint32")], ["idPool", xdr3.lookup("Uint64")], ["baseFee", xdr3.lookup("Uint32")], ["baseReserve", xdr3.lookup("Uint32")], ["maxTxSetSize", xdr3.lookup("Uint32")], ["skipList", xdr3.array(xdr3.lookup("Hash"), 4)], ["ext", xdr3.lookup("LedgerHeaderExt")]]);
      xdr3["enum"]("LedgerUpgradeType", {
        ledgerUpgradeVersion: 1,
        ledgerUpgradeBaseFee: 2,
        ledgerUpgradeMaxTxSetSize: 3,
        ledgerUpgradeBaseReserve: 4,
        ledgerUpgradeFlags: 5,
        ledgerUpgradeConfig: 6,
        ledgerUpgradeMaxSorobanTxSetSize: 7
      });
      xdr3.struct("ConfigUpgradeSetKey", [["contractId", xdr3.lookup("Hash")], ["contentHash", xdr3.lookup("Hash")]]);
      xdr3.union("LedgerUpgrade", {
        switchOn: xdr3.lookup("LedgerUpgradeType"),
        switchName: "type",
        switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]],
        arms: {
          newLedgerVersion: xdr3.lookup("Uint32"),
          newBaseFee: xdr3.lookup("Uint32"),
          newMaxTxSetSize: xdr3.lookup("Uint32"),
          newBaseReserve: xdr3.lookup("Uint32"),
          newFlags: xdr3.lookup("Uint32"),
          newConfig: xdr3.lookup("ConfigUpgradeSetKey"),
          newMaxSorobanTxSetSize: xdr3.lookup("Uint32")
        }
      });
      xdr3.struct("ConfigUpgradeSet", [["updatedEntry", xdr3.varArray(xdr3.lookup("ConfigSettingEntry"), 2147483647)]]);
      xdr3["enum"]("TxSetComponentType", {
        txsetCompTxsMaybeDiscountedFee: 0
      });
      xdr3.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", xdr3.option(xdr3.lookup("Int64"))], ["txes", xdr3.varArray(xdr3.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr3.union("TxSetComponent", {
        switchOn: xdr3.lookup("TxSetComponentType"),
        switchName: "type",
        switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]],
        arms: {
          txsMaybeDiscountedFee: xdr3.lookup("TxSetComponentTxsMaybeDiscountedFee")
        }
      });
      xdr3.union("TransactionPhase", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0Components"]],
        arms: {
          v0Components: xdr3.varArray(xdr3.lookup("TxSetComponent"), 2147483647)
        }
      });
      xdr3.struct("TransactionSet", [["previousLedgerHash", xdr3.lookup("Hash")], ["txes", xdr3.varArray(xdr3.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr3.struct("TransactionSetV1", [["previousLedgerHash", xdr3.lookup("Hash")], ["phases", xdr3.varArray(xdr3.lookup("TransactionPhase"), 2147483647)]]);
      xdr3.union("GeneralizedTransactionSet", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[1, "v1TxSet"]],
        arms: {
          v1TxSet: xdr3.lookup("TransactionSetV1")
        }
      });
      xdr3.struct("TransactionResultPair", [["transactionHash", xdr3.lookup("Hash")], ["result", xdr3.lookup("TransactionResult")]]);
      xdr3.struct("TransactionResultSet", [["results", xdr3.varArray(xdr3.lookup("TransactionResultPair"), 2147483647)]]);
      xdr3.union("TransactionHistoryEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "generalizedTxSet"]],
        arms: {
          generalizedTxSet: xdr3.lookup("GeneralizedTransactionSet")
        }
      });
      xdr3.struct("TransactionHistoryEntry", [["ledgerSeq", xdr3.lookup("Uint32")], ["txSet", xdr3.lookup("TransactionSet")], ["ext", xdr3.lookup("TransactionHistoryEntryExt")]]);
      xdr3.union("TransactionHistoryResultEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionHistoryResultEntry", [["ledgerSeq", xdr3.lookup("Uint32")], ["txResultSet", xdr3.lookup("TransactionResultSet")], ["ext", xdr3.lookup("TransactionHistoryResultEntryExt")]]);
      xdr3.union("LedgerHeaderHistoryEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerHeaderHistoryEntry", [["hash", xdr3.lookup("Hash")], ["header", xdr3.lookup("LedgerHeader")], ["ext", xdr3.lookup("LedgerHeaderHistoryEntryExt")]]);
      xdr3.struct("LedgerScpMessages", [["ledgerSeq", xdr3.lookup("Uint32")], ["messages", xdr3.varArray(xdr3.lookup("ScpEnvelope"), 2147483647)]]);
      xdr3.struct("ScpHistoryEntryV0", [["quorumSets", xdr3.varArray(xdr3.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", xdr3.lookup("LedgerScpMessages")]]);
      xdr3.union("ScpHistoryEntry", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("ScpHistoryEntryV0")
        }
      });
      xdr3["enum"]("LedgerEntryChangeType", {
        ledgerEntryCreated: 0,
        ledgerEntryUpdated: 1,
        ledgerEntryRemoved: 2,
        ledgerEntryState: 3
      });
      xdr3.union("LedgerEntryChange", {
        switchOn: xdr3.lookup("LedgerEntryChangeType"),
        switchName: "type",
        switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
        arms: {
          created: xdr3.lookup("LedgerEntry"),
          updated: xdr3.lookup("LedgerEntry"),
          removed: xdr3.lookup("LedgerKey"),
          state: xdr3.lookup("LedgerEntry")
        }
      });
      xdr3.typedef("LedgerEntryChanges", xdr3.varArray(xdr3.lookup("LedgerEntryChange"), 2147483647));
      xdr3.struct("OperationMeta", [["changes", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3.struct("TransactionMetaV1", [["txChanges", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)]]);
      xdr3.struct("TransactionMetaV2", [["txChangesBefore", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3["enum"]("ContractEventType", {
        system: 0,
        contract: 1,
        diagnostic: 2
      });
      xdr3.struct("ContractEventV0", [["topics", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)], ["data", xdr3.lookup("ScVal")]]);
      xdr3.union("ContractEventBody", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("ContractEventV0")
        }
      });
      xdr3.struct("ContractEvent", [["ext", xdr3.lookup("ExtensionPoint")], ["contractId", xdr3.option(xdr3.lookup("Hash"))], ["type", xdr3.lookup("ContractEventType")], ["body", xdr3.lookup("ContractEventBody")]]);
      xdr3.struct("DiagnosticEvent", [["inSuccessfulContractCall", xdr3.bool()], ["event", xdr3.lookup("ContractEvent")]]);
      xdr3.typedef("DiagnosticEvents", xdr3.varArray(xdr3.lookup("DiagnosticEvent"), 2147483647));
      xdr3.struct("SorobanTransactionMetaExtV1", [["ext", xdr3.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", xdr3.lookup("Int64")], ["totalRefundableResourceFeeCharged", xdr3.lookup("Int64")], ["rentFeeCharged", xdr3.lookup("Int64")]]);
      xdr3.union("SorobanTransactionMetaExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("SorobanTransactionMetaExtV1")
        }
      });
      xdr3.struct("SorobanTransactionMeta", [["ext", xdr3.lookup("SorobanTransactionMetaExt")], ["events", xdr3.varArray(xdr3.lookup("ContractEvent"), 2147483647)], ["returnValue", xdr3.lookup("ScVal")], ["diagnosticEvents", xdr3.varArray(xdr3.lookup("DiagnosticEvent"), 2147483647)]]);
      xdr3.struct("TransactionMetaV3", [["ext", xdr3.lookup("ExtensionPoint")], ["txChangesBefore", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr3.lookup("LedgerEntryChanges")], ["sorobanMeta", xdr3.option(xdr3.lookup("SorobanTransactionMeta"))]]);
      xdr3.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", xdr3.lookup("ScVal")], ["events", xdr3.varArray(xdr3.lookup("ContractEvent"), 2147483647)]]);
      xdr3.union("TransactionMeta", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]],
        arms: {
          operations: xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647),
          v1: xdr3.lookup("TransactionMetaV1"),
          v2: xdr3.lookup("TransactionMetaV2"),
          v3: xdr3.lookup("TransactionMetaV3")
        }
      });
      xdr3.struct("TransactionResultMeta", [["result", xdr3.lookup("TransactionResultPair")], ["feeProcessing", xdr3.lookup("LedgerEntryChanges")], ["txApplyProcessing", xdr3.lookup("TransactionMeta")]]);
      xdr3.struct("UpgradeEntryMeta", [["upgrade", xdr3.lookup("LedgerUpgrade")], ["changes", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3.struct("LedgerCloseMetaV0", [["ledgerHeader", xdr3.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr3.lookup("TransactionSet")], ["txProcessing", xdr3.varArray(xdr3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr3.varArray(xdr3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr3.varArray(xdr3.lookup("ScpHistoryEntry"), 2147483647)]]);
      xdr3.struct("LedgerCloseMetaExtV1", [["ext", xdr3.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", xdr3.lookup("Int64")]]);
      xdr3.union("LedgerCloseMetaExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerCloseMetaExtV1")
        }
      });
      xdr3.struct("LedgerCloseMetaV1", [["ext", xdr3.lookup("LedgerCloseMetaExt")], ["ledgerHeader", xdr3.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr3.lookup("GeneralizedTransactionSet")], ["txProcessing", xdr3.varArray(xdr3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr3.varArray(xdr3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr3.varArray(xdr3.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", xdr3.lookup("Uint64")], ["evictedTemporaryLedgerKeys", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", xdr3.varArray(xdr3.lookup("LedgerEntry"), 2147483647)]]);
      xdr3.union("LedgerCloseMeta", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"], [1, "v1"]],
        arms: {
          v0: xdr3.lookup("LedgerCloseMetaV0"),
          v1: xdr3.lookup("LedgerCloseMetaV1")
        }
      });
      xdr3["enum"]("ErrorCode", {
        errMisc: 0,
        errData: 1,
        errConf: 2,
        errAuth: 3,
        errLoad: 4
      });
      xdr3.struct("Error", [["code", xdr3.lookup("ErrorCode")], ["msg", xdr3.string(100)]]);
      xdr3.struct("SendMore", [["numMessages", xdr3.lookup("Uint32")]]);
      xdr3.struct("SendMoreExtended", [["numMessages", xdr3.lookup("Uint32")], ["numBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("AuthCert", [["pubkey", xdr3.lookup("Curve25519Public")], ["expiration", xdr3.lookup("Uint64")], ["sig", xdr3.lookup("Signature")]]);
      xdr3.struct("Hello", [["ledgerVersion", xdr3.lookup("Uint32")], ["overlayVersion", xdr3.lookup("Uint32")], ["overlayMinVersion", xdr3.lookup("Uint32")], ["networkId", xdr3.lookup("Hash")], ["versionStr", xdr3.string(100)], ["listeningPort", xdr3["int"]()], ["peerId", xdr3.lookup("NodeId")], ["cert", xdr3.lookup("AuthCert")], ["nonce", xdr3.lookup("Uint256")]]);
      xdr3["const"]("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200);
      xdr3.struct("Auth", [["flags", xdr3["int"]()]]);
      xdr3["enum"]("IpAddrType", {
        iPv4: 0,
        iPv6: 1
      });
      xdr3.union("PeerAddressIp", {
        switchOn: xdr3.lookup("IpAddrType"),
        switchName: "type",
        switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
        arms: {
          ipv4: xdr3.opaque(4),
          ipv6: xdr3.opaque(16)
        }
      });
      xdr3.struct("PeerAddress", [["ip", xdr3.lookup("PeerAddressIp")], ["port", xdr3.lookup("Uint32")], ["numFailures", xdr3.lookup("Uint32")]]);
      xdr3["enum"]("MessageType", {
        errorMsg: 0,
        auth: 2,
        dontHave: 3,
        getPeers: 4,
        peers: 5,
        getTxSet: 6,
        txSet: 7,
        generalizedTxSet: 17,
        transaction: 8,
        getScpQuorumset: 9,
        scpQuorumset: 10,
        scpMessage: 11,
        getScpState: 12,
        hello: 13,
        surveyRequest: 14,
        surveyResponse: 15,
        sendMore: 16,
        sendMoreExtended: 20,
        floodAdvert: 18,
        floodDemand: 19,
        timeSlicedSurveyRequest: 21,
        timeSlicedSurveyResponse: 22,
        timeSlicedSurveyStartCollecting: 23,
        timeSlicedSurveyStopCollecting: 24
      });
      xdr3.struct("DontHave", [["type", xdr3.lookup("MessageType")], ["reqHash", xdr3.lookup("Uint256")]]);
      xdr3["enum"]("SurveyMessageCommandType", {
        surveyTopology: 0,
        timeSlicedSurveyTopology: 1
      });
      xdr3["enum"]("SurveyMessageResponseType", {
        surveyTopologyResponseV0: 0,
        surveyTopologyResponseV1: 1,
        surveyTopologyResponseV2: 2
      });
      xdr3.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", xdr3.lookup("NodeId")], ["nonce", xdr3.lookup("Uint32")], ["ledgerNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", xdr3.lookup("Signature")], ["startCollecting", xdr3.lookup("TimeSlicedSurveyStartCollectingMessage")]]);
      xdr3.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", xdr3.lookup("NodeId")], ["nonce", xdr3.lookup("Uint32")], ["ledgerNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", xdr3.lookup("Signature")], ["stopCollecting", xdr3.lookup("TimeSlicedSurveyStopCollectingMessage")]]);
      xdr3.struct("SurveyRequestMessage", [["surveyorPeerId", xdr3.lookup("NodeId")], ["surveyedPeerId", xdr3.lookup("NodeId")], ["ledgerNum", xdr3.lookup("Uint32")], ["encryptionKey", xdr3.lookup("Curve25519Public")], ["commandType", xdr3.lookup("SurveyMessageCommandType")]]);
      xdr3.struct("TimeSlicedSurveyRequestMessage", [["request", xdr3.lookup("SurveyRequestMessage")], ["nonce", xdr3.lookup("Uint32")], ["inboundPeersIndex", xdr3.lookup("Uint32")], ["outboundPeersIndex", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedSurveyRequestMessage", [["requestSignature", xdr3.lookup("Signature")], ["request", xdr3.lookup("SurveyRequestMessage")]]);
      xdr3.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", xdr3.lookup("Signature")], ["request", xdr3.lookup("TimeSlicedSurveyRequestMessage")]]);
      xdr3.typedef("EncryptedBody", xdr3.varOpaque(64e3));
      xdr3.struct("SurveyResponseMessage", [["surveyorPeerId", xdr3.lookup("NodeId")], ["surveyedPeerId", xdr3.lookup("NodeId")], ["ledgerNum", xdr3.lookup("Uint32")], ["commandType", xdr3.lookup("SurveyMessageCommandType")], ["encryptedBody", xdr3.lookup("EncryptedBody")]]);
      xdr3.struct("TimeSlicedSurveyResponseMessage", [["response", xdr3.lookup("SurveyResponseMessage")], ["nonce", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedSurveyResponseMessage", [["responseSignature", xdr3.lookup("Signature")], ["response", xdr3.lookup("SurveyResponseMessage")]]);
      xdr3.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", xdr3.lookup("Signature")], ["response", xdr3.lookup("TimeSlicedSurveyResponseMessage")]]);
      xdr3.struct("PeerStats", [["id", xdr3.lookup("NodeId")], ["versionStr", xdr3.string(100)], ["messagesRead", xdr3.lookup("Uint64")], ["messagesWritten", xdr3.lookup("Uint64")], ["bytesRead", xdr3.lookup("Uint64")], ["bytesWritten", xdr3.lookup("Uint64")], ["secondsConnected", xdr3.lookup("Uint64")], ["uniqueFloodBytesRecv", xdr3.lookup("Uint64")], ["duplicateFloodBytesRecv", xdr3.lookup("Uint64")], ["uniqueFetchBytesRecv", xdr3.lookup("Uint64")], ["duplicateFetchBytesRecv", xdr3.lookup("Uint64")], ["uniqueFloodMessageRecv", xdr3.lookup("Uint64")], ["duplicateFloodMessageRecv", xdr3.lookup("Uint64")], ["uniqueFetchMessageRecv", xdr3.lookup("Uint64")], ["duplicateFetchMessageRecv", xdr3.lookup("Uint64")]]);
      xdr3.typedef("PeerStatList", xdr3.varArray(xdr3.lookup("PeerStats"), 25));
      xdr3.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", xdr3.lookup("Uint32")], ["droppedAuthenticatedPeers", xdr3.lookup("Uint32")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", xdr3.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", xdr3.lookup("Uint32")], ["lostSyncCount", xdr3.lookup("Uint32")], ["isValidator", xdr3.bool()], ["maxInboundPeerCount", xdr3.lookup("Uint32")], ["maxOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TimeSlicedPeerData", [["peerStats", xdr3.lookup("PeerStats")], ["averageLatencyMs", xdr3.lookup("Uint32")]]);
      xdr3.typedef("TimeSlicedPeerDataList", xdr3.varArray(xdr3.lookup("TimeSlicedPeerData"), 25));
      xdr3.struct("TopologyResponseBodyV0", [["inboundPeers", xdr3.lookup("PeerStatList")], ["outboundPeers", xdr3.lookup("PeerStatList")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TopologyResponseBodyV1", [["inboundPeers", xdr3.lookup("PeerStatList")], ["outboundPeers", xdr3.lookup("PeerStatList")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")], ["maxInboundPeerCount", xdr3.lookup("Uint32")], ["maxOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TopologyResponseBodyV2", [["inboundPeers", xdr3.lookup("TimeSlicedPeerDataList")], ["outboundPeers", xdr3.lookup("TimeSlicedPeerDataList")], ["nodeData", xdr3.lookup("TimeSlicedNodeData")]]);
      xdr3.union("SurveyResponseBody", {
        switchOn: xdr3.lookup("SurveyMessageResponseType"),
        switchName: "type",
        switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]],
        arms: {
          topologyResponseBodyV0: xdr3.lookup("TopologyResponseBodyV0"),
          topologyResponseBodyV1: xdr3.lookup("TopologyResponseBodyV1"),
          topologyResponseBodyV2: xdr3.lookup("TopologyResponseBodyV2")
        }
      });
      xdr3["const"]("TX_ADVERT_VECTOR_MAX_SIZE", 1e3);
      xdr3.typedef("TxAdvertVector", xdr3.varArray(xdr3.lookup("Hash"), xdr3.lookup("TX_ADVERT_VECTOR_MAX_SIZE")));
      xdr3.struct("FloodAdvert", [["txHashes", xdr3.lookup("TxAdvertVector")]]);
      xdr3["const"]("TX_DEMAND_VECTOR_MAX_SIZE", 1e3);
      xdr3.typedef("TxDemandVector", xdr3.varArray(xdr3.lookup("Hash"), xdr3.lookup("TX_DEMAND_VECTOR_MAX_SIZE")));
      xdr3.struct("FloodDemand", [["txHashes", xdr3.lookup("TxDemandVector")]]);
      xdr3.union("StellarMessage", {
        switchOn: xdr3.lookup("MessageType"),
        switchName: "type",
        switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", xdr3["void"]()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]],
        arms: {
          error: xdr3.lookup("Error"),
          hello: xdr3.lookup("Hello"),
          auth: xdr3.lookup("Auth"),
          dontHave: xdr3.lookup("DontHave"),
          peers: xdr3.varArray(xdr3.lookup("PeerAddress"), 100),
          txSetHash: xdr3.lookup("Uint256"),
          txSet: xdr3.lookup("TransactionSet"),
          generalizedTxSet: xdr3.lookup("GeneralizedTransactionSet"),
          transaction: xdr3.lookup("TransactionEnvelope"),
          signedSurveyRequestMessage: xdr3.lookup("SignedSurveyRequestMessage"),
          signedSurveyResponseMessage: xdr3.lookup("SignedSurveyResponseMessage"),
          signedTimeSlicedSurveyRequestMessage: xdr3.lookup("SignedTimeSlicedSurveyRequestMessage"),
          signedTimeSlicedSurveyResponseMessage: xdr3.lookup("SignedTimeSlicedSurveyResponseMessage"),
          signedTimeSlicedSurveyStartCollectingMessage: xdr3.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),
          signedTimeSlicedSurveyStopCollectingMessage: xdr3.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),
          qSetHash: xdr3.lookup("Uint256"),
          qSet: xdr3.lookup("ScpQuorumSet"),
          envelope: xdr3.lookup("ScpEnvelope"),
          getScpLedgerSeq: xdr3.lookup("Uint32"),
          sendMoreMessage: xdr3.lookup("SendMore"),
          sendMoreExtendedMessage: xdr3.lookup("SendMoreExtended"),
          floodAdvert: xdr3.lookup("FloodAdvert"),
          floodDemand: xdr3.lookup("FloodDemand")
        }
      });
      xdr3.struct("AuthenticatedMessageV0", [["sequence", xdr3.lookup("Uint64")], ["message", xdr3.lookup("StellarMessage")], ["mac", xdr3.lookup("HmacSha256Mac")]]);
      xdr3.union("AuthenticatedMessage", {
        switchOn: xdr3.lookup("Uint32"),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("AuthenticatedMessageV0")
        }
      });
      xdr3["const"]("MAX_OPS_PER_TX", 100);
      xdr3.union("LiquidityPoolParameters", {
        switchOn: xdr3.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr3.lookup("LiquidityPoolConstantProductParameters")
        }
      });
      xdr3.struct("MuxedAccountMed25519", [["id", xdr3.lookup("Uint64")], ["ed25519", xdr3.lookup("Uint256")]]);
      xdr3.union("MuxedAccount", {
        switchOn: xdr3.lookup("CryptoKeyType"),
        switchName: "type",
        switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
        arms: {
          ed25519: xdr3.lookup("Uint256"),
          med25519: xdr3.lookup("MuxedAccountMed25519")
        }
      });
      xdr3.struct("DecoratedSignature", [["hint", xdr3.lookup("SignatureHint")], ["signature", xdr3.lookup("Signature")]]);
      xdr3["enum"]("OperationType", {
        createAccount: 0,
        payment: 1,
        pathPaymentStrictReceive: 2,
        manageSellOffer: 3,
        createPassiveSellOffer: 4,
        setOptions: 5,
        changeTrust: 6,
        allowTrust: 7,
        accountMerge: 8,
        inflation: 9,
        manageData: 10,
        bumpSequence: 11,
        manageBuyOffer: 12,
        pathPaymentStrictSend: 13,
        createClaimableBalance: 14,
        claimClaimableBalance: 15,
        beginSponsoringFutureReserves: 16,
        endSponsoringFutureReserves: 17,
        revokeSponsorship: 18,
        clawback: 19,
        clawbackClaimableBalance: 20,
        setTrustLineFlags: 21,
        liquidityPoolDeposit: 22,
        liquidityPoolWithdraw: 23,
        invokeHostFunction: 24,
        extendFootprintTtl: 25,
        restoreFootprint: 26
      });
      xdr3.struct("CreateAccountOp", [["destination", xdr3.lookup("AccountId")], ["startingBalance", xdr3.lookup("Int64")]]);
      xdr3.struct("PaymentOp", [["destination", xdr3.lookup("MuxedAccount")], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("PathPaymentStrictReceiveOp", [["sendAsset", xdr3.lookup("Asset")], ["sendMax", xdr3.lookup("Int64")], ["destination", xdr3.lookup("MuxedAccount")], ["destAsset", xdr3.lookup("Asset")], ["destAmount", xdr3.lookup("Int64")], ["path", xdr3.varArray(xdr3.lookup("Asset"), 5)]]);
      xdr3.struct("PathPaymentStrictSendOp", [["sendAsset", xdr3.lookup("Asset")], ["sendAmount", xdr3.lookup("Int64")], ["destination", xdr3.lookup("MuxedAccount")], ["destAsset", xdr3.lookup("Asset")], ["destMin", xdr3.lookup("Int64")], ["path", xdr3.varArray(xdr3.lookup("Asset"), 5)]]);
      xdr3.struct("ManageSellOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("ManageBuyOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["buyAmount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("CreatePassiveSellOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")]]);
      xdr3.struct("SetOptionsOp", [["inflationDest", xdr3.option(xdr3.lookup("AccountId"))], ["clearFlags", xdr3.option(xdr3.lookup("Uint32"))], ["setFlags", xdr3.option(xdr3.lookup("Uint32"))], ["masterWeight", xdr3.option(xdr3.lookup("Uint32"))], ["lowThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["medThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["highThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["homeDomain", xdr3.option(xdr3.lookup("String32"))], ["signer", xdr3.option(xdr3.lookup("Signer"))]]);
      xdr3.union("ChangeTrustAsset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12"),
          liquidityPool: xdr3.lookup("LiquidityPoolParameters")
        }
      });
      xdr3.struct("ChangeTrustOp", [["line", xdr3.lookup("ChangeTrustAsset")], ["limit", xdr3.lookup("Int64")]]);
      xdr3.struct("AllowTrustOp", [["trustor", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("AssetCode")], ["authorize", xdr3.lookup("Uint32")]]);
      xdr3.struct("ManageDataOp", [["dataName", xdr3.lookup("String64")], ["dataValue", xdr3.option(xdr3.lookup("DataValue"))]]);
      xdr3.struct("BumpSequenceOp", [["bumpTo", xdr3.lookup("SequenceNumber")]]);
      xdr3.struct("CreateClaimableBalanceOp", [["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["claimants", xdr3.varArray(xdr3.lookup("Claimant"), 10)]]);
      xdr3.struct("ClaimClaimableBalanceOp", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", xdr3.lookup("AccountId")]]);
      xdr3["enum"]("RevokeSponsorshipType", {
        revokeSponsorshipLedgerEntry: 0,
        revokeSponsorshipSigner: 1
      });
      xdr3.struct("RevokeSponsorshipOpSigner", [["accountId", xdr3.lookup("AccountId")], ["signerKey", xdr3.lookup("SignerKey")]]);
      xdr3.union("RevokeSponsorshipOp", {
        switchOn: xdr3.lookup("RevokeSponsorshipType"),
        switchName: "type",
        switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
        arms: {
          ledgerKey: xdr3.lookup("LedgerKey"),
          signer: xdr3.lookup("RevokeSponsorshipOpSigner")
        }
      });
      xdr3.struct("ClawbackOp", [["asset", xdr3.lookup("Asset")], ["from", xdr3.lookup("MuxedAccount")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("ClawbackClaimableBalanceOp", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("SetTrustLineFlagsOp", [["trustor", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("Asset")], ["clearFlags", xdr3.lookup("Uint32")], ["setFlags", xdr3.lookup("Uint32")]]);
      xdr3["const"]("LIQUIDITY_POOL_FEE_V18", 30);
      xdr3.struct("LiquidityPoolDepositOp", [["liquidityPoolId", xdr3.lookup("PoolId")], ["maxAmountA", xdr3.lookup("Int64")], ["maxAmountB", xdr3.lookup("Int64")], ["minPrice", xdr3.lookup("Price")], ["maxPrice", xdr3.lookup("Price")]]);
      xdr3.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", xdr3.lookup("PoolId")], ["amount", xdr3.lookup("Int64")], ["minAmountA", xdr3.lookup("Int64")], ["minAmountB", xdr3.lookup("Int64")]]);
      xdr3["enum"]("HostFunctionType", {
        hostFunctionTypeInvokeContract: 0,
        hostFunctionTypeCreateContract: 1,
        hostFunctionTypeUploadContractWasm: 2,
        hostFunctionTypeCreateContractV2: 3
      });
      xdr3["enum"]("ContractIdPreimageType", {
        contractIdPreimageFromAddress: 0,
        contractIdPreimageFromAsset: 1
      });
      xdr3.struct("ContractIdPreimageFromAddress", [["address", xdr3.lookup("ScAddress")], ["salt", xdr3.lookup("Uint256")]]);
      xdr3.union("ContractIdPreimage", {
        switchOn: xdr3.lookup("ContractIdPreimageType"),
        switchName: "type",
        switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]],
        arms: {
          fromAddress: xdr3.lookup("ContractIdPreimageFromAddress"),
          fromAsset: xdr3.lookup("Asset")
        }
      });
      xdr3.struct("CreateContractArgs", [["contractIdPreimage", xdr3.lookup("ContractIdPreimage")], ["executable", xdr3.lookup("ContractExecutable")]]);
      xdr3.struct("CreateContractArgsV2", [["contractIdPreimage", xdr3.lookup("ContractIdPreimage")], ["executable", xdr3.lookup("ContractExecutable")], ["constructorArgs", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)]]);
      xdr3.struct("InvokeContractArgs", [["contractAddress", xdr3.lookup("ScAddress")], ["functionName", xdr3.lookup("ScSymbol")], ["args", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)]]);
      xdr3.union("HostFunction", {
        switchOn: xdr3.lookup("HostFunctionType"),
        switchName: "type",
        switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]],
        arms: {
          invokeContract: xdr3.lookup("InvokeContractArgs"),
          createContract: xdr3.lookup("CreateContractArgs"),
          wasm: xdr3.varOpaque(),
          createContractV2: xdr3.lookup("CreateContractArgsV2")
        }
      });
      xdr3["enum"]("SorobanAuthorizedFunctionType", {
        sorobanAuthorizedFunctionTypeContractFn: 0,
        sorobanAuthorizedFunctionTypeCreateContractHostFn: 1,
        sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2
      });
      xdr3.union("SorobanAuthorizedFunction", {
        switchOn: xdr3.lookup("SorobanAuthorizedFunctionType"),
        switchName: "type",
        switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]],
        arms: {
          contractFn: xdr3.lookup("InvokeContractArgs"),
          createContractHostFn: xdr3.lookup("CreateContractArgs"),
          createContractV2HostFn: xdr3.lookup("CreateContractArgsV2")
        }
      });
      xdr3.struct("SorobanAuthorizedInvocation", [["function", xdr3.lookup("SorobanAuthorizedFunction")], ["subInvocations", xdr3.varArray(xdr3.lookup("SorobanAuthorizedInvocation"), 2147483647)]]);
      xdr3.struct("SorobanAddressCredentials", [["address", xdr3.lookup("ScAddress")], ["nonce", xdr3.lookup("Int64")], ["signatureExpirationLedger", xdr3.lookup("Uint32")], ["signature", xdr3.lookup("ScVal")]]);
      xdr3["enum"]("SorobanCredentialsType", {
        sorobanCredentialsSourceAccount: 0,
        sorobanCredentialsAddress: 1
      });
      xdr3.union("SorobanCredentials", {
        switchOn: xdr3.lookup("SorobanCredentialsType"),
        switchName: "type",
        switches: [["sorobanCredentialsSourceAccount", xdr3["void"]()], ["sorobanCredentialsAddress", "address"]],
        arms: {
          address: xdr3.lookup("SorobanAddressCredentials")
        }
      });
      xdr3.struct("SorobanAuthorizationEntry", [["credentials", xdr3.lookup("SorobanCredentials")], ["rootInvocation", xdr3.lookup("SorobanAuthorizedInvocation")]]);
      xdr3.struct("InvokeHostFunctionOp", [["hostFunction", xdr3.lookup("HostFunction")], ["auth", xdr3.varArray(xdr3.lookup("SorobanAuthorizationEntry"), 2147483647)]]);
      xdr3.struct("ExtendFootprintTtlOp", [["ext", xdr3.lookup("ExtensionPoint")], ["extendTo", xdr3.lookup("Uint32")]]);
      xdr3.struct("RestoreFootprintOp", [["ext", xdr3.lookup("ExtensionPoint")]]);
      xdr3.union("OperationBody", {
        switchOn: xdr3.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", xdr3["void"]()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", xdr3["void"]()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]],
        arms: {
          createAccountOp: xdr3.lookup("CreateAccountOp"),
          paymentOp: xdr3.lookup("PaymentOp"),
          pathPaymentStrictReceiveOp: xdr3.lookup("PathPaymentStrictReceiveOp"),
          manageSellOfferOp: xdr3.lookup("ManageSellOfferOp"),
          createPassiveSellOfferOp: xdr3.lookup("CreatePassiveSellOfferOp"),
          setOptionsOp: xdr3.lookup("SetOptionsOp"),
          changeTrustOp: xdr3.lookup("ChangeTrustOp"),
          allowTrustOp: xdr3.lookup("AllowTrustOp"),
          destination: xdr3.lookup("MuxedAccount"),
          manageDataOp: xdr3.lookup("ManageDataOp"),
          bumpSequenceOp: xdr3.lookup("BumpSequenceOp"),
          manageBuyOfferOp: xdr3.lookup("ManageBuyOfferOp"),
          pathPaymentStrictSendOp: xdr3.lookup("PathPaymentStrictSendOp"),
          createClaimableBalanceOp: xdr3.lookup("CreateClaimableBalanceOp"),
          claimClaimableBalanceOp: xdr3.lookup("ClaimClaimableBalanceOp"),
          beginSponsoringFutureReservesOp: xdr3.lookup("BeginSponsoringFutureReservesOp"),
          revokeSponsorshipOp: xdr3.lookup("RevokeSponsorshipOp"),
          clawbackOp: xdr3.lookup("ClawbackOp"),
          clawbackClaimableBalanceOp: xdr3.lookup("ClawbackClaimableBalanceOp"),
          setTrustLineFlagsOp: xdr3.lookup("SetTrustLineFlagsOp"),
          liquidityPoolDepositOp: xdr3.lookup("LiquidityPoolDepositOp"),
          liquidityPoolWithdrawOp: xdr3.lookup("LiquidityPoolWithdrawOp"),
          invokeHostFunctionOp: xdr3.lookup("InvokeHostFunctionOp"),
          extendFootprintTtlOp: xdr3.lookup("ExtendFootprintTtlOp"),
          restoreFootprintOp: xdr3.lookup("RestoreFootprintOp")
        }
      });
      xdr3.struct("Operation", [["sourceAccount", xdr3.option(xdr3.lookup("MuxedAccount"))], ["body", xdr3.lookup("OperationBody")]]);
      xdr3.struct("HashIdPreimageOperationId", [["sourceAccount", xdr3.lookup("AccountId")], ["seqNum", xdr3.lookup("SequenceNumber")], ["opNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("HashIdPreimageRevokeId", [["sourceAccount", xdr3.lookup("AccountId")], ["seqNum", xdr3.lookup("SequenceNumber")], ["opNum", xdr3.lookup("Uint32")], ["liquidityPoolId", xdr3.lookup("PoolId")], ["asset", xdr3.lookup("Asset")]]);
      xdr3.struct("HashIdPreimageContractId", [["networkId", xdr3.lookup("Hash")], ["contractIdPreimage", xdr3.lookup("ContractIdPreimage")]]);
      xdr3.struct("HashIdPreimageSorobanAuthorization", [["networkId", xdr3.lookup("Hash")], ["nonce", xdr3.lookup("Int64")], ["signatureExpirationLedger", xdr3.lookup("Uint32")], ["invocation", xdr3.lookup("SorobanAuthorizedInvocation")]]);
      xdr3.union("HashIdPreimage", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]],
        arms: {
          operationId: xdr3.lookup("HashIdPreimageOperationId"),
          revokeId: xdr3.lookup("HashIdPreimageRevokeId"),
          contractId: xdr3.lookup("HashIdPreimageContractId"),
          sorobanAuthorization: xdr3.lookup("HashIdPreimageSorobanAuthorization")
        }
      });
      xdr3["enum"]("MemoType", {
        memoNone: 0,
        memoText: 1,
        memoId: 2,
        memoHash: 3,
        memoReturn: 4
      });
      xdr3.union("Memo", {
        switchOn: xdr3.lookup("MemoType"),
        switchName: "type",
        switches: [["memoNone", xdr3["void"]()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
        arms: {
          text: xdr3.string(28),
          id: xdr3.lookup("Uint64"),
          hash: xdr3.lookup("Hash"),
          retHash: xdr3.lookup("Hash")
        }
      });
      xdr3.struct("TimeBounds", [["minTime", xdr3.lookup("TimePoint")], ["maxTime", xdr3.lookup("TimePoint")]]);
      xdr3.struct("LedgerBounds", [["minLedger", xdr3.lookup("Uint32")], ["maxLedger", xdr3.lookup("Uint32")]]);
      xdr3.struct("PreconditionsV2", [["timeBounds", xdr3.option(xdr3.lookup("TimeBounds"))], ["ledgerBounds", xdr3.option(xdr3.lookup("LedgerBounds"))], ["minSeqNum", xdr3.option(xdr3.lookup("SequenceNumber"))], ["minSeqAge", xdr3.lookup("Duration")], ["minSeqLedgerGap", xdr3.lookup("Uint32")], ["extraSigners", xdr3.varArray(xdr3.lookup("SignerKey"), 2)]]);
      xdr3["enum"]("PreconditionType", {
        precondNone: 0,
        precondTime: 1,
        precondV2: 2
      });
      xdr3.union("Preconditions", {
        switchOn: xdr3.lookup("PreconditionType"),
        switchName: "type",
        switches: [["precondNone", xdr3["void"]()], ["precondTime", "timeBounds"], ["precondV2", "v2"]],
        arms: {
          timeBounds: xdr3.lookup("TimeBounds"),
          v2: xdr3.lookup("PreconditionsV2")
        }
      });
      xdr3.struct("LedgerFootprint", [["readOnly", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["readWrite", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)]]);
      xdr3["enum"]("ArchivalProofType", {
        existence: 0,
        nonexistence: 1
      });
      xdr3.struct("ArchivalProofNode", [["index", xdr3.lookup("Uint32")], ["hash", xdr3.lookup("Hash")]]);
      xdr3.typedef("ProofLevel", xdr3.varArray(xdr3.lookup("ArchivalProofNode"), 2147483647));
      xdr3.struct("NonexistenceProofBody", [["entriesToProve", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr3.varArray(xdr3.lookup("ProofLevel"), 2147483647)]]);
      xdr3.struct("ExistenceProofBody", [["keysToProve", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr3.varArray(xdr3.lookup("ProofLevel"), 2147483647)]]);
      xdr3.union("ArchivalProofBody", {
        switchOn: xdr3.lookup("ArchivalProofType"),
        switchName: "t",
        switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]],
        arms: {
          nonexistenceProof: xdr3.lookup("NonexistenceProofBody"),
          existenceProof: xdr3.lookup("ExistenceProofBody")
        }
      });
      xdr3.struct("ArchivalProof", [["epoch", xdr3.lookup("Uint32")], ["body", xdr3.lookup("ArchivalProofBody")]]);
      xdr3.struct("SorobanResources", [["footprint", xdr3.lookup("LedgerFootprint")], ["instructions", xdr3.lookup("Uint32")], ["readBytes", xdr3.lookup("Uint32")], ["writeBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("SorobanTransactionData", [["ext", xdr3.lookup("ExtensionPoint")], ["resources", xdr3.lookup("SorobanResources")], ["resourceFee", xdr3.lookup("Int64")]]);
      xdr3.union("TransactionV0Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionV0", [["sourceAccountEd25519", xdr3.lookup("Uint256")], ["fee", xdr3.lookup("Uint32")], ["seqNum", xdr3.lookup("SequenceNumber")], ["timeBounds", xdr3.option(xdr3.lookup("TimeBounds"))], ["memo", xdr3.lookup("Memo")], ["operations", xdr3.varArray(xdr3.lookup("Operation"), xdr3.lookup("MAX_OPS_PER_TX"))], ["ext", xdr3.lookup("TransactionV0Ext")]]);
      xdr3.struct("TransactionV0Envelope", [["tx", xdr3.lookup("TransactionV0")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("TransactionExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "sorobanData"]],
        arms: {
          sorobanData: xdr3.lookup("SorobanTransactionData")
        }
      });
      xdr3.struct("Transaction", [["sourceAccount", xdr3.lookup("MuxedAccount")], ["fee", xdr3.lookup("Uint32")], ["seqNum", xdr3.lookup("SequenceNumber")], ["cond", xdr3.lookup("Preconditions")], ["memo", xdr3.lookup("Memo")], ["operations", xdr3.varArray(xdr3.lookup("Operation"), xdr3.lookup("MAX_OPS_PER_TX"))], ["ext", xdr3.lookup("TransactionExt")]]);
      xdr3.struct("TransactionV1Envelope", [["tx", xdr3.lookup("Transaction")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("FeeBumpTransactionInnerTx", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "v1"]],
        arms: {
          v1: xdr3.lookup("TransactionV1Envelope")
        }
      });
      xdr3.union("FeeBumpTransactionExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("FeeBumpTransaction", [["feeSource", xdr3.lookup("MuxedAccount")], ["fee", xdr3.lookup("Int64")], ["innerTx", xdr3.lookup("FeeBumpTransactionInnerTx")], ["ext", xdr3.lookup("FeeBumpTransactionExt")]]);
      xdr3.struct("FeeBumpTransactionEnvelope", [["tx", xdr3.lookup("FeeBumpTransaction")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("TransactionEnvelope", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          v0: xdr3.lookup("TransactionV0Envelope"),
          v1: xdr3.lookup("TransactionV1Envelope"),
          feeBump: xdr3.lookup("FeeBumpTransactionEnvelope")
        }
      });
      xdr3.union("TransactionSignaturePayloadTaggedTransaction", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          tx: xdr3.lookup("Transaction"),
          feeBump: xdr3.lookup("FeeBumpTransaction")
        }
      });
      xdr3.struct("TransactionSignaturePayload", [["networkId", xdr3.lookup("Hash")], ["taggedTransaction", xdr3.lookup("TransactionSignaturePayloadTaggedTransaction")]]);
      xdr3["enum"]("ClaimAtomType", {
        claimAtomTypeV0: 0,
        claimAtomTypeOrderBook: 1,
        claimAtomTypeLiquidityPool: 2
      });
      xdr3.struct("ClaimOfferAtomV0", [["sellerEd25519", xdr3.lookup("Uint256")], ["offerId", xdr3.lookup("Int64")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.struct("ClaimOfferAtom", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.struct("ClaimLiquidityAtom", [["liquidityPoolId", xdr3.lookup("PoolId")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.union("ClaimAtom", {
        switchOn: xdr3.lookup("ClaimAtomType"),
        switchName: "type",
        switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
        arms: {
          v0: xdr3.lookup("ClaimOfferAtomV0"),
          orderBook: xdr3.lookup("ClaimOfferAtom"),
          liquidityPool: xdr3.lookup("ClaimLiquidityAtom")
        }
      });
      xdr3["enum"]("CreateAccountResultCode", {
        createAccountSuccess: 0,
        createAccountMalformed: -1,
        createAccountUnderfunded: -2,
        createAccountLowReserve: -3,
        createAccountAlreadyExist: -4
      });
      xdr3.union("CreateAccountResult", {
        switchOn: xdr3.lookup("CreateAccountResultCode"),
        switchName: "code",
        switches: [["createAccountSuccess", xdr3["void"]()], ["createAccountMalformed", xdr3["void"]()], ["createAccountUnderfunded", xdr3["void"]()], ["createAccountLowReserve", xdr3["void"]()], ["createAccountAlreadyExist", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("PaymentResultCode", {
        paymentSuccess: 0,
        paymentMalformed: -1,
        paymentUnderfunded: -2,
        paymentSrcNoTrust: -3,
        paymentSrcNotAuthorized: -4,
        paymentNoDestination: -5,
        paymentNoTrust: -6,
        paymentNotAuthorized: -7,
        paymentLineFull: -8,
        paymentNoIssuer: -9
      });
      xdr3.union("PaymentResult", {
        switchOn: xdr3.lookup("PaymentResultCode"),
        switchName: "code",
        switches: [["paymentSuccess", xdr3["void"]()], ["paymentMalformed", xdr3["void"]()], ["paymentUnderfunded", xdr3["void"]()], ["paymentSrcNoTrust", xdr3["void"]()], ["paymentSrcNotAuthorized", xdr3["void"]()], ["paymentNoDestination", xdr3["void"]()], ["paymentNoTrust", xdr3["void"]()], ["paymentNotAuthorized", xdr3["void"]()], ["paymentLineFull", xdr3["void"]()], ["paymentNoIssuer", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("PathPaymentStrictReceiveResultCode", {
        pathPaymentStrictReceiveSuccess: 0,
        pathPaymentStrictReceiveMalformed: -1,
        pathPaymentStrictReceiveUnderfunded: -2,
        pathPaymentStrictReceiveSrcNoTrust: -3,
        pathPaymentStrictReceiveSrcNotAuthorized: -4,
        pathPaymentStrictReceiveNoDestination: -5,
        pathPaymentStrictReceiveNoTrust: -6,
        pathPaymentStrictReceiveNotAuthorized: -7,
        pathPaymentStrictReceiveLineFull: -8,
        pathPaymentStrictReceiveNoIssuer: -9,
        pathPaymentStrictReceiveTooFewOffers: -10,
        pathPaymentStrictReceiveOfferCrossSelf: -11,
        pathPaymentStrictReceiveOverSendmax: -12
      });
      xdr3.struct("SimplePaymentResult", [["destination", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("PathPaymentStrictReceiveResultSuccess", [["offers", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["last", xdr3.lookup("SimplePaymentResult")]]);
      xdr3.union("PathPaymentStrictReceiveResult", {
        switchOn: xdr3.lookup("PathPaymentStrictReceiveResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", xdr3["void"]()], ["pathPaymentStrictReceiveUnderfunded", xdr3["void"]()], ["pathPaymentStrictReceiveSrcNoTrust", xdr3["void"]()], ["pathPaymentStrictReceiveSrcNotAuthorized", xdr3["void"]()], ["pathPaymentStrictReceiveNoDestination", xdr3["void"]()], ["pathPaymentStrictReceiveNoTrust", xdr3["void"]()], ["pathPaymentStrictReceiveNotAuthorized", xdr3["void"]()], ["pathPaymentStrictReceiveLineFull", xdr3["void"]()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", xdr3["void"]()], ["pathPaymentStrictReceiveOfferCrossSelf", xdr3["void"]()], ["pathPaymentStrictReceiveOverSendmax", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("PathPaymentStrictReceiveResultSuccess"),
          noIssuer: xdr3.lookup("Asset")
        }
      });
      xdr3["enum"]("PathPaymentStrictSendResultCode", {
        pathPaymentStrictSendSuccess: 0,
        pathPaymentStrictSendMalformed: -1,
        pathPaymentStrictSendUnderfunded: -2,
        pathPaymentStrictSendSrcNoTrust: -3,
        pathPaymentStrictSendSrcNotAuthorized: -4,
        pathPaymentStrictSendNoDestination: -5,
        pathPaymentStrictSendNoTrust: -6,
        pathPaymentStrictSendNotAuthorized: -7,
        pathPaymentStrictSendLineFull: -8,
        pathPaymentStrictSendNoIssuer: -9,
        pathPaymentStrictSendTooFewOffers: -10,
        pathPaymentStrictSendOfferCrossSelf: -11,
        pathPaymentStrictSendUnderDestmin: -12
      });
      xdr3.struct("PathPaymentStrictSendResultSuccess", [["offers", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["last", xdr3.lookup("SimplePaymentResult")]]);
      xdr3.union("PathPaymentStrictSendResult", {
        switchOn: xdr3.lookup("PathPaymentStrictSendResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", xdr3["void"]()], ["pathPaymentStrictSendUnderfunded", xdr3["void"]()], ["pathPaymentStrictSendSrcNoTrust", xdr3["void"]()], ["pathPaymentStrictSendSrcNotAuthorized", xdr3["void"]()], ["pathPaymentStrictSendNoDestination", xdr3["void"]()], ["pathPaymentStrictSendNoTrust", xdr3["void"]()], ["pathPaymentStrictSendNotAuthorized", xdr3["void"]()], ["pathPaymentStrictSendLineFull", xdr3["void"]()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", xdr3["void"]()], ["pathPaymentStrictSendOfferCrossSelf", xdr3["void"]()], ["pathPaymentStrictSendUnderDestmin", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("PathPaymentStrictSendResultSuccess"),
          noIssuer: xdr3.lookup("Asset")
        }
      });
      xdr3["enum"]("ManageSellOfferResultCode", {
        manageSellOfferSuccess: 0,
        manageSellOfferMalformed: -1,
        manageSellOfferSellNoTrust: -2,
        manageSellOfferBuyNoTrust: -3,
        manageSellOfferSellNotAuthorized: -4,
        manageSellOfferBuyNotAuthorized: -5,
        manageSellOfferLineFull: -6,
        manageSellOfferUnderfunded: -7,
        manageSellOfferCrossSelf: -8,
        manageSellOfferSellNoIssuer: -9,
        manageSellOfferBuyNoIssuer: -10,
        manageSellOfferNotFound: -11,
        manageSellOfferLowReserve: -12
      });
      xdr3["enum"]("ManageOfferEffect", {
        manageOfferCreated: 0,
        manageOfferUpdated: 1,
        manageOfferDeleted: 2
      });
      xdr3.union("ManageOfferSuccessResultOffer", {
        switchOn: xdr3.lookup("ManageOfferEffect"),
        switchName: "effect",
        switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", xdr3["void"]()]],
        arms: {
          offer: xdr3.lookup("OfferEntry")
        }
      });
      xdr3.struct("ManageOfferSuccessResult", [["offersClaimed", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["offer", xdr3.lookup("ManageOfferSuccessResultOffer")]]);
      xdr3.union("ManageSellOfferResult", {
        switchOn: xdr3.lookup("ManageSellOfferResultCode"),
        switchName: "code",
        switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", xdr3["void"]()], ["manageSellOfferSellNoTrust", xdr3["void"]()], ["manageSellOfferBuyNoTrust", xdr3["void"]()], ["manageSellOfferSellNotAuthorized", xdr3["void"]()], ["manageSellOfferBuyNotAuthorized", xdr3["void"]()], ["manageSellOfferLineFull", xdr3["void"]()], ["manageSellOfferUnderfunded", xdr3["void"]()], ["manageSellOfferCrossSelf", xdr3["void"]()], ["manageSellOfferSellNoIssuer", xdr3["void"]()], ["manageSellOfferBuyNoIssuer", xdr3["void"]()], ["manageSellOfferNotFound", xdr3["void"]()], ["manageSellOfferLowReserve", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("ManageOfferSuccessResult")
        }
      });
      xdr3["enum"]("ManageBuyOfferResultCode", {
        manageBuyOfferSuccess: 0,
        manageBuyOfferMalformed: -1,
        manageBuyOfferSellNoTrust: -2,
        manageBuyOfferBuyNoTrust: -3,
        manageBuyOfferSellNotAuthorized: -4,
        manageBuyOfferBuyNotAuthorized: -5,
        manageBuyOfferLineFull: -6,
        manageBuyOfferUnderfunded: -7,
        manageBuyOfferCrossSelf: -8,
        manageBuyOfferSellNoIssuer: -9,
        manageBuyOfferBuyNoIssuer: -10,
        manageBuyOfferNotFound: -11,
        manageBuyOfferLowReserve: -12
      });
      xdr3.union("ManageBuyOfferResult", {
        switchOn: xdr3.lookup("ManageBuyOfferResultCode"),
        switchName: "code",
        switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", xdr3["void"]()], ["manageBuyOfferSellNoTrust", xdr3["void"]()], ["manageBuyOfferBuyNoTrust", xdr3["void"]()], ["manageBuyOfferSellNotAuthorized", xdr3["void"]()], ["manageBuyOfferBuyNotAuthorized", xdr3["void"]()], ["manageBuyOfferLineFull", xdr3["void"]()], ["manageBuyOfferUnderfunded", xdr3["void"]()], ["manageBuyOfferCrossSelf", xdr3["void"]()], ["manageBuyOfferSellNoIssuer", xdr3["void"]()], ["manageBuyOfferBuyNoIssuer", xdr3["void"]()], ["manageBuyOfferNotFound", xdr3["void"]()], ["manageBuyOfferLowReserve", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("ManageOfferSuccessResult")
        }
      });
      xdr3["enum"]("SetOptionsResultCode", {
        setOptionsSuccess: 0,
        setOptionsLowReserve: -1,
        setOptionsTooManySigners: -2,
        setOptionsBadFlags: -3,
        setOptionsInvalidInflation: -4,
        setOptionsCantChange: -5,
        setOptionsUnknownFlag: -6,
        setOptionsThresholdOutOfRange: -7,
        setOptionsBadSigner: -8,
        setOptionsInvalidHomeDomain: -9,
        setOptionsAuthRevocableRequired: -10
      });
      xdr3.union("SetOptionsResult", {
        switchOn: xdr3.lookup("SetOptionsResultCode"),
        switchName: "code",
        switches: [["setOptionsSuccess", xdr3["void"]()], ["setOptionsLowReserve", xdr3["void"]()], ["setOptionsTooManySigners", xdr3["void"]()], ["setOptionsBadFlags", xdr3["void"]()], ["setOptionsInvalidInflation", xdr3["void"]()], ["setOptionsCantChange", xdr3["void"]()], ["setOptionsUnknownFlag", xdr3["void"]()], ["setOptionsThresholdOutOfRange", xdr3["void"]()], ["setOptionsBadSigner", xdr3["void"]()], ["setOptionsInvalidHomeDomain", xdr3["void"]()], ["setOptionsAuthRevocableRequired", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ChangeTrustResultCode", {
        changeTrustSuccess: 0,
        changeTrustMalformed: -1,
        changeTrustNoIssuer: -2,
        changeTrustInvalidLimit: -3,
        changeTrustLowReserve: -4,
        changeTrustSelfNotAllowed: -5,
        changeTrustTrustLineMissing: -6,
        changeTrustCannotDelete: -7,
        changeTrustNotAuthMaintainLiabilities: -8
      });
      xdr3.union("ChangeTrustResult", {
        switchOn: xdr3.lookup("ChangeTrustResultCode"),
        switchName: "code",
        switches: [["changeTrustSuccess", xdr3["void"]()], ["changeTrustMalformed", xdr3["void"]()], ["changeTrustNoIssuer", xdr3["void"]()], ["changeTrustInvalidLimit", xdr3["void"]()], ["changeTrustLowReserve", xdr3["void"]()], ["changeTrustSelfNotAllowed", xdr3["void"]()], ["changeTrustTrustLineMissing", xdr3["void"]()], ["changeTrustCannotDelete", xdr3["void"]()], ["changeTrustNotAuthMaintainLiabilities", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("AllowTrustResultCode", {
        allowTrustSuccess: 0,
        allowTrustMalformed: -1,
        allowTrustNoTrustLine: -2,
        allowTrustTrustNotRequired: -3,
        allowTrustCantRevoke: -4,
        allowTrustSelfNotAllowed: -5,
        allowTrustLowReserve: -6
      });
      xdr3.union("AllowTrustResult", {
        switchOn: xdr3.lookup("AllowTrustResultCode"),
        switchName: "code",
        switches: [["allowTrustSuccess", xdr3["void"]()], ["allowTrustMalformed", xdr3["void"]()], ["allowTrustNoTrustLine", xdr3["void"]()], ["allowTrustTrustNotRequired", xdr3["void"]()], ["allowTrustCantRevoke", xdr3["void"]()], ["allowTrustSelfNotAllowed", xdr3["void"]()], ["allowTrustLowReserve", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("AccountMergeResultCode", {
        accountMergeSuccess: 0,
        accountMergeMalformed: -1,
        accountMergeNoAccount: -2,
        accountMergeImmutableSet: -3,
        accountMergeHasSubEntries: -4,
        accountMergeSeqnumTooFar: -5,
        accountMergeDestFull: -6,
        accountMergeIsSponsor: -7
      });
      xdr3.union("AccountMergeResult", {
        switchOn: xdr3.lookup("AccountMergeResultCode"),
        switchName: "code",
        switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", xdr3["void"]()], ["accountMergeNoAccount", xdr3["void"]()], ["accountMergeImmutableSet", xdr3["void"]()], ["accountMergeHasSubEntries", xdr3["void"]()], ["accountMergeSeqnumTooFar", xdr3["void"]()], ["accountMergeDestFull", xdr3["void"]()], ["accountMergeIsSponsor", xdr3["void"]()]],
        arms: {
          sourceAccountBalance: xdr3.lookup("Int64")
        }
      });
      xdr3["enum"]("InflationResultCode", {
        inflationSuccess: 0,
        inflationNotTime: -1
      });
      xdr3.struct("InflationPayout", [["destination", xdr3.lookup("AccountId")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.union("InflationResult", {
        switchOn: xdr3.lookup("InflationResultCode"),
        switchName: "code",
        switches: [["inflationSuccess", "payouts"], ["inflationNotTime", xdr3["void"]()]],
        arms: {
          payouts: xdr3.varArray(xdr3.lookup("InflationPayout"), 2147483647)
        }
      });
      xdr3["enum"]("ManageDataResultCode", {
        manageDataSuccess: 0,
        manageDataNotSupportedYet: -1,
        manageDataNameNotFound: -2,
        manageDataLowReserve: -3,
        manageDataInvalidName: -4
      });
      xdr3.union("ManageDataResult", {
        switchOn: xdr3.lookup("ManageDataResultCode"),
        switchName: "code",
        switches: [["manageDataSuccess", xdr3["void"]()], ["manageDataNotSupportedYet", xdr3["void"]()], ["manageDataNameNotFound", xdr3["void"]()], ["manageDataLowReserve", xdr3["void"]()], ["manageDataInvalidName", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("BumpSequenceResultCode", {
        bumpSequenceSuccess: 0,
        bumpSequenceBadSeq: -1
      });
      xdr3.union("BumpSequenceResult", {
        switchOn: xdr3.lookup("BumpSequenceResultCode"),
        switchName: "code",
        switches: [["bumpSequenceSuccess", xdr3["void"]()], ["bumpSequenceBadSeq", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("CreateClaimableBalanceResultCode", {
        createClaimableBalanceSuccess: 0,
        createClaimableBalanceMalformed: -1,
        createClaimableBalanceLowReserve: -2,
        createClaimableBalanceNoTrust: -3,
        createClaimableBalanceNotAuthorized: -4,
        createClaimableBalanceUnderfunded: -5
      });
      xdr3.union("CreateClaimableBalanceResult", {
        switchOn: xdr3.lookup("CreateClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", xdr3["void"]()], ["createClaimableBalanceLowReserve", xdr3["void"]()], ["createClaimableBalanceNoTrust", xdr3["void"]()], ["createClaimableBalanceNotAuthorized", xdr3["void"]()], ["createClaimableBalanceUnderfunded", xdr3["void"]()]],
        arms: {
          balanceId: xdr3.lookup("ClaimableBalanceId")
        }
      });
      xdr3["enum"]("ClaimClaimableBalanceResultCode", {
        claimClaimableBalanceSuccess: 0,
        claimClaimableBalanceDoesNotExist: -1,
        claimClaimableBalanceCannotClaim: -2,
        claimClaimableBalanceLineFull: -3,
        claimClaimableBalanceNoTrust: -4,
        claimClaimableBalanceNotAuthorized: -5
      });
      xdr3.union("ClaimClaimableBalanceResult", {
        switchOn: xdr3.lookup("ClaimClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["claimClaimableBalanceSuccess", xdr3["void"]()], ["claimClaimableBalanceDoesNotExist", xdr3["void"]()], ["claimClaimableBalanceCannotClaim", xdr3["void"]()], ["claimClaimableBalanceLineFull", xdr3["void"]()], ["claimClaimableBalanceNoTrust", xdr3["void"]()], ["claimClaimableBalanceNotAuthorized", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("BeginSponsoringFutureReservesResultCode", {
        beginSponsoringFutureReservesSuccess: 0,
        beginSponsoringFutureReservesMalformed: -1,
        beginSponsoringFutureReservesAlreadySponsored: -2,
        beginSponsoringFutureReservesRecursive: -3
      });
      xdr3.union("BeginSponsoringFutureReservesResult", {
        switchOn: xdr3.lookup("BeginSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["beginSponsoringFutureReservesSuccess", xdr3["void"]()], ["beginSponsoringFutureReservesMalformed", xdr3["void"]()], ["beginSponsoringFutureReservesAlreadySponsored", xdr3["void"]()], ["beginSponsoringFutureReservesRecursive", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("EndSponsoringFutureReservesResultCode", {
        endSponsoringFutureReservesSuccess: 0,
        endSponsoringFutureReservesNotSponsored: -1
      });
      xdr3.union("EndSponsoringFutureReservesResult", {
        switchOn: xdr3.lookup("EndSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["endSponsoringFutureReservesSuccess", xdr3["void"]()], ["endSponsoringFutureReservesNotSponsored", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("RevokeSponsorshipResultCode", {
        revokeSponsorshipSuccess: 0,
        revokeSponsorshipDoesNotExist: -1,
        revokeSponsorshipNotSponsor: -2,
        revokeSponsorshipLowReserve: -3,
        revokeSponsorshipOnlyTransferable: -4,
        revokeSponsorshipMalformed: -5
      });
      xdr3.union("RevokeSponsorshipResult", {
        switchOn: xdr3.lookup("RevokeSponsorshipResultCode"),
        switchName: "code",
        switches: [["revokeSponsorshipSuccess", xdr3["void"]()], ["revokeSponsorshipDoesNotExist", xdr3["void"]()], ["revokeSponsorshipNotSponsor", xdr3["void"]()], ["revokeSponsorshipLowReserve", xdr3["void"]()], ["revokeSponsorshipOnlyTransferable", xdr3["void"]()], ["revokeSponsorshipMalformed", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ClawbackResultCode", {
        clawbackSuccess: 0,
        clawbackMalformed: -1,
        clawbackNotClawbackEnabled: -2,
        clawbackNoTrust: -3,
        clawbackUnderfunded: -4
      });
      xdr3.union("ClawbackResult", {
        switchOn: xdr3.lookup("ClawbackResultCode"),
        switchName: "code",
        switches: [["clawbackSuccess", xdr3["void"]()], ["clawbackMalformed", xdr3["void"]()], ["clawbackNotClawbackEnabled", xdr3["void"]()], ["clawbackNoTrust", xdr3["void"]()], ["clawbackUnderfunded", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ClawbackClaimableBalanceResultCode", {
        clawbackClaimableBalanceSuccess: 0,
        clawbackClaimableBalanceDoesNotExist: -1,
        clawbackClaimableBalanceNotIssuer: -2,
        clawbackClaimableBalanceNotClawbackEnabled: -3
      });
      xdr3.union("ClawbackClaimableBalanceResult", {
        switchOn: xdr3.lookup("ClawbackClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["clawbackClaimableBalanceSuccess", xdr3["void"]()], ["clawbackClaimableBalanceDoesNotExist", xdr3["void"]()], ["clawbackClaimableBalanceNotIssuer", xdr3["void"]()], ["clawbackClaimableBalanceNotClawbackEnabled", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("SetTrustLineFlagsResultCode", {
        setTrustLineFlagsSuccess: 0,
        setTrustLineFlagsMalformed: -1,
        setTrustLineFlagsNoTrustLine: -2,
        setTrustLineFlagsCantRevoke: -3,
        setTrustLineFlagsInvalidState: -4,
        setTrustLineFlagsLowReserve: -5
      });
      xdr3.union("SetTrustLineFlagsResult", {
        switchOn: xdr3.lookup("SetTrustLineFlagsResultCode"),
        switchName: "code",
        switches: [["setTrustLineFlagsSuccess", xdr3["void"]()], ["setTrustLineFlagsMalformed", xdr3["void"]()], ["setTrustLineFlagsNoTrustLine", xdr3["void"]()], ["setTrustLineFlagsCantRevoke", xdr3["void"]()], ["setTrustLineFlagsInvalidState", xdr3["void"]()], ["setTrustLineFlagsLowReserve", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("LiquidityPoolDepositResultCode", {
        liquidityPoolDepositSuccess: 0,
        liquidityPoolDepositMalformed: -1,
        liquidityPoolDepositNoTrust: -2,
        liquidityPoolDepositNotAuthorized: -3,
        liquidityPoolDepositUnderfunded: -4,
        liquidityPoolDepositLineFull: -5,
        liquidityPoolDepositBadPrice: -6,
        liquidityPoolDepositPoolFull: -7
      });
      xdr3.union("LiquidityPoolDepositResult", {
        switchOn: xdr3.lookup("LiquidityPoolDepositResultCode"),
        switchName: "code",
        switches: [["liquidityPoolDepositSuccess", xdr3["void"]()], ["liquidityPoolDepositMalformed", xdr3["void"]()], ["liquidityPoolDepositNoTrust", xdr3["void"]()], ["liquidityPoolDepositNotAuthorized", xdr3["void"]()], ["liquidityPoolDepositUnderfunded", xdr3["void"]()], ["liquidityPoolDepositLineFull", xdr3["void"]()], ["liquidityPoolDepositBadPrice", xdr3["void"]()], ["liquidityPoolDepositPoolFull", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("LiquidityPoolWithdrawResultCode", {
        liquidityPoolWithdrawSuccess: 0,
        liquidityPoolWithdrawMalformed: -1,
        liquidityPoolWithdrawNoTrust: -2,
        liquidityPoolWithdrawUnderfunded: -3,
        liquidityPoolWithdrawLineFull: -4,
        liquidityPoolWithdrawUnderMinimum: -5
      });
      xdr3.union("LiquidityPoolWithdrawResult", {
        switchOn: xdr3.lookup("LiquidityPoolWithdrawResultCode"),
        switchName: "code",
        switches: [["liquidityPoolWithdrawSuccess", xdr3["void"]()], ["liquidityPoolWithdrawMalformed", xdr3["void"]()], ["liquidityPoolWithdrawNoTrust", xdr3["void"]()], ["liquidityPoolWithdrawUnderfunded", xdr3["void"]()], ["liquidityPoolWithdrawLineFull", xdr3["void"]()], ["liquidityPoolWithdrawUnderMinimum", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("InvokeHostFunctionResultCode", {
        invokeHostFunctionSuccess: 0,
        invokeHostFunctionMalformed: -1,
        invokeHostFunctionTrapped: -2,
        invokeHostFunctionResourceLimitExceeded: -3,
        invokeHostFunctionEntryArchived: -4,
        invokeHostFunctionInsufficientRefundableFee: -5
      });
      xdr3.union("InvokeHostFunctionResult", {
        switchOn: xdr3.lookup("InvokeHostFunctionResultCode"),
        switchName: "code",
        switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", xdr3["void"]()], ["invokeHostFunctionTrapped", xdr3["void"]()], ["invokeHostFunctionResourceLimitExceeded", xdr3["void"]()], ["invokeHostFunctionEntryArchived", xdr3["void"]()], ["invokeHostFunctionInsufficientRefundableFee", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ExtendFootprintTtlResultCode", {
        extendFootprintTtlSuccess: 0,
        extendFootprintTtlMalformed: -1,
        extendFootprintTtlResourceLimitExceeded: -2,
        extendFootprintTtlInsufficientRefundableFee: -3
      });
      xdr3.union("ExtendFootprintTtlResult", {
        switchOn: xdr3.lookup("ExtendFootprintTtlResultCode"),
        switchName: "code",
        switches: [["extendFootprintTtlSuccess", xdr3["void"]()], ["extendFootprintTtlMalformed", xdr3["void"]()], ["extendFootprintTtlResourceLimitExceeded", xdr3["void"]()], ["extendFootprintTtlInsufficientRefundableFee", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("RestoreFootprintResultCode", {
        restoreFootprintSuccess: 0,
        restoreFootprintMalformed: -1,
        restoreFootprintResourceLimitExceeded: -2,
        restoreFootprintInsufficientRefundableFee: -3
      });
      xdr3.union("RestoreFootprintResult", {
        switchOn: xdr3.lookup("RestoreFootprintResultCode"),
        switchName: "code",
        switches: [["restoreFootprintSuccess", xdr3["void"]()], ["restoreFootprintMalformed", xdr3["void"]()], ["restoreFootprintResourceLimitExceeded", xdr3["void"]()], ["restoreFootprintInsufficientRefundableFee", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("OperationResultCode", {
        opInner: 0,
        opBadAuth: -1,
        opNoAccount: -2,
        opNotSupported: -3,
        opTooManySubentries: -4,
        opExceededWorkLimit: -5,
        opTooManySponsoring: -6
      });
      xdr3.union("OperationResultTr", {
        switchOn: xdr3.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]],
        arms: {
          createAccountResult: xdr3.lookup("CreateAccountResult"),
          paymentResult: xdr3.lookup("PaymentResult"),
          pathPaymentStrictReceiveResult: xdr3.lookup("PathPaymentStrictReceiveResult"),
          manageSellOfferResult: xdr3.lookup("ManageSellOfferResult"),
          createPassiveSellOfferResult: xdr3.lookup("ManageSellOfferResult"),
          setOptionsResult: xdr3.lookup("SetOptionsResult"),
          changeTrustResult: xdr3.lookup("ChangeTrustResult"),
          allowTrustResult: xdr3.lookup("AllowTrustResult"),
          accountMergeResult: xdr3.lookup("AccountMergeResult"),
          inflationResult: xdr3.lookup("InflationResult"),
          manageDataResult: xdr3.lookup("ManageDataResult"),
          bumpSeqResult: xdr3.lookup("BumpSequenceResult"),
          manageBuyOfferResult: xdr3.lookup("ManageBuyOfferResult"),
          pathPaymentStrictSendResult: xdr3.lookup("PathPaymentStrictSendResult"),
          createClaimableBalanceResult: xdr3.lookup("CreateClaimableBalanceResult"),
          claimClaimableBalanceResult: xdr3.lookup("ClaimClaimableBalanceResult"),
          beginSponsoringFutureReservesResult: xdr3.lookup("BeginSponsoringFutureReservesResult"),
          endSponsoringFutureReservesResult: xdr3.lookup("EndSponsoringFutureReservesResult"),
          revokeSponsorshipResult: xdr3.lookup("RevokeSponsorshipResult"),
          clawbackResult: xdr3.lookup("ClawbackResult"),
          clawbackClaimableBalanceResult: xdr3.lookup("ClawbackClaimableBalanceResult"),
          setTrustLineFlagsResult: xdr3.lookup("SetTrustLineFlagsResult"),
          liquidityPoolDepositResult: xdr3.lookup("LiquidityPoolDepositResult"),
          liquidityPoolWithdrawResult: xdr3.lookup("LiquidityPoolWithdrawResult"),
          invokeHostFunctionResult: xdr3.lookup("InvokeHostFunctionResult"),
          extendFootprintTtlResult: xdr3.lookup("ExtendFootprintTtlResult"),
          restoreFootprintResult: xdr3.lookup("RestoreFootprintResult")
        }
      });
      xdr3.union("OperationResult", {
        switchOn: xdr3.lookup("OperationResultCode"),
        switchName: "code",
        switches: [["opInner", "tr"], ["opBadAuth", xdr3["void"]()], ["opNoAccount", xdr3["void"]()], ["opNotSupported", xdr3["void"]()], ["opTooManySubentries", xdr3["void"]()], ["opExceededWorkLimit", xdr3["void"]()], ["opTooManySponsoring", xdr3["void"]()]],
        arms: {
          tr: xdr3.lookup("OperationResultTr")
        }
      });
      xdr3["enum"]("TransactionResultCode", {
        txFeeBumpInnerSuccess: 1,
        txSuccess: 0,
        txFailed: -1,
        txTooEarly: -2,
        txTooLate: -3,
        txMissingOperation: -4,
        txBadSeq: -5,
        txBadAuth: -6,
        txInsufficientBalance: -7,
        txNoAccount: -8,
        txInsufficientFee: -9,
        txBadAuthExtra: -10,
        txInternalError: -11,
        txNotSupported: -12,
        txFeeBumpInnerFailed: -13,
        txBadSponsorship: -14,
        txBadMinSeqAgeOrGap: -15,
        txMalformed: -16,
        txSorobanInvalid: -17
      });
      xdr3.union("InnerTransactionResultResult", {
        switchOn: xdr3.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr3["void"]()], ["txTooLate", xdr3["void"]()], ["txMissingOperation", xdr3["void"]()], ["txBadSeq", xdr3["void"]()], ["txBadAuth", xdr3["void"]()], ["txInsufficientBalance", xdr3["void"]()], ["txNoAccount", xdr3["void"]()], ["txInsufficientFee", xdr3["void"]()], ["txBadAuthExtra", xdr3["void"]()], ["txInternalError", xdr3["void"]()], ["txNotSupported", xdr3["void"]()], ["txBadSponsorship", xdr3["void"]()], ["txBadMinSeqAgeOrGap", xdr3["void"]()], ["txMalformed", xdr3["void"]()], ["txSorobanInvalid", xdr3["void"]()]],
        arms: {
          results: xdr3.varArray(xdr3.lookup("OperationResult"), 2147483647)
        }
      });
      xdr3.union("InnerTransactionResultExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("InnerTransactionResult", [["feeCharged", xdr3.lookup("Int64")], ["result", xdr3.lookup("InnerTransactionResultResult")], ["ext", xdr3.lookup("InnerTransactionResultExt")]]);
      xdr3.struct("InnerTransactionResultPair", [["transactionHash", xdr3.lookup("Hash")], ["result", xdr3.lookup("InnerTransactionResult")]]);
      xdr3.union("TransactionResultResult", {
        switchOn: xdr3.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr3["void"]()], ["txTooLate", xdr3["void"]()], ["txMissingOperation", xdr3["void"]()], ["txBadSeq", xdr3["void"]()], ["txBadAuth", xdr3["void"]()], ["txInsufficientBalance", xdr3["void"]()], ["txNoAccount", xdr3["void"]()], ["txInsufficientFee", xdr3["void"]()], ["txBadAuthExtra", xdr3["void"]()], ["txInternalError", xdr3["void"]()], ["txNotSupported", xdr3["void"]()], ["txBadSponsorship", xdr3["void"]()], ["txBadMinSeqAgeOrGap", xdr3["void"]()], ["txMalformed", xdr3["void"]()], ["txSorobanInvalid", xdr3["void"]()]],
        arms: {
          innerResultPair: xdr3.lookup("InnerTransactionResultPair"),
          results: xdr3.varArray(xdr3.lookup("OperationResult"), 2147483647)
        }
      });
      xdr3.union("TransactionResultExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionResult", [["feeCharged", xdr3.lookup("Int64")], ["result", xdr3.lookup("TransactionResultResult")], ["ext", xdr3.lookup("TransactionResultExt")]]);
      xdr3.typedef("Hash", xdr3.opaque(32));
      xdr3.typedef("Uint256", xdr3.opaque(32));
      xdr3.typedef("Uint32", xdr3.uint());
      xdr3.typedef("Int32", xdr3["int"]());
      xdr3.typedef("Uint64", xdr3.uhyper());
      xdr3.typedef("Int64", xdr3.hyper());
      xdr3.typedef("TimePoint", xdr3.lookup("Uint64"));
      xdr3.typedef("Duration", xdr3.lookup("Uint64"));
      xdr3.union("ExtensionPoint", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("CryptoKeyType", {
        keyTypeEd25519: 0,
        keyTypePreAuthTx: 1,
        keyTypeHashX: 2,
        keyTypeEd25519SignedPayload: 3,
        keyTypeMuxedEd25519: 256
      });
      xdr3["enum"]("PublicKeyType", {
        publicKeyTypeEd25519: 0
      });
      xdr3["enum"]("SignerKeyType", {
        signerKeyTypeEd25519: 0,
        signerKeyTypePreAuthTx: 1,
        signerKeyTypeHashX: 2,
        signerKeyTypeEd25519SignedPayload: 3
      });
      xdr3.union("PublicKey", {
        switchOn: xdr3.lookup("PublicKeyType"),
        switchName: "type",
        switches: [["publicKeyTypeEd25519", "ed25519"]],
        arms: {
          ed25519: xdr3.lookup("Uint256")
        }
      });
      xdr3.struct("SignerKeyEd25519SignedPayload", [["ed25519", xdr3.lookup("Uint256")], ["payload", xdr3.varOpaque(64)]]);
      xdr3.union("SignerKey", {
        switchOn: xdr3.lookup("SignerKeyType"),
        switchName: "type",
        switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]],
        arms: {
          ed25519: xdr3.lookup("Uint256"),
          preAuthTx: xdr3.lookup("Uint256"),
          hashX: xdr3.lookup("Uint256"),
          ed25519SignedPayload: xdr3.lookup("SignerKeyEd25519SignedPayload")
        }
      });
      xdr3.typedef("Signature", xdr3.varOpaque(64));
      xdr3.typedef("SignatureHint", xdr3.opaque(4));
      xdr3.typedef("NodeId", xdr3.lookup("PublicKey"));
      xdr3.typedef("AccountId", xdr3.lookup("PublicKey"));
      xdr3.struct("Curve25519Secret", [["key", xdr3.opaque(32)]]);
      xdr3.struct("Curve25519Public", [["key", xdr3.opaque(32)]]);
      xdr3.struct("HmacSha256Key", [["key", xdr3.opaque(32)]]);
      xdr3.struct("HmacSha256Mac", [["mac", xdr3.opaque(32)]]);
      xdr3.struct("ShortHashSeed", [["seed", xdr3.opaque(16)]]);
      xdr3["enum"]("BinaryFuseFilterType", {
        binaryFuseFilter8Bit: 0,
        binaryFuseFilter16Bit: 1,
        binaryFuseFilter32Bit: 2
      });
      xdr3.struct("SerializedBinaryFuseFilter", [["type", xdr3.lookup("BinaryFuseFilterType")], ["inputHashSeed", xdr3.lookup("ShortHashSeed")], ["filterSeed", xdr3.lookup("ShortHashSeed")], ["segmentLength", xdr3.lookup("Uint32")], ["segementLengthMask", xdr3.lookup("Uint32")], ["segmentCount", xdr3.lookup("Uint32")], ["segmentCountLength", xdr3.lookup("Uint32")], ["fingerprintLength", xdr3.lookup("Uint32")], ["fingerprints", xdr3.varOpaque()]]);
      xdr3["enum"]("ScValType", {
        scvBool: 0,
        scvVoid: 1,
        scvError: 2,
        scvU32: 3,
        scvI32: 4,
        scvU64: 5,
        scvI64: 6,
        scvTimepoint: 7,
        scvDuration: 8,
        scvU128: 9,
        scvI128: 10,
        scvU256: 11,
        scvI256: 12,
        scvBytes: 13,
        scvString: 14,
        scvSymbol: 15,
        scvVec: 16,
        scvMap: 17,
        scvAddress: 18,
        scvContractInstance: 19,
        scvLedgerKeyContractInstance: 20,
        scvLedgerKeyNonce: 21
      });
      xdr3["enum"]("ScErrorType", {
        sceContract: 0,
        sceWasmVm: 1,
        sceContext: 2,
        sceStorage: 3,
        sceObject: 4,
        sceCrypto: 5,
        sceEvents: 6,
        sceBudget: 7,
        sceValue: 8,
        sceAuth: 9
      });
      xdr3["enum"]("ScErrorCode", {
        scecArithDomain: 0,
        scecIndexBounds: 1,
        scecInvalidInput: 2,
        scecMissingValue: 3,
        scecExistingValue: 4,
        scecExceededLimit: 5,
        scecInvalidAction: 6,
        scecInternalError: 7,
        scecUnexpectedType: 8,
        scecUnexpectedSize: 9
      });
      xdr3.union("ScError", {
        switchOn: xdr3.lookup("ScErrorType"),
        switchName: "type",
        switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]],
        arms: {
          contractCode: xdr3.lookup("Uint32"),
          code: xdr3.lookup("ScErrorCode")
        }
      });
      xdr3.struct("UInt128Parts", [["hi", xdr3.lookup("Uint64")], ["lo", xdr3.lookup("Uint64")]]);
      xdr3.struct("Int128Parts", [["hi", xdr3.lookup("Int64")], ["lo", xdr3.lookup("Uint64")]]);
      xdr3.struct("UInt256Parts", [["hiHi", xdr3.lookup("Uint64")], ["hiLo", xdr3.lookup("Uint64")], ["loHi", xdr3.lookup("Uint64")], ["loLo", xdr3.lookup("Uint64")]]);
      xdr3.struct("Int256Parts", [["hiHi", xdr3.lookup("Int64")], ["hiLo", xdr3.lookup("Uint64")], ["loHi", xdr3.lookup("Uint64")], ["loLo", xdr3.lookup("Uint64")]]);
      xdr3["enum"]("ContractExecutableType", {
        contractExecutableWasm: 0,
        contractExecutableStellarAsset: 1
      });
      xdr3.union("ContractExecutable", {
        switchOn: xdr3.lookup("ContractExecutableType"),
        switchName: "type",
        switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", xdr3["void"]()]],
        arms: {
          wasmHash: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ScAddressType", {
        scAddressTypeAccount: 0,
        scAddressTypeContract: 1
      });
      xdr3.union("ScAddress", {
        switchOn: xdr3.lookup("ScAddressType"),
        switchName: "type",
        switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]],
        arms: {
          accountId: xdr3.lookup("AccountId"),
          contractId: xdr3.lookup("Hash")
        }
      });
      xdr3["const"]("SCSYMBOL_LIMIT", 32);
      xdr3.typedef("ScVec", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647));
      xdr3.typedef("ScMap", xdr3.varArray(xdr3.lookup("ScMapEntry"), 2147483647));
      xdr3.typedef("ScBytes", xdr3.varOpaque());
      xdr3.typedef("ScString", xdr3.string());
      xdr3.typedef("ScSymbol", xdr3.string(SCSYMBOL_LIMIT));
      xdr3.struct("ScNonceKey", [["nonce", xdr3.lookup("Int64")]]);
      xdr3.struct("ScContractInstance", [["executable", xdr3.lookup("ContractExecutable")], ["storage", xdr3.option(xdr3.lookup("ScMap"))]]);
      xdr3.union("ScVal", {
        switchOn: xdr3.lookup("ScValType"),
        switchName: "type",
        switches: [["scvBool", "b"], ["scvVoid", xdr3["void"]()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", xdr3["void"]()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]],
        arms: {
          b: xdr3.bool(),
          error: xdr3.lookup("ScError"),
          u32: xdr3.lookup("Uint32"),
          i32: xdr3.lookup("Int32"),
          u64: xdr3.lookup("Uint64"),
          i64: xdr3.lookup("Int64"),
          timepoint: xdr3.lookup("TimePoint"),
          duration: xdr3.lookup("Duration"),
          u128: xdr3.lookup("UInt128Parts"),
          i128: xdr3.lookup("Int128Parts"),
          u256: xdr3.lookup("UInt256Parts"),
          i256: xdr3.lookup("Int256Parts"),
          bytes: xdr3.lookup("ScBytes"),
          str: xdr3.lookup("ScString"),
          sym: xdr3.lookup("ScSymbol"),
          vec: xdr3.option(xdr3.lookup("ScVec")),
          map: xdr3.option(xdr3.lookup("ScMap")),
          address: xdr3.lookup("ScAddress"),
          nonceKey: xdr3.lookup("ScNonceKey"),
          instance: xdr3.lookup("ScContractInstance")
        }
      });
      xdr3.struct("ScMapEntry", [["key", xdr3.lookup("ScVal")], ["val", xdr3.lookup("ScVal")]]);
      xdr3["enum"]("ScEnvMetaKind", {
        scEnvMetaKindInterfaceVersion: 0
      });
      xdr3.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", xdr3.lookup("Uint32")], ["preRelease", xdr3.lookup("Uint32")]]);
      xdr3.union("ScEnvMetaEntry", {
        switchOn: xdr3.lookup("ScEnvMetaKind"),
        switchName: "kind",
        switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]],
        arms: {
          interfaceVersion: xdr3.lookup("ScEnvMetaEntryInterfaceVersion")
        }
      });
      xdr3.struct("ScMetaV0", [["key", xdr3.string()], ["val", xdr3.string()]]);
      xdr3["enum"]("ScMetaKind", {
        scMetaV0: 0
      });
      xdr3.union("ScMetaEntry", {
        switchOn: xdr3.lookup("ScMetaKind"),
        switchName: "kind",
        switches: [["scMetaV0", "v0"]],
        arms: {
          v0: xdr3.lookup("ScMetaV0")
        }
      });
      xdr3["const"]("SC_SPEC_DOC_LIMIT", 1024);
      xdr3["enum"]("ScSpecType", {
        scSpecTypeVal: 0,
        scSpecTypeBool: 1,
        scSpecTypeVoid: 2,
        scSpecTypeError: 3,
        scSpecTypeU32: 4,
        scSpecTypeI32: 5,
        scSpecTypeU64: 6,
        scSpecTypeI64: 7,
        scSpecTypeTimepoint: 8,
        scSpecTypeDuration: 9,
        scSpecTypeU128: 10,
        scSpecTypeI128: 11,
        scSpecTypeU256: 12,
        scSpecTypeI256: 13,
        scSpecTypeBytes: 14,
        scSpecTypeString: 16,
        scSpecTypeSymbol: 17,
        scSpecTypeAddress: 19,
        scSpecTypeOption: 1e3,
        scSpecTypeResult: 1001,
        scSpecTypeVec: 1002,
        scSpecTypeMap: 1004,
        scSpecTypeTuple: 1005,
        scSpecTypeBytesN: 1006,
        scSpecTypeUdt: 2e3
      });
      xdr3.struct("ScSpecTypeOption", [["valueType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeResult", [["okType", xdr3.lookup("ScSpecTypeDef")], ["errorType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeVec", [["elementType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeMap", [["keyType", xdr3.lookup("ScSpecTypeDef")], ["valueType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeTuple", [["valueTypes", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 12)]]);
      xdr3.struct("ScSpecTypeBytesN", [["n", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecTypeUdt", [["name", xdr3.string(60)]]);
      xdr3.union("ScSpecTypeDef", {
        switchOn: xdr3.lookup("ScSpecType"),
        switchName: "type",
        switches: [["scSpecTypeVal", xdr3["void"]()], ["scSpecTypeBool", xdr3["void"]()], ["scSpecTypeVoid", xdr3["void"]()], ["scSpecTypeError", xdr3["void"]()], ["scSpecTypeU32", xdr3["void"]()], ["scSpecTypeI32", xdr3["void"]()], ["scSpecTypeU64", xdr3["void"]()], ["scSpecTypeI64", xdr3["void"]()], ["scSpecTypeTimepoint", xdr3["void"]()], ["scSpecTypeDuration", xdr3["void"]()], ["scSpecTypeU128", xdr3["void"]()], ["scSpecTypeI128", xdr3["void"]()], ["scSpecTypeU256", xdr3["void"]()], ["scSpecTypeI256", xdr3["void"]()], ["scSpecTypeBytes", xdr3["void"]()], ["scSpecTypeString", xdr3["void"]()], ["scSpecTypeSymbol", xdr3["void"]()], ["scSpecTypeAddress", xdr3["void"]()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]],
        arms: {
          option: xdr3.lookup("ScSpecTypeOption"),
          result: xdr3.lookup("ScSpecTypeResult"),
          vec: xdr3.lookup("ScSpecTypeVec"),
          map: xdr3.lookup("ScSpecTypeMap"),
          tuple: xdr3.lookup("ScSpecTypeTuple"),
          bytesN: xdr3.lookup("ScSpecTypeBytesN"),
          udt: xdr3.lookup("ScSpecTypeUdt")
        }
      });
      xdr3.struct("ScSpecUdtStructFieldV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(30)], ["type", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecUdtStructV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["fields", xdr3.varArray(xdr3.lookup("ScSpecUdtStructFieldV0"), 40)]]);
      xdr3.struct("ScSpecUdtUnionCaseVoidV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)]]);
      xdr3.struct("ScSpecUdtUnionCaseTupleV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["type", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 12)]]);
      xdr3["enum"]("ScSpecUdtUnionCaseV0Kind", {
        scSpecUdtUnionCaseVoidV0: 0,
        scSpecUdtUnionCaseTupleV0: 1
      });
      xdr3.union("ScSpecUdtUnionCaseV0", {
        switchOn: xdr3.lookup("ScSpecUdtUnionCaseV0Kind"),
        switchName: "kind",
        switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]],
        arms: {
          voidCase: xdr3.lookup("ScSpecUdtUnionCaseVoidV0"),
          tupleCase: xdr3.lookup("ScSpecUdtUnionCaseTupleV0")
        }
      });
      xdr3.struct("ScSpecUdtUnionV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtUnionCaseV0"), 50)]]);
      xdr3.struct("ScSpecUdtEnumCaseV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["value", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecUdtEnumV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtEnumCaseV0"), 50)]]);
      xdr3.struct("ScSpecUdtErrorEnumCaseV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["value", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecUdtErrorEnumV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]);
      xdr3.struct("ScSpecFunctionInputV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(30)], ["type", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecFunctionV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.lookup("ScSymbol")], ["inputs", xdr3.varArray(xdr3.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 1)]]);
      xdr3["enum"]("ScSpecEntryKind", {
        scSpecEntryFunctionV0: 0,
        scSpecEntryUdtStructV0: 1,
        scSpecEntryUdtUnionV0: 2,
        scSpecEntryUdtEnumV0: 3,
        scSpecEntryUdtErrorEnumV0: 4
      });
      xdr3.union("ScSpecEntry", {
        switchOn: xdr3.lookup("ScSpecEntryKind"),
        switchName: "kind",
        switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]],
        arms: {
          functionV0: xdr3.lookup("ScSpecFunctionV0"),
          udtStructV0: xdr3.lookup("ScSpecUdtStructV0"),
          udtUnionV0: xdr3.lookup("ScSpecUdtUnionV0"),
          udtEnumV0: xdr3.lookup("ScSpecUdtEnumV0"),
          udtErrorEnumV0: xdr3.lookup("ScSpecUdtErrorEnumV0")
        }
      });
      xdr3.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", xdr3.lookup("Int64")], ["txMaxInstructions", xdr3.lookup("Int64")], ["feeRatePerInstructionsIncrement", xdr3.lookup("Int64")], ["txMemoryLimit", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", xdr3.lookup("Uint32")], ["ledgerMaxReadBytes", xdr3.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", xdr3.lookup("Uint32")], ["ledgerMaxWriteBytes", xdr3.lookup("Uint32")], ["txMaxReadLedgerEntries", xdr3.lookup("Uint32")], ["txMaxReadBytes", xdr3.lookup("Uint32")], ["txMaxWriteLedgerEntries", xdr3.lookup("Uint32")], ["txMaxWriteBytes", xdr3.lookup("Uint32")], ["feeReadLedgerEntry", xdr3.lookup("Int64")], ["feeWriteLedgerEntry", xdr3.lookup("Int64")], ["feeRead1Kb", xdr3.lookup("Int64")], ["bucketListTargetSizeBytes", xdr3.lookup("Int64")], ["writeFee1KbBucketListLow", xdr3.lookup("Int64")], ["writeFee1KbBucketListHigh", xdr3.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", xdr3.lookup("Int64")]]);
      xdr3.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", xdr3.lookup("Uint32")], ["feeContractEvents1Kb", xdr3.lookup("Int64")]]);
      xdr3.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", xdr3.lookup("Uint32")], ["txMaxSizeBytes", xdr3.lookup("Uint32")], ["feeTxSize1Kb", xdr3.lookup("Int64")]]);
      xdr3["enum"]("ContractCostType", {
        wasmInsnExec: 0,
        memAlloc: 1,
        memCpy: 2,
        memCmp: 3,
        dispatchHostFunction: 4,
        visitObject: 5,
        valSer: 6,
        valDeser: 7,
        computeSha256Hash: 8,
        computeEd25519PubKey: 9,
        verifyEd25519Sig: 10,
        vmInstantiation: 11,
        vmCachedInstantiation: 12,
        invokeVmFunction: 13,
        computeKeccak256Hash: 14,
        decodeEcdsaCurve256Sig: 15,
        recoverEcdsaSecp256k1Key: 16,
        int256AddSub: 17,
        int256Mul: 18,
        int256Div: 19,
        int256Pow: 20,
        int256Shift: 21,
        chaCha20DrawBytes: 22,
        parseWasmInstructions: 23,
        parseWasmFunctions: 24,
        parseWasmGlobals: 25,
        parseWasmTableEntries: 26,
        parseWasmTypes: 27,
        parseWasmDataSegments: 28,
        parseWasmElemSegments: 29,
        parseWasmImports: 30,
        parseWasmExports: 31,
        parseWasmDataSegmentBytes: 32,
        instantiateWasmInstructions: 33,
        instantiateWasmFunctions: 34,
        instantiateWasmGlobals: 35,
        instantiateWasmTableEntries: 36,
        instantiateWasmTypes: 37,
        instantiateWasmDataSegments: 38,
        instantiateWasmElemSegments: 39,
        instantiateWasmImports: 40,
        instantiateWasmExports: 41,
        instantiateWasmDataSegmentBytes: 42,
        sec1DecodePointUncompressed: 43,
        verifyEcdsaSecp256r1Sig: 44,
        bls12381EncodeFp: 45,
        bls12381DecodeFp: 46,
        bls12381G1CheckPointOnCurve: 47,
        bls12381G1CheckPointInSubgroup: 48,
        bls12381G2CheckPointOnCurve: 49,
        bls12381G2CheckPointInSubgroup: 50,
        bls12381G1ProjectiveToAffine: 51,
        bls12381G2ProjectiveToAffine: 52,
        bls12381G1Add: 53,
        bls12381G1Mul: 54,
        bls12381G1Msm: 55,
        bls12381MapFpToG1: 56,
        bls12381HashToG1: 57,
        bls12381G2Add: 58,
        bls12381G2Mul: 59,
        bls12381G2Msm: 60,
        bls12381MapFp2ToG2: 61,
        bls12381HashToG2: 62,
        bls12381Pairing: 63,
        bls12381FrFromU256: 64,
        bls12381FrToU256: 65,
        bls12381FrAddSub: 66,
        bls12381FrMul: 67,
        bls12381FrPow: 68,
        bls12381FrInv: 69
      });
      xdr3.struct("ContractCostParamEntry", [["ext", xdr3.lookup("ExtensionPoint")], ["constTerm", xdr3.lookup("Int64")], ["linearTerm", xdr3.lookup("Int64")]]);
      xdr3.struct("StateArchivalSettings", [["maxEntryTtl", xdr3.lookup("Uint32")], ["minTemporaryTtl", xdr3.lookup("Uint32")], ["minPersistentTtl", xdr3.lookup("Uint32")], ["persistentRentRateDenominator", xdr3.lookup("Int64")], ["tempRentRateDenominator", xdr3.lookup("Int64")], ["maxEntriesToArchive", xdr3.lookup("Uint32")], ["bucketListSizeWindowSampleSize", xdr3.lookup("Uint32")], ["bucketListWindowSamplePeriod", xdr3.lookup("Uint32")], ["evictionScanSize", xdr3.lookup("Uint32")], ["startingEvictionScanLevel", xdr3.lookup("Uint32")]]);
      xdr3.struct("EvictionIterator", [["bucketListLevel", xdr3.lookup("Uint32")], ["isCurrBucket", xdr3.bool()], ["bucketFileOffset", xdr3.lookup("Uint64")]]);
      xdr3["const"]("CONTRACT_COST_COUNT_LIMIT", 1024);
      xdr3.typedef("ContractCostParams", xdr3.varArray(xdr3.lookup("ContractCostParamEntry"), xdr3.lookup("CONTRACT_COST_COUNT_LIMIT")));
      xdr3["enum"]("ConfigSettingId", {
        configSettingContractMaxSizeBytes: 0,
        configSettingContractComputeV0: 1,
        configSettingContractLedgerCostV0: 2,
        configSettingContractHistoricalDataV0: 3,
        configSettingContractEventsV0: 4,
        configSettingContractBandwidthV0: 5,
        configSettingContractCostParamsCpuInstructions: 6,
        configSettingContractCostParamsMemoryBytes: 7,
        configSettingContractDataKeySizeBytes: 8,
        configSettingContractDataEntrySizeBytes: 9,
        configSettingStateArchival: 10,
        configSettingContractExecutionLanes: 11,
        configSettingBucketlistSizeWindow: 12,
        configSettingEvictionIterator: 13
      });
      xdr3.union("ConfigSettingEntry", {
        switchOn: xdr3.lookup("ConfigSettingId"),
        switchName: "configSettingId",
        switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]],
        arms: {
          contractMaxSizeBytes: xdr3.lookup("Uint32"),
          contractCompute: xdr3.lookup("ConfigSettingContractComputeV0"),
          contractLedgerCost: xdr3.lookup("ConfigSettingContractLedgerCostV0"),
          contractHistoricalData: xdr3.lookup("ConfigSettingContractHistoricalDataV0"),
          contractEvents: xdr3.lookup("ConfigSettingContractEventsV0"),
          contractBandwidth: xdr3.lookup("ConfigSettingContractBandwidthV0"),
          contractCostParamsCpuInsns: xdr3.lookup("ContractCostParams"),
          contractCostParamsMemBytes: xdr3.lookup("ContractCostParams"),
          contractDataKeySizeBytes: xdr3.lookup("Uint32"),
          contractDataEntrySizeBytes: xdr3.lookup("Uint32"),
          stateArchivalSettings: xdr3.lookup("StateArchivalSettings"),
          contractExecutionLanes: xdr3.lookup("ConfigSettingContractExecutionLanesV0"),
          bucketListSizeWindow: xdr3.varArray(xdr3.lookup("Uint64"), 2147483647),
          evictionIterator: xdr3.lookup("EvictionIterator")
        }
      });
    });
    var _default = exports["default"] = types;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/xdr.js
var require_xdr2 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/xdr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _curr_generated = _interopRequireDefault(require_curr_generated());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = _curr_generated["default"];
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/jsxdr.js
var require_jsxdr = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/jsxdr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _jsXdr = require_xdr();
    var cereal = {
      XdrWriter: _jsXdr.XdrWriter,
      XdrReader: _jsXdr.XdrReader
    };
    var _default = exports["default"] = cereal;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer5 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer5(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer5.prototype);
    copyProps(Buffer5, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer5(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer5(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer5(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    var Buffer5 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer5.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer5.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    var inherits = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer5 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer5.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha256();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha512();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/hashing.js
var require_hashing = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hash = hash2;
    var _sha = require_sha2();
    function hash2(data) {
      var hasher = new _sha.sha256();
      hasher.update(data, "utf8");
      return hasher.digest();
    }
  }
});

// browser-external:sodium-native
var require_sodium_native = __commonJS({
  "browser-external:sodium-native"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "sodium-native" has been externalized for browser compatibility. Cannot access "sodium-native.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/signing.js
var require_signing = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FastSigning = void 0;
    exports.generate = generate;
    exports.sign = sign;
    exports.verify = verify;
    var actualMethods = {};
    var FastSigning = exports.FastSigning = checkFastSigning();
    function sign(data, secretKey) {
      return actualMethods.sign(data, secretKey);
    }
    function verify(data, signature, publicKey) {
      return actualMethods.verify(data, signature, publicKey);
    }
    function generate(secretKey) {
      return actualMethods.generate(secretKey);
    }
    function checkFastSigning() {
      return typeof window === "undefined" ? checkFastSigningNode() : checkFastSigningBrowser();
    }
    function checkFastSigningNode() {
      var sodium;
      try {
        sodium = require_sodium_native();
      } catch (err) {
        return checkFastSigningBrowser();
      }
      if (!Object.keys(sodium).length) {
        return checkFastSigningBrowser();
      }
      actualMethods.generate = function(secretKey) {
        var pk = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
        var sk = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
        sodium.crypto_sign_seed_keypair(pk, sk, secretKey);
        return pk;
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        var signature = Buffer.alloc(sodium.crypto_sign_BYTES);
        sodium.crypto_sign_detached(signature, data, secretKey);
        return signature;
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        try {
          return sodium.crypto_sign_verify_detached(signature, data, publicKey);
        } catch (e) {
          return false;
        }
      };
      return true;
    }
    function checkFastSigningBrowser() {
      var nacl = require_nacl_fast();
      actualMethods.generate = function(secretKey) {
        var secretKeyUint8 = new Uint8Array(secretKey);
        var naclKeys = nacl.sign.keyPair.fromSeed(secretKeyUint8);
        return Buffer.from(naclKeys.publicKey);
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        secretKey = new Uint8Array(secretKey.toJSON().data);
        var signature = nacl.sign.detached(data, secretKey);
        return Buffer.from(signature);
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        signature = new Uint8Array(signature.toJSON().data);
        publicKey = new Uint8Array(publicKey.toJSON().data);
        return nacl.sign.detached.verify(data, signature, publicKey);
      };
      return false;
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/util.js
var require_util = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.trimEnd = void 0;
    var trimEnd = exports.trimEnd = function trimEnd2(input, _char) {
      var isNumber = typeof input === "number";
      var str = String(input);
      while (str.endsWith(_char)) {
        str = str.slice(0, -1);
      }
      return isNumber ? Number(str) : str;
    };
  }
});

// node_modules/base32.js/base32.js
var require_base32 = __commonJS({
  "node_modules/base32.js/base32.js"(exports) {
    "use strict";
    var charmap = function(alphabet, mappings) {
      mappings || (mappings = {});
      alphabet.split("").forEach(function(c, i) {
        if (!(c in mappings)) mappings[c] = i;
      });
      return mappings;
    };
    var rfc4648 = {
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      charmap: {
        0: 14,
        1: 8
      }
    };
    rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);
    var crockford = {
      alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
      charmap: {
        O: 0,
        I: 1,
        L: 1
      }
    };
    crockford.charmap = charmap(crockford.alphabet, crockford.charmap);
    var base32hex = {
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      charmap: {}
    };
    base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);
    function Decoder(options) {
      this.buf = [];
      this.shift = 8;
      this.carry = 0;
      if (options) {
        switch (options.type) {
          case "rfc4648":
            this.charmap = exports.rfc4648.charmap;
            break;
          case "crockford":
            this.charmap = exports.crockford.charmap;
            break;
          case "base32hex":
            this.charmap = exports.base32hex.charmap;
            break;
          default:
            throw new Error("invalid type");
        }
        if (options.charmap) this.charmap = options.charmap;
      }
    }
    Decoder.prototype.charmap = rfc4648.charmap;
    Decoder.prototype.write = function(str) {
      var charmap2 = this.charmap;
      var buf = this.buf;
      var shift = this.shift;
      var carry = this.carry;
      str.toUpperCase().split("").forEach(function(char) {
        if (char == "=") return;
        var symbol = charmap2[char] & 255;
        shift -= 5;
        if (shift > 0) {
          carry |= symbol << shift;
        } else if (shift < 0) {
          buf.push(carry | symbol >> -shift);
          shift += 8;
          carry = symbol << shift & 255;
        } else {
          buf.push(carry | symbol);
          shift = 8;
          carry = 0;
        }
      });
      this.shift = shift;
      this.carry = carry;
      return this;
    };
    Decoder.prototype.finalize = function(str) {
      if (str) {
        this.write(str);
      }
      if (this.shift !== 8 && this.carry !== 0) {
        this.buf.push(this.carry);
        this.shift = 8;
        this.carry = 0;
      }
      return this.buf;
    };
    function Encoder(options) {
      this.buf = "";
      this.shift = 3;
      this.carry = 0;
      if (options) {
        switch (options.type) {
          case "rfc4648":
            this.alphabet = exports.rfc4648.alphabet;
            break;
          case "crockford":
            this.alphabet = exports.crockford.alphabet;
            break;
          case "base32hex":
            this.alphabet = exports.base32hex.alphabet;
            break;
          default:
            throw new Error("invalid type");
        }
        if (options.alphabet) this.alphabet = options.alphabet;
        else if (options.lc) this.alphabet = this.alphabet.toLowerCase();
      }
    }
    Encoder.prototype.alphabet = rfc4648.alphabet;
    Encoder.prototype.write = function(buf) {
      var shift = this.shift;
      var carry = this.carry;
      var symbol;
      var byte;
      var i;
      for (i = 0; i < buf.length; i++) {
        byte = buf[i];
        symbol = carry | byte >> shift;
        this.buf += this.alphabet[symbol & 31];
        if (shift > 5) {
          shift -= 5;
          symbol = byte >> shift;
          this.buf += this.alphabet[symbol & 31];
        }
        shift = 5 - shift;
        carry = byte << shift;
        shift = 8 - shift;
      }
      this.shift = shift;
      this.carry = carry;
      return this;
    };
    Encoder.prototype.finalize = function(buf) {
      if (buf) {
        this.write(buf);
      }
      if (this.shift !== 3) {
        this.buf += this.alphabet[this.carry & 31];
        this.shift = 3;
        this.carry = 0;
      }
      return this.buf;
    };
    exports.encode = function(buf, options) {
      return new Encoder(options).finalize(buf);
    };
    exports.decode = function(str, options) {
      return new Decoder(options).finalize(str);
    };
    exports.Decoder = Decoder;
    exports.Encoder = Encoder;
    exports.charmap = charmap;
    exports.crockford = crockford;
    exports.rfc4648 = rfc4648;
    exports.base32hex = base32hex;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/checksum.js
var require_checksum = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/checksum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.verifyChecksum = verifyChecksum;
    function verifyChecksum(expected, actual) {
      if (expected.length !== actual.length) {
        return false;
      }
      if (expected.length === 0) {
        return true;
      }
      for (var i = 0; i < expected.length; i += 1) {
        if (expected[i] !== actual[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/strkey.js
var require_strkey = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/strkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StrKey = void 0;
    exports.decodeCheck = decodeCheck;
    exports.encodeCheck = encodeCheck;
    var _base = _interopRequireDefault(require_base32());
    var _checksum = require_checksum();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var versionBytes = {
      ed25519PublicKey: 6 << 3,
      // G (when encoded in base32)
      ed25519SecretSeed: 18 << 3,
      // S
      med25519PublicKey: 12 << 3,
      // M
      preAuthTx: 19 << 3,
      // T
      sha256Hash: 23 << 3,
      // X
      signedPayload: 15 << 3,
      // P
      contract: 2 << 3
      // C
    };
    var strkeyTypes = {
      G: "ed25519PublicKey",
      S: "ed25519SecretSeed",
      M: "med25519PublicKey",
      T: "preAuthTx",
      X: "sha256Hash",
      P: "signedPayload",
      C: "contract"
    };
    var StrKey2 = exports.StrKey = function() {
      function StrKey3() {
        _classCallCheck(this, StrKey3);
      }
      return _createClass(StrKey3, null, [{
        key: "encodeEd25519PublicKey",
        value: (
          /**
           * Encodes `data` to strkey ed25519 public key.
           *
           * @param   {Buffer} data   raw data to encode
           * @returns {string}        "G..." representation of the key
           */
          function encodeEd25519PublicKey(data) {
            return encodeCheck("ed25519PublicKey", data);
          }
        )
        /**
         * Decodes strkey ed25519 public key to raw data.
         *
         * If the parameter is a muxed account key ("M..."), this will only encode it
         * as a basic Ed25519 key (as if in "G..." format).
         *
         * @param   {string} data   "G..." (or "M...") key representation to decode
         * @returns {Buffer}        raw key
         */
      }, {
        key: "decodeEd25519PublicKey",
        value: function decodeEd25519PublicKey(data) {
          return decodeCheck("ed25519PublicKey", data);
        }
        /**
         * Returns true if the given Stellar public key is a valid ed25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519PublicKey",
        value: function isValidEd25519PublicKey(publicKey) {
          return isValid("ed25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey ed25519 seed.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeEd25519SecretSeed",
        value: function encodeEd25519SecretSeed(data) {
          return encodeCheck("ed25519SecretSeed", data);
        }
        /**
         * Decodes strkey ed25519 seed to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeEd25519SecretSeed",
        value: function decodeEd25519SecretSeed(address) {
          return decodeCheck("ed25519SecretSeed", address);
        }
        /**
         * Returns true if the given Stellar secret key is a valid ed25519 secret seed.
         * @param {string} seed seed to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519SecretSeed",
        value: function isValidEd25519SecretSeed(seed) {
          return isValid("ed25519SecretSeed", seed);
        }
        /**
         * Encodes data to strkey med25519 public key.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeMed25519PublicKey",
        value: function encodeMed25519PublicKey(data) {
          return encodeCheck("med25519PublicKey", data);
        }
        /**
         * Decodes strkey med25519 public key to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeMed25519PublicKey",
        value: function decodeMed25519PublicKey(address) {
          return decodeCheck("med25519PublicKey", address);
        }
        /**
         * Returns true if the given Stellar public key is a valid med25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidMed25519PublicKey",
        value: function isValidMed25519PublicKey(publicKey) {
          return isValid("med25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey preAuthTx.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodePreAuthTx",
        value: function encodePreAuthTx(data) {
          return encodeCheck("preAuthTx", data);
        }
        /**
         * Decodes strkey PreAuthTx to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodePreAuthTx",
        value: function decodePreAuthTx(address) {
          return decodeCheck("preAuthTx", address);
        }
        /**
         * Encodes data to strkey sha256 hash.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSha256Hash",
        value: function encodeSha256Hash(data) {
          return encodeCheck("sha256Hash", data);
        }
        /**
         * Decodes strkey sha256 hash to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSha256Hash",
        value: function decodeSha256Hash(address) {
          return decodeCheck("sha256Hash", address);
        }
        /**
         * Encodes raw data to strkey signed payload (P...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSignedPayload",
        value: function encodeSignedPayload(data) {
          return encodeCheck("signedPayload", data);
        }
        /**
         * Decodes strkey signed payload (P...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSignedPayload",
        value: function decodeSignedPayload(address) {
          return decodeCheck("signedPayload", address);
        }
        /**
         * Checks validity of alleged signed payload (P...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidSignedPayload",
        value: function isValidSignedPayload(address) {
          return isValid("signedPayload", address);
        }
        /**
         * Encodes raw data to strkey contract (C...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeContract",
        value: function encodeContract(data) {
          return encodeCheck("contract", data);
        }
        /**
         * Decodes strkey contract (C...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeContract",
        value: function decodeContract(address) {
          return decodeCheck("contract", address);
        }
        /**
         * Checks validity of alleged contract (C...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidContract",
        value: function isValidContract(address) {
          return isValid("contract", address);
        }
      }, {
        key: "getVersionByteForPrefix",
        value: function getVersionByteForPrefix(address) {
          return strkeyTypes[address[0]];
        }
      }]);
    }();
    function isValid(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
          if (encoded.length !== 56) {
            return false;
          }
          break;
        case "med25519PublicKey":
          if (encoded.length !== 69) {
            return false;
          }
          break;
        case "signedPayload":
          if (encoded.length < 56 || encoded.length > 165) {
            return false;
          }
          break;
        default:
          return false;
      }
      var decoded = "";
      try {
        decoded = decodeCheck(versionByteName, encoded);
      } catch (err) {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
          return decoded.length === 32;
        case "med25519PublicKey":
          return decoded.length === 40;
        case "signedPayload":
          return (
            // 32 for the signer, +4 for the payload size, then either +4 for the
            // min or +64 for the max payload
            decoded.length >= 32 + 4 + 4 && decoded.length <= 32 + 4 + 64
          );
        default:
          return false;
      }
    }
    function decodeCheck(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        throw new TypeError("encoded argument must be of type String");
      }
      var decoded = _base["default"].decode(encoded);
      var versionByte = decoded[0];
      var payload = decoded.slice(0, -2);
      var data = payload.slice(1);
      var checksum = decoded.slice(-2);
      if (encoded !== _base["default"].encode(decoded)) {
        throw new Error("invalid encoded string");
      }
      var expectedVersion = versionBytes[versionByteName];
      if (expectedVersion === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      if (versionByte !== expectedVersion) {
        throw new Error("invalid version byte. expected ".concat(expectedVersion, ", got ").concat(versionByte));
      }
      var expectedChecksum = calculateChecksum(payload);
      if (!(0, _checksum.verifyChecksum)(expectedChecksum, checksum)) {
        throw new Error("invalid checksum");
      }
      return Buffer.from(data);
    }
    function encodeCheck(versionByteName, data) {
      if (data === null || data === void 0) {
        throw new Error("cannot encode null data");
      }
      var versionByte = versionBytes[versionByteName];
      if (versionByte === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      data = Buffer.from(data);
      var versionBuffer = Buffer.from([versionByte]);
      var payload = Buffer.concat([versionBuffer, data]);
      var checksum = Buffer.from(calculateChecksum(payload));
      var unencoded = Buffer.concat([payload, checksum]);
      return _base["default"].encode(unencoded);
    }
    function calculateChecksum(payload) {
      var crcTable = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
      var crc16 = 0;
      for (var i = 0; i < payload.length; i += 1) {
        var _byte = payload[i];
        var lookupIndex = crc16 >> 8 ^ _byte;
        crc16 = crc16 << 8 ^ crcTable[lookupIndex];
        crc16 &= 65535;
      }
      var checksum = new Uint8Array(2);
      checksum[0] = crc16 & 255;
      checksum[1] = crc16 >> 8 & 255;
      return checksum;
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/keypair.js
var require_keypair = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/keypair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Keypair = void 0;
    var _tweetnacl = _interopRequireDefault(require_nacl_fast());
    var _signing = require_signing();
    var _strkey = require_strkey();
    var _hashing = require_hashing();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Keypair2 = exports.Keypair = function() {
      function Keypair3(keys) {
        _classCallCheck(this, Keypair3);
        if (keys.type !== "ed25519") {
          throw new Error("Invalid keys type");
        }
        this.type = keys.type;
        if (keys.secretKey) {
          keys.secretKey = Buffer.from(keys.secretKey);
          if (keys.secretKey.length !== 32) {
            throw new Error("secretKey length is invalid");
          }
          this._secretSeed = keys.secretKey;
          this._publicKey = (0, _signing.generate)(keys.secretKey);
          this._secretKey = Buffer.concat([keys.secretKey, this._publicKey]);
          if (keys.publicKey && !this._publicKey.equals(Buffer.from(keys.publicKey))) {
            throw new Error("secretKey does not match publicKey");
          }
        } else {
          this._publicKey = Buffer.from(keys.publicKey);
          if (this._publicKey.length !== 32) {
            throw new Error("publicKey length is invalid");
          }
        }
      }
      return _createClass(Keypair3, [{
        key: "xdrAccountId",
        value: function xdrAccountId() {
          return new _xdr["default"].AccountId.publicKeyTypeEd25519(this._publicKey);
        }
      }, {
        key: "xdrPublicKey",
        value: function xdrPublicKey() {
          return new _xdr["default"].PublicKey.publicKeyTypeEd25519(this._publicKey);
        }
        /**
         * Creates a {@link xdr.MuxedAccount} object from the public key.
         *
         * You will get a different type of muxed account depending on whether or not
         * you pass an ID.
         *
         * @param  {string} [id] - stringified integer indicating the underlying muxed
         *     ID of the new account object
         *
         * @return {xdr.MuxedAccount}
         */
      }, {
        key: "xdrMuxedAccount",
        value: function xdrMuxedAccount(id) {
          if (typeof id !== "undefined") {
            if (typeof id !== "string") {
              throw new TypeError("expected string for ID, got ".concat(_typeof(id)));
            }
            return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
              id: _xdr["default"].Uint64.fromString(id),
              ed25519: this._publicKey
            }));
          }
          return new _xdr["default"].MuxedAccount.keyTypeEd25519(this._publicKey);
        }
        /**
         * Returns raw public key
         * @returns {Buffer}
         */
      }, {
        key: "rawPublicKey",
        value: function rawPublicKey() {
          return this._publicKey;
        }
      }, {
        key: "signatureHint",
        value: function signatureHint() {
          var a = this.xdrAccountId().toXDR();
          return a.slice(a.length - 4);
        }
        /**
         * Returns public key associated with this `Keypair` object.
         * @returns {string}
         */
      }, {
        key: "publicKey",
        value: function publicKey() {
          return _strkey.StrKey.encodeEd25519PublicKey(this._publicKey);
        }
        /**
         * Returns secret key associated with this `Keypair` object
         * @returns {string}
         */
      }, {
        key: "secret",
        value: function secret() {
          if (!this._secretSeed) {
            throw new Error("no secret key available");
          }
          if (this.type === "ed25519") {
            return _strkey.StrKey.encodeEd25519SecretSeed(this._secretSeed);
          }
          throw new Error("Invalid Keypair type");
        }
        /**
         * Returns raw secret key.
         * @returns {Buffer}
         */
      }, {
        key: "rawSecretKey",
        value: function rawSecretKey() {
          return this._secretSeed;
        }
        /**
         * Returns `true` if this `Keypair` object contains secret key and can sign.
         * @returns {boolean}
         */
      }, {
        key: "canSign",
        value: function canSign() {
          return !!this._secretKey;
        }
        /**
         * Signs data.
         * @param {Buffer} data Data to sign
         * @returns {Buffer}
         */
      }, {
        key: "sign",
        value: function sign(data) {
          if (!this.canSign()) {
            throw new Error("cannot sign: no secret key available");
          }
          return (0, _signing.sign)(data, this._secretKey);
        }
        /**
         * Verifies if `signature` for `data` is valid.
         * @param {Buffer} data Signed data
         * @param {Buffer} signature Signature
         * @returns {boolean}
         */
      }, {
        key: "verify",
        value: function verify(data, signature) {
          return (0, _signing.verify)(data, signature, this._publicKey);
        }
        /**
         * Returns the decorated signature (hint+sig) for arbitrary data.
         *
         * @param  {Buffer} data  arbitrary data to sign
         * @return {xdr.DecoratedSignature}   the raw signature structure which can be
         *     added directly to a transaction envelope
         *
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signDecorated",
        value: function signDecorated(data) {
          var signature = this.sign(data);
          var hint = this.signatureHint();
          return new _xdr["default"].DecoratedSignature({
            hint,
            signature
          });
        }
        /**
         * Returns the raw decorated signature (hint+sig) for a signed payload signer.
         *
         *  The hint is defined as the last 4 bytes of the signer key XORed with last
         *  4 bytes of the payload (zero-left-padded if necessary).
         *
         * @param  {Buffer} data    data to both sign and treat as the payload
         * @return {xdr.DecoratedSignature}
         *
         * @see https://github.com/stellar/stellar-protocol/blob/master/core/cap-0040.md#signature-hint
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signPayloadDecorated",
        value: function signPayloadDecorated(data) {
          var signature = this.sign(data);
          var keyHint = this.signatureHint();
          var hint = Buffer.from(data.slice(-4));
          if (hint.length < 4) {
            hint = Buffer.concat([hint, Buffer.alloc(4 - data.length, 0)]);
          }
          return new _xdr["default"].DecoratedSignature({
            hint: hint.map(function(_byte, i) {
              return _byte ^ keyHint[i];
            }),
            signature
          });
        }
      }], [{
        key: "fromSecret",
        value: function fromSecret(secret) {
          var rawSecret = _strkey.StrKey.decodeEd25519SecretSeed(secret);
          return this.fromRawEd25519Seed(rawSecret);
        }
        /**
         * Creates a new `Keypair` object from ed25519 secret key seed raw bytes.
         *
         * @param {Buffer} rawSeed Raw 32-byte ed25519 secret key seed
         * @returns {Keypair}
         */
      }, {
        key: "fromRawEd25519Seed",
        value: function fromRawEd25519Seed(rawSeed) {
          return new this({
            type: "ed25519",
            secretKey: rawSeed
          });
        }
        /**
         * Returns `Keypair` object representing network master key.
         * @param {string} networkPassphrase passphrase of the target stellar network (e.g. "Public Global Stellar Network ; September 2015").
         * @returns {Keypair}
         */
      }, {
        key: "master",
        value: function master(networkPassphrase) {
          if (!networkPassphrase) {
            throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
          }
          return this.fromRawEd25519Seed((0, _hashing.hash)(networkPassphrase));
        }
        /**
         * Creates a new `Keypair` object from public key.
         * @param {string} publicKey public key (ex. `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`)
         * @returns {Keypair}
         */
      }, {
        key: "fromPublicKey",
        value: function fromPublicKey(publicKey) {
          publicKey = _strkey.StrKey.decodeEd25519PublicKey(publicKey);
          if (publicKey.length !== 32) {
            throw new Error("Invalid Stellar public key");
          }
          return new this({
            type: "ed25519",
            publicKey
          });
        }
        /**
         * Create a random `Keypair` object.
         * @returns {Keypair}
         */
      }, {
        key: "random",
        value: function random() {
          var secret = _tweetnacl["default"].randomBytes(32);
          return this.fromRawEd25519Seed(secret);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/asset.js
var require_asset = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Asset = void 0;
    var _util = require_util();
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    var _hashing = require_hashing();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Asset = exports.Asset = function() {
      function Asset2(code, issuer) {
        _classCallCheck(this, Asset2);
        if (!/^[a-zA-Z0-9]{1,12}$/.test(code)) {
          throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
        }
        if (String(code).toLowerCase() !== "xlm" && !issuer) {
          throw new Error("Issuer cannot be null");
        }
        if (issuer && !_strkey.StrKey.isValidEd25519PublicKey(issuer)) {
          throw new Error("Issuer is invalid");
        }
        if (String(code).toLowerCase() === "xlm") {
          this.code = "XLM";
        } else {
          this.code = code;
        }
        this.issuer = issuer;
      }
      return _createClass(Asset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr.Asset object for this asset.
           * @returns {xdr.Asset} XDR asset object
           */
          function toXDRObject() {
            return this._toXDRObject(_xdr["default"].Asset);
          }
        )
        /**
         * Returns the xdr.ChangeTrustAsset object for this asset.
         * @returns {xdr.ChangeTrustAsset} XDR asset object
         */
      }, {
        key: "toChangeTrustXDRObject",
        value: function toChangeTrustXDRObject() {
          return this._toXDRObject(_xdr["default"].ChangeTrustAsset);
        }
        /**
         * Returns the xdr.TrustLineAsset object for this asset.
         * @returns {xdr.TrustLineAsset} XDR asset object
         */
      }, {
        key: "toTrustLineXDRObject",
        value: function toTrustLineXDRObject() {
          return this._toXDRObject(_xdr["default"].TrustLineAsset);
        }
        /**
         * Returns the would-be contract ID (`C...` format) for this asset on a given
         * network.
         *
         * @param {string}    networkPassphrase   indicates which network the contract
         *    ID should refer to, since every network will have a unique ID for the
         *    same contract (see {@link Networks} for options)
         *
         * @returns {string}  the strkey-encoded (`C...`) contract ID for this asset
         *
         * @warning This makes no guarantee that this contract actually *exists*.
         */
      }, {
        key: "contractId",
        value: function contractId(networkPassphrase) {
          var networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
          var preimage = _xdr["default"].HashIdPreimage.envelopeTypeContractId(new _xdr["default"].HashIdPreimageContractId({
            networkId,
            contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())
          }));
          return _strkey.StrKey.encodeContract((0, _hashing.hash)(preimage.toXDR()));
        }
        /**
         * Returns the xdr object for this asset.
         * @param {xdr.Asset | xdr.ChangeTrustAsset} xdrAsset - The asset xdr object.
         * @returns {xdr.Asset | xdr.ChangeTrustAsset | xdr.TrustLineAsset} XDR Asset object
         */
      }, {
        key: "_toXDRObject",
        value: function _toXDRObject() {
          var xdrAsset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _xdr["default"].Asset;
          if (this.isNative()) {
            return xdrAsset.assetTypeNative();
          }
          var xdrType;
          var xdrTypeString;
          if (this.code.length <= 4) {
            xdrType = _xdr["default"].AlphaNum4;
            xdrTypeString = "assetTypeCreditAlphanum4";
          } else {
            xdrType = _xdr["default"].AlphaNum12;
            xdrTypeString = "assetTypeCreditAlphanum12";
          }
          var padLength = this.code.length <= 4 ? 4 : 12;
          var paddedCode = this.code.padEnd(padLength, "\0");
          var assetType = new xdrType({
            assetCode: paddedCode,
            issuer: _keypair.Keypair.fromPublicKey(this.issuer).xdrAccountId()
          });
          return new xdrAsset(xdrTypeString, assetType);
        }
        /**
         * @returns {string} Asset code
         */
      }, {
        key: "getCode",
        value: function getCode() {
          if (this.code === void 0) {
            return void 0;
          }
          return String(this.code);
        }
        /**
         * @returns {string} Asset issuer
         */
      }, {
        key: "getIssuer",
        value: function getIssuer() {
          if (this.issuer === void 0) {
            return void 0;
          }
          return String(this.issuer);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {string} Asset type. Can be one of following types:
         *
         *  - `native`,
         *  - `credit_alphanum4`,
         *  - `credit_alphanum12`, or
         *  - `unknown` as the error case (which should never occur)
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          switch (this.getRawAssetType().value) {
            case _xdr["default"].AssetType.assetTypeNative().value:
              return "native";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4().value:
              return "credit_alphanum4";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12().value:
              return "credit_alphanum12";
            default:
              return "unknown";
          }
        }
        /**
         * @returns {xdr.AssetType}  the raw XDR representation of the asset type
         */
      }, {
        key: "getRawAssetType",
        value: function getRawAssetType() {
          if (this.isNative()) {
            return _xdr["default"].AssetType.assetTypeNative();
          }
          if (this.code.length <= 4) {
            return _xdr["default"].AssetType.assetTypeCreditAlphanum4();
          }
          return _xdr["default"].AssetType.assetTypeCreditAlphanum12();
        }
        /**
         * @returns {boolean}  true if this asset object is the native asset.
         */
      }, {
        key: "isNative",
        value: function isNative() {
          return !this.issuer;
        }
        /**
         * @param {Asset} asset Asset to compare
         * @returns {boolean} true if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.code === asset.getCode() && this.issuer === asset.getIssuer();
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.isNative()) {
            return "native";
          }
          return "".concat(this.getCode(), ":").concat(this.getIssuer());
        }
        /**
         * Compares two assets according to the criteria:
         *
         *  1. First compare the type (native < alphanum4 < alphanum12).
         *  2. If the types are equal, compare the assets codes.
         *  3. If the asset codes are equal, compare the issuers.
         *
         * @param   {Asset} assetA - the first asset
         * @param   {Asset} assetB - the second asset
         * @returns {number} `-1` if assetA < assetB, `0` if assetA == assetB, `1` if assetA > assetB.
         *
         * @static
         * @memberof Asset
         */
      }], [{
        key: "native",
        value: function _native() {
          return new Asset2("XLM");
        }
        /**
         * Returns an asset object from its XDR object representation.
         * @param {xdr.Asset} assetXdr - The asset xdr object.
         * @returns {Asset}
         */
      }, {
        key: "fromOperation",
        value: function fromOperation(assetXdr) {
          var anum;
          var code;
          var issuer;
          switch (assetXdr["switch"]()) {
            case _xdr["default"].AssetType.assetTypeNative():
              return this["native"]();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4():
              anum = assetXdr.alphaNum4();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12():
              anum = anum || assetXdr.alphaNum12();
              issuer = _strkey.StrKey.encodeEd25519PublicKey(anum.issuer().ed25519());
              code = (0, _util.trimEnd)(anum.assetCode(), "\0");
              return new this(code, issuer);
            default:
              throw new Error("Invalid asset type: ".concat(assetXdr["switch"]().name));
          }
        }
      }, {
        key: "compare",
        value: function compare(assetA, assetB) {
          if (!assetA || !(assetA instanceof Asset2)) {
            throw new Error("assetA is invalid");
          }
          if (!assetB || !(assetB instanceof Asset2)) {
            throw new Error("assetB is invalid");
          }
          if (assetA.equals(assetB)) {
            return 0;
          }
          var xdrAtype = assetA.getRawAssetType().value;
          var xdrBtype = assetB.getRawAssetType().value;
          if (xdrAtype !== xdrBtype) {
            return xdrAtype < xdrBtype ? -1 : 1;
          }
          var result = asciiCompare(assetA.getCode(), assetB.getCode());
          if (result !== 0) {
            return result;
          }
          return asciiCompare(assetA.getIssuer(), assetB.getIssuer());
        }
      }]);
    }();
    function asciiCompare(a, b) {
      return Buffer.compare(Buffer.from(a, "ascii"), Buffer.from(b, "ascii"));
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js
var require_get_liquidity_pool_id = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolFeeV18 = void 0;
    exports.getLiquidityPoolId = getLiquidityPoolId;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    var _hashing = require_hashing();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var LiquidityPoolFeeV18 = exports.LiquidityPoolFeeV18 = 30;
    function getLiquidityPoolId(liquidityPoolType) {
      var liquidityPoolParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (liquidityPoolType !== "constant_product") {
        throw new Error("liquidityPoolType is invalid");
      }
      var assetA = liquidityPoolParameters.assetA, assetB = liquidityPoolParameters.assetB, fee = liquidityPoolParameters.fee;
      if (!assetA || !(assetA instanceof _asset.Asset)) {
        throw new Error("assetA is invalid");
      }
      if (!assetB || !(assetB instanceof _asset.Asset)) {
        throw new Error("assetB is invalid");
      }
      if (!fee || fee !== LiquidityPoolFeeV18) {
        throw new Error("fee is invalid");
      }
      if (_asset.Asset.compare(assetA, assetB) !== -1) {
        throw new Error("Assets are not in lexicographic order");
      }
      var lpTypeData = _xdr["default"].LiquidityPoolType.liquidityPoolConstantProduct().toXDR();
      var lpParamsData = new _xdr["default"].LiquidityPoolConstantProductParameters({
        assetA: assetA.toXDRObject(),
        assetB: assetB.toXDRObject(),
        fee
      }).toXDR();
      var payload = Buffer.concat([lpTypeData, lpParamsData]);
      return (0, _hashing.hash)(payload);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/transaction_base.js
var require_transaction_base = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/transaction_base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBase = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _hashing = require_hashing();
    var _keypair = require_keypair();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var TransactionBase = exports.TransactionBase = function() {
      function TransactionBase2(tx, signatures, fee, networkPassphrase) {
        _classCallCheck(this, TransactionBase2);
        if (typeof networkPassphrase !== "string") {
          throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(_typeof(networkPassphrase)));
        }
        this._networkPassphrase = networkPassphrase;
        this._tx = tx;
        this._signatures = signatures;
        this._fee = fee;
      }
      return _createClass(TransactionBase2, [{
        key: "signatures",
        get: function get() {
          return this._signatures;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
      }, {
        key: "tx",
        get: function get() {
          return this._tx;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "fee",
        get: function get() {
          return this._fee;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "networkPassphrase",
        get: function get() {
          return this._networkPassphrase;
        },
        set: function set(networkPassphrase) {
          this._networkPassphrase = networkPassphrase;
        }
        /**
         * Signs the transaction with the given {@link Keypair}.
         * @param {...Keypair} keypairs Keypairs of signers
         * @returns {void}
         */
      }, {
        key: "sign",
        value: function sign() {
          var _this = this;
          var txHash = this.hash();
          for (var _len = arguments.length, keypairs = new Array(_len), _key = 0; _key < _len; _key++) {
            keypairs[_key] = arguments[_key];
          }
          keypairs.forEach(function(kp) {
            var sig = kp.signDecorated(txHash);
            _this.signatures.push(sig);
          });
        }
        /**
         * Signs a transaction with the given {@link Keypair}. Useful if someone sends
         * you a transaction XDR for you to sign and return (see
         * [addSignature](#addSignature) for more information).
         *
         * When you get a transaction XDR to sign....
         * - Instantiate a `Transaction` object with the XDR
         * - Use {@link Keypair} to generate a keypair object for your Stellar seed.
         * - Run `getKeypairSignature` with that keypair
         * - Send back the signature along with your publicKey (not your secret seed!)
         *
         * Example:
         * ```javascript
         * // `transactionXDR` is a string from the person generating the transaction
         * const transaction = new Transaction(transactionXDR, networkPassphrase);
         * const keypair = Keypair.fromSecret(myStellarSeed);
         * return transaction.getKeypairSignature(keypair);
         * ```
         *
         * @param {Keypair} keypair Keypair of signer
         * @returns {string} Signature string
         */
      }, {
        key: "getKeypairSignature",
        value: function getKeypairSignature(keypair) {
          return keypair.sign(this.hash()).toString("base64");
        }
        /**
         * Add a signature to the transaction. Useful when a party wants to pre-sign
         * a transaction but doesn't want to give access to their secret keys.
         * This will also verify whether the signature is valid.
         *
         * Here's how you would use this feature to solicit multiple signatures.
         * - Use `TransactionBuilder` to build a new transaction.
         * - Make sure to set a long enough timeout on that transaction to give your
         * signers enough time to sign!
         * - Once you build the transaction, use `transaction.toXDR()` to get the
         * base64-encoded XDR string.
         * - _Warning!_ Once you've built this transaction, don't submit any other
         * transactions onto your account! Doing so will invalidate this pre-compiled
         * transaction!
         * - Send this XDR string to your other parties. They can use the instructions
         * for [getKeypairSignature](#getKeypairSignature) to sign the transaction.
         * - They should send you back their `publicKey` and the `signature` string
         * from [getKeypairSignature](#getKeypairSignature), both of which you pass to
         * this function.
         *
         * @param {string} publicKey The public key of the signer
         * @param {string} signature The base64 value of the signature XDR
         * @returns {void}
         */
      }, {
        key: "addSignature",
        value: function addSignature() {
          var publicKey = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var signature = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          if (!signature || typeof signature !== "string") {
            throw new Error("Invalid signature");
          }
          if (!publicKey || typeof publicKey !== "string") {
            throw new Error("Invalid publicKey");
          }
          var keypair;
          var hint;
          var signatureBuffer = Buffer.from(signature, "base64");
          try {
            keypair = _keypair.Keypair.fromPublicKey(publicKey);
            hint = keypair.signatureHint();
          } catch (e) {
            throw new Error("Invalid publicKey");
          }
          if (!keypair.verify(this.hash(), signatureBuffer)) {
            throw new Error("Invalid signature");
          }
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature: signatureBuffer
          }));
        }
        /**
         * Add a decorated signature directly to the transaction envelope.
         *
         * @param {xdr.DecoratedSignature} signature    raw signature to add
         * @returns {void}
         *
         * @see Keypair.signDecorated
         * @see Keypair.signPayloadDecorated
         */
      }, {
        key: "addDecoratedSignature",
        value: function addDecoratedSignature(signature) {
          this.signatures.push(signature);
        }
        /**
         * Add `hashX` signer preimage as signature.
         * @param {Buffer|String} preimage Preimage of hash used as signer
         * @returns {void}
         */
      }, {
        key: "signHashX",
        value: function signHashX(preimage) {
          if (typeof preimage === "string") {
            preimage = Buffer.from(preimage, "hex");
          }
          if (preimage.length > 64) {
            throw new Error("preimage cannnot be longer than 64 bytes");
          }
          var signature = preimage;
          var hashX = (0, _hashing.hash)(preimage);
          var hint = hashX.slice(hashX.length - 4);
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature
          }));
        }
        /**
         * Returns a hash for this transaction, suitable for signing.
         * @returns {Buffer}
         */
      }, {
        key: "hash",
        value: function hash2() {
          return (0, _hashing.hash)(this.signatureBase());
        }
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          throw new Error("Implement in subclass");
        }
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          throw new Error("Implement in subclass");
        }
        /**
         * Get the transaction envelope as a base64-encoded string
         * @returns {string} XDR string
         */
      }, {
        key: "toXDR",
        value: function toXDR() {
          return this.toEnvelope().toXDR().toString("base64");
        }
      }]);
    }();
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/bignumber.js
var require_bignumber2 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/bignumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var BigNumber = _bignumber["default"].clone();
    BigNumber.DEBUG = true;
    var _default = exports["default"] = BigNumber;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js
var require_continued_fraction = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.best_r = best_r;
    var _bignumber = _interopRequireDefault(require_bignumber2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var MAX_INT = (1 << 31 >>> 0) - 1;
    function best_r(rawNumber) {
      var number = new _bignumber["default"](rawNumber);
      var a;
      var f;
      var fractions = [[new _bignumber["default"](0), new _bignumber["default"](1)], [new _bignumber["default"](1), new _bignumber["default"](0)]];
      var i = 2;
      while (true) {
        if (number.gt(MAX_INT)) {
          break;
        }
        a = number.integerValue(_bignumber["default"].ROUND_FLOOR);
        f = number.minus(a);
        var h = a.times(fractions[i - 1][0]).plus(fractions[i - 2][0]);
        var k = a.times(fractions[i - 1][1]).plus(fractions[i - 2][1]);
        if (h.gt(MAX_INT) || k.gt(MAX_INT)) {
          break;
        }
        fractions.push([h, k]);
        if (f.eq(0)) {
          break;
        }
        number = new _bignumber["default"](1).div(f);
        i += 1;
      }
      var _fractions = _slicedToArray(fractions[fractions.length - 1], 2), n = _fractions[0], d = _fractions[1];
      if (n.isZero() || d.isZero()) {
        throw new Error("Couldn't find approximation");
      }
      return [n.toNumber(), d.toNumber()];
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js
var require_liquidity_pool_asset = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolAsset = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolAsset = exports.LiquidityPoolAsset = function() {
      function LiquidityPoolAsset2(assetA, assetB, fee) {
        _classCallCheck(this, LiquidityPoolAsset2);
        if (!assetA || !(assetA instanceof _asset.Asset)) {
          throw new Error("assetA is invalid");
        }
        if (!assetB || !(assetB instanceof _asset.Asset)) {
          throw new Error("assetB is invalid");
        }
        if (_asset.Asset.compare(assetA, assetB) !== -1) {
          throw new Error("Assets are not in lexicographic order");
        }
        if (!fee || fee !== _get_liquidity_pool_id.LiquidityPoolFeeV18) {
          throw new Error("fee is invalid");
        }
        this.assetA = assetA;
        this.assetB = assetB;
        this.fee = fee;
      }
      return _createClass(LiquidityPoolAsset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.ChangeTrustAsset` object for this liquidity pool asset.
           *
           * Note: To convert from an {@link Asset `Asset`} to `xdr.ChangeTrustAsset`
           * please refer to the
           * {@link Asset.toChangeTrustXDRObject `Asset.toChangeTrustXDRObject`} method.
           *
           * @returns {xdr.ChangeTrustAsset} XDR ChangeTrustAsset object.
           */
          function toXDRObject() {
            var lpConstantProductParamsXdr = new _xdr["default"].LiquidityPoolConstantProductParameters({
              assetA: this.assetA.toXDRObject(),
              assetB: this.assetB.toXDRObject(),
              fee: this.fee
            });
            var lpParamsXdr = new _xdr["default"].LiquidityPoolParameters("liquidityPoolConstantProduct", lpConstantProductParamsXdr);
            return new _xdr["default"].ChangeTrustAsset("assetTypePoolShare", lpParamsXdr);
          }
        )
        /**
         * @returns {LiquidityPoolParameters} Liquidity pool parameters.
         */
      }, {
        key: "getLiquidityPoolParameters",
        value: function getLiquidityPoolParameters() {
          return _objectSpread(_objectSpread({}, this), {}, {
            assetA: this.assetA,
            assetB: this.assetB,
            fee: this.fee
          });
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolAsset} other the LiquidityPoolAsset to compare
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(other) {
          return this.assetA.equals(other.assetA) && this.assetB.equals(other.assetB) && this.fee === other.fee;
        }
      }, {
        key: "toString",
        value: function toString() {
          var poolId = (0, _get_liquidity_pool_id.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
          return "liquidity_pool:".concat(poolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(ctAssetXdr) {
          var assetType = ctAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolParameters = ctAssetXdr.liquidityPool().constantProduct();
            return new this(_asset.Asset.fromOperation(liquidityPoolParameters.assetA()), _asset.Asset.fromOperation(liquidityPoolParameters.assetB()), liquidityPoolParameters.fee());
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/claimant.js
var require_claimant = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/claimant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Claimant = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Claimant = exports.Claimant = function() {
      function Claimant2(destination, predicate) {
        _classCallCheck(this, Claimant2);
        if (destination && !_strkey.StrKey.isValidEd25519PublicKey(destination)) {
          throw new Error("Destination is invalid");
        }
        this._destination = destination;
        if (!predicate) {
          this._predicate = _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        } else if (predicate instanceof _xdr["default"].ClaimPredicate) {
          this._predicate = predicate;
        } else {
          throw new Error("Predicate should be an xdr.ClaimPredicate");
        }
      }
      return _createClass(Claimant2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr object for this claimant.
           * @returns {xdr.Claimant} XDR Claimant object
           */
          function toXDRObject() {
            var claimant = new _xdr["default"].ClaimantV0({
              destination: _keypair.Keypair.fromPublicKey(this._destination).xdrAccountId(),
              predicate: this._predicate
            });
            return _xdr["default"].Claimant.claimantTypeV0(claimant);
          }
        )
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "destination",
        get: function get() {
          return this._destination;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
        /**
         * @type {xdr.ClaimPredicate}
         * @readonly
         */
      }, {
        key: "predicate",
        get: function get() {
          return this._predicate;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
      }], [{
        key: "predicateUnconditional",
        value: function predicateUnconditional() {
          return _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        }
        /**
         * Returns an `and` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateAnd",
        value: function predicateAnd(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateAnd([left, right]);
        }
        /**
         * Returns an `or` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateOr",
        value: function predicateOr(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateOr([left, right]);
        }
        /**
         * Returns a `not` claim predicate
         * @param {xdr.ClaimPredicate} predicate an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateNot",
        value: function predicateNot(predicate) {
          if (!(predicate instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateNot(predicate);
        }
        /**
         * Returns a `BeforeAbsoluteTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation is less than this (absolute)
         * Unix timestamp (expressed in seconds).
         *
         * @param {string} absBefore Unix epoch (in seconds) as a string
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeAbsoluteTime",
        value: function predicateBeforeAbsoluteTime(absBefore) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeAbsoluteTime(_xdr["default"].Int64.fromString(absBefore));
        }
        /**
         * Returns a `BeforeRelativeTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation plus this relative time delta
         * (in seconds) is less than the current time.
         *
         * @param {strings} seconds seconds since closeTime of the ledger in which the ClaimableBalanceEntry was created (as string)
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeRelativeTime",
        value: function predicateBeforeRelativeTime(seconds) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeRelativeTime(_xdr["default"].Int64.fromString(seconds));
        }
        /**
         * Returns a claimant object from its XDR object representation.
         * @param {xdr.Claimant} claimantXdr - The claimant xdr object.
         * @returns {Claimant}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(claimantXdr) {
          var value;
          switch (claimantXdr["switch"]()) {
            case _xdr["default"].ClaimantType.claimantTypeV0():
              value = claimantXdr.v0();
              return new this(_strkey.StrKey.encodeEd25519PublicKey(value.destination().ed25519()), value.predicate());
            default:
              throw new Error("Invalid claimant type: ".concat(claimantXdr["switch"]().name));
          }
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js
var require_liquidity_pool_id = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolId = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolId = exports.LiquidityPoolId = function() {
      function LiquidityPoolId2(liquidityPoolId) {
        _classCallCheck(this, LiquidityPoolId2);
        if (!liquidityPoolId) {
          throw new Error("liquidityPoolId cannot be empty");
        }
        if (!/^[a-f0-9]{64}$/.test(liquidityPoolId)) {
          throw new Error("Liquidity pool ID is not a valid hash");
        }
        this.liquidityPoolId = liquidityPoolId;
      }
      return _createClass(LiquidityPoolId2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.TrustLineAsset` object for this liquidity pool ID.
           *
           * Note: To convert from {@link Asset `Asset`} to `xdr.TrustLineAsset` please
           * refer to the
           * {@link Asset.toTrustLineXDRObject `Asset.toTrustLineXDRObject`} method.
           *
           * @returns {xdr.TrustLineAsset} XDR LiquidityPoolId object
           */
          function toXDRObject() {
            var xdrPoolId = _xdr["default"].PoolId.fromXDR(this.liquidityPoolId, "hex");
            return new _xdr["default"].TrustLineAsset("assetTypePoolShare", xdrPoolId);
          }
        )
        /**
         * @returns {string} Liquidity pool ID.
         */
      }, {
        key: "getLiquidityPoolId",
        value: function getLiquidityPoolId() {
          return String(this.liquidityPoolId);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolId} asset LiquidityPoolId to compare.
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.liquidityPoolId === asset.getLiquidityPoolId();
        }
      }, {
        key: "toString",
        value: function toString() {
          return "liquidity_pool:".concat(this.liquidityPoolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(tlAssetXdr) {
          var assetType = tlAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolId = tlAssetXdr.liquidityPoolId().toString("hex");
            return new this(liquidityPoolId);
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js
var require_manage_sell_offer = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageSellOffer = manageSellOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageSellOfferOp = new _xdr["default"].ManageSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageSellOffer(manageSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js
var require_create_passive_sell_offer = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createPassiveSellOffer = createPassiveSellOffer;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createPassiveSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      var createPassiveSellOfferOp = new _xdr["default"].CreatePassiveSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createPassiveSellOffer(createPassiveSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js
var require_decode_encode_muxed_account = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;
    exports.encodeMuxedAccount = encodeMuxedAccount;
    exports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;
    exports.extractBaseAddress = extractBaseAddress;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function decodeAddressToMuxedAccount(address) {
      if (_strkey.StrKey.isValidMed25519PublicKey(address)) {
        return _decodeAddressFullyToMuxedAccount(address);
      }
      return _xdr["default"].MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));
    }
    function encodeMuxedAccountToAddress(muxedAccount) {
      if (muxedAccount["switch"]().value === _xdr["default"].CryptoKeyType.keyTypeMuxedEd25519().value) {
        return _encodeMuxedAccountFullyToAddress(muxedAccount);
      }
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());
    }
    function encodeMuxedAccount(address, id) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {
        throw new Error("address should be a Stellar account ID (G...)");
      }
      if (typeof id !== "string") {
        throw new Error("id should be a string representing a number (uint64)");
      }
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromString(id),
        ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)
      }));
    }
    function extractBaseAddress(address) {
      if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
        return address;
      }
      if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {
        throw new TypeError("expected muxed account (M...), got ".concat(address));
      }
      var muxedAccount = decodeAddressToMuxedAccount(address);
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());
    }
    function _decodeAddressFullyToMuxedAccount(address) {
      var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromXDR(rawBytes.subarray(-8)),
        ed25519: rawBytes.subarray(0, -8)
      }));
    }
    function _encodeMuxedAccountFullyToAddress(muxedAccount) {
      if (muxedAccount["switch"]() === _xdr["default"].CryptoKeyType.keyTypeEd25519()) {
        return encodeMuxedAccountToAddress(muxedAccount);
      }
      var muxed = muxedAccount.med25519();
      return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR("raw")]));
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/account_merge.js
var require_account_merge = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/account_merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.accountMerge = accountMerge;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function accountMerge(opts) {
      var opAttributes = {};
      try {
        opAttributes.body = _xdr["default"].OperationBody.accountMerge((0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination));
      } catch (e) {
        throw new Error("destination is invalid");
      }
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js
var require_allow_trust = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.allowTrust = allowTrust;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function allowTrust(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.trustor)) {
        throw new Error("trustor is invalid");
      }
      var attributes = {};
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      if (opts.assetCode.length <= 4) {
        var code = opts.assetCode.padEnd(4, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum4(code);
      } else if (opts.assetCode.length <= 12) {
        var _code = opts.assetCode.padEnd(12, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum12(_code);
      } else {
        throw new Error("Asset code must be 12 characters at max.");
      }
      if (typeof opts.authorize === "boolean") {
        if (opts.authorize) {
          attributes.authorize = _xdr["default"].TrustLineFlags.authorizedFlag().value;
        } else {
          attributes.authorize = 0;
        }
      } else {
        attributes.authorize = opts.authorize;
      }
      var allowTrustOp = new _xdr["default"].AllowTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.allowTrust(allowTrustOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js
var require_bump_sequence = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bumpSequence = bumpSequence;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function bumpSequence(opts) {
      var attributes = {};
      if (typeof opts.bumpTo !== "string") {
        throw new Error("bumpTo must be a string");
      }
      try {
        new _bignumber["default"](opts.bumpTo);
      } catch (e) {
        throw new Error("bumpTo must be a stringified number");
      }
      attributes.bumpTo = _jsXdr.Hyper.fromString(opts.bumpTo);
      var bumpSequenceOp = new _xdr["default"].BumpSequenceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.bumpSequence(bumpSequenceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/change_trust.js
var require_change_trust = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/change_trust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.changeTrust = changeTrust;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    var _liquidity_pool_asset = require_liquidity_pool_asset();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var MAX_INT64 = "9223372036854775807";
    function changeTrust(opts) {
      var attributes = {};
      if (opts.asset instanceof _asset.Asset) {
        attributes.line = opts.asset.toChangeTrustXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_asset.LiquidityPoolAsset) {
        attributes.line = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be Asset or LiquidityPoolAsset");
      }
      if (opts.limit !== void 0 && !this.isValidAmount(opts.limit, true)) {
        throw new TypeError(this.constructAmountRequirementsError("limit"));
      }
      if (opts.limit) {
        attributes.limit = this._toXDRAmount(opts.limit);
      } else {
        attributes.limit = _jsXdr.Hyper.fromString(new _bignumber["default"](MAX_INT64).toString());
      }
      if (opts.source) {
        attributes.source = opts.source.masterKeypair;
      }
      var changeTrustOP = new _xdr["default"].ChangeTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.changeTrust(changeTrustOP);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/create_account.js
var require_create_account = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/create_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createAccount = createAccount;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createAccount(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.destination)) {
        throw new Error("destination is invalid");
      }
      if (!this.isValidAmount(opts.startingBalance, true)) {
        throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
      }
      var attributes = {};
      attributes.destination = _keypair.Keypair.fromPublicKey(opts.destination).xdrAccountId();
      attributes.startingBalance = this._toXDRAmount(opts.startingBalance);
      var createAccountOp = new _xdr["default"].CreateAccountOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createAccount(createAccountOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js
var require_create_claimable_balance = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createClaimableBalance = createClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createClaimableBalance(opts) {
      if (!(opts.asset instanceof _asset.Asset)) {
        throw new Error("must provide an asset for create claimable balance operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      if (!Array.isArray(opts.claimants) || opts.claimants.length === 0) {
        throw new Error("must provide at least one claimant");
      }
      var attributes = {};
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.claimants = Object.values(opts.claimants).map(function(c) {
        return c.toXDRObject();
      });
      var createClaimableBalanceOp = new _xdr["default"].CreateClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createClaimableBalance(createClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js
var require_claim_claimable_balance = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.claimClaimableBalance = claimClaimableBalance;
    exports.validateClaimableBalanceId = validateClaimableBalanceId;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function claimClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      validateClaimableBalanceId(opts.balanceId);
      var attributes = {};
      attributes.balanceId = _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex");
      var claimClaimableBalanceOp = new _xdr["default"].ClaimClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.claimClaimableBalance(claimClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function validateClaimableBalanceId(balanceId) {
      if (typeof balanceId !== "string" || balanceId.length !== 8 + 64) {
        throw new Error("must provide a valid claimable balance id");
      }
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js
var require_clawback_claimable_balance = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawbackClaimableBalance = clawbackClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _claim_claimable_balance = require_claim_claimable_balance();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawbackClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _claim_claimable_balance.validateClaimableBalanceId)(opts.balanceId);
      var attributes = {
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      };
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawbackClaimableBalance(new _xdr["default"].ClawbackClaimableBalanceOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/inflation.js
var require_inflation = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/inflation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inflation = inflation;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function inflation() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.inflation();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_data.js
var require_manage_data = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageData = manageData;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageData(opts) {
      var attributes = {};
      if (!(typeof opts.name === "string" && opts.name.length <= 64)) {
        throw new Error("name must be a string, up to 64 characters");
      }
      attributes.dataName = opts.name;
      if (typeof opts.value !== "string" && !Buffer.isBuffer(opts.value) && opts.value !== null) {
        throw new Error("value must be a string, Buffer or null");
      }
      if (typeof opts.value === "string") {
        attributes.dataValue = Buffer.from(opts.value);
      } else {
        attributes.dataValue = opts.value;
      }
      if (attributes.dataValue !== null && attributes.dataValue.length > 64) {
        throw new Error("value cannot be longer that 64 bytes");
      }
      var manageDataOp = new _xdr["default"].ManageDataOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageData(manageDataOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js
var require_manage_buy_offer = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageBuyOffer = manageBuyOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageBuyOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.buyAmount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
      }
      attributes.buyAmount = this._toXDRAmount(opts.buyAmount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageBuyOfferOp = new _xdr["default"].ManageBuyOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageBuyOffer(manageBuyOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js
var require_path_payment_strict_receive = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictReceive = pathPaymentStrictReceive;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictReceive(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendMax):
          throw new TypeError(this.constructAmountRequirementsError("sendMax"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destAmount):
          throw new TypeError(this.constructAmountRequirementsError("destAmount"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendMax = this._toXDRAmount(opts.sendMax);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destAmount = this._toXDRAmount(opts.destAmount);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictReceiveOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictReceive(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js
var require_path_payment_strict_send = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictSend = pathPaymentStrictSend;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictSend(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendAmount):
          throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destMin):
          throw new TypeError(this.constructAmountRequirementsError("destMin"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendAmount = this._toXDRAmount(opts.sendAmount);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destMin = this._toXDRAmount(opts.destMin);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictSendOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictSend(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/payment.js
var require_payment = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/payment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.payment = payment;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function payment(opts) {
      if (!opts.asset) {
        throw new Error("Must provide an asset for a payment operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      var attributes = {};
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      var paymentOp = new _xdr["default"].PaymentOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.payment(paymentOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/set_options.js
var require_set_options = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/set_options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setOptions = setOptions;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function weightCheckFunction(value, name) {
      if (value >= 0 && value <= 255) {
        return true;
      }
      throw new Error("".concat(name, " value must be between 0 and 255"));
    }
    function setOptions(opts) {
      var attributes = {};
      if (opts.inflationDest) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.inflationDest)) {
          throw new Error("inflationDest is invalid");
        }
        attributes.inflationDest = _keypair.Keypair.fromPublicKey(opts.inflationDest).xdrAccountId();
      }
      attributes.clearFlags = this._checkUnsignedIntValue("clearFlags", opts.clearFlags);
      attributes.setFlags = this._checkUnsignedIntValue("setFlags", opts.setFlags);
      attributes.masterWeight = this._checkUnsignedIntValue("masterWeight", opts.masterWeight, weightCheckFunction);
      attributes.lowThreshold = this._checkUnsignedIntValue("lowThreshold", opts.lowThreshold, weightCheckFunction);
      attributes.medThreshold = this._checkUnsignedIntValue("medThreshold", opts.medThreshold, weightCheckFunction);
      attributes.highThreshold = this._checkUnsignedIntValue("highThreshold", opts.highThreshold, weightCheckFunction);
      if (opts.homeDomain !== void 0 && typeof opts.homeDomain !== "string") {
        throw new TypeError("homeDomain argument must be of type String");
      }
      attributes.homeDomain = opts.homeDomain;
      if (opts.signer) {
        var weight = this._checkUnsignedIntValue("signer.weight", opts.signer.weight, weightCheckFunction);
        var key;
        var setValues = 0;
        if (opts.signer.ed25519PublicKey) {
          if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
            throw new Error("signer.ed25519PublicKey is invalid.");
          }
          var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
          key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
          setValues += 1;
        }
        if (opts.signer.preAuthTx) {
          if (typeof opts.signer.preAuthTx === "string") {
            opts.signer.preAuthTx = Buffer.from(opts.signer.preAuthTx, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.preAuthTx) && opts.signer.preAuthTx.length === 32)) {
            throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(opts.signer.preAuthTx);
          setValues += 1;
        }
        if (opts.signer.sha256Hash) {
          if (typeof opts.signer.sha256Hash === "string") {
            opts.signer.sha256Hash = Buffer.from(opts.signer.sha256Hash, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.sha256Hash) && opts.signer.sha256Hash.length === 32)) {
            throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypeHashX(opts.signer.sha256Hash);
          setValues += 1;
        }
        if (opts.signer.ed25519SignedPayload) {
          if (!_strkey.StrKey.isValidSignedPayload(opts.signer.ed25519SignedPayload)) {
            throw new Error("signer.ed25519SignedPayload is invalid.");
          }
          var _rawKey = _strkey.StrKey.decodeSignedPayload(opts.signer.ed25519SignedPayload);
          var signedPayloadXdr = _xdr["default"].SignerKeyEd25519SignedPayload.fromXDR(_rawKey);
          key = _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload(signedPayloadXdr);
          setValues += 1;
        }
        if (setValues !== 1) {
          throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
        }
        attributes.signer = new _xdr["default"].Signer({
          key,
          weight
        });
      }
      var setOptionsOp = new _xdr["default"].SetOptionsOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.setOptions(setOptionsOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js
var require_begin_sponsoring_future_reserves = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.beginSponsoringFutureReserves = beginSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    var _keypair = require_keypair();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function beginSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.sponsoredId)) {
        throw new Error("sponsoredId is invalid");
      }
      var op = new _xdr["default"].BeginSponsoringFutureReservesOp({
        sponsoredId: _keypair.Keypair.fromPublicKey(opts.sponsoredId).xdrAccountId()
      });
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.beginSponsoringFutureReserves(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js
var require_end_sponsoring_future_reserves = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.endSponsoringFutureReserves = endSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function endSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.endSponsoringFutureReserves();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js
var require_revoke_sponsorship = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.revokeAccountSponsorship = revokeAccountSponsorship;
    exports.revokeClaimableBalanceSponsorship = revokeClaimableBalanceSponsorship;
    exports.revokeDataSponsorship = revokeDataSponsorship;
    exports.revokeLiquidityPoolSponsorship = revokeLiquidityPoolSponsorship;
    exports.revokeOfferSponsorship = revokeOfferSponsorship;
    exports.revokeSignerSponsorship = revokeSignerSponsorship;
    exports.revokeTrustlineSponsorship = revokeTrustlineSponsorship;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    var _keypair = require_keypair();
    var _asset = require_asset();
    var _liquidity_pool_id = require_liquidity_pool_id();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function revokeAccountSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.account(new _xdr["default"].LedgerKeyAccount({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId()
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeTrustlineSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var asset;
      if (opts.asset instanceof _asset.Asset) {
        asset = opts.asset.toTrustLineXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_id.LiquidityPoolId) {
        asset = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be an Asset or LiquidityPoolId");
      }
      var ledgerKey = _xdr["default"].LedgerKey.trustline(new _xdr["default"].LedgerKeyTrustLine({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        asset
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeOfferSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.seller)) {
        throw new Error("seller is invalid");
      }
      if (typeof opts.offerId !== "string") {
        throw new Error("offerId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.offer(new _xdr["default"].LedgerKeyOffer({
        sellerId: _keypair.Keypair.fromPublicKey(opts.seller).xdrAccountId(),
        offerId: _xdr["default"].Int64.fromString(opts.offerId)
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeDataSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      if (typeof opts.name !== "string" || opts.name.length > 64) {
        throw new Error("name must be a string, up to 64 characters");
      }
      var ledgerKey = _xdr["default"].LedgerKey.data(new _xdr["default"].LedgerKeyData({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        dataName: opts.name
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeClaimableBalanceSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.balanceId !== "string") {
        throw new Error("balanceId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.claimableBalance(new _xdr["default"].LedgerKeyClaimableBalance({
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeLiquidityPoolSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.liquidityPoolId !== "string") {
        throw new Error("liquidityPoolId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.liquidityPool(new _xdr["default"].LedgerKeyLiquidityPool({
        liquidityPoolId: _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {
        body: _xdr["default"].OperationBody.revokeSponsorship(op)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeSignerSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var key;
      if (opts.signer.ed25519PublicKey) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
          throw new Error("signer.ed25519PublicKey is invalid.");
        }
        var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
        key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
      } else if (opts.signer.preAuthTx) {
        var buffer;
        if (typeof opts.signer.preAuthTx === "string") {
          buffer = Buffer.from(opts.signer.preAuthTx, "hex");
        } else {
          buffer = opts.signer.preAuthTx;
        }
        if (!(Buffer.isBuffer(buffer) && buffer.length === 32)) {
          throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(buffer);
      } else if (opts.signer.sha256Hash) {
        var _buffer;
        if (typeof opts.signer.sha256Hash === "string") {
          _buffer = Buffer.from(opts.signer.sha256Hash, "hex");
        } else {
          _buffer = opts.signer.sha256Hash;
        }
        if (!(Buffer.isBuffer(_buffer) && _buffer.length === 32)) {
          throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypeHashX(_buffer);
      } else {
        throw new Error("signer is invalid");
      }
      var signer = new _xdr["default"].RevokeSponsorshipOpSigner({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        signerKey: key
      });
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipSigner(signer);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback.js
var require_clawback = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawback = clawback;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawback(opts) {
      var attributes = {};
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.asset = opts.asset.toXDRObject();
      try {
        attributes.from = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.from);
      } catch (e) {
        throw new Error("from address is invalid");
      }
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawback(new _xdr["default"].ClawbackOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js
var require_set_trustline_flags = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setTrustLineFlags = setTrustLineFlags;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function setTrustLineFlags() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (_typeof(opts.flags) !== "object" || Object.keys(opts.flags).length === 0) {
        throw new Error("opts.flags must be a map of boolean flags to modify");
      }
      var mapping = {
        authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
        authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
        clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
      };
      var clearFlag = 0;
      var setFlag = 0;
      Object.keys(opts.flags).forEach(function(flagName) {
        if (!Object.prototype.hasOwnProperty.call(mapping, flagName)) {
          throw new Error("unsupported flag name specified: ".concat(flagName));
        }
        var flagValue = opts.flags[flagName];
        var bit = mapping[flagName].value;
        if (flagValue === true) {
          setFlag |= bit;
        } else if (flagValue === false) {
          clearFlag |= bit;
        }
      });
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      attributes.asset = opts.asset.toXDRObject();
      attributes.clearFlags = clearFlag;
      attributes.setFlags = setFlag;
      var opAttributes = {
        body: _xdr["default"].OperationBody.setTrustLineFlags(new _xdr["default"].SetTrustLineFlagsOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js
var require_liquidity_pool_deposit = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolDeposit = liquidityPoolDeposit;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolDeposit() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var liquidityPoolId = opts.liquidityPoolId, maxAmountA = opts.maxAmountA, maxAmountB = opts.maxAmountB, minPrice = opts.minPrice, maxPrice = opts.maxPrice;
      var attributes = {};
      if (!liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(liquidityPoolId, "hex");
      if (!this.isValidAmount(maxAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
      }
      attributes.maxAmountA = this._toXDRAmount(maxAmountA);
      if (!this.isValidAmount(maxAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
      }
      attributes.maxAmountB = this._toXDRAmount(maxAmountB);
      if (minPrice === void 0) {
        throw new TypeError("minPrice argument is required");
      }
      attributes.minPrice = this._toXDRPrice(minPrice);
      if (maxPrice === void 0) {
        throw new TypeError("maxPrice argument is required");
      }
      attributes.maxPrice = this._toXDRPrice(maxPrice);
      var liquidityPoolDepositOp = new _xdr["default"].LiquidityPoolDepositOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolDeposit(liquidityPoolDepositOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js
var require_liquidity_pool_withdraw = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolWithdraw = liquidityPoolWithdraw;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolWithdraw() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (!opts.liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex");
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (!this.isValidAmount(opts.minAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
      }
      attributes.minAmountA = this._toXDRAmount(opts.minAmountA);
      if (!this.isValidAmount(opts.minAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
      }
      attributes.minAmountB = this._toXDRAmount(opts.minAmountB);
      var liquidityPoolWithdrawOp = new _xdr["default"].LiquidityPoolWithdrawOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolWithdraw(liquidityPoolWithdrawOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/address.js
var require_address = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Address = void 0;
    var _strkey = require_strkey();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Address2 = exports.Address = function() {
      function Address3(address) {
        _classCallCheck(this, Address3);
        if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
          this._type = "account";
          this._key = _strkey.StrKey.decodeEd25519PublicKey(address);
        } else if (_strkey.StrKey.isValidContract(address)) {
          this._type = "contract";
          this._key = _strkey.StrKey.decodeContract(address);
        } else {
          throw new Error("Unsupported address type: ".concat(address));
        }
      }
      return _createClass(Address3, [{
        key: "toString",
        value: (
          /**
           * Serialize an address to string.
           *
           * @returns {string}
           */
          function toString() {
            switch (this._type) {
              case "account":
                return _strkey.StrKey.encodeEd25519PublicKey(this._key);
              case "contract":
                return _strkey.StrKey.encodeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          }
        )
        /**
         * Convert this Address to an xdr.ScVal type.
         *
         * @returns {xdr.ScVal}
         */
      }, {
        key: "toScVal",
        value: function toScVal() {
          return _xdr["default"].ScVal.scvAddress(this.toScAddress());
        }
        /**
         * Convert this Address to an xdr.ScAddress type.
         *
         * @returns {xdr.ScAddress}
         */
      }, {
        key: "toScAddress",
        value: function toScAddress() {
          switch (this._type) {
            case "account":
              return _xdr["default"].ScAddress.scAddressTypeAccount(_xdr["default"].PublicKey.publicKeyTypeEd25519(this._key));
            case "contract":
              return _xdr["default"].ScAddress.scAddressTypeContract(this._key);
            default:
              throw new Error("Unsupported address type");
          }
        }
        /**
         * Return the raw public key bytes for this address.
         *
         * @returns {Buffer}
         */
      }, {
        key: "toBuffer",
        value: function toBuffer() {
          return this._key;
        }
      }], [{
        key: "fromString",
        value: function fromString(address) {
          return new Address3(address);
        }
        /**
         * Creates a new account Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "account",
        value: function account(buffer) {
          return new Address3(_strkey.StrKey.encodeEd25519PublicKey(buffer));
        }
        /**
         * Creates a new contract Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "contract",
        value: function contract(buffer) {
          return new Address3(_strkey.StrKey.encodeContract(buffer));
        }
        /**
         * Convert this from an xdr.ScVal type
         *
         * @param {xdr.ScVal} scVal - The xdr.ScVal type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScVal",
        value: function fromScVal(scVal) {
          return Address3.fromScAddress(scVal.address());
        }
        /**
         * Convert this from an xdr.ScAddress type
         *
         * @param {xdr.ScAddress} scAddress - The xdr.ScAddress type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScAddress",
        value: function fromScAddress(scAddress) {
          switch (scAddress["switch"]().value) {
            case _xdr["default"].ScAddressType.scAddressTypeAccount().value:
              return Address3.account(scAddress.accountId().ed25519());
            case _xdr["default"].ScAddressType.scAddressTypeContract().value:
              return Address3.contract(scAddress.contractId());
            default:
              throw new Error("Unsupported address type");
          }
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js
var require_invoke_host_function = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createCustomContract = createCustomContract;
    exports.createStellarAssetContract = createStellarAssetContract;
    exports.invokeContractFunction = invokeContractFunction;
    exports.invokeHostFunction = invokeHostFunction;
    exports.uploadContractWasm = uploadContractWasm;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _address = require_address();
    var _asset = require_asset();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function invokeHostFunction(opts) {
      if (!opts.func) {
        throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(opts), ")"));
      }
      var invokeHostFunctionOp = new _xdr["default"].InvokeHostFunctionOp({
        hostFunction: opts.func,
        auth: opts.auth || []
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.invokeHostFunction(invokeHostFunctionOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function invokeContractFunction(opts) {
      var c = new _address.Address(opts.contract);
      if (c._type !== "contract") {
        throw new TypeError("expected contract strkey instance, got ".concat(c));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeInvokeContract(new _xdr["default"].InvokeContractArgs({
          contractAddress: c.toScAddress(),
          functionName: opts["function"],
          args: opts.args
        }))
      });
    }
    function createCustomContract(opts) {
      var _opts$constructorArgs;
      var salt = Buffer.from(opts.salt || getSalty());
      if (!opts.wasmHash || opts.wasmHash.length !== 32) {
        throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(opts.wasmHash));
      }
      if (salt.length !== 32) {
        throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(opts.wasmHash));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContractV2(new _xdr["default"].CreateContractArgsV2({
          executable: _xdr["default"].ContractExecutable.contractExecutableWasm(Buffer.from(opts.wasmHash)),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAddress(new _xdr["default"].ContractIdPreimageFromAddress({
            address: opts.address.toScAddress(),
            salt
          })),
          constructorArgs: (_opts$constructorArgs = opts.constructorArgs) !== null && _opts$constructorArgs !== void 0 ? _opts$constructorArgs : []
        }))
      });
    }
    function createStellarAssetContract(opts) {
      var asset = opts.asset;
      if (typeof asset === "string") {
        var _asset$split = asset.split(":"), _asset$split2 = _slicedToArray(_asset$split, 2), code = _asset$split2[0], issuer = _asset$split2[1];
        asset = new _asset.Asset(code, issuer);
      }
      if (!(asset instanceof _asset.Asset)) {
        throw new TypeError("expected Asset in 'opts.asset', got ".concat(asset));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContract(new _xdr["default"].CreateContractArgs({
          executable: _xdr["default"].ContractExecutable.contractExecutableStellarAsset(),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(asset.toXDRObject())
        }))
      });
    }
    function uploadContractWasm(opts) {
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeUploadContractWasm(
          Buffer.from(opts.wasm)
          // coalesce so we can drop `Buffer` someday
        )
      });
    }
    function getSalty() {
      return _keypair.Keypair.random().xdrPublicKey().value();
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js
var require_extend_footprint_ttl = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extendFootprintTtl = extendFootprintTtl;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function extendFootprintTtl(opts) {
      var _opts$extendTo;
      if (((_opts$extendTo = opts.extendTo) !== null && _opts$extendTo !== void 0 ? _opts$extendTo : -1) <= 0) {
        throw new RangeError("extendTo has to be positive");
      }
      var extendFootprintOp = new _xdr["default"].ExtendFootprintTtlOp({
        ext: new _xdr["default"].ExtensionPoint(0),
        extendTo: opts.extendTo
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.extendFootprintTtl(extendFootprintOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js
var require_restore_footprint = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.restoreFootprint = restoreFootprint;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function restoreFootprint() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var op = new _xdr["default"].RestoreFootprintOp({
        ext: new _xdr["default"].ExtensionPoint(0)
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.restoreFootprint(op)
      };
      this.setSourceAccount(opAttributes, opts !== null && opts !== void 0 ? opts : {});
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/index.js
var require_operations = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operations/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "accountMerge", {
      enumerable: true,
      get: function get() {
        return _account_merge.accountMerge;
      }
    });
    Object.defineProperty(exports, "allowTrust", {
      enumerable: true,
      get: function get() {
        return _allow_trust.allowTrust;
      }
    });
    Object.defineProperty(exports, "beginSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _begin_sponsoring_future_reserves.beginSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "bumpSequence", {
      enumerable: true,
      get: function get() {
        return _bump_sequence.bumpSequence;
      }
    });
    Object.defineProperty(exports, "changeTrust", {
      enumerable: true,
      get: function get() {
        return _change_trust.changeTrust;
      }
    });
    Object.defineProperty(exports, "claimClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _claim_claimable_balance.claimClaimableBalance;
      }
    });
    Object.defineProperty(exports, "clawback", {
      enumerable: true,
      get: function get() {
        return _clawback.clawback;
      }
    });
    Object.defineProperty(exports, "clawbackClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _clawback_claimable_balance.clawbackClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createAccount", {
      enumerable: true,
      get: function get() {
        return _create_account.createAccount;
      }
    });
    Object.defineProperty(exports, "createClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _create_claimable_balance.createClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createCustomContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createCustomContract;
      }
    });
    Object.defineProperty(exports, "createPassiveSellOffer", {
      enumerable: true,
      get: function get() {
        return _create_passive_sell_offer.createPassiveSellOffer;
      }
    });
    Object.defineProperty(exports, "createStellarAssetContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createStellarAssetContract;
      }
    });
    Object.defineProperty(exports, "endSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _end_sponsoring_future_reserves.endSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "extendFootprintTtl", {
      enumerable: true,
      get: function get() {
        return _extend_footprint_ttl.extendFootprintTtl;
      }
    });
    Object.defineProperty(exports, "inflation", {
      enumerable: true,
      get: function get() {
        return _inflation.inflation;
      }
    });
    Object.defineProperty(exports, "invokeContractFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeContractFunction;
      }
    });
    Object.defineProperty(exports, "invokeHostFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeHostFunction;
      }
    });
    Object.defineProperty(exports, "liquidityPoolDeposit", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_deposit.liquidityPoolDeposit;
      }
    });
    Object.defineProperty(exports, "liquidityPoolWithdraw", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_withdraw.liquidityPoolWithdraw;
      }
    });
    Object.defineProperty(exports, "manageBuyOffer", {
      enumerable: true,
      get: function get() {
        return _manage_buy_offer.manageBuyOffer;
      }
    });
    Object.defineProperty(exports, "manageData", {
      enumerable: true,
      get: function get() {
        return _manage_data.manageData;
      }
    });
    Object.defineProperty(exports, "manageSellOffer", {
      enumerable: true,
      get: function get() {
        return _manage_sell_offer.manageSellOffer;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictReceive", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_receive.pathPaymentStrictReceive;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictSend", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_send.pathPaymentStrictSend;
      }
    });
    Object.defineProperty(exports, "payment", {
      enumerable: true,
      get: function get() {
        return _payment.payment;
      }
    });
    Object.defineProperty(exports, "restoreFootprint", {
      enumerable: true,
      get: function get() {
        return _restore_footprint.restoreFootprint;
      }
    });
    Object.defineProperty(exports, "revokeAccountSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeAccountSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeClaimableBalanceSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeClaimableBalanceSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeDataSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeDataSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeLiquidityPoolSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeLiquidityPoolSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeOfferSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeOfferSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeSignerSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeSignerSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeTrustlineSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeTrustlineSponsorship;
      }
    });
    Object.defineProperty(exports, "setOptions", {
      enumerable: true,
      get: function get() {
        return _set_options.setOptions;
      }
    });
    Object.defineProperty(exports, "setTrustLineFlags", {
      enumerable: true,
      get: function get() {
        return _set_trustline_flags.setTrustLineFlags;
      }
    });
    Object.defineProperty(exports, "uploadContractWasm", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.uploadContractWasm;
      }
    });
    var _manage_sell_offer = require_manage_sell_offer();
    var _create_passive_sell_offer = require_create_passive_sell_offer();
    var _account_merge = require_account_merge();
    var _allow_trust = require_allow_trust();
    var _bump_sequence = require_bump_sequence();
    var _change_trust = require_change_trust();
    var _create_account = require_create_account();
    var _create_claimable_balance = require_create_claimable_balance();
    var _claim_claimable_balance = require_claim_claimable_balance();
    var _clawback_claimable_balance = require_clawback_claimable_balance();
    var _inflation = require_inflation();
    var _manage_data = require_manage_data();
    var _manage_buy_offer = require_manage_buy_offer();
    var _path_payment_strict_receive = require_path_payment_strict_receive();
    var _path_payment_strict_send = require_path_payment_strict_send();
    var _payment = require_payment();
    var _set_options = require_set_options();
    var _begin_sponsoring_future_reserves = require_begin_sponsoring_future_reserves();
    var _end_sponsoring_future_reserves = require_end_sponsoring_future_reserves();
    var _revoke_sponsorship = require_revoke_sponsorship();
    var _clawback = require_clawback();
    var _set_trustline_flags = require_set_trustline_flags();
    var _liquidity_pool_deposit = require_liquidity_pool_deposit();
    var _liquidity_pool_withdraw = require_liquidity_pool_withdraw();
    var _invoke_host_function = require_invoke_host_function();
    var _extend_footprint_ttl = require_extend_footprint_ttl();
    var _restore_footprint = require_restore_footprint();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operation.js
var require_operation = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Operation = exports.AuthRevocableFlag = exports.AuthRequiredFlag = exports.AuthImmutableFlag = exports.AuthClawbackEnabledFlag = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _util = require_util();
    var _continued_fraction = require_continued_fraction();
    var _asset = require_asset();
    var _liquidity_pool_asset = require_liquidity_pool_asset();
    var _claimant = require_claimant();
    var _strkey = require_strkey();
    var _liquidity_pool_id = require_liquidity_pool_id();
    var _xdr = _interopRequireDefault(require_xdr2());
    var ops = _interopRequireWildcard(require_operations());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var ONE = 1e7;
    var MAX_INT64 = "9223372036854775807";
    var AuthRequiredFlag = exports.AuthRequiredFlag = 1 << 0;
    var AuthRevocableFlag = exports.AuthRevocableFlag = 1 << 1;
    var AuthImmutableFlag = exports.AuthImmutableFlag = 1 << 2;
    var AuthClawbackEnabledFlag = exports.AuthClawbackEnabledFlag = 1 << 3;
    var Operation2 = exports.Operation = function() {
      function Operation3() {
        _classCallCheck(this, Operation3);
      }
      return _createClass(Operation3, null, [{
        key: "setSourceAccount",
        value: function setSourceAccount(opAttributes, opts) {
          if (opts.source) {
            try {
              opAttributes.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.source);
            } catch (e) {
              throw new Error("Source address is invalid");
            }
          }
        }
        /**
         * Deconstructs the raw XDR operation object into the structured object that
         * was used to create the operation (i.e. the `opts` parameter to most ops).
         *
         * @param {xdr.Operation}   operation - An XDR Operation.
         * @return {Operation}
         */
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(operation) {
          var result = {};
          if (operation.sourceAccount()) {
            result.source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(operation.sourceAccount());
          }
          var attrs = operation.body().value();
          var operationName = operation.body()["switch"]().name;
          switch (operationName) {
            case "createAccount": {
              result.type = "createAccount";
              result.destination = accountIdtoAddress(attrs.destination());
              result.startingBalance = this._fromXDRAmount(attrs.startingBalance());
              break;
            }
            case "payment": {
              result.type = "payment";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              break;
            }
            case "pathPaymentStrictReceive": {
              result.type = "pathPaymentStrictReceive";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendMax = this._fromXDRAmount(attrs.sendMax());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destAmount = this._fromXDRAmount(attrs.destAmount());
              result.path = [];
              var path = attrs.path();
              Object.keys(path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(path[pathKey]));
              });
              break;
            }
            case "pathPaymentStrictSend": {
              result.type = "pathPaymentStrictSend";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendAmount = this._fromXDRAmount(attrs.sendAmount());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destMin = this._fromXDRAmount(attrs.destMin());
              result.path = [];
              var _path = attrs.path();
              Object.keys(_path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(_path[pathKey]));
              });
              break;
            }
            case "changeTrust": {
              result.type = "changeTrust";
              switch (attrs.line()["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.line = _liquidity_pool_asset.LiquidityPoolAsset.fromOperation(attrs.line());
                  break;
                default:
                  result.line = _asset.Asset.fromOperation(attrs.line());
                  break;
              }
              result.limit = this._fromXDRAmount(attrs.limit());
              break;
            }
            case "allowTrust": {
              result.type = "allowTrust";
              result.trustor = accountIdtoAddress(attrs.trustor());
              result.assetCode = attrs.asset().value().toString();
              result.assetCode = (0, _util.trimEnd)(result.assetCode, "\0");
              result.authorize = attrs.authorize();
              break;
            }
            case "setOptions": {
              result.type = "setOptions";
              if (attrs.inflationDest()) {
                result.inflationDest = accountIdtoAddress(attrs.inflationDest());
              }
              result.clearFlags = attrs.clearFlags();
              result.setFlags = attrs.setFlags();
              result.masterWeight = attrs.masterWeight();
              result.lowThreshold = attrs.lowThreshold();
              result.medThreshold = attrs.medThreshold();
              result.highThreshold = attrs.highThreshold();
              result.homeDomain = attrs.homeDomain() !== void 0 ? attrs.homeDomain().toString("ascii") : void 0;
              if (attrs.signer()) {
                var signer = {};
                var arm = attrs.signer().key().arm();
                if (arm === "ed25519") {
                  signer.ed25519PublicKey = accountIdtoAddress(attrs.signer().key());
                } else if (arm === "preAuthTx") {
                  signer.preAuthTx = attrs.signer().key().preAuthTx();
                } else if (arm === "hashX") {
                  signer.sha256Hash = attrs.signer().key().hashX();
                } else if (arm === "ed25519SignedPayload") {
                  var signedPayload = attrs.signer().key().ed25519SignedPayload();
                  signer.ed25519SignedPayload = _strkey.StrKey.encodeSignedPayload(signedPayload.toXDR());
                }
                signer.weight = attrs.signer().weight();
                result.signer = signer;
              }
              break;
            }
            case "manageOffer":
            case "manageSellOffer": {
              result.type = "manageSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "manageBuyOffer": {
              result.type = "manageBuyOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.buyAmount = this._fromXDRAmount(attrs.buyAmount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "createPassiveOffer":
            case "createPassiveSellOffer": {
              result.type = "createPassiveSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              break;
            }
            case "accountMerge": {
              result.type = "accountMerge";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs);
              break;
            }
            case "manageData": {
              result.type = "manageData";
              result.name = attrs.dataName().toString("ascii");
              result.value = attrs.dataValue();
              break;
            }
            case "inflation": {
              result.type = "inflation";
              break;
            }
            case "bumpSequence": {
              result.type = "bumpSequence";
              result.bumpTo = attrs.bumpTo().toString();
              break;
            }
            case "createClaimableBalance": {
              result.type = "createClaimableBalance";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.claimants = [];
              attrs.claimants().forEach(function(claimant) {
                result.claimants.push(_claimant.Claimant.fromXDR(claimant));
              });
              break;
            }
            case "claimClaimableBalance": {
              result.type = "claimClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "beginSponsoringFutureReserves": {
              result.type = "beginSponsoringFutureReserves";
              result.sponsoredId = accountIdtoAddress(attrs.sponsoredId());
              break;
            }
            case "endSponsoringFutureReserves": {
              result.type = "endSponsoringFutureReserves";
              break;
            }
            case "revokeSponsorship": {
              extractRevokeSponshipDetails(attrs, result);
              break;
            }
            case "clawback": {
              result.type = "clawback";
              result.amount = this._fromXDRAmount(attrs.amount());
              result.from = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.from());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              break;
            }
            case "clawbackClaimableBalance": {
              result.type = "clawbackClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "setTrustLineFlags": {
              result.type = "setTrustLineFlags";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.trustor = accountIdtoAddress(attrs.trustor());
              var clears = attrs.clearFlags();
              var sets = attrs.setFlags();
              var mapping = {
                authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
                authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
              };
              var getFlagValue = function getFlagValue2(key) {
                var bit = mapping[key].value;
                if (sets & bit) {
                  return true;
                }
                if (clears & bit) {
                  return false;
                }
                return void 0;
              };
              result.flags = {};
              Object.keys(mapping).forEach(function(flagName) {
                result.flags[flagName] = getFlagValue(flagName);
              });
              break;
            }
            case "liquidityPoolDeposit": {
              result.type = "liquidityPoolDeposit";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.maxAmountA = this._fromXDRAmount(attrs.maxAmountA());
              result.maxAmountB = this._fromXDRAmount(attrs.maxAmountB());
              result.minPrice = this._fromXDRPrice(attrs.minPrice());
              result.maxPrice = this._fromXDRPrice(attrs.maxPrice());
              break;
            }
            case "liquidityPoolWithdraw": {
              result.type = "liquidityPoolWithdraw";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.amount = this._fromXDRAmount(attrs.amount());
              result.minAmountA = this._fromXDRAmount(attrs.minAmountA());
              result.minAmountB = this._fromXDRAmount(attrs.minAmountB());
              break;
            }
            case "invokeHostFunction": {
              var _attrs$auth;
              result.type = "invokeHostFunction";
              result.func = attrs.hostFunction();
              result.auth = (_attrs$auth = attrs.auth()) !== null && _attrs$auth !== void 0 ? _attrs$auth : [];
              break;
            }
            case "extendFootprintTtl": {
              result.type = "extendFootprintTtl";
              result.extendTo = attrs.extendTo();
              break;
            }
            case "restoreFootprint": {
              result.type = "restoreFootprint";
              break;
            }
            default: {
              throw new Error("Unknown operation: ".concat(operationName));
            }
          }
          return result;
        }
        /**
         * Validates that a given amount is possible for a Stellar asset.
         *
         * Specifically, this means that the amount is well, a valid number, but also
         * that it is within the int64 range and has no more than 7 decimal levels of
         * precision.
         *
         * Note that while smart contracts allow larger amounts, this is oriented
         * towards validating the standard Stellar operations.
         *
         * @param {string}  value       the amount to validate
         * @param {boolean} allowZero   optionally, whether or not zero is valid (default: no)
         *
         * @returns {boolean}
         */
      }, {
        key: "isValidAmount",
        value: function isValidAmount(value) {
          var allowZero = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (typeof value !== "string") {
            return false;
          }
          var amount;
          try {
            amount = new _bignumber["default"](value);
          } catch (e) {
            return false;
          }
          if (
            // == 0
            !allowZero && amount.isZero() || // < 0
            amount.isNegative() || // > Max value
            amount.times(ONE).gt(new _bignumber["default"](MAX_INT64).toString()) || // Decimal places (max 7)
            amount.decimalPlaces() > 7 || // NaN or Infinity
            amount.isNaN() || !amount.isFinite()
          ) {
            return false;
          }
          return true;
        }
      }, {
        key: "constructAmountRequirementsError",
        value: function constructAmountRequirementsError(arg) {
          return "".concat(arg, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
        }
        /**
         * Returns value converted to uint32 value or undefined.
         * If `value` is not `Number`, `String` or `Undefined` then throws an error.
         * Used in {@link Operation.setOptions}.
         * @private
         * @param {string} name Name of the property (used in error message only)
         * @param {*} value Value to check
         * @param {function(value, name)} isValidFunction Function to check other constraints (the argument will be a `Number`)
         * @returns {undefined|Number}
         */
      }, {
        key: "_checkUnsignedIntValue",
        value: function _checkUnsignedIntValue(name, value) {
          var isValidFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (typeof value === "undefined") {
            return void 0;
          }
          if (typeof value === "string") {
            value = parseFloat(value);
          }
          switch (true) {
            case (typeof value !== "number" || !Number.isFinite(value) || value % 1 !== 0):
              throw new Error("".concat(name, " value is invalid"));
            case value < 0:
              throw new Error("".concat(name, " value must be unsigned"));
            case (!isValidFunction || isValidFunction && isValidFunction(value, name)):
              return value;
            default:
              throw new Error("".concat(name, " value is invalid"));
          }
        }
        /**
         * @private
         * @param {string|BigNumber} value Value
         * @returns {Hyper} XDR amount
         */
      }, {
        key: "_toXDRAmount",
        value: function _toXDRAmount(value) {
          var amount = new _bignumber["default"](value).times(ONE);
          return _jsXdr.Hyper.fromString(amount.toString());
        }
        /**
         * @private
         * @param {string|BigNumber} value XDR amount
         * @returns {BigNumber} Number
         */
      }, {
        key: "_fromXDRAmount",
        value: function _fromXDRAmount(value) {
          return new _bignumber["default"](value).div(ONE).toFixed(7);
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {BigNumber} Big string
         */
      }, {
        key: "_fromXDRPrice",
        value: function _fromXDRPrice(price) {
          var n = new _bignumber["default"](price.n());
          return n.div(new _bignumber["default"](price.d())).toString();
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {object} XDR price object
         */
      }, {
        key: "_toXDRPrice",
        value: function _toXDRPrice(price) {
          var xdrObject;
          if (price.n && price.d) {
            xdrObject = new _xdr["default"].Price(price);
          } else {
            var approx = (0, _continued_fraction.best_r)(price);
            xdrObject = new _xdr["default"].Price({
              n: parseInt(approx[0], 10),
              d: parseInt(approx[1], 10)
            });
          }
          if (xdrObject.n() < 0 || xdrObject.d() < 0) {
            throw new Error("price must be positive");
          }
          return xdrObject;
        }
      }]);
    }();
    function extractRevokeSponshipDetails(attrs, result) {
      switch (attrs["switch"]().name) {
        case "revokeSponsorshipLedgerEntry": {
          var ledgerKey = attrs.ledgerKey();
          switch (ledgerKey["switch"]().name) {
            case _xdr["default"].LedgerEntryType.account().name: {
              result.type = "revokeAccountSponsorship";
              result.account = accountIdtoAddress(ledgerKey.account().accountId());
              break;
            }
            case _xdr["default"].LedgerEntryType.trustline().name: {
              result.type = "revokeTrustlineSponsorship";
              result.account = accountIdtoAddress(ledgerKey.trustLine().accountId());
              var xdrAsset = ledgerKey.trustLine().asset();
              switch (xdrAsset["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.asset = _liquidity_pool_id.LiquidityPoolId.fromOperation(xdrAsset);
                  break;
                default:
                  result.asset = _asset.Asset.fromOperation(xdrAsset);
                  break;
              }
              break;
            }
            case _xdr["default"].LedgerEntryType.offer().name: {
              result.type = "revokeOfferSponsorship";
              result.seller = accountIdtoAddress(ledgerKey.offer().sellerId());
              result.offerId = ledgerKey.offer().offerId().toString();
              break;
            }
            case _xdr["default"].LedgerEntryType.data().name: {
              result.type = "revokeDataSponsorship";
              result.account = accountIdtoAddress(ledgerKey.data().accountId());
              result.name = ledgerKey.data().dataName().toString("ascii");
              break;
            }
            case _xdr["default"].LedgerEntryType.claimableBalance().name: {
              result.type = "revokeClaimableBalanceSponsorship";
              result.balanceId = ledgerKey.claimableBalance().balanceId().toXDR("hex");
              break;
            }
            case _xdr["default"].LedgerEntryType.liquidityPool().name: {
              result.type = "revokeLiquidityPoolSponsorship";
              result.liquidityPoolId = ledgerKey.liquidityPool().liquidityPoolId().toString("hex");
              break;
            }
            default: {
              throw new Error("Unknown ledgerKey: ".concat(attrs["switch"]().name));
            }
          }
          break;
        }
        case "revokeSponsorshipSigner": {
          result.type = "revokeSignerSponsorship";
          result.account = accountIdtoAddress(attrs.signer().accountId());
          result.signer = convertXDRSignerKeyToObject(attrs.signer().signerKey());
          break;
        }
        default: {
          throw new Error("Unknown revokeSponsorship: ".concat(attrs["switch"]().name));
        }
      }
    }
    function convertXDRSignerKeyToObject(signerKey) {
      var attrs = {};
      switch (signerKey["switch"]().name) {
        case _xdr["default"].SignerKeyType.signerKeyTypeEd25519().name: {
          attrs.ed25519PublicKey = _strkey.StrKey.encodeEd25519PublicKey(signerKey.ed25519());
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx().name: {
          attrs.preAuthTx = signerKey.preAuthTx().toString("hex");
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypeHashX().name: {
          attrs.sha256Hash = signerKey.hashX().toString("hex");
          break;
        }
        default: {
          throw new Error("Unknown signerKey: ".concat(signerKey["switch"]().name));
        }
      }
      return attrs;
    }
    function accountIdtoAddress(accountId) {
      return _strkey.StrKey.encodeEd25519PublicKey(accountId.ed25519());
    }
    Operation2.accountMerge = ops.accountMerge;
    Operation2.allowTrust = ops.allowTrust;
    Operation2.bumpSequence = ops.bumpSequence;
    Operation2.changeTrust = ops.changeTrust;
    Operation2.createAccount = ops.createAccount;
    Operation2.createClaimableBalance = ops.createClaimableBalance;
    Operation2.claimClaimableBalance = ops.claimClaimableBalance;
    Operation2.clawbackClaimableBalance = ops.clawbackClaimableBalance;
    Operation2.createPassiveSellOffer = ops.createPassiveSellOffer;
    Operation2.inflation = ops.inflation;
    Operation2.manageData = ops.manageData;
    Operation2.manageSellOffer = ops.manageSellOffer;
    Operation2.manageBuyOffer = ops.manageBuyOffer;
    Operation2.pathPaymentStrictReceive = ops.pathPaymentStrictReceive;
    Operation2.pathPaymentStrictSend = ops.pathPaymentStrictSend;
    Operation2.payment = ops.payment;
    Operation2.setOptions = ops.setOptions;
    Operation2.beginSponsoringFutureReserves = ops.beginSponsoringFutureReserves;
    Operation2.endSponsoringFutureReserves = ops.endSponsoringFutureReserves;
    Operation2.revokeAccountSponsorship = ops.revokeAccountSponsorship;
    Operation2.revokeTrustlineSponsorship = ops.revokeTrustlineSponsorship;
    Operation2.revokeOfferSponsorship = ops.revokeOfferSponsorship;
    Operation2.revokeDataSponsorship = ops.revokeDataSponsorship;
    Operation2.revokeClaimableBalanceSponsorship = ops.revokeClaimableBalanceSponsorship;
    Operation2.revokeLiquidityPoolSponsorship = ops.revokeLiquidityPoolSponsorship;
    Operation2.revokeSignerSponsorship = ops.revokeSignerSponsorship;
    Operation2.clawback = ops.clawback;
    Operation2.setTrustLineFlags = ops.setTrustLineFlags;
    Operation2.liquidityPoolDeposit = ops.liquidityPoolDeposit;
    Operation2.liquidityPoolWithdraw = ops.liquidityPoolWithdraw;
    Operation2.invokeHostFunction = ops.invokeHostFunction;
    Operation2.extendFootprintTtl = ops.extendFootprintTtl;
    Operation2.restoreFootprint = ops.restoreFootprint;
    Operation2.createStellarAssetContract = ops.createStellarAssetContract;
    Operation2.invokeContractFunction = ops.invokeContractFunction;
    Operation2.createCustomContract = ops.createCustomContract;
    Operation2.uploadContractWasm = ops.uploadContractWasm;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/memo.js
var require_memo = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/memo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MemoText = exports.MemoReturn = exports.MemoNone = exports.MemoID = exports.MemoHash = exports.Memo = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MemoNone = exports.MemoNone = "none";
    var MemoID = exports.MemoID = "id";
    var MemoText = exports.MemoText = "text";
    var MemoHash = exports.MemoHash = "hash";
    var MemoReturn = exports.MemoReturn = "return";
    var Memo = exports.Memo = function() {
      function Memo2(type) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Memo2);
        this._type = type;
        this._value = value;
        switch (this._type) {
          case MemoNone:
            break;
          case MemoID:
            Memo2._validateIdValue(value);
            break;
          case MemoText:
            Memo2._validateTextValue(value);
            break;
          case MemoHash:
          case MemoReturn:
            Memo2._validateHashValue(value);
            if (typeof value === "string") {
              this._value = Buffer.from(value, "hex");
            }
            break;
          default:
            throw new Error("Invalid memo type");
        }
      }
      return _createClass(Memo2, [{
        key: "type",
        get: function get() {
          return this._type;
        },
        set: function set(type) {
          throw new Error("Memo is immutable");
        }
        /**
         * Contains memo value:
         * * `null` for `MemoNone`,
         * * `string` for `MemoID`,
         * * `Buffer` for `MemoText` after decoding using `fromXDRObject`, original value otherwise,
         * * `Buffer` for `MemoHash`, `MemoReturn`.
         */
      }, {
        key: "value",
        get: function get() {
          switch (this._type) {
            case MemoNone:
              return null;
            case MemoID:
            case MemoText:
              return this._value;
            case MemoHash:
            case MemoReturn:
              return Buffer.from(this._value);
            default:
              throw new Error("Invalid memo type");
          }
        },
        set: function set(value) {
          throw new Error("Memo is immutable");
        }
      }, {
        key: "toXDRObject",
        value: (
          /**
           * Returns XDR memo object.
           * @returns {xdr.Memo}
           */
          function toXDRObject() {
            switch (this._type) {
              case MemoNone:
                return _xdr["default"].Memo.memoNone();
              case MemoID:
                return _xdr["default"].Memo.memoId(_jsXdr.UnsignedHyper.fromString(this._value));
              case MemoText:
                return _xdr["default"].Memo.memoText(this._value);
              case MemoHash:
                return _xdr["default"].Memo.memoHash(this._value);
              case MemoReturn:
                return _xdr["default"].Memo.memoReturn(this._value);
              default:
                return null;
            }
          }
        )
        /**
         * Returns {@link Memo} from XDR memo object.
         * @param {xdr.Memo} object XDR memo object
         * @returns {Memo}
         */
      }], [{
        key: "_validateIdValue",
        value: function _validateIdValue(value) {
          var error = new Error("Expects a int64 as a string. Got ".concat(value));
          if (typeof value !== "string") {
            throw error;
          }
          var number;
          try {
            number = new _bignumber["default"](value);
          } catch (e) {
            throw error;
          }
          if (!number.isFinite()) {
            throw error;
          }
          if (number.isNaN()) {
            throw error;
          }
        }
      }, {
        key: "_validateTextValue",
        value: function _validateTextValue(value) {
          if (!_xdr["default"].Memo.armTypeForArm("text").isValid(value)) {
            throw new Error("Expects string, array or buffer, max 28 bytes");
          }
        }
      }, {
        key: "_validateHashValue",
        value: function _validateHashValue(value) {
          var error = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(value));
          if (value === null || typeof value === "undefined") {
            throw error;
          }
          var valueBuffer;
          if (typeof value === "string") {
            if (!/^[0-9A-Fa-f]{64}$/g.test(value)) {
              throw error;
            }
            valueBuffer = Buffer.from(value, "hex");
          } else if (Buffer.isBuffer(value)) {
            valueBuffer = Buffer.from(value);
          } else {
            throw error;
          }
          if (!valueBuffer.length || valueBuffer.length !== 32) {
            throw error;
          }
        }
        /**
         * Returns an empty memo (`MemoNone`).
         * @returns {Memo}
         */
      }, {
        key: "none",
        value: function none() {
          return new Memo2(MemoNone);
        }
        /**
         * Creates and returns a `MemoText` memo.
         * @param {string} text - memo text
         * @returns {Memo}
         */
      }, {
        key: "text",
        value: function text(_text) {
          return new Memo2(MemoText, _text);
        }
        /**
         * Creates and returns a `MemoID` memo.
         * @param {string} id - 64-bit number represented as a string
         * @returns {Memo}
         */
      }, {
        key: "id",
        value: function id(_id) {
          return new Memo2(MemoID, _id);
        }
        /**
         * Creates and returns a `MemoHash` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "hash",
        value: function hash2(_hash) {
          return new Memo2(MemoHash, _hash);
        }
        /**
         * Creates and returns a `MemoReturn` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "return",
        value: function _return(hash2) {
          return new Memo2(MemoReturn, hash2);
        }
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(object) {
          switch (object.arm()) {
            case "id":
              return Memo2.id(object.value().toString());
            case "text":
              return Memo2.text(object.value());
            case "hash":
              return Memo2.hash(object.value());
            case "retHash":
              return Memo2["return"](object.value());
            default:
              break;
          }
          if (typeof object.value() === "undefined") {
            return Memo2.none();
          }
          throw new Error("Unknown type");
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/transaction.js
var require_transaction = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/transaction.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _hashing = require_hashing();
    var _strkey = require_strkey();
    var _operation = require_operation();
    var _memo = require_memo();
    var _transaction_base = require_transaction_base();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Transaction = exports.Transaction = function(_TransactionBase) {
      function Transaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, Transaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (!(envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0() || envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTx())) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, Transaction2, [tx, signatures, fee, networkPassphrase]);
        _this._envelopeType = envelopeType;
        _this._memo = tx.memo();
        _this._sequence = tx.seqNum().toString();
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            _this._source = _strkey.StrKey.encodeEd25519PublicKey(_this.tx.sourceAccountEd25519());
            break;
          default:
            _this._source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.sourceAccount());
            break;
        }
        var cond = null;
        var timeBounds = null;
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            timeBounds = tx.timeBounds();
            break;
          case _xdr["default"].EnvelopeType.envelopeTypeTx():
            switch (tx.cond()["switch"]()) {
              case _xdr["default"].PreconditionType.precondTime():
                timeBounds = tx.cond().timeBounds();
                break;
              case _xdr["default"].PreconditionType.precondV2():
                cond = tx.cond().v2();
                timeBounds = cond.timeBounds();
                break;
              default:
                break;
            }
            break;
          default:
            break;
        }
        if (timeBounds) {
          _this._timeBounds = {
            minTime: timeBounds.minTime().toString(),
            maxTime: timeBounds.maxTime().toString()
          };
        }
        if (cond) {
          var ledgerBounds = cond.ledgerBounds();
          if (ledgerBounds) {
            _this._ledgerBounds = {
              minLedger: ledgerBounds.minLedger(),
              maxLedger: ledgerBounds.maxLedger()
            };
          }
          var minSeq = cond.minSeqNum();
          if (minSeq) {
            _this._minAccountSequence = minSeq.toString();
          }
          _this._minAccountSequenceAge = cond.minSeqAge();
          _this._minAccountSequenceLedgerGap = cond.minSeqLedgerGap();
          _this._extraSigners = cond.extraSigners();
        }
        var operations = tx.operations() || [];
        _this._operations = operations.map(function(op) {
          return _operation.Operation.fromXDRObject(op);
        });
        return _this;
      }
      _inherits(Transaction2, _TransactionBase);
      return _createClass(Transaction2, [{
        key: "timeBounds",
        get: function get() {
          return this._timeBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {object}
         * @property {number} minLedger - smallest ledger bound (uint32)
         * @property {number} maxLedger - largest ledger bound (or 0 for inf)
         * @readonly
         */
      }, {
        key: "ledgerBounds",
        get: function get() {
          return this._ledgerBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit account sequence
         * @readonly
         * @type {string}
         */
      }, {
        key: "minAccountSequence",
        get: function get() {
          return this._minAccountSequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit number of seconds
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceAge",
        get: function get() {
          return this._minAccountSequenceAge;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 32 bit number of ledgers
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceLedgerGap",
        get: function get() {
          return this._minAccountSequenceLedgerGap;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * array of extra signers ({@link StrKey}s)
         * @type {string[]}
         * @readonly
         */
      }, {
        key: "extraSigners",
        get: function get() {
          return this._extraSigners;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "sequence",
        get: function get() {
          return this._sequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "source",
        get: function get() {
          return this._source;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {Array.<xdr.Operation>}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._operations;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "memo",
        get: function get() {
          return _memo.Memo.fromXDRObject(this._memo);
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var tx = this.tx;
          if (this._envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            tx = _xdr["default"].Transaction.fromXDR(Buffer.concat([
              // TransactionV0 is a transaction with the AccountID discriminant
              // stripped off, we need to put it back to build a valid transaction
              // which we can use to build a TransactionSignaturePayloadTaggedTransaction
              _xdr["default"].PublicKeyType.publicKeyTypeEd25519().toXDR(),
              tx.toXDR()
            ]));
          }
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var rawTx = this.tx.toXDR();
          var signatures = this.signatures.slice();
          var envelope;
          switch (this._envelopeType) {
            case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxV0(new _xdr["default"].TransactionV0Envelope({
                tx: _xdr["default"].TransactionV0.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            case _xdr["default"].EnvelopeType.envelopeTypeTx():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                tx: _xdr["default"].Transaction.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            default:
              throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
          }
          return envelope;
        }
        /**
         * Calculate the claimable balance ID for an operation within the transaction.
         *
         * @param   {integer}  opIndex   the index of the CreateClaimableBalance op
         * @returns {string}   a hex string representing the claimable balance ID
         *
         * @throws {RangeError}   for invalid `opIndex` value
         * @throws {TypeError}    if op at `opIndex` is not `CreateClaimableBalance`
         * @throws for general XDR un/marshalling failures
         *
         * @see https://github.com/stellar/go/blob/d712346e61e288d450b0c08038c158f8848cc3e4/txnbuild/transaction.go#L392-L435
         *
         */
      }, {
        key: "getClaimableBalanceId",
        value: function getClaimableBalanceId(opIndex) {
          if (!Number.isInteger(opIndex) || opIndex < 0 || opIndex >= this.operations.length) {
            throw new RangeError("invalid operation index");
          }
          var op = this.operations[opIndex];
          try {
            op = _operation.Operation.createClaimableBalance(op);
          } catch (err) {
            throw new TypeError("expected createClaimableBalance, got ".concat(op.type, ": ").concat(err));
          }
          var account = _strkey.StrKey.decodeEd25519PublicKey((0, _decode_encode_muxed_account.extractBaseAddress)(this.source));
          var operationId = _xdr["default"].HashIdPreimage.envelopeTypeOpId(new _xdr["default"].HashIdPreimageOperationId({
            sourceAccount: _xdr["default"].AccountId.publicKeyTypeEd25519(account),
            seqNum: _xdr["default"].SequenceNumber.fromString(this.sequence),
            opNum: opIndex
          }));
          var opIdHash = (0, _hashing.hash)(operationId.toXDR("raw"));
          var balanceId = _xdr["default"].ClaimableBalanceId.claimableBalanceIdTypeV0(opIdHash);
          return balanceId.toXDR("hex");
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js
var require_fee_bump_transaction = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FeeBumpTransaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _hashing = require_hashing();
    var _transaction = require_transaction();
    var _transaction_base = require_transaction_base();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var FeeBumpTransaction = exports.FeeBumpTransaction = function(_TransactionBase) {
      function FeeBumpTransaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, FeeBumpTransaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (envelopeType !== _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, FeeBumpTransaction2, [tx, signatures, fee, networkPassphrase]);
        var innerTxEnvelope = _xdr["default"].TransactionEnvelope.envelopeTypeTx(tx.innerTx().v1());
        _this._feeSource = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.feeSource());
        _this._innerTransaction = new _transaction.Transaction(innerTxEnvelope, networkPassphrase);
        return _this;
      }
      _inherits(FeeBumpTransaction2, _TransactionBase);
      return _createClass(FeeBumpTransaction2, [{
        key: "innerTransaction",
        get: function get() {
          return this._innerTransaction;
        }
        /**
         * @type {Operation[]}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._innerTransaction.operations;
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "feeSource",
        get: function get() {
          return this._feeSource;
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var envelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx: _xdr["default"].FeeBumpTransaction.fromXDR(this.tx.toXDR()),
            // make a copy of the tx
            signatures: this.signatures.slice()
            // make a copy of the signatures
          });
          return new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(envelope);
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/account.js
var require_account = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Account = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Account = exports.Account = function() {
      function Account2(accountId, sequence) {
        _classCallCheck(this, Account2);
        if (_strkey.StrKey.isValidMed25519PublicKey(accountId)) {
          throw new Error("accountId is an M-address; use MuxedAccount instead");
        }
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        if (!(typeof sequence === "string")) {
          throw new Error("sequence must be of type string");
        }
        this._accountId = accountId;
        this.sequence = new _bignumber["default"](sequence);
      }
      return _createClass(Account2, [{
        key: "accountId",
        value: function accountId() {
          return this._accountId;
        }
        /**
         * @returns {string}  sequence number for the account as a string
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.sequence.toString();
        }
        /**
         * Increments sequence number in this object by one.
         * @returns {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          this.sequence = this.sequence.plus(1);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/muxed_account.js
var require_muxed_account = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/muxed_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MuxedAccount = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _account = require_account();
    var _strkey = require_strkey();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MuxedAccount = exports.MuxedAccount = function() {
      function MuxedAccount2(baseAccount, id) {
        _classCallCheck(this, MuxedAccount2);
        var accountId = baseAccount.accountId();
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        this.account = baseAccount;
        this._muxedXdr = (0, _decode_encode_muxed_account.encodeMuxedAccount)(accountId, id);
        this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
        this._id = id;
      }
      return _createClass(MuxedAccount2, [{
        key: "baseAccount",
        value: (
          /**
           * @return {Account} the underlying account object shared among all muxed
           *     accounts with this Stellar address
           */
          function baseAccount() {
            return this.account;
          }
        )
        /**
         * @return {string} the M-address representing this account's (G-address, ID)
         */
      }, {
        key: "accountId",
        value: function accountId() {
          return this._mAddress;
        }
      }, {
        key: "id",
        value: function id() {
          return this._id;
        }
      }, {
        key: "setId",
        value: function setId(id) {
          if (typeof id !== "string") {
            throw new Error("id should be a string representing a number (uint64)");
          }
          this._muxedXdr.med25519().id(_xdr["default"].Uint64.fromString(id));
          this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
          this._id = id;
          return this;
        }
        /**
         * Accesses the underlying account's sequence number.
         * @return {string}  strigified sequence number for the underlying account
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.account.sequenceNumber();
        }
        /**
         * Increments the underlying account's sequence number by one.
         * @return {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          return this.account.incrementSequenceNumber();
        }
        /**
         * @return {xdr.MuxedAccount} the XDR object representing this muxed account's
         *     G-address and uint64 ID
         */
      }, {
        key: "toXDRObject",
        value: function toXDRObject() {
          return this._muxedXdr;
        }
      }, {
        key: "equals",
        value: function equals(otherMuxedAccount) {
          return this.accountId() === otherMuxedAccount.accountId();
        }
      }], [{
        key: "fromAddress",
        value: function fromAddress(mAddress, sequenceNum) {
          var muxedAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(mAddress);
          var gAddress = (0, _decode_encode_muxed_account.extractBaseAddress)(mAddress);
          var id = muxedAccount.med25519().id().toString();
          return new MuxedAccount2(new _account.Account(gAddress, sequenceNum), id);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js
var require_sorobandata_builder = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SorobanDataBuilder = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SorobanDataBuilder = exports.SorobanDataBuilder = function() {
      function SorobanDataBuilder2(sorobanData) {
        _classCallCheck(this, SorobanDataBuilder2);
        _defineProperty(this, "_data", void 0);
        var data;
        if (!sorobanData) {
          data = new _xdr["default"].SorobanTransactionData({
            resources: new _xdr["default"].SorobanResources({
              footprint: new _xdr["default"].LedgerFootprint({
                readOnly: [],
                readWrite: []
              }),
              instructions: 0,
              readBytes: 0,
              writeBytes: 0
            }),
            ext: new _xdr["default"].ExtensionPoint(0),
            resourceFee: new _xdr["default"].Int64(0)
          });
        } else if (typeof sorobanData === "string" || ArrayBuffer.isView(sorobanData)) {
          data = SorobanDataBuilder2.fromXDR(sorobanData);
        } else {
          data = SorobanDataBuilder2.fromXDR(sorobanData.toXDR());
        }
        this._data = data;
      }
      return _createClass(SorobanDataBuilder2, [{
        key: "setResourceFee",
        value: (
          /**
           * Sets the resource fee portion of the Soroban data.
           * @param {number | bigint | string} fee  the resource fee to set (int64)
           * @returns {SorobanDataBuilder}
           */
          function setResourceFee(fee) {
            this._data.resourceFee(new _xdr["default"].Int64(fee));
            return this;
          }
        )
        /**
         * Sets up the resource metrics.
         *
         * You should almost NEVER need this, as its often generated / provided to you
         * by transaction simulation/preflight from a Soroban RPC server.
         *
         * @param {number} cpuInstrs      number of CPU instructions
         * @param {number} readBytes      number of bytes being read
         * @param {number} writeBytes     number of bytes being written
         *
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setResources",
        value: function setResources(cpuInstrs, readBytes, writeBytes) {
          this._data.resources().instructions(cpuInstrs);
          this._data.resources().readBytes(readBytes);
          this._data.resources().writeBytes(writeBytes);
          return this;
        }
        /**
         * Appends the given ledger keys to the existing storage access footprint.
         * @param {xdr.LedgerKey[]} readOnly   read-only keys to add
         * @param {xdr.LedgerKey[]} readWrite  read-write keys to add
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "appendFootprint",
        value: function appendFootprint(readOnly, readWrite) {
          return this.setFootprint(this.getReadOnly().concat(readOnly), this.getReadWrite().concat(readWrite));
        }
        /**
         * Sets the storage access footprint to be a certain set of ledger keys.
         *
         * You can also set each field explicitly via
         * {@link SorobanDataBuilder.setReadOnly} and
         * {@link SorobanDataBuilder.setReadWrite} or add to the existing footprint
         * via {@link SorobanDataBuilder.appendFootprint}.
         *
         * Passing `null|undefined` to either parameter will IGNORE the existing
         * values. If you want to clear them, pass `[]`, instead.
         *
         * @param {xdr.LedgerKey[]|null} [readOnly]   the set of ledger keys to set in
         *    the read-only portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @param {xdr.LedgerKey[]|null} [readWrite]  the set of ledger keys to set in
         *    the read-write portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "setFootprint",
        value: function setFootprint(readOnly, readWrite) {
          if (readOnly !== null) {
            this.setReadOnly(readOnly);
          }
          if (readWrite !== null) {
            this.setReadWrite(readWrite);
          }
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readOnly  read-only keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadOnly",
        value: function setReadOnly(readOnly) {
          this._data.resources().footprint().readOnly(readOnly !== null && readOnly !== void 0 ? readOnly : []);
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readWrite  read-write keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadWrite",
        value: function setReadWrite(readWrite) {
          this._data.resources().footprint().readWrite(readWrite !== null && readWrite !== void 0 ? readWrite : []);
          return this;
        }
        /**
         * @returns {xdr.SorobanTransactionData} a copy of the final data structure
         */
      }, {
        key: "build",
        value: function build() {
          return _xdr["default"].SorobanTransactionData.fromXDR(this._data.toXDR());
        }
        //
        // getters follow
        //
        /** @returns {xdr.LedgerKey[]} the read-only storage access pattern */
      }, {
        key: "getReadOnly",
        value: function getReadOnly() {
          return this.getFootprint().readOnly();
        }
        /** @returns {xdr.LedgerKey[]} the read-write storage access pattern */
      }, {
        key: "getReadWrite",
        value: function getReadWrite() {
          return this.getFootprint().readWrite();
        }
        /** @returns {xdr.LedgerFootprint} the storage access pattern */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return this._data.resources().footprint();
        }
      }], [{
        key: "fromXDR",
        value: function fromXDR(data) {
          return _xdr["default"].SorobanTransactionData.fromXDR(data, typeof data === "string" ? "base64" : "raw");
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/signerkey.js
var require_signerkey = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/signerkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SignerKey = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SignerKey2 = exports.SignerKey = function() {
      function SignerKey3() {
        _classCallCheck(this, SignerKey3);
      }
      return _createClass(SignerKey3, null, [{
        key: "decodeAddress",
        value: (
          /**
           * Decodes a StrKey address into an xdr.SignerKey instance.
           *
           * Only ED25519 public keys (G...), pre-auth transactions (T...), hashes
           * (H...), and signed payloads (P...) can be signer keys.
           *
           * @param   {string} address  a StrKey-encoded signer address
           * @returns {xdr.SignerKey}
           */
          function decodeAddress(address) {
            var signerKeyMap = {
              ed25519PublicKey: _xdr["default"].SignerKey.signerKeyTypeEd25519,
              preAuthTx: _xdr["default"].SignerKey.signerKeyTypePreAuthTx,
              sha256Hash: _xdr["default"].SignerKey.signerKeyTypeHashX,
              signedPayload: _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload
            };
            var vb = _strkey.StrKey.getVersionByteForPrefix(address);
            var encoder = signerKeyMap[vb];
            if (!encoder) {
              throw new Error("invalid signer key type (".concat(vb, ")"));
            }
            var raw = (0, _strkey.decodeCheck)(vb, address);
            switch (vb) {
              case "signedPayload":
                return encoder(new _xdr["default"].SignerKeyEd25519SignedPayload({
                  ed25519: raw.slice(0, 32),
                  payload: raw.slice(32 + 4)
                }));
              case "ed25519PublicKey":
              case "preAuthTx":
              case "sha256Hash":
              default:
                return encoder(raw);
            }
          }
        )
        /**
         * Encodes a signer key into its StrKey equivalent.
         *
         * @param   {xdr.SignerKey} signerKey   the signer
         * @returns {string} the StrKey representation of the signer
         */
      }, {
        key: "encodeSignerKey",
        value: function encodeSignerKey(signerKey) {
          var strkeyType;
          var raw;
          switch (signerKey["switch"]()) {
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519():
              strkeyType = "ed25519PublicKey";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx():
              strkeyType = "preAuthTx";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeHashX():
              strkeyType = "sha256Hash";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519SignedPayload():
              strkeyType = "signedPayload";
              raw = signerKey.ed25519SignedPayload().toXDR("raw");
              break;
            default:
              throw new Error("invalid SignerKey (type: ".concat(signerKey["switch"](), ")"));
          }
          return (0, _strkey.encodeCheck)(strkeyType, raw);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/transaction_builder.js
var require_transaction_builder = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/transaction_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = void 0;
    exports.isValidDate = isValidDate;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    var _account = require_account();
    var _muxed_account = require_muxed_account();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    var _transaction = require_transaction();
    var _fee_bump_transaction = require_fee_bump_transaction();
    var _sorobandata_builder = require_sorobandata_builder();
    var _strkey = require_strkey();
    var _signerkey = require_signerkey();
    var _memo = require_memo();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var BASE_FEE = exports.BASE_FEE = "100";
    var TimeoutInfinite = exports.TimeoutInfinite = 0;
    var TransactionBuilder2 = exports.TransactionBuilder = function() {
      function TransactionBuilder3(sourceAccount) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, TransactionBuilder3);
        if (!sourceAccount) {
          throw new Error("must specify source account for the transaction");
        }
        if (opts.fee === void 0) {
          throw new Error("must specify fee for the transaction (in stroops)");
        }
        this.source = sourceAccount;
        this.operations = [];
        this.baseFee = opts.fee;
        this.timebounds = opts.timebounds ? _objectSpread({}, opts.timebounds) : null;
        this.ledgerbounds = opts.ledgerbounds ? _objectSpread({}, opts.ledgerbounds) : null;
        this.minAccountSequence = opts.minAccountSequence || null;
        this.minAccountSequenceAge = opts.minAccountSequenceAge || null;
        this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;
        this.extraSigners = opts.extraSigners ? _toConsumableArray(opts.extraSigners) : null;
        this.memo = opts.memo || _memo.Memo.none();
        this.networkPassphrase = opts.networkPassphrase || null;
        this.sorobanData = opts.sorobanData ? new _sorobandata_builder.SorobanDataBuilder(opts.sorobanData).build() : null;
      }
      return _createClass(TransactionBuilder3, [{
        key: "addOperation",
        value: (
          /**
           * Adds an operation to the transaction.
           *
           * @param {xdr.Operation} operation   The xdr operation object, use {@link
           *     Operation} static methods.
           *
           * @returns {TransactionBuilder}
           */
          function addOperation(operation) {
            this.operations.push(operation);
            return this;
          }
        )
        /**
         * Adds an operation to the transaction at a specific index.
         *
         * @param {xdr.Operation} operation - The xdr operation object to add, use {@link Operation} static methods.
         * @param {number} index - The index at which to insert the operation.
         *
         * @returns {TransactionBuilder} - The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "addOperationAt",
        value: function addOperationAt(operation, index) {
          this.operations.splice(index, 0, operation);
          return this;
        }
        /**
         * Removes the operations from the builder (useful when cloning).
         * @returns {TransactionBuilder} this builder instance
         */
      }, {
        key: "clearOperations",
        value: function clearOperations() {
          this.operations = [];
          return this;
        }
        /**
         * Removes the operation at the specified index from the transaction.
         *
         * @param {number} index - The index of the operation to remove.
         *
         * @returns {TransactionBuilder} The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "clearOperationAt",
        value: function clearOperationAt(index) {
          this.operations.splice(index, 1);
          return this;
        }
        /**
         * Adds a memo to the transaction.
         * @param {Memo} memo {@link Memo} object
         * @returns {TransactionBuilder}
         */
      }, {
        key: "addMemo",
        value: function addMemo(memo) {
          this.memo = memo;
          return this;
        }
        /**
         * Sets a timeout precondition on the transaction.
         *
         *  Because of the distributed nature of the Stellar network it is possible
         *  that the status of your transaction will be determined after a long time
         *  if the network is highly congested. If you want to be sure to receive the
         *  status of the transaction within a given period you should set the {@link
         *  TimeBounds} with `maxTime` on the transaction (this is what `setTimeout`
         *  does internally; if there's `minTime` set but no `maxTime` it will be
         *  added).
         *
         *  A call to `TransactionBuilder.setTimeout` is **required** if Transaction
         *  does not have `max_time` set. If you don't want to set timeout, use
         *  `{@link TimeoutInfinite}`. In general you should set `{@link
         *  TimeoutInfinite}` only in smart contracts.
         *
         *  Please note that Horizon may still return <code>504 Gateway Timeout</code>
         *  error, even for short timeouts. In such case you need to resubmit the same
         *  transaction again without making any changes to receive a status. This
         *  method is using the machine system time (UTC), make sure it is set
         *  correctly.
         *
         * @param {number} timeoutSeconds   Number of seconds the transaction is good.
         *     Can't be negative. If the value is {@link TimeoutInfinite}, the
         *     transaction is good indefinitely.
         *
         * @returns {TransactionBuilder}
         *
         * @see {@link TimeoutInfinite}
         * @see https://developers.stellar.org/docs/tutorials/handling-errors/
         */
      }, {
        key: "setTimeout",
        value: function setTimeout2(timeoutSeconds) {
          if (this.timebounds !== null && this.timebounds.maxTime > 0) {
            throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
          }
          if (timeoutSeconds < 0) {
            throw new Error("timeout cannot be negative");
          }
          if (timeoutSeconds > 0) {
            var timeoutTimestamp = Math.floor(Date.now() / 1e3) + timeoutSeconds;
            if (this.timebounds === null) {
              this.timebounds = {
                minTime: 0,
                maxTime: timeoutTimestamp
              };
            } else {
              this.timebounds = {
                minTime: this.timebounds.minTime,
                maxTime: timeoutTimestamp
              };
            }
          } else {
            this.timebounds = {
              minTime: 0,
              maxTime: 0
            };
          }
          return this;
        }
        /**
         * If you want to prepare a transaction which will become valid at some point
         * in the future, or be invalid after some time, you can set a timebounds
         * precondition. Internally this will set the `minTime`, and `maxTime`
         * preconditions. Conflicts with `setTimeout`, so use one or the other.
         *
         * @param {Date|number} minEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid after this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     immediately.
         * @param {Date|number} maxEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid until this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setTimebounds",
        value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {
          if (typeof minEpochOrDate === "number") {
            minEpochOrDate = new Date(minEpochOrDate * 1e3);
          }
          if (typeof maxEpochOrDate === "number") {
            maxEpochOrDate = new Date(maxEpochOrDate * 1e3);
          }
          if (this.timebounds !== null) {
            throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
          }
          var minTime = Math.floor(minEpochOrDate.valueOf() / 1e3);
          var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1e3);
          if (minTime < 0) {
            throw new Error("min_time cannot be negative");
          }
          if (maxTime < 0) {
            throw new Error("max_time cannot be negative");
          }
          if (maxTime > 0 && minTime > maxTime) {
            throw new Error("min_time cannot be greater than max_time");
          }
          this.timebounds = {
            minTime,
            maxTime
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will only be valid within some
         * range of ledgers, you can set a ledgerbounds precondition.
         * Internally this will set the `minLedger` and `maxLedger` preconditions.
         *
         * @param {number} minLedger  The minimum ledger this transaction is valid at
         *     or after. Cannot be negative. If the value is `0` (the default), the
         *     transaction is valid immediately.
         *
         * @param {number} maxLedger  The maximum ledger this transaction is valid
         *     before. Cannot be negative. If the value is `0`, the transaction is
         *     valid indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setLedgerbounds",
        value: function setLedgerbounds(minLedger, maxLedger) {
          if (this.ledgerbounds !== null) {
            throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
          }
          if (minLedger < 0) {
            throw new Error("min_ledger cannot be negative");
          }
          if (maxLedger < 0) {
            throw new Error("max_ledger cannot be negative");
          }
          if (maxLedger > 0 && minLedger > maxLedger) {
            throw new Error("min_ledger cannot be greater than max_ledger");
          }
          this.ledgerbounds = {
            minLedger,
            maxLedger
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will be valid only while the
         * account sequence number is
         *
         *     minAccountSequence <= sourceAccountSequence < tx.seqNum
         *
         * Note that after execution the account's sequence number is always raised to
         * `tx.seqNum`. Internally this will set the `minAccountSequence`
         * precondition.
         *
         * @param {string} minAccountSequence   The minimum source account sequence
         *     number this transaction is valid for. If the value is `0` (the
         *     default), the transaction is valid when `sourceAccount's sequence
         *     number == tx.seqNum- 1`.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequence",
        value: function setMinAccountSequence(minAccountSequence) {
          if (this.minAccountSequence !== null) {
            throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
          }
          this.minAccountSequence = minAccountSequence;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger time must be at least
         * `minAccountSequenceAge` greater than sourceAccount's `sequenceTime`.
         * Internally this will set the `minAccountSequenceAge` precondition.
         *
         * @param {number} durationInSeconds  The minimum amount of time between
         *     source account sequence time and the ledger time when this transaction
         *     will become valid. If the value is `0`, the transaction is unrestricted
         *     by the account sequence age. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceAge",
        value: function setMinAccountSequenceAge(durationInSeconds) {
          if (typeof durationInSeconds !== "number") {
            throw new Error("min_account_sequence_age must be a number");
          }
          if (this.minAccountSequenceAge !== null) {
            throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
          }
          if (durationInSeconds < 0) {
            throw new Error("min_account_sequence_age cannot be negative");
          }
          this.minAccountSequenceAge = durationInSeconds;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger number must be at least
         * `minAccountSequenceLedgerGap` greater than sourceAccount's ledger sequence.
         * Internally this will set the `minAccountSequenceLedgerGap` precondition.
         *
         * @param {number} gap  The minimum number of ledgers between source account
         *     sequence and the ledger number when this transaction will become valid.
         *     If the value is `0`, the transaction is unrestricted by the account
         *     sequence ledger. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceLedgerGap",
        value: function setMinAccountSequenceLedgerGap(gap) {
          if (this.minAccountSequenceLedgerGap !== null) {
            throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
          }
          if (gap < 0) {
            throw new Error("min_account_sequence_ledger_gap cannot be negative");
          }
          this.minAccountSequenceLedgerGap = gap;
          return this;
        }
        /**
         * For the transaction to be valid, there must be a signature corresponding to
         * every Signer in this array, even if the signature is not otherwise required
         * by the sourceAccount or operations. Internally this will set the
         * `extraSigners` precondition.
         *
         * @param {string[]} extraSigners   required extra signers (as {@link StrKey}s)
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setExtraSigners",
        value: function setExtraSigners(extraSigners) {
          if (!Array.isArray(extraSigners)) {
            throw new Error("extra_signers must be an array of strings.");
          }
          if (this.extraSigners !== null) {
            throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
          }
          if (extraSigners.length > 2) {
            throw new Error("extra_signers cannot be longer than 2 elements.");
          }
          this.extraSigners = _toConsumableArray(extraSigners);
          return this;
        }
        /**
         * Set network nassphrase for the Transaction that will be built.
         *
         * @param {string} networkPassphrase    passphrase of the target Stellar
         *     network (e.g. "Public Global Stellar Network ; September 2015").
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setNetworkPassphrase",
        value: function setNetworkPassphrase(networkPassphrase) {
          this.networkPassphrase = networkPassphrase;
          return this;
        }
        /**
         * Sets the transaction's internal Soroban transaction data (resources,
         * footprint, etc.).
         *
         * For non-contract(non-Soroban) transactions, this setting has no effect. In
         * the case of Soroban transactions, this is either an instance of
         * {@link xdr.SorobanTransactionData} or a base64-encoded string of said
         * structure. This is usually obtained from the simulation response based on a
         * transaction with a Soroban operation (e.g.
         * {@link Operation.invokeHostFunction}, providing necessary resource
         * and storage footprint estimations for contract invocation.
         *
         * @param {xdr.SorobanTransactionData | string} sorobanData    the
         *    {@link xdr.SorobanTransactionData} as a raw xdr object or a base64
         *    string to be decoded
         *
         * @returns {TransactionBuilder}
         * @see {SorobanDataBuilder}
         */
      }, {
        key: "setSorobanData",
        value: function setSorobanData(sorobanData) {
          this.sorobanData = new _sorobandata_builder.SorobanDataBuilder(sorobanData).build();
          return this;
        }
        /**
         * This will build the transaction.
         * It will also increment the source account's sequence number by 1.
         * @returns {Transaction} This method will return the built {@link Transaction}.
         */
      }, {
        key: "build",
        value: function build() {
          var sequenceNumber = new _bignumber["default"](this.source.sequenceNumber()).plus(1);
          var fee = new _bignumber["default"](this.baseFee).times(this.operations.length).toNumber();
          var attrs = {
            fee,
            seqNum: _xdr["default"].SequenceNumber.fromString(sequenceNumber.toString()),
            memo: this.memo ? this.memo.toXDRObject() : null
          };
          if (this.timebounds === null || typeof this.timebounds.minTime === "undefined" || typeof this.timebounds.maxTime === "undefined") {
            throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
          }
          if (isValidDate(this.timebounds.minTime)) {
            this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3;
          }
          if (isValidDate(this.timebounds.maxTime)) {
            this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3;
          }
          this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());
          this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
          var timeBounds = new _xdr["default"].TimeBounds(this.timebounds);
          if (this.hasV2Preconditions()) {
            var ledgerBounds = null;
            if (this.ledgerbounds !== null) {
              ledgerBounds = new _xdr["default"].LedgerBounds(this.ledgerbounds);
            }
            var minSeqNum = this.minAccountSequence || "0";
            minSeqNum = _xdr["default"].SequenceNumber.fromString(minSeqNum);
            var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0");
            var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;
            var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];
            attrs.cond = _xdr["default"].Preconditions.precondV2(new _xdr["default"].PreconditionsV2({
              timeBounds,
              ledgerBounds,
              minSeqNum,
              minSeqAge,
              minSeqLedgerGap,
              extraSigners
            }));
          } else {
            attrs.cond = _xdr["default"].Preconditions.precondTime(timeBounds);
          }
          attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());
          if (this.sorobanData) {
            attrs.ext = new _xdr["default"].TransactionExt(1, this.sorobanData);
          } else {
            attrs.ext = new _xdr["default"].TransactionExt(0, _xdr["default"].Void);
          }
          var xtx = new _xdr["default"].Transaction(attrs);
          xtx.operations(this.operations);
          var txEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
            tx: xtx
          }));
          var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);
          this.source.incrementSequenceNumber();
          return tx;
        }
      }, {
        key: "hasV2Preconditions",
        value: function hasV2Preconditions() {
          return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
        }
        /**
         * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing
         * transaction with a higher fee.
         *
         * @param {Keypair|string}  feeSource - account paying for the transaction,
         *     in the form of either a Keypair (only the public key is used) or
         *     an account ID (in G... or M... form, but refer to `withMuxing`)
         * @param {string}          baseFee   - max fee willing to pay per operation
         *     in inner transaction (**in stroops**)
         * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by
         *     the fee bump transaction
         * @param {string}          networkPassphrase - passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September 2015",
         *     see {@link Networks})
         *
         * @todo Alongside the next major version bump, this type signature can be
         *       changed to be less awkward: accept a MuxedAccount as the `feeSource`
         *       rather than a keypair or string.
         *
         * @note Your fee-bump amount should be >= 10x the original fee.
         * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee
         *
         * @returns {FeeBumpTransaction}
         */
      }], [{
        key: "cloneFrom",
        value: function cloneFrom(tx) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!(tx instanceof _transaction.Transaction)) {
            throw new TypeError("expected a 'Transaction', got: ".concat(tx));
          }
          var sequenceNum = (BigInt(tx.sequence) - 1n).toString();
          var source;
          if (_strkey.StrKey.isValidMed25519PublicKey(tx.source)) {
            source = _muxed_account.MuxedAccount.fromAddress(tx.source, sequenceNum);
          } else if (_strkey.StrKey.isValidEd25519PublicKey(tx.source)) {
            source = new _account.Account(tx.source, sequenceNum);
          } else {
            throw new TypeError("unsupported tx source account: ".concat(tx.source));
          }
          var unscaledFee = parseInt(tx.fee, 10) / tx.operations.length;
          var builder = new TransactionBuilder3(source, _objectSpread({
            fee: (unscaledFee || BASE_FEE).toString(),
            memo: tx.memo,
            networkPassphrase: tx.networkPassphrase,
            timebounds: tx.timeBounds,
            ledgerbounds: tx.ledgerBounds,
            minAccountSequence: tx.minAccountSequence,
            minAccountSequenceAge: tx.minAccountSequenceAge,
            minAccountSequenceLedgerGap: tx.minAccountSequenceLedgerGap,
            extraSigners: tx.extraSigners
          }, opts));
          tx._tx.operations().forEach(function(op) {
            return builder.addOperation(op);
          });
          return builder;
        }
      }, {
        key: "buildFeeBumpTransaction",
        value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {
          var innerOps = innerTx.operations.length;
          var innerBaseFeeRate = new _bignumber["default"](innerTx.fee).div(innerOps);
          var base = new _bignumber["default"](baseFee);
          if (base.lt(innerBaseFeeRate)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(innerBaseFeeRate, " stroops."));
          }
          var minBaseFee = new _bignumber["default"](BASE_FEE);
          if (base.lt(minBaseFee)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(minBaseFee, " stroops."));
          }
          var innerTxEnvelope = innerTx.toEnvelope();
          if (innerTxEnvelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            var v0Tx = innerTxEnvelope.v0().tx();
            var v1Tx = new _xdr["default"].Transaction({
              sourceAccount: new _xdr["default"].MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),
              fee: v0Tx.fee(),
              seqNum: v0Tx.seqNum(),
              cond: _xdr["default"].Preconditions.precondTime(v0Tx.timeBounds()),
              memo: v0Tx.memo(),
              operations: v0Tx.operations(),
              ext: new _xdr["default"].TransactionExt(0)
            });
            innerTxEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
              tx: v1Tx,
              signatures: innerTxEnvelope.v0().signatures()
            }));
          }
          var feeSourceAccount;
          if (typeof feeSource === "string") {
            feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);
          } else {
            feeSourceAccount = feeSource.xdrMuxedAccount();
          }
          var tx = new _xdr["default"].FeeBumpTransaction({
            feeSource: feeSourceAccount,
            fee: _xdr["default"].Int64.fromString(base.times(innerOps + 1).toString()),
            innerTx: _xdr["default"].FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),
            ext: new _xdr["default"].FeeBumpTransactionExt(0)
          });
          var feeBumpTxEnvelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx,
            signatures: []
          });
          var envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);
          return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
        }
        /**
         * Build a {@link Transaction} or {@link FeeBumpTransaction} from an
         * xdr.TransactionEnvelope.
         *
         * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope
         *     object or base64 encoded string.
         * @param {string} networkPassphrase - The network passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September
         *     2015"), see {@link Networks}.
         *
         * @returns {Transaction|FeeBumpTransaction}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(envelope, networkPassphrase) {
          if (typeof envelope === "string") {
            envelope = _xdr["default"].TransactionEnvelope.fromXDR(envelope, "base64");
          }
          if (envelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
            return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
          }
          return new _transaction.Transaction(envelope, networkPassphrase);
        }
      }]);
    }();
    function isValidDate(d) {
      return d instanceof Date && !isNaN(d);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/network.js
var require_network = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Networks = void 0;
    var Networks = exports.Networks = {
      PUBLIC: "Public Global Stellar Network ; September 2015",
      TESTNET: "Test SDF Network ; September 2015",
      FUTURENET: "Test SDF Future Network ; October 2022",
      SANDBOX: "Local Sandbox Stellar Network ; September 2022",
      STANDALONE: "Standalone Network ; February 2017"
    };
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/soroban.js
var require_soroban = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/soroban.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Soroban = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toArray(r) {
      return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Soroban = exports.Soroban = function() {
      function Soroban2() {
        _classCallCheck(this, Soroban2);
      }
      return _createClass(Soroban2, null, [{
        key: "formatTokenAmount",
        value: (
          /**
           * Given a whole number smart contract amount of a token and an amount of
           * decimal places (if the token has any), it returns a "display" value.
           *
           * All arithmetic inside the contract is performed on integers to avoid
           * potential precision and consistency issues of floating-point.
           *
           * @param {string} amount   the token amount you want to display
           * @param {number} decimals specify how many decimal places a token has
           *
           * @returns {string} the display value
           * @throws {TypeError} if the given amount has a decimal point already
           * @example
           * formatTokenAmount("123000", 4) === "12.3";
           */
          function formatTokenAmount(amount, decimals) {
            if (amount.includes(".")) {
              throw new TypeError("No decimals are allowed");
            }
            var formatted = amount;
            if (decimals > 0) {
              if (decimals > formatted.length) {
                formatted = ["0", formatted.toString().padStart(decimals, "0")].join(".");
              } else {
                formatted = [formatted.slice(0, -decimals), formatted.slice(-decimals)].join(".");
              }
            }
            return formatted.replace(/(\.\d*?)0+$/, "$1");
          }
        )
        /**
         * Parse a token amount to use it on smart contract
         *
         * This function takes the display value and its decimals (if the token has
         * any) and returns a string that'll be used within the smart contract.
         *
         * @param {string} value      the token amount you want to use it on smart
         *    contract which you've been displaying in a UI
         * @param {number} decimals   the number of decimal places expected in the
         *    display value (different than the "actual" number, because suffix zeroes
         *    might not be present)
         *
         * @returns {string}  the whole number token amount represented by the display
         *    value with the decimal places shifted over
         *
         * @example
         * const displayValueAmount = "123.4560"
         * const parsedAmtForSmartContract = parseTokenAmount(displayValueAmount, 5);
         * parsedAmtForSmartContract === "12345600"
         */
      }, {
        key: "parseTokenAmount",
        value: function parseTokenAmount(value, decimals) {
          var _fraction$padEnd;
          var _value$split$slice = value.split(".").slice(), _value$split$slice2 = _toArray(_value$split$slice), whole = _value$split$slice2[0], fraction = _value$split$slice2[1], rest = _value$split$slice2.slice(2);
          if (rest.length) {
            throw new Error("Invalid decimal value: ".concat(value));
          }
          var shifted = BigInt(whole + ((_fraction$padEnd = fraction === null || fraction === void 0 ? void 0 : fraction.padEnd(decimals, "0")) !== null && _fraction$padEnd !== void 0 ? _fraction$padEnd : "0".repeat(decimals)));
          return shifted.toString();
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/contract.js
var require_contract = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Contract = void 0;
    var _address = require_address();
    var _operation = require_operation();
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Contract = exports.Contract = function() {
      function Contract2(contractId) {
        _classCallCheck(this, Contract2);
        try {
          this._id = _strkey.StrKey.decodeContract(contractId);
        } catch (_) {
          throw new Error("Invalid contract ID: ".concat(contractId));
        }
      }
      return _createClass(Contract2, [{
        key: "contractId",
        value: function contractId() {
          return _strkey.StrKey.encodeContract(this._id);
        }
        /** @returns {string} the ID as a strkey (C...) */
      }, {
        key: "toString",
        value: function toString() {
          return this.contractId();
        }
        /** @returns {Address} the wrapped address of this contract */
      }, {
        key: "address",
        value: function address() {
          return _address.Address.contract(this._id);
        }
        /**
         * Returns an operation that will invoke this contract call.
         *
         * @param {string}        method   name of the method to call
         * @param {...xdr.ScVal}  params   arguments to pass to the function call
         *
         * @returns {xdr.Operation}   an InvokeHostFunctionOp operation to call the
         *    contract with the given method and parameters
         *
         * @see Operation.invokeHostFunction
         * @see Operation.invokeContractFunction
         * @see Operation.createCustomContract
         * @see Operation.createStellarAssetContract
         * @see Operation.uploadContractWasm
         */
      }, {
        key: "call",
        value: function call(method) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          return _operation.Operation.invokeContractFunction({
            contract: this.address().toString(),
            "function": method,
            args: params
          });
        }
        /**
         * Returns the read-only footprint entries necessary for any invocations to
         * this contract, for convenience when manually adding it to your
         * transaction's overall footprint or doing bump/restore operations.
         *
         * @returns {xdr.LedgerKey} the ledger key for the deployed contract instance
         */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
            contract: this.address().toScAddress(),
            key: _xdr["default"].ScVal.scvLedgerKeyContractInstance(),
            durability: _xdr["default"].ContractDataDurability.persistent()
          }));
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint128.js
var require_uint128 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint128.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint128 = exports.Uint128 = function(_LargeInt) {
      function Uint1282() {
        _classCallCheck(this, Uint1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint1282, [args]);
      }
      _inherits(Uint1282, _LargeInt);
      return _createClass(Uint1282, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint128.defineIntBoundaries();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint256.js
var require_uint256 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint256.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint256 = exports.Uint256 = function(_LargeInt) {
      function Uint2562() {
        _classCallCheck(this, Uint2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint2562, [args]);
      }
      _inherits(Uint2562, _LargeInt);
      return _createClass(Uint2562, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint256.defineIntBoundaries();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/int128.js
var require_int128 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/int128.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int128 = exports.Int128 = function(_LargeInt) {
      function Int1282() {
        _classCallCheck(this, Int1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int1282, [args]);
      }
      _inherits(Int1282, _LargeInt);
      return _createClass(Int1282, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int128.defineIntBoundaries();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/int256.js
var require_int256 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/int256.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int256 = exports.Int256 = function(_LargeInt) {
      function Int2562() {
        _classCallCheck(this, Int2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int2562, [args]);
      }
      _inherits(Int2562, _LargeInt);
      return _createClass(Int2562, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int256.defineIntBoundaries();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js
var require_xdr_large_int = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.XdrLargeInt = void 0;
    var _jsXdr = require_xdr();
    var _uint = require_uint128();
    var _uint2 = require_uint256();
    var _int = require_int128();
    var _int2 = require_int256();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var XdrLargeInt = exports.XdrLargeInt = function() {
      function XdrLargeInt2(type, values) {
        _classCallCheck(this, XdrLargeInt2);
        _defineProperty(this, "int", void 0);
        _defineProperty(this, "type", void 0);
        if (!(values instanceof Array)) {
          values = [values];
        }
        values = values.map(function(i) {
          if (typeof i === "bigint") {
            return i;
          }
          if (i instanceof XdrLargeInt2) {
            return i.toBigInt();
          }
          return BigInt(i);
        });
        switch (type) {
          case "i64":
            this["int"] = new _jsXdr.Hyper(values);
            break;
          case "i128":
            this["int"] = new _int.Int128(values);
            break;
          case "i256":
            this["int"] = new _int2.Int256(values);
            break;
          case "u64":
            this["int"] = new _jsXdr.UnsignedHyper(values);
            break;
          case "u128":
            this["int"] = new _uint.Uint128(values);
            break;
          case "u256":
            this["int"] = new _uint2.Uint256(values);
            break;
          default:
            throw TypeError("invalid type: ".concat(type));
        }
        this.type = type;
      }
      return _createClass(XdrLargeInt2, [{
        key: "toNumber",
        value: function toNumber() {
          var bi = this["int"].toBigInt();
          if (bi > Number.MAX_SAFE_INTEGER || bi < Number.MIN_SAFE_INTEGER) {
            throw RangeError("value ".concat(bi, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
          }
          return Number(bi);
        }
        /** @returns {bigint} */
      }, {
        key: "toBigInt",
        value: function toBigInt() {
          return this["int"].toBigInt();
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I64` */
      }, {
        key: "toI64",
        value: function toI64() {
          this._sizeCheck(64);
          var v = this.toBigInt();
          if (BigInt.asIntN(64, v) !== v) {
            throw RangeError("value too large for i64: ".concat(v));
          }
          return _xdr["default"].ScVal.scvI64(new _xdr["default"].Int64(v));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U64` */
      }, {
        key: "toU64",
        value: function toU64() {
          this._sizeCheck(64);
          return _xdr["default"].ScVal.scvU64(
            new _xdr["default"].Uint64(BigInt.asUintN(64, this.toBigInt()))
            // reiterpret as unsigned
          );
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = I128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toI128",
        value: function toI128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          var hi64 = BigInt.asIntN(64, v >> 64n);
          var lo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI128(new _xdr["default"].Int128Parts({
            hi: new _xdr["default"].Int64(hi64),
            lo: new _xdr["default"].Uint64(lo64)
          }));
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = U128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toU128",
        value: function toU128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          return _xdr["default"].ScVal.scvU128(new _xdr["default"].UInt128Parts({
            hi: new _xdr["default"].Uint64(BigInt.asUintN(64, v >> 64n)),
            lo: new _xdr["default"].Uint64(BigInt.asUintN(64, v))
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I256` */
      }, {
        key: "toI256",
        value: function toI256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asIntN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI256(new _xdr["default"].Int256Parts({
            hiHi: new _xdr["default"].Int64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U256` */
      }, {
        key: "toU256",
        value: function toU256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asUintN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvU256(new _xdr["default"].UInt256Parts({
            hiHi: new _xdr["default"].Uint64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the smallest interpretation of the stored value */
      }, {
        key: "toScVal",
        value: function toScVal() {
          switch (this.type) {
            case "i64":
              return this.toI64();
            case "i128":
              return this.toI128();
            case "i256":
              return this.toI256();
            case "u64":
              return this.toU64();
            case "u128":
              return this.toU128();
            case "u256":
              return this.toU256();
            default:
              throw TypeError("invalid type: ".concat(this.type));
          }
        }
      }, {
        key: "valueOf",
        value: function valueOf() {
          return this["int"].valueOf();
        }
      }, {
        key: "toString",
        value: function toString() {
          return this["int"].toString();
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            value: this.toBigInt().toString(),
            type: this.type
          };
        }
      }, {
        key: "_sizeCheck",
        value: function _sizeCheck(bits) {
          if (this["int"].size > bits) {
            throw RangeError("value too large for ".concat(bits, " bits (").concat(this.type, ")"));
          }
        }
      }], [{
        key: "isType",
        value: function isType(type) {
          switch (type) {
            case "i64":
            case "i128":
            case "i256":
            case "u64":
            case "u128":
            case "u256":
              return true;
            default:
              return false;
          }
        }
        /**
         * Convert the raw `ScValType` string (e.g. 'scvI128', generated by the XDR)
         * to a type description for {@link XdrLargeInt} construction (e.g. 'i128')
         *
         * @param {string} scvType  the `xdr.ScValType` as a string
         * @returns {string} a suitable equivalent type to construct this object
         */
      }, {
        key: "getType",
        value: function getType(scvType) {
          return scvType.slice(3).toLowerCase();
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js
var require_sc_int = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScInt = void 0;
    var _xdr_large_int = require_xdr_large_int();
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var ScInt = exports.ScInt = function(_XdrLargeInt) {
      function ScInt2(value, opts) {
        var _opts$type;
        _classCallCheck(this, ScInt2);
        var signed = value < 0;
        var type = (_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "";
        if (type.startsWith("u") && signed) {
          throw TypeError("specified type ".concat(opts.type, " yet negative (").concat(value, ")"));
        }
        if (type === "") {
          type = signed ? "i" : "u";
          var bitlen = nearestBigIntSize(value);
          switch (bitlen) {
            case 64:
            case 128:
            case 256:
              type += bitlen.toString();
              break;
            default:
              throw RangeError("expected 64/128/256 bits for input (".concat(value, "), got ").concat(bitlen));
          }
        }
        return _callSuper(this, ScInt2, [type, value]);
      }
      _inherits(ScInt2, _XdrLargeInt);
      return _createClass(ScInt2);
    }(_xdr_large_int.XdrLargeInt);
    function nearestBigIntSize(bigI) {
      var _find;
      var bitlen = bigI.toString(2).length;
      return (_find = [64, 128, 256].find(function(len) {
        return bitlen <= len;
      })) !== null && _find !== void 0 ? _find : bitlen;
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/index.js
var require_numbers = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/numbers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Int128", {
      enumerable: true,
      get: function get() {
        return _int.Int128;
      }
    });
    Object.defineProperty(exports, "Int256", {
      enumerable: true,
      get: function get() {
        return _int2.Int256;
      }
    });
    Object.defineProperty(exports, "ScInt", {
      enumerable: true,
      get: function get() {
        return _sc_int.ScInt;
      }
    });
    Object.defineProperty(exports, "Uint128", {
      enumerable: true,
      get: function get() {
        return _uint.Uint128;
      }
    });
    Object.defineProperty(exports, "Uint256", {
      enumerable: true,
      get: function get() {
        return _uint2.Uint256;
      }
    });
    Object.defineProperty(exports, "XdrLargeInt", {
      enumerable: true,
      get: function get() {
        return _xdr_large_int.XdrLargeInt;
      }
    });
    exports.scValToBigInt = scValToBigInt;
    var _xdr_large_int = require_xdr_large_int();
    var _uint = require_uint128();
    var _uint2 = require_uint256();
    var _int = require_int128();
    var _int2 = require_int256();
    var _sc_int = require_sc_int();
    function scValToBigInt(scv) {
      var scIntType = _xdr_large_int.XdrLargeInt.getType(scv["switch"]().name);
      switch (scv["switch"]().name) {
        case "scvU32":
        case "scvI32":
          return BigInt(scv.value());
        case "scvU64":
        case "scvI64":
          return new _xdr_large_int.XdrLargeInt(scIntType, scv.value()).toBigInt();
        case "scvU128":
        case "scvI128":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().lo(), scv.value().hi()]).toBigInt();
        case "scvU256":
        case "scvI256":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().loLo(), scv.value().loHi(), scv.value().hiLo(), scv.value().hiHi()]).toBigInt();
        default:
          throw TypeError("expected integer type, got ".concat(scv["switch"]()));
      }
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/scval.js
var require_scval = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/scval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nativeToScVal = nativeToScVal;
    exports.scValToNative = scValToNative;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _address = require_address();
    var _contract = require_contract();
    var _index = require_numbers();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function nativeToScVal(val) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      switch (_typeof(val)) {
        case "object": {
          var _val$constructor$name, _val$constructor;
          if (val === null) {
            return _xdr["default"].ScVal.scvVoid();
          }
          if (val instanceof _xdr["default"].ScVal) {
            return val;
          }
          if (val instanceof _address.Address) {
            return val.toScVal();
          }
          if (val instanceof _keypair.Keypair) {
            return nativeToScVal(val.publicKey(), {
              type: "address"
            });
          }
          if (val instanceof _contract.Contract) {
            return val.address().toScVal();
          }
          if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
            var _opts$type;
            var copy = Uint8Array.from(val);
            switch ((_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "bytes") {
              case "bytes":
                return _xdr["default"].ScVal.scvBytes(copy);
              case "symbol":
                return _xdr["default"].ScVal.scvSymbol(copy);
              case "string":
                return _xdr["default"].ScVal.scvString(copy);
              default:
                throw new TypeError("invalid type (".concat(opts.type, ") specified for bytes-like value"));
            }
          }
          if (Array.isArray(val)) {
            return _xdr["default"].ScVal.scvVec(val.map(function(v) {
              return nativeToScVal(v, opts);
            }));
          }
          if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
            var _val$constructor2;
            throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
          }
          return _xdr["default"].ScVal.scvMap(Object.entries(val).sort(function(_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
            var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
            return key1.localeCompare(key2);
          }).map(function(_ref5) {
            var _k, _opts$type2;
            var _ref6 = _slicedToArray(_ref5, 2), k = _ref6[0], v = _ref6[1];
            var _ref7 = (_k = ((_opts$type2 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type2 !== void 0 ? _opts$type2 : {})[k]) !== null && _k !== void 0 ? _k : [null, null], _ref8 = _slicedToArray(_ref7, 2), keyType = _ref8[0], valType = _ref8[1];
            var keyOpts = keyType ? {
              type: keyType
            } : {};
            var valOpts = valType ? {
              type: valType
            } : {};
            return new _xdr["default"].ScMapEntry({
              key: nativeToScVal(k, keyOpts),
              val: nativeToScVal(v, valOpts)
            });
          }));
        }
        case "number":
        case "bigint":
          switch (opts === null || opts === void 0 ? void 0 : opts.type) {
            case "u32":
              return _xdr["default"].ScVal.scvU32(val);
            case "i32":
              return _xdr["default"].ScVal.scvI32(val);
            default:
              break;
          }
          return new _index.ScInt(val, {
            type: opts === null || opts === void 0 ? void 0 : opts.type
          }).toScVal();
        case "string": {
          var _opts$type3;
          var optType = (_opts$type3 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type3 !== void 0 ? _opts$type3 : "string";
          switch (optType) {
            case "string":
              return _xdr["default"].ScVal.scvString(val);
            case "symbol":
              return _xdr["default"].ScVal.scvSymbol(val);
            case "address":
              return new _address.Address(val).toScVal();
            case "u32":
              return _xdr["default"].ScVal.scvU32(parseInt(val, 10));
            case "i32":
              return _xdr["default"].ScVal.scvI32(parseInt(val, 10));
            default:
              if (_index.XdrLargeInt.isType(optType)) {
                return new _index.XdrLargeInt(optType, val).toScVal();
              }
              throw new TypeError("invalid type (".concat(opts.type, ") specified for string value"));
          }
        }
        case "boolean":
          return _xdr["default"].ScVal.scvBool(val);
        case "undefined":
          return _xdr["default"].ScVal.scvVoid();
        case "function":
          return nativeToScVal(val());
        default:
          throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
      }
    }
    function scValToNative(scv) {
      var _scv$vec, _scv$map;
      switch (scv["switch"]().value) {
        case _xdr["default"].ScValType.scvVoid().value:
          return null;
        case _xdr["default"].ScValType.scvU64().value:
        case _xdr["default"].ScValType.scvI64().value:
          return scv.value().toBigInt();
        case _xdr["default"].ScValType.scvU128().value:
        case _xdr["default"].ScValType.scvI128().value:
        case _xdr["default"].ScValType.scvU256().value:
        case _xdr["default"].ScValType.scvI256().value:
          return (0, _index.scValToBigInt)(scv);
        case _xdr["default"].ScValType.scvVec().value:
          return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(scValToNative);
        case _xdr["default"].ScValType.scvAddress().value:
          return _address.Address.fromScVal(scv).toString();
        case _xdr["default"].ScValType.scvMap().value:
          return Object.fromEntries(((_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : []).map(function(entry) {
            return [scValToNative(entry.key()), scValToNative(entry.val())];
          }));
        case _xdr["default"].ScValType.scvBool().value:
        case _xdr["default"].ScValType.scvU32().value:
        case _xdr["default"].ScValType.scvI32().value:
        case _xdr["default"].ScValType.scvBytes().value:
          return scv.value();
        case _xdr["default"].ScValType.scvSymbol().value:
        case _xdr["default"].ScValType.scvString().value: {
          var v = scv.value();
          if (Buffer.isBuffer(v) || ArrayBuffer.isView(v)) {
            try {
              return new TextDecoder().decode(v);
            } catch (e) {
              return new Uint8Array(v.buffer);
            }
          }
          return v;
        }
        case _xdr["default"].ScValType.scvTimepoint().value:
        case _xdr["default"].ScValType.scvDuration().value:
          return new _xdr["default"].Uint64(scv.value()).toBigInt();
        case _xdr["default"].ScValType.scvError().value:
          switch (scv.error()["switch"]().value) {
            case _xdr["default"].ScErrorType.sceContract().value:
              return {
                type: "contract",
                code: scv.error().contractCode()
              };
            default: {
              var err = scv.error();
              return {
                type: "system",
                code: err.code().value,
                value: err.code().name
              };
            }
          }
        default:
          return scv.value();
      }
    }
    _xdr["default"].scvSortedMap = function(items) {
      var sorted = Array.from(items).sort(function(a, b) {
        var nativeA = scValToNative(a.key());
        var nativeB = scValToNative(b.key());
        switch (_typeof(nativeA)) {
          case "number":
          case "bigint":
            return nativeA < nativeB ? -1 : 1;
          default:
            return nativeA.toString().localeCompare(nativeB.toString());
        }
      });
      return _xdr["default"].ScVal.scvMap(sorted);
    };
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/events.js
var require_events = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.humanizeEvents = humanizeEvents;
    var _strkey = require_strkey();
    var _scval = require_scval();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function humanizeEvents(events) {
      return events.map(function(e) {
        if (e.inSuccessfulContractCall) {
          return extractEvent(e.event());
        }
        return extractEvent(e);
      });
    }
    function extractEvent(event) {
      return _objectSpread(_objectSpread({}, typeof event.contractId === "function" && event.contractId() != null && {
        contractId: _strkey.StrKey.encodeContract(event.contractId())
      }), {}, {
        type: event.type().name,
        topics: event.body().value().topics().map(function(t) {
          return (0, _scval.scValToNative)(t);
        }),
        data: (0, _scval.scValToNative)(event.body().value().data())
      });
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/auth.js
var require_auth = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.authorizeEntry = authorizeEntry;
    exports.authorizeInvocation = authorizeInvocation;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    var _network = require_network();
    var _hashing = require_hashing();
    var _address = require_address();
    var _scval = require_scval();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, "catch": function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function authorizeEntry(_x, _x2, _x3) {
      return _authorizeEntry.apply(this, arguments);
    }
    function _authorizeEntry() {
      _authorizeEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(entry, signer, validUntilLedgerSeq) {
        var networkPassphrase, clone, addrAuth, networkId, preimage, payload, signature, publicKey, sigResult, sigScVal, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              networkPassphrase = _args.length > 3 && _args[3] !== void 0 ? _args[3] : _network.Networks.FUTURENET;
              if (!(entry.credentials()["switch"]().value !== _xdr["default"].SorobanCredentialsType.sorobanCredentialsAddress().value)) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", entry);
            case 3:
              clone = _xdr["default"].SorobanAuthorizationEntry.fromXDR(entry.toXDR());
              addrAuth = clone.credentials().address();
              addrAuth.signatureExpirationLedger(validUntilLedgerSeq);
              networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
              preimage = _xdr["default"].HashIdPreimage.envelopeTypeSorobanAuthorization(new _xdr["default"].HashIdPreimageSorobanAuthorization({
                networkId,
                nonce: addrAuth.nonce(),
                invocation: clone.rootInvocation(),
                signatureExpirationLedger: addrAuth.signatureExpirationLedger()
              }));
              payload = (0, _hashing.hash)(preimage.toXDR());
              if (!(typeof signer === "function")) {
                _context.next = 16;
                break;
              }
              _context.next = 12;
              return signer(preimage);
            case 12:
              sigResult = _context.sent;
              if (sigResult !== null && sigResult !== void 0 && sigResult.signature) {
                signature = Buffer.from(sigResult.signature);
                publicKey = sigResult.publicKey;
              } else {
                signature = Buffer.from(sigResult);
                publicKey = _address.Address.fromScAddress(addrAuth.address()).toString();
              }
              _context.next = 18;
              break;
            case 16:
              signature = Buffer.from(signer.sign(payload));
              publicKey = signer.publicKey();
            case 18:
              if (_keypair.Keypair.fromPublicKey(publicKey).verify(payload, signature)) {
                _context.next = 20;
                break;
              }
              throw new Error("signature doesn't match payload");
            case 20:
              sigScVal = (0, _scval.nativeToScVal)({
                public_key: _strkey.StrKey.decodeEd25519PublicKey(publicKey),
                signature
              }, {
                type: {
                  public_key: ["symbol", null],
                  signature: ["symbol", null]
                }
              });
              addrAuth.signature(_xdr["default"].ScVal.scvVec([sigScVal]));
              return _context.abrupt("return", clone);
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _authorizeEntry.apply(this, arguments);
    }
    function authorizeInvocation(signer, validUntilLedgerSeq, invocation) {
      var publicKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var networkPassphrase = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : _network.Networks.FUTURENET;
      var kp = _keypair.Keypair.random().rawPublicKey();
      var nonce = new _xdr["default"].Int64(bytesToInt64(kp));
      var pk = publicKey || signer.publicKey();
      if (!pk) {
        throw new Error("authorizeInvocation requires publicKey parameter");
      }
      var entry = new _xdr["default"].SorobanAuthorizationEntry({
        rootInvocation: invocation,
        credentials: _xdr["default"].SorobanCredentials.sorobanCredentialsAddress(new _xdr["default"].SorobanAddressCredentials({
          address: new _address.Address(pk).toScAddress(),
          nonce,
          signatureExpirationLedger: 0,
          // replaced
          signature: _xdr["default"].ScVal.scvVec([])
          // replaced
        }))
      });
      return authorizeEntry(entry, signer, validUntilLedgerSeq, networkPassphrase);
    }
    function bytesToInt64(bytes) {
      return bytes.subarray(0, 8).reduce(function(accum, b) {
        return accum << 8 | b;
      }, 0);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/invocation.js
var require_invocation = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/invocation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildInvocationTree = buildInvocationTree;
    exports.walkInvocationTree = walkInvocationTree;
    var _asset = require_asset();
    var _address = require_address();
    var _scval = require_scval();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function buildInvocationTree(root) {
      var fn = root["function"]();
      var output = {};
      var inner = fn.value();
      switch (fn["switch"]().value) {
        case 0:
          output.type = "execute";
          output.args = {
            source: _address.Address.fromScAddress(inner.contractAddress()).toString(),
            "function": inner.functionName(),
            args: inner.args().map(function(arg) {
              return (0, _scval.scValToNative)(arg);
            })
          };
          break;
        case 1:
        case 2: {
          var createV2 = fn["switch"]().value === 2;
          output.type = "create";
          output.args = {};
          var _ref = [inner.executable(), inner.contractIdPreimage()], exec = _ref[0], preimage = _ref[1];
          if (!!exec["switch"]().value !== !!preimage["switch"]().value) {
            throw new Error("creation function appears invalid: ".concat(JSON.stringify(inner), " (should be wasm+address or token+asset)"));
          }
          switch (exec["switch"]().value) {
            case 0: {
              var details = preimage.fromAddress();
              output.args.type = "wasm";
              output.args.wasm = _objectSpread({
                salt: details.salt().toString("hex"),
                hash: exec.wasmHash().toString("hex"),
                address: _address.Address.fromScAddress(details.address()).toString()
              }, createV2 && {
                constructorArgs: inner.constructorArgs().map(function(arg) {
                  return (0, _scval.scValToNative)(arg);
                })
              });
              break;
            }
            case 1:
              output.args.type = "sac";
              output.args.asset = _asset.Asset.fromOperation(preimage.fromAsset()).toString();
              break;
            default:
              throw new Error("unknown creation type: ".concat(JSON.stringify(exec)));
          }
          break;
        }
        default:
          throw new Error("unknown invocation type (".concat(fn["switch"](), "): ").concat(JSON.stringify(fn)));
      }
      output.invocations = root.subInvocations().map(function(i) {
        return buildInvocationTree(i);
      });
      return output;
    }
    function walkInvocationTree(root, callback) {
      walkHelper(root, 1, callback);
    }
    function walkHelper(node, depth, callback, parent) {
      if (callback(node, depth, parent) === false) {
        return;
      }
      node.subInvocations().forEach(function(i) {
        return walkHelper(i, depth + 1, callback, node);
      });
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/index.js
var require_lib = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-base/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      xdr: true,
      cereal: true,
      hash: true,
      sign: true,
      verify: true,
      FastSigning: true,
      getLiquidityPoolId: true,
      LiquidityPoolFeeV18: true,
      Keypair: true,
      UnsignedHyper: true,
      Hyper: true,
      TransactionBase: true,
      Transaction: true,
      FeeBumpTransaction: true,
      TransactionBuilder: true,
      TimeoutInfinite: true,
      BASE_FEE: true,
      Asset: true,
      LiquidityPoolAsset: true,
      LiquidityPoolId: true,
      Operation: true,
      AuthRequiredFlag: true,
      AuthRevocableFlag: true,
      AuthImmutableFlag: true,
      AuthClawbackEnabledFlag: true,
      Account: true,
      MuxedAccount: true,
      Claimant: true,
      Networks: true,
      StrKey: true,
      SignerKey: true,
      Soroban: true,
      decodeAddressToMuxedAccount: true,
      encodeMuxedAccountToAddress: true,
      extractBaseAddress: true,
      encodeMuxedAccount: true,
      Contract: true,
      Address: true
    };
    Object.defineProperty(exports, "Account", {
      enumerable: true,
      get: function get() {
        return _account.Account;
      }
    });
    Object.defineProperty(exports, "Address", {
      enumerable: true,
      get: function get() {
        return _address.Address;
      }
    });
    Object.defineProperty(exports, "Asset", {
      enumerable: true,
      get: function get() {
        return _asset.Asset;
      }
    });
    Object.defineProperty(exports, "AuthClawbackEnabledFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthClawbackEnabledFlag;
      }
    });
    Object.defineProperty(exports, "AuthImmutableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthImmutableFlag;
      }
    });
    Object.defineProperty(exports, "AuthRequiredFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRequiredFlag;
      }
    });
    Object.defineProperty(exports, "AuthRevocableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRevocableFlag;
      }
    });
    Object.defineProperty(exports, "BASE_FEE", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.BASE_FEE;
      }
    });
    Object.defineProperty(exports, "Claimant", {
      enumerable: true,
      get: function get() {
        return _claimant.Claimant;
      }
    });
    Object.defineProperty(exports, "Contract", {
      enumerable: true,
      get: function get() {
        return _contract.Contract;
      }
    });
    Object.defineProperty(exports, "FastSigning", {
      enumerable: true,
      get: function get() {
        return _signing.FastSigning;
      }
    });
    Object.defineProperty(exports, "FeeBumpTransaction", {
      enumerable: true,
      get: function get() {
        return _fee_bump_transaction.FeeBumpTransaction;
      }
    });
    Object.defineProperty(exports, "Hyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.Hyper;
      }
    });
    Object.defineProperty(exports, "Keypair", {
      enumerable: true,
      get: function get() {
        return _keypair.Keypair;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolAsset", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_asset.LiquidityPoolAsset;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolFeeV18", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.LiquidityPoolFeeV18;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_id.LiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "MuxedAccount", {
      enumerable: true,
      get: function get() {
        return _muxed_account.MuxedAccount;
      }
    });
    Object.defineProperty(exports, "Networks", {
      enumerable: true,
      get: function get() {
        return _network.Networks;
      }
    });
    Object.defineProperty(exports, "Operation", {
      enumerable: true,
      get: function get() {
        return _operation.Operation;
      }
    });
    Object.defineProperty(exports, "SignerKey", {
      enumerable: true,
      get: function get() {
        return _signerkey.SignerKey;
      }
    });
    Object.defineProperty(exports, "Soroban", {
      enumerable: true,
      get: function get() {
        return _soroban.Soroban;
      }
    });
    Object.defineProperty(exports, "StrKey", {
      enumerable: true,
      get: function get() {
        return _strkey.StrKey;
      }
    });
    Object.defineProperty(exports, "TimeoutInfinite", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TimeoutInfinite;
      }
    });
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function get() {
        return _transaction.Transaction;
      }
    });
    Object.defineProperty(exports, "TransactionBase", {
      enumerable: true,
      get: function get() {
        return _transaction_base.TransactionBase;
      }
    });
    Object.defineProperty(exports, "TransactionBuilder", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TransactionBuilder;
      }
    });
    Object.defineProperty(exports, "UnsignedHyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.UnsignedHyper;
      }
    });
    Object.defineProperty(exports, "cereal", {
      enumerable: true,
      get: function get() {
        return _jsxdr["default"];
      }
    });
    Object.defineProperty(exports, "decodeAddressToMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.decodeAddressToMuxedAccount;
      }
    });
    exports["default"] = void 0;
    Object.defineProperty(exports, "encodeMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccount;
      }
    });
    Object.defineProperty(exports, "encodeMuxedAccountToAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccountToAddress;
      }
    });
    Object.defineProperty(exports, "extractBaseAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.extractBaseAddress;
      }
    });
    Object.defineProperty(exports, "getLiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.getLiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "hash", {
      enumerable: true,
      get: function get() {
        return _hashing.hash;
      }
    });
    Object.defineProperty(exports, "sign", {
      enumerable: true,
      get: function get() {
        return _signing.sign;
      }
    });
    Object.defineProperty(exports, "verify", {
      enumerable: true,
      get: function get() {
        return _signing.verify;
      }
    });
    Object.defineProperty(exports, "xdr", {
      enumerable: true,
      get: function get() {
        return _xdr["default"];
      }
    });
    var _xdr = _interopRequireDefault(require_xdr2());
    var _jsxdr = _interopRequireDefault(require_jsxdr());
    var _hashing = require_hashing();
    var _signing = require_signing();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id();
    var _keypair = require_keypair();
    var _jsXdr = require_xdr();
    var _transaction_base = require_transaction_base();
    var _transaction = require_transaction();
    var _fee_bump_transaction = require_fee_bump_transaction();
    var _transaction_builder = require_transaction_builder();
    var _asset = require_asset();
    var _liquidity_pool_asset = require_liquidity_pool_asset();
    var _liquidity_pool_id = require_liquidity_pool_id();
    var _operation = require_operation();
    var _memo = require_memo();
    Object.keys(_memo).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _memo[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _memo[key];
        }
      });
    });
    var _account = require_account();
    var _muxed_account = require_muxed_account();
    var _claimant = require_claimant();
    var _network = require_network();
    var _strkey = require_strkey();
    var _signerkey = require_signerkey();
    var _soroban = require_soroban();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    var _contract = require_contract();
    var _address = require_address();
    var _numbers = require_numbers();
    Object.keys(_numbers).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _numbers[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _numbers[key];
        }
      });
    });
    var _scval = require_scval();
    Object.keys(_scval).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _scval[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _scval[key];
        }
      });
    });
    var _events = require_events();
    Object.keys(_events).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _events[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _events[key];
        }
      });
    });
    var _sorobandata_builder = require_sorobandata_builder();
    Object.keys(_sorobandata_builder).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _sorobandata_builder[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sorobandata_builder[key];
        }
      });
    });
    var _auth = require_auth();
    Object.keys(_auth).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _auth[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _auth[key];
        }
      });
    });
    var _invocation = require_invocation();
    Object.keys(_invocation).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _invocation[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _invocation[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = module.exports;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/api.js
var require_api = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Api = void 0;
    var Api;
    (function(_Api) {
      var GetTransactionStatus = function(GetTransactionStatus2) {
        GetTransactionStatus2["SUCCESS"] = "SUCCESS";
        GetTransactionStatus2["NOT_FOUND"] = "NOT_FOUND";
        GetTransactionStatus2["FAILED"] = "FAILED";
        return GetTransactionStatus2;
      }({});
      _Api.GetTransactionStatus = GetTransactionStatus;
      function isSimulationError(sim) {
        return "error" in sim;
      }
      _Api.isSimulationError = isSimulationError;
      function isSimulationSuccess(sim) {
        return "transactionData" in sim;
      }
      _Api.isSimulationSuccess = isSimulationSuccess;
      function isSimulationRestore(sim) {
        return isSimulationSuccess(sim) && "restorePreamble" in sim && !!sim.restorePreamble.transactionData;
      }
      _Api.isSimulationRestore = isSimulationRestore;
      function isSimulationRaw(sim) {
        return !sim._parsed;
      }
      _Api.isSimulationRaw = isSimulationRaw;
    })(Api || (exports.Api = Api = {}));
  }
});

// node_modules/urijs/src/punycode.js
var require_punycode = __commonJS({
  "node_modules/urijs/src/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/urijs/src/IPv6.js
var require_IPv6 = __commonJS({
  "node_modules/urijs/src/IPv6.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.IPv6 = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i = 0; i < total; i++) {
          _segments = segments[i].split("");
          for (var j = 0; j < 3; j++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i = 0; i < total; i++) {
          if (inzeroes) {
            if (segments[i] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i] === "0") {
              inzeroes = true;
              current = i;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i = 0; i < length; i++) {
          result += segments[i];
          if (i === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  }
});

// node_modules/urijs/src/SecondLevelDomains.js
var require_SecondLevelDomains = __commonJS({
  "node_modules/urijs/src/SecondLevelDomains.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  }
});

// node_modules/urijs/src/URI.js
var require_URI = __commonJS({
  "node_modules/urijs/src/URI.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
      } else if (typeof define === "function" && define.amd) {
        define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(exports, function(punycode, IPv6, SLD, root) {
      "use strict";
      var _URI = root && root.URI;
      function URI(url, base) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI(url, base);
            }
            return new URI(url);
          }
          return new URI();
        }
        if (url === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url = location.href + "";
          } else {
            url = "";
          }
        }
        if (url === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url);
        if (base !== void 0) {
          return this.absoluteTo(base);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI.version = "1.19.11";
      var p = URI.prototype;
      var hasOwn = Object.prototype.hasOwnProperty;
      function escapeRegEx(string) {
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray(obj) {
        return getType(obj) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup = {};
        var i, length;
        if (getType(value) === "RegExp") {
          lookup = null;
        } else if (isArray(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            lookup[value[i]] = true;
          }
        } else {
          lookup[value] = true;
        }
        for (i = 0, length = data.length; i < length; i++) {
          var _match = lookup && lookup[data[i]] !== void 0 || !lookup && value.test(data[i]);
          if (_match) {
            data.splice(i, 1);
            length--;
            i--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i, length;
        if (isArray(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            if (!arrayContains(list, value[i])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i = 0, length = list.length; i < length; i++) {
          if (_type === "RegExp") {
            if (typeof list[i] === "string" && list[i].match(value)) {
              return true;
            }
          } else if (list[i] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray(one) || !isArray(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i = 0, l = one.length; i < l; i++) {
          if (one[i] !== two[i]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: URI.preventInvalidHostname,
          duplicateQueryParameters: URI.duplicateQueryParameters,
          escapeQuerySpace: URI.escapeQuerySpace
        };
      };
      URI.preventInvalidHostname = false;
      URI.duplicateQueryParameters = false;
      URI.escapeQuerySpace = true;
      URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI.idn_expression = /[^a-z0-9\._-]/i;
      URI.punycode_expression = /(xn--)/i;
      URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
      URI.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI.hostProtocols = [
        "http",
        "https"
      ];
      URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        // but only if type="image"
        "audio": "src",
        "video": "src"
      };
      URI.getDomAttribute = function(node) {
        if (!node || !node.nodeName) {
          return void 0;
        }
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "input" && node.type !== "image") {
          return void 0;
        }
        return URI.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string) {
        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
      URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
      };
      URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
      };
      URI.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI.encodeQuery = function(string, escapeQuerySpace) {
        var escaped = URI.encode(string + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI.decodeQuery = function(string, escapeQuerySpace) {
        string += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        try {
          return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
        } catch (e) {
          return string;
        }
      };
      var _parts = { "encode": "encode", "decode": "decode" };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string) {
          try {
            return URI[_part2](string + "").replace(URI.characters[_group][_part2].expression, function(c) {
              return URI.characters[_group][_part2].map[c];
            });
          } catch (e) {
            return string;
          }
        };
      };
      for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI[_codingFuncName];
          } else {
            actualCodingFunc = function(string2) {
              return URI[_codingFuncName](URI[_innerCodingFuncName](string2));
            };
          }
          var segments = (string + "").split(_sep);
          for (var i = 0, length = segments.length; i < length; i++) {
            segments[i] = actualCodingFunc(segments[i]);
          }
          return segments.join(_sep);
        };
      };
      URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI.encodeReserved = generateAccessor("reserved", "encode");
      URI.parse = function(string, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI.preventInvalidHostname
          };
        }
        string = string.replace(URI.leading_whitespace_expression, "");
        string = string.replace(URI.ascii_tab_whitespace, "");
        pos = string.indexOf("#");
        if (pos > -1) {
          parts.fragment = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        pos = string.indexOf("?");
        if (pos > -1) {
          parts.query = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string = string.replace(/^[/\\]{2,}/i, "//");
        if (string.substring(0, 2) === "//") {
          parts.protocol = null;
          string = string.substring(2);
          string = URI.parseAuthority(string, parts);
        } else {
          pos = string.indexOf(":");
          if (pos > -1) {
            parts.protocol = string.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string = string.substring(pos + 3);
              string = URI.parseAuthority(string, parts);
            } else {
              string = string.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string;
        return parts;
      };
      URI.parseHost = function(string, parts) {
        if (!string) {
          string = "";
        }
        string = string.replace(/\\/g, "/");
        var pos = string.indexOf("/");
        var bracketPos;
        var t;
        if (pos === -1) {
          pos = string.length;
        }
        if (string.charAt(0) === "[") {
          bracketPos = string.indexOf("]");
          parts.hostname = string.substring(1, bracketPos) || null;
          parts.port = string.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string.indexOf(":");
          var firstSlash = string.indexOf("/");
          var nextColon = string.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string.substring(0, pos) || null;
            parts.port = null;
          } else {
            t = string.substring(0, pos).split(":");
            parts.hostname = t[0] || null;
            parts.port = t[1] || null;
          }
        }
        if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
          pos++;
          string = "/" + string;
        }
        if (parts.preventInvalidHostname) {
          URI.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI.ensureValidPort(parts.port);
        }
        return string.substring(pos) || "/";
      };
      URI.parseAuthority = function(string, parts) {
        string = URI.parseUserinfo(string, parts);
        return URI.parseHost(string, parts);
      };
      URI.parseUserinfo = function(string, parts) {
        var _string = string;
        var firstBackSlash = string.indexOf("\\");
        if (firstBackSlash !== -1) {
          string = string.replace(/\\/g, "/");
        }
        var firstSlash = string.indexOf("/");
        var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
        var t;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t = string.substring(0, pos).split(":");
          parts.username = t[0] ? URI.decode(t[0]) : null;
          t.shift();
          parts.password = t[0] ? URI.decode(t.join(":")) : null;
          string = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string;
      };
      URI.parseQuery = function(string, escapeQuerySpace) {
        if (!string) {
          return {};
        }
        string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string) {
          return {};
        }
        var items = {};
        var splits = string.split("&");
        var length = splits.length;
        var v, name, value;
        for (var i = 0; i < length; i++) {
          v = splits[i].split("=");
          name = URI.decodeQuery(v.shift(), escapeQuerySpace);
          value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [items[name]];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI.build = function(parts) {
        var t = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t += parts.protocol + ":";
        }
        if (!parts.urn && (t || parts.hostname)) {
          t += "//";
          requireAbsolutePath = true;
        }
        t += URI.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t += "/";
          }
          t += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t += "#" + parts.fragment;
        }
        return t;
      };
      URI.buildHost = function(parts) {
        var t = "";
        if (!parts.hostname) {
          return "";
        } else if (URI.ip6_expression.test(parts.hostname)) {
          t += "[" + parts.hostname + "]";
        } else {
          t += parts.hostname;
        }
        if (parts.port) {
          t += ":" + parts.port;
        }
        return t;
      };
      URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
      };
      URI.buildUserinfo = function(parts) {
        var t = "";
        if (parts.username) {
          t += URI.encode(parts.username);
        }
        if (parts.password) {
          t += ":" + URI.encode(parts.password);
        }
        if (t) {
          t += "@";
        }
        return t;
      };
      URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t = "";
        var unique, key, i, length;
        for (key in data) {
          if (key === "__proto__") {
            continue;
          } else if (hasOwn.call(data, key)) {
            if (isArray(data[key])) {
              unique = {};
              for (i = 0, length = data[key].length; i < length; i++) {
                if (data[key][i] !== void 0 && unique[data[key][i] + ""] === void 0) {
                  t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key][i] + ""] = true;
                  }
                }
              }
            } else if (data[key] !== void 0) {
              t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            }
          }
        }
        return t.substring(1);
      };
      URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.addQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
          }
          if (!isArray(value)) {
            value = [value];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.setQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI.removeQuery = function(data, name, value) {
        var i, length, key;
        if (isArray(name)) {
          for (i = 0, length = name.length; i < length; i++) {
            data[name[i]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key in data) {
            if (name.test(key)) {
              data[key] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key in name) {
            if (hasOwn.call(name, key)) {
              URI.removeQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key in data) {
              if (hasOwn.call(data, key)) {
                if (name.test(key) && (value === void 0 || URI.hasQuery(data, key, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn.call(name, _key)) {
                if (!URI.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          case "Boolean":
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          case "String":
            if (!isArray(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i = 0; i < arguments.length; i++) {
          var url = new URI(arguments[i]);
          input.push(url);
          var _segments = url.segment();
          for (var s = 0; s < _segments.length; s++) {
            if (typeof _segments[s] === "string") {
              segments.push(_segments[s]);
            }
            if (_segments[s]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI("");
        }
        var uri = new URI("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri.path("/" + uri.path());
        }
        return uri.normalize();
      };
      URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI.withinString = function(string, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start;
        var _end = options.end || URI.findUri.end;
        var _trim = options.trim || URI.findUri.trim;
        var _parens = options.parens || URI.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match = _start.exec(string);
          if (!match) {
            break;
          }
          var start = match.index;
          if (options.ignoreHtml) {
            var attributeOpen = string.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string.slice(start).search(_end);
          var slice = string.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
          } else {
            slice = slice.replace(_trim, "");
          }
          if (slice.length <= match[0].length) {
            continue;
          }
          if (options.ignore && options.ignore.test(slice)) {
            continue;
          }
          end = start + slice.length;
          var result = callback(slice, start, end, string);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string = string.slice(0, start) + result + string.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string;
      };
      URI.ensureValidHostname = function(v, protocol) {
        var hasHostname = !!v;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v && v.match(URI.invalid_hostname_characters)) {
          if (!punycode) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI.ensureValidPort = function(v) {
        if (!v) {
          return;
        }
        var port = Number(v);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v + '" is not a valid port');
      };
      URI.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p.clone = function() {
        return new URI(this);
      };
      p.valueOf = p.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v || null;
            this.build(!build);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v !== null) {
              v = v + "";
              if (v.charAt(0) === _key) {
                v = v.substring(1);
              }
            }
            this._parts[_part2] = v;
            this.build(!build);
            return this;
          }
        };
      }
      p.protocol = generateSimpleAccessor("protocol");
      p.username = generateSimpleAccessor("username");
      p.password = generateSimpleAccessor("password");
      p.hostname = generateSimpleAccessor("hostname");
      p.port = generateSimpleAccessor("port");
      p.query = generatePrefixAccessor("query", "?");
      p.fragment = generatePrefixAccessor("fragment", "#");
      p.search = function(v, build) {
        var t = this.query(v, build);
        return typeof t === "string" && t.length ? "?" + t : t;
      };
      p.hash = function(v, build) {
        var t = this.fragment(v, build);
        return typeof t === "string" && t.length ? "#" + t : t;
      };
      p.pathname = function(v, build) {
        if (v === void 0 || v === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v ? URI.recodeUrnPath(v) : "";
          } else {
            this._parts.path = v ? URI.recodePath(v) : "/";
          }
          this.build(!build);
          return this;
        }
      };
      p.path = p.pathname;
      p.href = function(href, build) {
        var key;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI._parts();
        var _URI2 = href instanceof URI;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key in src) {
            if (key === "query") {
              continue;
            }
            if (hasOwn.call(this._parts, key)) {
              this._parts[key] = src[key];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build);
        return this;
      };
      p.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode2 = false;
        var relative = !this._parts.urn;
        if (this._parts.hostname) {
          relative = false;
          ip4 = URI.ip4_expression.test(this._parts.hostname);
          ip6 = URI.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI.idn_expression.test(this._parts.hostname);
          punycode2 = name && URI.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative;
          case "absolute":
            return !relative;
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode2;
        }
        return null;
      };
      var _protocol = p.protocol;
      var _port = p.port;
      var _hostname = p.hostname;
      p.protocol = function(v, build) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, "");
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v, build);
      };
      p.scheme = p.protocol;
      p.port = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          if (v === 0) {
            v = null;
          }
          if (v) {
            v += "";
            if (v.charAt(0) === ":") {
              v = v.substring(1);
            }
            URI.ensureValidPort(v);
          }
        }
        return _port.call(this, v, build);
      };
      p.hostname = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
          var res = URI.parseHost(v, x);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          v = x.hostname;
          if (this._parts.preventInvalidHostname) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
        }
        return _hostname.call(this, v, build);
      };
      p.origin = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI(v);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
          return this;
        }
      };
      p.host = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
          var res = URI.parseHost(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.authority = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
          var res = URI.parseAuthority(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.userinfo = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var t = URI.buildUserinfo(this._parts);
          return t ? t.substring(0, t.length - 1) : t;
        } else {
          if (v[v.length - 1] !== "@") {
            v += "@";
          }
          URI.parseUserinfo(v, this._parts);
          this.build(!build);
          return this;
        }
      };
      p.resource = function(v, build) {
        var parts;
        if (v === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI.parse(v);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build);
        return this;
      };
      p.subdomain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v && v.charAt(v.length - 1) !== ".") {
            v += ".";
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.domain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t = this._parts.hostname.match(/\./g);
          if (t && t.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v) {
            throw new TypeError("cannot set domain empty");
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI.ensureValidHostname(v, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.tld = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v) {
            throw new TypeError("cannot set TLD empty");
          } else if (v.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v);
            } else {
              throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.directory = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v ? URI.decodePath(res) : res;
        } else {
          var e = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v) {
              v = "/";
            }
            if (v.charAt(0) !== "/") {
              v = "/" + v;
            }
          }
          if (v && v.charAt(v.length - 1) !== "/") {
            v += "/";
          }
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.filename = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v ? URI.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v.charAt(0) === "/") {
            v = v.substring(1);
          }
          if (v.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          if (mutatedDirectory) {
            this.normalizePath(build);
          } else {
            this.build(!build);
          }
          return this;
        }
      };
      p.suffix = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s, res;
          if (pos === -1) {
            return "";
          }
          s = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s) ? s : "";
          return v ? URI.decodePathSegment(res) : res;
        } else {
          if (v.charAt(0) === ".") {
            v = v.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v) {
              return this;
            }
            this._parts.path += "." + URI.recodePath(v);
          } else if (!v) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ":" : "/";
        var path = this.path();
        var absolute = path.substring(0, 1) === "/";
        var segments = path.split(separator);
        if (segment !== void 0 && typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray(v)) {
            segments = [];
            for (var i = 0, l = v.length; i < l; i++) {
              if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v[i]));
            }
          } else if (v || typeof v === "string") {
            v = trimSlashes(v);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v;
            } else {
              segments.push(v);
            }
          }
        } else {
          if (v) {
            segments[segment] = trimSlashes(v);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator), build);
      };
      p.segmentCoded = function(segment, v, build) {
        var segments, i, l;
        if (typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (v === void 0) {
          segments = this.segment(segment, v, build);
          if (!isArray(segments)) {
            segments = segments !== void 0 ? URI.decode(segments) : void 0;
          } else {
            for (i = 0, l = segments.length; i < l; i++) {
              segments[i] = URI.decode(segments[i]);
            }
          }
          return segments;
        }
        if (!isArray(v)) {
          v = typeof v === "string" || v instanceof String ? URI.encode(v) : v;
        } else {
          for (i = 0, l = v.length; i < l; i++) {
            v[i] = URI.encode(v[i]);
          }
        }
        return this.segment(segment, v, build);
      };
      var q = p.query;
      p.query = function(v, build) {
        if (v === true) {
          return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v === "function") {
          var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v.call(this, data);
          this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else if (v !== void 0 && typeof v !== "string") {
          this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else {
          return q.call(this, v, build);
        }
      };
      p.setQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              data[key] = name[key];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
      };
      p.setSearch = p.setQuery;
      p.addSearch = p.addQuery;
      p.removeSearch = p.removeQuery;
      p.hasSearch = p.hasQuery;
      p.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizePort = function(build) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI.recodeUrnPath(this._parts.path);
          this.build(!build);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build);
        return this;
      };
      p.normalizePathname = p.normalizePath;
      p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build);
        }
        return this;
      };
      p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizeSearch = p.normalizeQuery;
      p.normalizeHash = p.normalizeFragment;
      p.iso8859 = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = escape;
        URI.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.unicode = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t = "";
        if (uri._parts.protocol) {
          t += uri._parts.protocol + "://";
        }
        if (uri._parts.hostname) {
          if (uri.is("punycode") && punycode) {
            t += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
              t += ":" + uri._parts.port;
            }
          } else {
            t += uri.host();
          }
        }
        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
          t += "/";
        }
        t += uri.path(true);
        if (uri._parts.query) {
          var q2 = "";
          for (var i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
            var kv = (qp[i] || "").split("=");
            q2 += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q2 += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t += "?" + q2.substring(1);
        }
        t += URI.decodeQuery(uri.hash(), true);
        return t;
      };
      p.absoluteTo = function(base) {
        var resolved = this.clone();
        var properties = ["protocol", "username", "password", "hostname", "port"];
        var basedir, i, p2;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base instanceof URI)) {
          base = new URI(base);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i = 0; p2 = properties[i]; i++) {
          resolved._parts[p2] = base._parts[p2];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base.directory();
            basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p.relativeTo = function(base) {
        var relative = this.clone().normalize();
        var relativeParts, baseParts, common, relativePath, basePath;
        if (relative._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base = new URI(base).normalize();
        relativeParts = relative._parts;
        baseParts = base._parts;
        relativePath = relative.path();
        basePath = base.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative.build();
        }
        common = URI.commonPath(relativePath, basePath);
        if (!common) {
          return relative.build();
        }
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
        return relative.build();
      };
      p.equals = function(uri) {
        var one = this.clone();
        var two = new URI(uri);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) {
          if (hasOwn.call(one_map, key)) {
            if (!isArray(one_map[key])) {
              if (one_map[key] !== two_map[key]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
              return false;
            }
            checked[key] = true;
          }
        }
        for (key in two_map) {
          if (hasOwn.call(two_map, key)) {
            if (!checked[key]) {
              return false;
            }
          }
        }
        return true;
      };
      p.preventInvalidHostname = function(v) {
        this._parts.preventInvalidHostname = !!v;
        return this;
      };
      p.duplicateQueryParameters = function(v) {
        this._parts.duplicateQueryParameters = !!v;
        return this;
      };
      p.escapeQuerySpace = function(v) {
        this._parts.escapeQuerySpace = !!v;
        return this;
      };
      return URI;
    });
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/types.js
var require_types = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CancelToken = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var CancelToken = exports.CancelToken = function() {
      function CancelToken2(executor) {
        var _this = this;
        _classCallCheck(this, CancelToken2);
        var resolvePromise;
        this.promise = new Promise(function(resolve) {
          resolvePromise = resolve;
        });
        executor(function(reason) {
          _this.reason = reason;
          resolvePromise();
        });
      }
      return _createClass(CancelToken2, [{
        key: "throwIfRequested",
        value: function throwIfRequested() {
          if (this.reason) {
            throw new Error(this.reason);
          }
        }
      }]);
    }();
  }
});

// node_modules/feaxios/dist/index.js
var require_dist = __commonJS({
  "node_modules/feaxios/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function prepareAxiosResponse(options, res) {
      const response = { config: options };
      response.status = res.status;
      response.statusText = res.statusText;
      response.headers = res.headers;
      if (options.responseType === "stream") {
        response.data = res.body;
        return response;
      }
      return res[options.responseType || "text"]().then((data) => {
        if (options.transformResponse) {
          Array.isArray(options.transformResponse) ? options.transformResponse.map(
            (fn) => data = fn.call(options, data, res == null ? void 0 : res.headers, res == null ? void 0 : res.status)
          ) : data = options.transformResponse(data, res == null ? void 0 : res.headers, res == null ? void 0 : res.status);
          response.data = data;
        } else {
          response.data = data;
          response.data = JSON.parse(data);
        }
      }).catch(Object).then(() => response);
    }
    async function handleFetch(options, fetchOptions) {
      let res = null;
      if ("any" in AbortSignal) {
        const signals = [];
        if (options.timeout) {
          signals.push(AbortSignal.timeout(options.timeout));
        }
        if (options.signal) {
          signals.push(options.signal);
        }
        if (signals.length > 0) {
          fetchOptions.signal = AbortSignal.any(signals);
        }
      } else {
        if (options.timeout) {
          fetchOptions.signal = AbortSignal.timeout(options.timeout);
        }
      }
      try {
        res = await fetch(options.url, fetchOptions);
        const ok = options.validateStatus ? options.validateStatus(res.status) : res.ok;
        if (!ok) {
          return Promise.reject(
            new AxiosError(
              `Request failed with status code ${res == null ? void 0 : res.status}`,
              [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor((res == null ? void 0 : res.status) / 100) - 4],
              options,
              new Request(options.url, fetchOptions),
              await prepareAxiosResponse(options, res)
            )
          );
        }
        return await prepareAxiosResponse(options, res);
      } catch (error) {
        if (error.name === "AbortError" || error.name === "TimeoutError") {
          const isTimeoutError = error.name === "TimeoutError";
          return Promise.reject(
            isTimeoutError ? new AxiosError(
              options.timeoutErrorMessage || `timeout of ${options.timeout} ms exceeded`,
              AxiosError.ECONNABORTED,
              options,
              request
            ) : new CanceledError(null, options)
          );
        }
        return Promise.reject(
          new AxiosError(
            error.message,
            void 0,
            options,
            request,
            void 0
          )
        );
      }
    }
    function buildURL(options) {
      let url = options.url || "";
      if (options.baseURL && options.url) {
        url = options.url.replace(/^(?!.*\/\/)\/?/, `${options.baseURL}/`);
      }
      if (options.params && Object.keys(options.params).length > 0 && options.url) {
        url += (~options.url.indexOf("?") ? "&" : "?") + (options.paramsSerializer ? options.paramsSerializer(options.params) : new URLSearchParams(options.params));
      }
      return url;
    }
    function mergeAxiosOptions(input, defaults) {
      const merged = {
        ...defaults,
        ...input
      };
      if ((defaults == null ? void 0 : defaults.params) && (input == null ? void 0 : input.params)) {
        merged.params = {
          ...defaults == null ? void 0 : defaults.params,
          ...input == null ? void 0 : input.params
        };
      }
      if ((defaults == null ? void 0 : defaults.headers) && (input == null ? void 0 : input.headers)) {
        merged.headers = new Headers(defaults.headers || {});
        const headers = new Headers(input.headers || {});
        headers.forEach((value, key) => {
          merged.headers.set(key, value);
        });
      }
      return merged;
    }
    function mergeFetchOptions(input, defaults) {
      const merged = {
        ...defaults,
        ...input
      };
      if ((defaults == null ? void 0 : defaults.headers) && (input == null ? void 0 : input.headers)) {
        merged.headers = new Headers(defaults.headers || {});
        const headers = new Headers(input.headers || {});
        headers.forEach((value, key) => {
          merged.headers.set(key, value);
        });
      }
      return merged;
    }
    function defaultTransformer(data, headers) {
      const contentType = headers.get("content-type");
      if (!contentType) {
        if (typeof data === "string") {
          headers.set("content-type", "text/plain");
        } else if (data instanceof URLSearchParams) {
          headers.set("content-type", "application/x-www-form-urlencoded");
        } else if (data instanceof Blob || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
          headers.set("content-type", "application/octet-stream");
        } else if (typeof data === "object" && typeof data.append !== "function" && typeof data.text !== "function") {
          data = JSON.stringify(data);
          headers.set("content-type", "application/json");
        }
      } else {
        if (contentType === "application/x-www-form-urlencoded" && !(data instanceof URLSearchParams)) {
          data = new URLSearchParams(data);
        } else if (contentType === "application/json" && typeof data === "object") {
          data = JSON.stringify(data);
        }
      }
      return data;
    }
    async function request(configOrUrl, config, defaults, method, interceptors, data) {
      var _a2;
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else
        config = configOrUrl || {};
      const options = mergeAxiosOptions(config, defaults || {});
      options.fetchOptions = options.fetchOptions || {};
      options.timeout = options.timeout || 0;
      options.headers = new Headers(options.headers || {});
      options.transformRequest = options.transformRequest ?? defaultTransformer;
      data = data || options.data;
      if (options.transformRequest && data) {
        Array.isArray(options.transformRequest) ? options.transformRequest.map(
          (fn) => data = fn.call(options, data, options.headers)
        ) : data = options.transformRequest(data, options.headers);
      }
      options.url = buildURL(options);
      options.method = method || options.method || "get";
      if (interceptors && interceptors.request.handlers.length > 0) {
        const chain = interceptors.request.handlers.filter(
          (interceptor) => !(interceptor == null ? void 0 : interceptor.runWhen) || typeof interceptor.runWhen === "function" && interceptor.runWhen(options)
        ).flatMap((interceptor) => [interceptor.fulfilled, interceptor.rejected]);
        let result = options;
        for (let i = 0, len = chain.length; i < len; i += 2) {
          const onFulfilled = chain[i];
          const onRejected = chain[i + 1];
          try {
            if (onFulfilled)
              result = onFulfilled(result);
          } catch (error) {
            if (onRejected)
              onRejected == null ? void 0 : onRejected(error);
            break;
          }
        }
      }
      const init = mergeFetchOptions(
        {
          method: (_a2 = options.method) == null ? void 0 : _a2.toUpperCase(),
          body: data,
          headers: options.headers,
          credentials: options.withCredentials ? "include" : void 0,
          signal: options.signal
        },
        options.fetchOptions
      );
      let resp = handleFetch(options, init);
      if (interceptors && interceptors.response.handlers.length > 0) {
        const chain = interceptors.response.handlers.flatMap((interceptor) => [
          interceptor.fulfilled,
          interceptor.rejected
        ]);
        for (let i = 0, len = chain.length; i < len; i += 2) {
          resp = resp.then(chain[i], chain[i + 1]);
        }
      }
      return resp;
    }
    var AxiosInterceptorManager = class {
      constructor() {
        __publicField(this, "handlers", []);
        __publicField(this, "use", (onFulfilled, onRejected, options) => {
          this.handlers.push({
            fulfilled: onFulfilled,
            rejected: onRejected,
            runWhen: options == null ? void 0 : options.runWhen
          });
          return this.handlers.length - 1;
        });
        __publicField(this, "eject", (id) => {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        });
        __publicField(this, "clear", () => {
          this.handlers = [];
        });
        this.handlers = [];
      }
    };
    function createAxiosInstance(defaults) {
      defaults = defaults || {};
      const interceptors = {
        request: new AxiosInterceptorManager(),
        response: new AxiosInterceptorManager()
      };
      const axios2 = (url, config) => request(url, config, defaults, void 0, interceptors);
      axios2.defaults = defaults;
      axios2.interceptors = interceptors;
      axios2.getUri = (config) => {
        const merged = mergeAxiosOptions(config || {}, defaults);
        return buildURL(merged);
      };
      axios2.request = (config) => request(config, void 0, defaults, void 0, interceptors);
      ["get", "delete", "head", "options"].forEach((method) => {
        axios2[method] = (url, config) => request(url, config, defaults, method, interceptors);
      });
      ["post", "put", "patch"].forEach((method) => {
        axios2[method] = (url, data, config) => request(url, config, defaults, method, interceptors, data);
      });
      ["postForm", "putForm", "patchForm"].forEach((method) => {
        axios2[method] = (url, data, config) => {
          config = config || {};
          config.headers = new Headers(config.headers || {});
          config.headers.set("content-type", "application/x-www-form-urlencoded");
          return request(
            url,
            config,
            defaults,
            method.replace("Form", ""),
            interceptors,
            data
          );
        };
      });
      return axios2;
    }
    var _a;
    var AxiosError = (_a = class extends Error {
      constructor(message, code, config, request2, response) {
        super(message);
        __publicField(this, "config");
        __publicField(this, "code");
        __publicField(this, "request");
        __publicField(this, "response");
        __publicField(this, "status");
        __publicField(this, "isAxiosError");
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack;
        }
        this.name = "AxiosError";
        this.code = code;
        this.config = config;
        this.request = request2;
        this.response = response;
        this.isAxiosError = true;
      }
    }, __publicField(_a, "ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION_VALUE"), __publicField(_a, "ERR_BAD_OPTION", "ERR_BAD_OPTION"), __publicField(_a, "ERR_NETWORK", "ERR_NETWORK"), __publicField(_a, "ERR_BAD_RESPONSE", "ERR_BAD_RESPONSE"), __publicField(_a, "ERR_BAD_REQUEST", "ERR_BAD_REQUEST"), __publicField(_a, "ERR_INVALID_URL", "ERR_INVALID_URL"), __publicField(_a, "ERR_CANCELED", "ERR_CANCELED"), __publicField(_a, "ECONNABORTED", "ECONNABORTED"), __publicField(_a, "ETIMEDOUT", "ETIMEDOUT"), _a);
    var CanceledError = class extends AxiosError {
      constructor(message, config, request2) {
        super(
          !message ? "canceled" : message,
          AxiosError.ERR_CANCELED,
          config,
          request2
        );
        this.name = "CanceledError";
      }
    };
    function isAxiosError(payload) {
      return payload !== null && typeof payload === "object" && payload.isAxiosError;
    }
    var axios = createAxiosInstance();
    axios.create = (defaults) => createAxiosInstance(defaults);
    var src_default = axios;
    exports.AxiosError = AxiosError;
    exports.CanceledError = CanceledError;
    exports.default = src_default;
    exports.isAxiosError = isAxiosError;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/fetch-client.js
var require_fetch_client = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/fetch-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.create = createFetchClient;
    exports.fetchClient = void 0;
    var _feaxios = _interopRequireDefault(require_dist());
    var _types = require_types();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var InterceptorManager = function() {
      function InterceptorManager2() {
        _classCallCheck(this, InterceptorManager2);
        _defineProperty(this, "handlers", []);
      }
      return _createClass(InterceptorManager2, [{
        key: "use",
        value: function use(fulfilled, rejected) {
          this.handlers.push({
            fulfilled,
            rejected
          });
          return this.handlers.length - 1;
        }
      }, {
        key: "eject",
        value: function eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          this.handlers.forEach(function(h) {
            if (h !== null) {
              fn(h);
            }
          });
        }
      }]);
    }();
    function getFormConfig(config) {
      var formConfig = config || {};
      formConfig.headers = new Headers(formConfig.headers || {});
      formConfig.headers.set("Content-Type", "application/x-www-form-urlencoded");
      return formConfig;
    }
    function createFetchClient() {
      var fetchConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = _objectSpread(_objectSpread({}, fetchConfig), {}, {
        headers: fetchConfig.headers || {}
      });
      var instance = _feaxios.default.create(defaults);
      var requestInterceptors = new InterceptorManager();
      var responseInterceptors = new InterceptorManager();
      var httpClient = {
        interceptors: {
          request: requestInterceptors,
          response: responseInterceptors
        },
        defaults: _objectSpread(_objectSpread({}, defaults), {}, {
          adapter: function adapter(config) {
            return instance.request(config);
          }
        }),
        create: function create(config) {
          return createFetchClient(_objectSpread(_objectSpread({}, this.defaults), config));
        },
        makeRequest: function makeRequest(config) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var abortController = new AbortController();
            config.signal = abortController.signal;
            if (config.cancelToken) {
              config.cancelToken.promise.then(function() {
                abortController.abort();
                reject(new Error("Request canceled"));
              });
            }
            var modifiedConfig = config;
            if (requestInterceptors.handlers.length > 0) {
              var chain = requestInterceptors.handlers.filter(function(interceptor) {
                return interceptor !== null;
              }).flatMap(function(interceptor) {
                return [interceptor.fulfilled, interceptor.rejected];
              });
              for (var i = 0, len = chain.length; i < len; i += 2) {
                var onFulfilled = chain[i];
                var onRejected = chain[i + 1];
                try {
                  if (onFulfilled) modifiedConfig = onFulfilled(modifiedConfig);
                } catch (error) {
                  if (onRejected) onRejected === null || onRejected === void 0 || onRejected(error);
                  reject(error);
                  return;
                }
              }
            }
            var adapter = modifiedConfig.adapter || _this.defaults.adapter;
            if (!adapter) {
              throw new Error("No adapter available");
            }
            var responsePromise = adapter(modifiedConfig).then(function(axiosResponse) {
              var httpClientResponse = {
                data: axiosResponse.data,
                headers: axiosResponse.headers,
                config: axiosResponse.config,
                status: axiosResponse.status,
                statusText: axiosResponse.statusText
              };
              return httpClientResponse;
            });
            if (responseInterceptors.handlers.length > 0) {
              var _chain = responseInterceptors.handlers.filter(function(interceptor) {
                return interceptor !== null;
              }).flatMap(function(interceptor) {
                return [interceptor.fulfilled, interceptor.rejected];
              });
              var _loop = function _loop2(_i2) {
                responsePromise = responsePromise.then(function(response) {
                  var fulfilledInterceptor = _chain[_i2];
                  if (typeof fulfilledInterceptor === "function") {
                    return fulfilledInterceptor(response);
                  }
                  return response;
                }, function(error) {
                  var rejectedInterceptor = _chain[_i2 + 1];
                  if (typeof rejectedInterceptor === "function") {
                    return rejectedInterceptor(error);
                  }
                  throw error;
                }).then(function(interceptedResponse) {
                  return interceptedResponse;
                });
              };
              for (var _i = 0, _len = _chain.length; _i < _len; _i += 2) {
                _loop(_i);
              }
            }
            responsePromise.then(resolve).catch(reject);
          });
        },
        get: function get(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "get"
          }));
        },
        delete: function _delete(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "delete"
          }));
        },
        head: function head(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "head"
          }));
        },
        options: function options(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "options"
          }));
        },
        post: function post(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "post",
            data
          }));
        },
        put: function put(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "put",
            data
          }));
        },
        patch: function patch(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "patch",
            data
          }));
        },
        postForm: function postForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "post",
            data
          }));
        },
        putForm: function putForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "put",
            data
          }));
        },
        patchForm: function patchForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "patch",
            data
          }));
        },
        CancelToken: _types.CancelToken,
        isCancel: function isCancel(value) {
          return value instanceof Error && value.message === "Request canceled";
        }
      };
      return httpClient;
    }
    var fetchClient = exports.fetchClient = createFetchClient();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/index.js
var require_http_client = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      httpClient: true,
      create: true
    };
    exports.httpClient = exports.create = void 0;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    var httpClient;
    var create;
    if (false) {
      axiosModule = null;
      exports.httpClient = httpClient = axiosModule.axiosClient;
      exports.create = create = axiosModule.create;
    } else {
      fetchModule = require_fetch_client();
      exports.httpClient = httpClient = fetchModule.fetchClient;
      exports.create = create = fetchModule.create;
    }
    var axiosModule;
    var fetchModule;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/axios.js
var require_axios = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/axios.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.version = exports.default = exports.AxiosClient = void 0;
    var _httpClient = require_http_client();
    var version2 = exports.version = "13.3.0";
    var AxiosClient = exports.AxiosClient = (0, _httpClient.create)({
      headers: {
        "X-Client-Name": "js-soroban-client",
        "X-Client-Version": version2
      }
    });
    var _default = exports.default = AxiosClient;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.postObject = postObject;
    var _axios = _interopRequireDefault(require_axios());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function hasOwnProperty(obj, prop) {
      return obj.hasOwnProperty(prop);
    }
    function postObject(_x, _x2) {
      return _postObject.apply(this, arguments);
    }
    function _postObject() {
      _postObject = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(url, method) {
        var param, response, _response$data, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              param = _args.length > 2 && _args[2] !== void 0 ? _args[2] : null;
              _context.next = 3;
              return _axios.default.post(url, {
                jsonrpc: "2.0",
                id: 1,
                method,
                params: param
              });
            case 3:
              response = _context.sent;
              if (!hasOwnProperty(response.data, "error")) {
                _context.next = 8;
                break;
              }
              throw response.data.error;
            case 8:
              return _context.abrupt("return", (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.result);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _postObject.apply(this, arguments);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/parsers.js
var require_parsers = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/parsers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseRawEvents = parseRawEvents;
    exports.parseRawLedgerEntries = parseRawLedgerEntries;
    exports.parseRawSendTransaction = parseRawSendTransaction;
    exports.parseRawSimulation = parseRawSimulation;
    exports.parseRawTransactions = parseRawTransactions;
    exports.parseTransactionInfo = parseTransactionInfo;
    var _stellarBase = require_lib();
    var _api = require_api();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function parseRawSendTransaction(raw) {
      var errorResultXdr = raw.errorResultXdr, diagnosticEventsXdr = raw.diagnosticEventsXdr;
      delete raw.errorResultXdr;
      delete raw.diagnosticEventsXdr;
      if (errorResultXdr) {
        return _objectSpread(_objectSpread(_objectSpread({}, raw), diagnosticEventsXdr !== void 0 && diagnosticEventsXdr.length > 0 && {
          diagnosticEvents: diagnosticEventsXdr.map(function(evt) {
            return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
          })
        }), {}, {
          errorResult: _stellarBase.xdr.TransactionResult.fromXDR(errorResultXdr, "base64")
        });
      }
      return _objectSpread({}, raw);
    }
    function parseTransactionInfo(raw) {
      var meta = _stellarBase.xdr.TransactionMeta.fromXDR(raw.resultMetaXdr, "base64");
      var info = {
        ledger: raw.ledger,
        createdAt: raw.createdAt,
        applicationOrder: raw.applicationOrder,
        feeBump: raw.feeBump,
        envelopeXdr: _stellarBase.xdr.TransactionEnvelope.fromXDR(raw.envelopeXdr, "base64"),
        resultXdr: _stellarBase.xdr.TransactionResult.fromXDR(raw.resultXdr, "base64"),
        resultMetaXdr: meta
      };
      if (meta.switch() === 3 && meta.v3().sorobanMeta() !== null) {
        var _meta$v3$sorobanMeta;
        info.returnValue = (_meta$v3$sorobanMeta = meta.v3().sorobanMeta()) === null || _meta$v3$sorobanMeta === void 0 ? void 0 : _meta$v3$sorobanMeta.returnValue();
      }
      if ("diagnosticEventsXdr" in raw && raw.diagnosticEventsXdr) {
        info.diagnosticEventsXdr = raw.diagnosticEventsXdr.map(function(diagnosticEvent) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(diagnosticEvent, "base64");
        });
      }
      return info;
    }
    function parseRawTransactions(r) {
      return _objectSpread({
        status: r.status,
        txHash: r.txHash
      }, parseTransactionInfo(r));
    }
    function parseRawEvents(raw) {
      var _raw$events;
      return {
        latestLedger: raw.latestLedger,
        cursor: raw.cursor,
        events: ((_raw$events = raw.events) !== null && _raw$events !== void 0 ? _raw$events : []).map(function(evt) {
          var clone = _objectSpread({}, evt);
          delete clone.contractId;
          return _objectSpread(_objectSpread(_objectSpread({}, clone), evt.contractId !== "" && {
            contractId: new _stellarBase.Contract(evt.contractId)
          }), {}, {
            topic: evt.topic.map(function(topic) {
              return _stellarBase.xdr.ScVal.fromXDR(topic, "base64");
            }),
            value: _stellarBase.xdr.ScVal.fromXDR(evt.value, "base64")
          });
        })
      };
    }
    function parseRawLedgerEntries(raw) {
      var _raw$entries;
      return {
        latestLedger: raw.latestLedger,
        entries: ((_raw$entries = raw.entries) !== null && _raw$entries !== void 0 ? _raw$entries : []).map(function(rawEntry) {
          if (!rawEntry.key || !rawEntry.xdr) {
            throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(rawEntry)));
          }
          return _objectSpread({
            lastModifiedLedgerSeq: rawEntry.lastModifiedLedgerSeq,
            key: _stellarBase.xdr.LedgerKey.fromXDR(rawEntry.key, "base64"),
            val: _stellarBase.xdr.LedgerEntryData.fromXDR(rawEntry.xdr, "base64")
          }, rawEntry.liveUntilLedgerSeq !== void 0 && {
            liveUntilLedgerSeq: rawEntry.liveUntilLedgerSeq
          });
        })
      };
    }
    function parseSuccessful(sim, partial) {
      var _sim$results$length, _sim$results, _sim$stateChanges$len, _sim$stateChanges, _sim$stateChanges2;
      var success = _objectSpread(_objectSpread(_objectSpread({}, partial), {}, {
        transactionData: new _stellarBase.SorobanDataBuilder(sim.transactionData),
        minResourceFee: sim.minResourceFee
      }, ((_sim$results$length = (_sim$results = sim.results) === null || _sim$results === void 0 ? void 0 : _sim$results.length) !== null && _sim$results$length !== void 0 ? _sim$results$length : 0 > 0) && {
        result: sim.results.map(function(row) {
          var _row$auth;
          return {
            auth: ((_row$auth = row.auth) !== null && _row$auth !== void 0 ? _row$auth : []).map(function(entry) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(entry, "base64");
            }),
            retval: row.xdr ? _stellarBase.xdr.ScVal.fromXDR(row.xdr, "base64") : _stellarBase.xdr.ScVal.scvVoid()
          };
        })[0]
      }), ((_sim$stateChanges$len = (_sim$stateChanges = sim.stateChanges) === null || _sim$stateChanges === void 0 ? void 0 : _sim$stateChanges.length) !== null && _sim$stateChanges$len !== void 0 ? _sim$stateChanges$len : 0 > 0) && {
        stateChanges: (_sim$stateChanges2 = sim.stateChanges) === null || _sim$stateChanges2 === void 0 ? void 0 : _sim$stateChanges2.map(function(entryChange) {
          return {
            type: entryChange.type,
            key: _stellarBase.xdr.LedgerKey.fromXDR(entryChange.key, "base64"),
            before: entryChange.before ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.before, "base64") : null,
            after: entryChange.after ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.after, "base64") : null
          };
        })
      });
      if (!sim.restorePreamble || sim.restorePreamble.transactionData === "") {
        return success;
      }
      return _objectSpread(_objectSpread({}, success), {}, {
        restorePreamble: {
          minResourceFee: sim.restorePreamble.minResourceFee,
          transactionData: new _stellarBase.SorobanDataBuilder(sim.restorePreamble.transactionData)
        }
      });
    }
    function parseRawSimulation(sim) {
      var _sim$events$map, _sim$events;
      var looksRaw = _api.Api.isSimulationRaw(sim);
      if (!looksRaw) {
        return sim;
      }
      var base = {
        _parsed: true,
        id: sim.id,
        latestLedger: sim.latestLedger,
        events: (_sim$events$map = (_sim$events = sim.events) === null || _sim$events === void 0 ? void 0 : _sim$events.map(function(evt) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
        })) !== null && _sim$events$map !== void 0 ? _sim$events$map : []
      };
      if (typeof sim.error === "string") {
        return _objectSpread(_objectSpread({}, base), {}, {
          error: sim.error
        });
      }
      return parseSuccessful(sim, base);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assembleTransaction = assembleTransaction;
    var _stellarBase = require_lib();
    var _api = require_api();
    var _parsers = require_parsers();
    function isSorobanTransaction(tx) {
      if (tx.operations.length !== 1) {
        return false;
      }
      switch (tx.operations[0].type) {
        case "invokeHostFunction":
        case "extendFootprintTtl":
        case "restoreFootprint":
          return true;
        default:
          return false;
      }
    }
    function assembleTransaction(raw, simulation) {
      if ("innerTransaction" in raw) {
        return assembleTransaction(raw.innerTransaction, simulation);
      }
      if (!isSorobanTransaction(raw)) {
        throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
      }
      var success = (0, _parsers.parseRawSimulation)(simulation);
      if (!_api.Api.isSimulationSuccess(success)) {
        throw new Error("simulation incorrect: ".concat(JSON.stringify(success)));
      }
      var classicFeeNum = parseInt(raw.fee) || 0;
      var minResourceFeeNum = parseInt(success.minResourceFee) || 0;
      var txnBuilder = _stellarBase.TransactionBuilder.cloneFrom(raw, {
        fee: (classicFeeNum + minResourceFeeNum).toString(),
        sorobanData: success.transactionData.build(),
        networkPassphrase: raw.networkPassphrase
      });
      if (raw.operations[0].type === "invokeHostFunction") {
        var _invokeOp$auth;
        txnBuilder.clearOperations();
        var invokeOp = raw.operations[0];
        var existingAuth = (_invokeOp$auth = invokeOp.auth) !== null && _invokeOp$auth !== void 0 ? _invokeOp$auth : [];
        txnBuilder.addOperation(_stellarBase.Operation.invokeHostFunction({
          source: invokeOp.source,
          func: invokeOp.func,
          auth: existingAuth.length > 0 ? existingAuth : success.result.auth
        }));
      }
      return txnBuilder;
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/utils.js
var require_utils = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Utils = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Utils = exports.Utils = function() {
      function Utils2() {
        _classCallCheck(this, Utils2);
      }
      return _createClass(Utils2, null, [{
        key: "validateTimebounds",
        value: function validateTimebounds(transaction) {
          var gracePeriod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          if (!transaction.timeBounds) {
            return false;
          }
          var now = Math.floor(Date.now() / 1e3);
          var _transaction$timeBoun = transaction.timeBounds, minTime = _transaction$timeBoun.minTime, maxTime = _transaction$timeBoun.maxTime;
          return now >= Number.parseInt(minTime, 10) - gracePeriod && now <= Number.parseInt(maxTime, 10) + gracePeriod;
        }
      }, {
        key: "sleep",
        value: function sleep(ms) {
          return new Promise(function(resolve) {
            return setTimeout(resolve, ms);
          });
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/server.js
var require_server = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SUBMIT_TRANSACTION_TIMEOUT = exports.RpcServer = exports.LinearSleepStrategy = exports.Durability = exports.BasicSleepStrategy = void 0;
    var _urijs = _interopRequireDefault(require_URI());
    var _stellarBase = require_lib();
    var _axios = _interopRequireDefault(require_axios());
    var jsonrpc = _interopRequireWildcard(require_jsonrpc());
    var _api = require_api();
    var _transaction = require_transaction2();
    var _parsers = require_parsers();
    var _utils = require_utils();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SUBMIT_TRANSACTION_TIMEOUT = exports.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
    var Durability2 = exports.Durability = function(Durability3) {
      Durability3["Temporary"] = "temporary";
      Durability3["Persistent"] = "persistent";
      return Durability3;
    }({});
    var DEFAULT_GET_TRANSACTION_TIMEOUT = 30;
    var BasicSleepStrategy = exports.BasicSleepStrategy = function BasicSleepStrategy2(_iter) {
      return 1e3;
    };
    var LinearSleepStrategy = exports.LinearSleepStrategy = function LinearSleepStrategy2(iter) {
      return 1e3 * iter;
    };
    function findCreatedAccountSequenceInTransactionMeta(meta) {
      var _operations$flatMap$f;
      var operations = [];
      switch (meta.switch()) {
        case 0:
          operations = meta.operations();
          break;
        case 1:
        case 2:
        case 3:
          operations = meta.value().operations();
          break;
        default:
          throw new Error("Unexpected transaction meta switch value");
      }
      var sequenceNumber = (_operations$flatMap$f = operations.flatMap(function(op) {
        return op.changes();
      }).find(function(c) {
        return c.switch() === _stellarBase.xdr.LedgerEntryChangeType.ledgerEntryCreated() && c.created().data().switch() === _stellarBase.xdr.LedgerEntryType.account();
      })) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.created()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.data()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.account()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.seqNum()) === null || _operations$flatMap$f === void 0 ? void 0 : _operations$flatMap$f.toString();
      if (sequenceNumber) {
        return sequenceNumber;
      }
      throw new Error("No account created in transaction");
    }
    var RpcServer = exports.RpcServer = function() {
      function RpcServer2(serverURL) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, RpcServer2);
        this.serverURL = (0, _urijs.default)(serverURL);
        if (opts.headers && Object.keys(opts.headers).length !== 0) {
          _axios.default.interceptors.request.use(function(config) {
            config.headers = Object.assign(config.headers, opts.headers);
            return config;
          });
        }
        if (this.serverURL.protocol() !== "https" && !opts.allowHttp) {
          throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
        }
      }
      return _createClass(RpcServer2, [{
        key: "getAccount",
        value: function() {
          var _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(address) {
            var ledgerKey, resp, accountEntry;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  ledgerKey = _stellarBase.xdr.LedgerKey.account(new _stellarBase.xdr.LedgerKeyAccount({
                    accountId: _stellarBase.Keypair.fromPublicKey(address).xdrPublicKey()
                  }));
                  _context.next = 3;
                  return this.getLedgerEntries(ledgerKey);
                case 3:
                  resp = _context.sent;
                  if (!(resp.entries.length === 0)) {
                    _context.next = 6;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Account not found: ".concat(address)
                  }));
                case 6:
                  accountEntry = resp.entries[0].val.account();
                  return _context.abrupt("return", new _stellarBase.Account(address, accountEntry.seqNum().toString()));
                case 8:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function getAccount(_x) {
            return _getAccount.apply(this, arguments);
          }
          return getAccount;
        }()
      }, {
        key: "getHealth",
        value: function() {
          var _getHealth = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getHealth"));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function getHealth() {
            return _getHealth.apply(this, arguments);
          }
          return getHealth;
        }()
      }, {
        key: "getContractData",
        value: function() {
          var _getContractData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(contract, key) {
            var durability, scAddress, xdrDurability, contractKey, _args3 = arguments;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  durability = _args3.length > 2 && _args3[2] !== void 0 ? _args3[2] : Durability2.Persistent;
                  if (!(typeof contract === "string")) {
                    _context3.next = 5;
                    break;
                  }
                  scAddress = new _stellarBase.Contract(contract).address().toScAddress();
                  _context3.next = 14;
                  break;
                case 5:
                  if (!(contract instanceof _stellarBase.Address)) {
                    _context3.next = 9;
                    break;
                  }
                  scAddress = contract.toScAddress();
                  _context3.next = 14;
                  break;
                case 9:
                  if (!(contract instanceof _stellarBase.Contract)) {
                    _context3.next = 13;
                    break;
                  }
                  scAddress = contract.address().toScAddress();
                  _context3.next = 14;
                  break;
                case 13:
                  throw new TypeError("unknown contract type: ".concat(contract));
                case 14:
                  _context3.t0 = durability;
                  _context3.next = _context3.t0 === Durability2.Temporary ? 17 : _context3.t0 === Durability2.Persistent ? 19 : 21;
                  break;
                case 17:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.temporary();
                  return _context3.abrupt("break", 22);
                case 19:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.persistent();
                  return _context3.abrupt("break", 22);
                case 21:
                  throw new TypeError("invalid durability: ".concat(durability));
                case 22:
                  contractKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    key,
                    contract: scAddress,
                    durability: xdrDurability
                  }));
                  return _context3.abrupt("return", this.getLedgerEntries(contractKey).then(function(r) {
                    if (r.entries.length === 0) {
                      return Promise.reject({
                        code: 404,
                        message: "Contract data not found. Contract: ".concat(_stellarBase.Address.fromScAddress(scAddress).toString(), ", Key: ").concat(key.toXDR("base64"), ", Durability: ").concat(durability)
                      });
                    }
                    return r.entries[0];
                  }));
                case 24:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this);
          }));
          function getContractData(_x2, _x3) {
            return _getContractData.apply(this, arguments);
          }
          return getContractData;
        }()
      }, {
        key: "getContractWasmByContractId",
        value: function() {
          var _getContractWasmByContractId = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(contractId) {
            var _response$entries$;
            var contractLedgerKey, response, wasmHash;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  contractLedgerKey = new _stellarBase.Contract(contractId).getFootprint();
                  _context4.next = 3;
                  return this.getLedgerEntries(contractLedgerKey);
                case 3:
                  response = _context4.sent;
                  if (!(!response.entries.length || !((_response$entries$ = response.entries[0]) !== null && _response$entries$ !== void 0 && _response$entries$.val))) {
                    _context4.next = 6;
                    break;
                  }
                  return _context4.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract hash from server"
                  }));
                case 6:
                  wasmHash = response.entries[0].val.contractData().val().instance().executable().wasmHash();
                  return _context4.abrupt("return", this.getContractWasmByHash(wasmHash));
                case 8:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));
          function getContractWasmByContractId(_x4) {
            return _getContractWasmByContractId.apply(this, arguments);
          }
          return getContractWasmByContractId;
        }()
      }, {
        key: "getContractWasmByHash",
        value: function() {
          var _getContractWasmByHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasmHash) {
            var _responseWasm$entries;
            var format, wasmHashBuffer, ledgerKeyWasmHash, responseWasm, wasmBuffer, _args5 = arguments;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  format = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : void 0;
                  wasmHashBuffer = typeof wasmHash === "string" ? Buffer.from(wasmHash, format) : wasmHash;
                  ledgerKeyWasmHash = _stellarBase.xdr.LedgerKey.contractCode(new _stellarBase.xdr.LedgerKeyContractCode({
                    hash: wasmHashBuffer
                  }));
                  _context5.next = 5;
                  return this.getLedgerEntries(ledgerKeyWasmHash);
                case 5:
                  responseWasm = _context5.sent;
                  if (!(!responseWasm.entries.length || !((_responseWasm$entries = responseWasm.entries[0]) !== null && _responseWasm$entries !== void 0 && _responseWasm$entries.val))) {
                    _context5.next = 8;
                    break;
                  }
                  return _context5.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract wasm from server"
                  }));
                case 8:
                  wasmBuffer = responseWasm.entries[0].val.contractCode().code();
                  return _context5.abrupt("return", wasmBuffer);
                case 10:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function getContractWasmByHash(_x5) {
            return _getContractWasmByHash.apply(this, arguments);
          }
          return getContractWasmByHash;
        }()
      }, {
        key: "getLedgerEntries",
        value: function() {
          var _getLedgerEntries2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
            var _args6 = arguments;
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  return _context6.abrupt("return", this._getLedgerEntries.apply(this, _args6).then(_parsers.parseRawLedgerEntries));
                case 1:
                case "end":
                  return _context6.stop();
              }
            }, _callee6, this);
          }));
          function getLedgerEntries() {
            return _getLedgerEntries2.apply(this, arguments);
          }
          return getLedgerEntries;
        }()
      }, {
        key: "_getLedgerEntries",
        value: function() {
          var _getLedgerEntries3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var _len, keys, _key, _args7 = arguments;
            return _regeneratorRuntime().wrap(function _callee7$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  for (_len = _args7.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
                    keys[_key] = _args7[_key];
                  }
                  return _context7.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLedgerEntries", {
                    keys: keys.map(function(k) {
                      return k.toXDR("base64");
                    })
                  }));
                case 2:
                case "end":
                  return _context7.stop();
              }
            }, _callee7, this);
          }));
          function _getLedgerEntries() {
            return _getLedgerEntries3.apply(this, arguments);
          }
          return _getLedgerEntries;
        }()
      }, {
        key: "pollTransaction",
        value: function() {
          var _pollTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(hash2, opts) {
            var _opts$attempts, _opts$attempts2;
            var maxAttempts, foundInfo, attempt, _opts$sleepStrategy;
            return _regeneratorRuntime().wrap(function _callee8$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  maxAttempts = ((_opts$attempts = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts !== void 0 ? _opts$attempts : 0) < 1 ? DEFAULT_GET_TRANSACTION_TIMEOUT : (_opts$attempts2 = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts2 !== void 0 ? _opts$attempts2 : DEFAULT_GET_TRANSACTION_TIMEOUT;
                  attempt = 1;
                case 2:
                  if (!(attempt < maxAttempts)) {
                    _context8.next = 13;
                    break;
                  }
                  _context8.next = 5;
                  return this.getTransaction(hash2);
                case 5:
                  foundInfo = _context8.sent;
                  if (!(foundInfo.status !== _api.Api.GetTransactionStatus.NOT_FOUND)) {
                    _context8.next = 8;
                    break;
                  }
                  return _context8.abrupt("return", foundInfo);
                case 8:
                  _context8.next = 10;
                  return _utils.Utils.sleep(((_opts$sleepStrategy = opts === null || opts === void 0 ? void 0 : opts.sleepStrategy) !== null && _opts$sleepStrategy !== void 0 ? _opts$sleepStrategy : BasicSleepStrategy)(attempt));
                case 10:
                  attempt++;
                  _context8.next = 2;
                  break;
                case 13:
                  return _context8.abrupt("return", foundInfo);
                case 14:
                case "end":
                  return _context8.stop();
              }
            }, _callee8, this);
          }));
          function pollTransaction(_x6, _x7) {
            return _pollTransaction.apply(this, arguments);
          }
          return pollTransaction;
        }()
      }, {
        key: "getTransaction",
        value: function() {
          var _getTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(hash2) {
            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  return _context9.abrupt("return", this._getTransaction(hash2).then(function(raw) {
                    var foundInfo = {};
                    if (raw.status !== _api.Api.GetTransactionStatus.NOT_FOUND) {
                      Object.assign(foundInfo, (0, _parsers.parseTransactionInfo)(raw));
                    }
                    var result = _objectSpread({
                      status: raw.status,
                      txHash: hash2,
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTime: raw.latestLedgerCloseTime,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTime: raw.oldestLedgerCloseTime
                    }, foundInfo);
                    return result;
                  }));
                case 1:
                case "end":
                  return _context9.stop();
              }
            }, _callee9, this);
          }));
          function getTransaction(_x8) {
            return _getTransaction2.apply(this, arguments);
          }
          return getTransaction;
        }()
      }, {
        key: "_getTransaction",
        value: function() {
          var _getTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(hash2) {
            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  return _context10.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransaction", {
                    hash: hash2
                  }));
                case 1:
                case "end":
                  return _context10.stop();
              }
            }, _callee10, this);
          }));
          function _getTransaction(_x9) {
            return _getTransaction3.apply(this, arguments);
          }
          return _getTransaction;
        }()
      }, {
        key: "getTransactions",
        value: function() {
          var _getTransactions2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(request) {
            return _regeneratorRuntime().wrap(function _callee11$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  return _context11.abrupt("return", this._getTransactions(request).then(function(raw) {
                    var result = {
                      transactions: (raw.transactions || []).map(_parsers.parseRawTransactions),
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTimestamp: raw.latestLedgerCloseTimestamp,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTimestamp: raw.oldestLedgerCloseTimestamp,
                      cursor: raw.cursor
                    };
                    return result;
                  }));
                case 1:
                case "end":
                  return _context11.stop();
              }
            }, _callee11, this);
          }));
          function getTransactions(_x10) {
            return _getTransactions2.apply(this, arguments);
          }
          return getTransactions;
        }()
      }, {
        key: "_getTransactions",
        value: function() {
          var _getTransactions3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee12(request) {
            return _regeneratorRuntime().wrap(function _callee12$(_context12) {
              while (1) switch (_context12.prev = _context12.next) {
                case 0:
                  return _context12.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransactions", request));
                case 1:
                case "end":
                  return _context12.stop();
              }
            }, _callee12, this);
          }));
          function _getTransactions(_x11) {
            return _getTransactions3.apply(this, arguments);
          }
          return _getTransactions;
        }()
      }, {
        key: "getEvents",
        value: function() {
          var _getEvents2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee13(request) {
            return _regeneratorRuntime().wrap(function _callee13$(_context13) {
              while (1) switch (_context13.prev = _context13.next) {
                case 0:
                  return _context13.abrupt("return", this._getEvents(request).then(_parsers.parseRawEvents));
                case 1:
                case "end":
                  return _context13.stop();
              }
            }, _callee13, this);
          }));
          function getEvents(_x12) {
            return _getEvents2.apply(this, arguments);
          }
          return getEvents;
        }()
      }, {
        key: "_getEvents",
        value: function() {
          var _getEvents3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee14(request) {
            var _request$filters;
            return _regeneratorRuntime().wrap(function _callee14$(_context14) {
              while (1) switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getEvents", _objectSpread(_objectSpread({
                    filters: (_request$filters = request.filters) !== null && _request$filters !== void 0 ? _request$filters : [],
                    pagination: _objectSpread(_objectSpread({}, request.cursor && {
                      cursor: request.cursor
                    }), request.limit && {
                      limit: request.limit
                    })
                  }, request.startLedger && {
                    startLedger: request.startLedger
                  }), request.endLedger && {
                    endLedger: request.endLedger
                  })));
                case 1:
                case "end":
                  return _context14.stop();
              }
            }, _callee14, this);
          }));
          function _getEvents(_x13) {
            return _getEvents3.apply(this, arguments);
          }
          return _getEvents;
        }()
      }, {
        key: "getNetwork",
        value: function() {
          var _getNetwork = _asyncToGenerator(_regeneratorRuntime().mark(function _callee15() {
            return _regeneratorRuntime().wrap(function _callee15$(_context15) {
              while (1) switch (_context15.prev = _context15.next) {
                case 0:
                  return _context15.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getNetwork"));
                case 1:
                case "end":
                  return _context15.stop();
              }
            }, _callee15, this);
          }));
          function getNetwork() {
            return _getNetwork.apply(this, arguments);
          }
          return getNetwork;
        }()
      }, {
        key: "getLatestLedger",
        value: function() {
          var _getLatestLedger = _asyncToGenerator(_regeneratorRuntime().mark(function _callee16() {
            return _regeneratorRuntime().wrap(function _callee16$(_context16) {
              while (1) switch (_context16.prev = _context16.next) {
                case 0:
                  return _context16.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLatestLedger"));
                case 1:
                case "end":
                  return _context16.stop();
              }
            }, _callee16, this);
          }));
          function getLatestLedger() {
            return _getLatestLedger.apply(this, arguments);
          }
          return getLatestLedger;
        }()
      }, {
        key: "simulateTransaction",
        value: function() {
          var _simulateTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee17(tx, addlResources) {
            return _regeneratorRuntime().wrap(function _callee17$(_context17) {
              while (1) switch (_context17.prev = _context17.next) {
                case 0:
                  return _context17.abrupt("return", this._simulateTransaction(tx, addlResources).then(_parsers.parseRawSimulation));
                case 1:
                case "end":
                  return _context17.stop();
              }
            }, _callee17, this);
          }));
          function simulateTransaction(_x14, _x15) {
            return _simulateTransaction2.apply(this, arguments);
          }
          return simulateTransaction;
        }()
      }, {
        key: "_simulateTransaction",
        value: function() {
          var _simulateTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee18(transaction, addlResources) {
            return _regeneratorRuntime().wrap(function _callee18$(_context18) {
              while (1) switch (_context18.prev = _context18.next) {
                case 0:
                  return _context18.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "simulateTransaction", _objectSpread({
                    transaction: transaction.toXDR()
                  }, addlResources !== void 0 && {
                    resourceConfig: {
                      instructionLeeway: addlResources.cpuInstructions
                    }
                  })));
                case 1:
                case "end":
                  return _context18.stop();
              }
            }, _callee18, this);
          }));
          function _simulateTransaction(_x16, _x17) {
            return _simulateTransaction3.apply(this, arguments);
          }
          return _simulateTransaction;
        }()
      }, {
        key: "prepareTransaction",
        value: function() {
          var _prepareTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee19(tx) {
            var simResponse;
            return _regeneratorRuntime().wrap(function _callee19$(_context19) {
              while (1) switch (_context19.prev = _context19.next) {
                case 0:
                  _context19.next = 2;
                  return this.simulateTransaction(tx);
                case 2:
                  simResponse = _context19.sent;
                  if (!_api.Api.isSimulationError(simResponse)) {
                    _context19.next = 5;
                    break;
                  }
                  throw new Error(simResponse.error);
                case 5:
                  return _context19.abrupt("return", (0, _transaction.assembleTransaction)(tx, simResponse).build());
                case 6:
                case "end":
                  return _context19.stop();
              }
            }, _callee19, this);
          }));
          function prepareTransaction(_x18) {
            return _prepareTransaction.apply(this, arguments);
          }
          return prepareTransaction;
        }()
      }, {
        key: "sendTransaction",
        value: function() {
          var _sendTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee20(transaction) {
            return _regeneratorRuntime().wrap(function _callee20$(_context20) {
              while (1) switch (_context20.prev = _context20.next) {
                case 0:
                  return _context20.abrupt("return", this._sendTransaction(transaction).then(_parsers.parseRawSendTransaction));
                case 1:
                case "end":
                  return _context20.stop();
              }
            }, _callee20, this);
          }));
          function sendTransaction(_x19) {
            return _sendTransaction2.apply(this, arguments);
          }
          return sendTransaction;
        }()
      }, {
        key: "_sendTransaction",
        value: function() {
          var _sendTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee21(transaction) {
            return _regeneratorRuntime().wrap(function _callee21$(_context21) {
              while (1) switch (_context21.prev = _context21.next) {
                case 0:
                  return _context21.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "sendTransaction", {
                    transaction: transaction.toXDR()
                  }));
                case 1:
                case "end":
                  return _context21.stop();
              }
            }, _callee21, this);
          }));
          function _sendTransaction(_x20) {
            return _sendTransaction3.apply(this, arguments);
          }
          return _sendTransaction;
        }()
      }, {
        key: "requestAirdrop",
        value: function() {
          var _requestAirdrop = _asyncToGenerator(_regeneratorRuntime().mark(function _callee22(address, friendbotUrl) {
            var account, response, meta, txMeta, sequence, _error$response, _error$response$detai;
            return _regeneratorRuntime().wrap(function _callee22$(_context22) {
              while (1) switch (_context22.prev = _context22.next) {
                case 0:
                  account = typeof address === "string" ? address : address.accountId();
                  _context22.t0 = friendbotUrl;
                  if (_context22.t0) {
                    _context22.next = 6;
                    break;
                  }
                  _context22.next = 5;
                  return this.getNetwork();
                case 5:
                  _context22.t0 = _context22.sent.friendbotUrl;
                case 6:
                  friendbotUrl = _context22.t0;
                  if (friendbotUrl) {
                    _context22.next = 9;
                    break;
                  }
                  throw new Error("No friendbot URL configured for current network");
                case 9:
                  _context22.prev = 9;
                  _context22.next = 12;
                  return _axios.default.post("".concat(friendbotUrl, "?addr=").concat(encodeURIComponent(account)));
                case 12:
                  response = _context22.sent;
                  if (response.data.result_meta_xdr) {
                    _context22.next = 22;
                    break;
                  }
                  _context22.next = 16;
                  return this.getTransaction(response.data.hash);
                case 16:
                  txMeta = _context22.sent;
                  if (!(txMeta.status !== _api.Api.GetTransactionStatus.SUCCESS)) {
                    _context22.next = 19;
                    break;
                  }
                  throw new Error("Funding account ".concat(address, " failed"));
                case 19:
                  meta = txMeta.resultMetaXdr;
                  _context22.next = 23;
                  break;
                case 22:
                  meta = _stellarBase.xdr.TransactionMeta.fromXDR(response.data.result_meta_xdr, "base64");
                case 23:
                  sequence = findCreatedAccountSequenceInTransactionMeta(meta);
                  return _context22.abrupt("return", new _stellarBase.Account(account, sequence));
                case 27:
                  _context22.prev = 27;
                  _context22.t1 = _context22["catch"](9);
                  if (!(((_error$response = _context22.t1.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 400)) {
                    _context22.next = 32;
                    break;
                  }
                  if (!((_error$response$detai = _context22.t1.response.detail) !== null && _error$response$detai !== void 0 && _error$response$detai.includes("createAccountAlreadyExist"))) {
                    _context22.next = 32;
                    break;
                  }
                  return _context22.abrupt("return", this.getAccount(account));
                case 32:
                  throw _context22.t1;
                case 33:
                case "end":
                  return _context22.stop();
              }
            }, _callee22, this, [[9, 27]]);
          }));
          function requestAirdrop(_x21, _x22) {
            return _requestAirdrop.apply(this, arguments);
          }
          return requestAirdrop;
        }()
      }, {
        key: "getFeeStats",
        value: function() {
          var _getFeeStats = _asyncToGenerator(_regeneratorRuntime().mark(function _callee23() {
            return _regeneratorRuntime().wrap(function _callee23$(_context23) {
              while (1) switch (_context23.prev = _context23.next) {
                case 0:
                  return _context23.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getFeeStats"));
                case 1:
                case "end":
                  return _context23.stop();
              }
            }, _callee23, this);
          }));
          function getFeeStats() {
            return _getFeeStats.apply(this, arguments);
          }
          return getFeeStats;
        }()
      }, {
        key: "getVersionInfo",
        value: function() {
          var _getVersionInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee24() {
            return _regeneratorRuntime().wrap(function _callee24$(_context24) {
              while (1) switch (_context24.prev = _context24.next) {
                case 0:
                  return _context24.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getVersionInfo"));
                case 1:
                case "end":
                  return _context24.stop();
              }
            }, _callee24, this);
          }));
          function getVersionInfo() {
            return _getVersionInfo.apply(this, arguments);
          }
          return getVersionInfo;
        }()
      }, {
        key: "getSACBalance",
        value: function() {
          var _getSACBalance = _asyncToGenerator(_regeneratorRuntime().mark(function _callee25(contractId, sac, networkPassphrase) {
            var passphrase, sacId, key, ledgerKey, response, _response$entries$2, lastModifiedLedgerSeq, liveUntilLedgerSeq, val, entry;
            return _regeneratorRuntime().wrap(function _callee25$(_context25) {
              while (1) switch (_context25.prev = _context25.next) {
                case 0:
                  if (_stellarBase.StrKey.isValidContract(contractId)) {
                    _context25.next = 2;
                    break;
                  }
                  throw new TypeError("expected contract ID, got ".concat(contractId));
                case 2:
                  if (!(networkPassphrase !== null && networkPassphrase !== void 0)) {
                    _context25.next = 6;
                    break;
                  }
                  _context25.t0 = networkPassphrase;
                  _context25.next = 9;
                  break;
                case 6:
                  _context25.next = 8;
                  return this.getNetwork().then(function(n) {
                    return n.passphrase;
                  });
                case 8:
                  _context25.t0 = _context25.sent;
                case 9:
                  passphrase = _context25.t0;
                  sacId = sac.contractId(passphrase);
                  key = _stellarBase.xdr.ScVal.scvVec([(0, _stellarBase.nativeToScVal)("Balance", {
                    type: "symbol"
                  }), (0, _stellarBase.nativeToScVal)(contractId, {
                    type: "address"
                  })]);
                  ledgerKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    contract: new _stellarBase.Address(sacId).toScAddress(),
                    durability: _stellarBase.xdr.ContractDataDurability.persistent(),
                    key
                  }));
                  _context25.next = 15;
                  return this.getLedgerEntries(ledgerKey);
                case 15:
                  response = _context25.sent;
                  if (!(response.entries.length === 0)) {
                    _context25.next = 18;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 18:
                  _response$entries$2 = response.entries[0], lastModifiedLedgerSeq = _response$entries$2.lastModifiedLedgerSeq, liveUntilLedgerSeq = _response$entries$2.liveUntilLedgerSeq, val = _response$entries$2.val;
                  if (!(val.switch().value !== _stellarBase.xdr.LedgerEntryType.contractData().value)) {
                    _context25.next = 21;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 21:
                  entry = (0, _stellarBase.scValToNative)(val.contractData().val());
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger,
                    balanceEntry: {
                      liveUntilLedgerSeq,
                      lastModifiedLedgerSeq,
                      amount: entry.amount.toString(),
                      authorized: entry.authorized,
                      clawback: entry.clawback
                    }
                  });
                case 23:
                case "end":
                  return _context25.stop();
              }
            }, _callee25, this);
          }));
          function getSACBalance(_x23, _x24, _x25) {
            return _getSACBalance.apply(this, arguments);
          }
          return getSACBalance;
        }()
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/index.js
var require_rpc = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      Server: true,
      BasicSleepStrategy: true,
      LinearSleepStrategy: true,
      Durability: true,
      AxiosClient: true,
      parseRawSimulation: true,
      parseRawEvents: true
    };
    Object.defineProperty(exports, "AxiosClient", {
      enumerable: true,
      get: function get() {
        return _axios.default;
      }
    });
    Object.defineProperty(exports, "BasicSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.BasicSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Durability", {
      enumerable: true,
      get: function get() {
        return _server.Durability;
      }
    });
    Object.defineProperty(exports, "LinearSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.LinearSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Server", {
      enumerable: true,
      get: function get() {
        return _server.RpcServer;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "parseRawEvents", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawEvents;
      }
    });
    Object.defineProperty(exports, "parseRawSimulation", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawSimulation;
      }
    });
    var _api = require_api();
    Object.keys(_api).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _api[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _api[key];
        }
      });
    });
    var _server = require_server();
    var _axios = _interopRequireDefault(require_axios());
    var _parsers = require_parsers();
    var _transaction = require_transaction2();
    Object.keys(_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _transaction[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var _default = exports.default = module.exports;
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/rust_result.js
var require_rust_result = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/rust_result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Ok = exports.Err = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Ok = exports.Ok = function() {
      function Ok2(value) {
        _classCallCheck(this, Ok2);
        this.value = value;
      }
      return _createClass(Ok2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          throw new Error("No error");
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          return this.value;
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return true;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return false;
        }
      }]);
    }();
    var Err = exports.Err = function() {
      function Err2(error) {
        _classCallCheck(this, Err2);
        this.error = error;
      }
      return _createClass(Err2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          return this.error;
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          throw new Error(this.error.message);
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return false;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return true;
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/types.js
var require_types2 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NULL_ACCOUNT = exports.DEFAULT_TIMEOUT = void 0;
    var _stellarBase = require_lib();
    var DEFAULT_TIMEOUT = exports.DEFAULT_TIMEOUT = 5 * 60;
    var NULL_ACCOUNT = exports.NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/utils.js
var require_utils2 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contractErrorPattern = void 0;
    exports.getAccount = getAccount;
    exports.implementsToString = implementsToString;
    exports.processSpecEntryStream = processSpecEntryStream;
    exports.withExponentialBackoff = withExponentialBackoff;
    var _stellarBase = require_lib();
    var _types = require_types2();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function withExponentialBackoff(_x, _x2, _x3) {
      return _withExponentialBackoff.apply(this, arguments);
    }
    function _withExponentialBackoff() {
      _withExponentialBackoff = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(fn, keepWaitingIf, timeoutInSeconds) {
        var exponentialFactor, verbose, attempts, count, waitUntil, waitTime, totalWaitTime, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              exponentialFactor = _args.length > 3 && _args[3] !== void 0 ? _args[3] : 1.5;
              verbose = _args.length > 4 && _args[4] !== void 0 ? _args[4] : false;
              attempts = [];
              count = 0;
              _context.t0 = attempts;
              _context.next = 7;
              return fn();
            case 7:
              _context.t1 = _context.sent;
              _context.t0.push.call(_context.t0, _context.t1);
              if (keepWaitingIf(attempts[attempts.length - 1])) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", attempts);
            case 11:
              waitUntil = new Date(Date.now() + timeoutInSeconds * 1e3).valueOf();
              waitTime = 1e3;
              totalWaitTime = waitTime;
            case 14:
              if (!(Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1]))) {
                _context.next = 30;
                break;
              }
              count += 1;
              if (verbose) {
                console.info("Waiting ".concat(waitTime, "ms before trying again (bringing the total wait time to ").concat(totalWaitTime, "ms so far, of total ").concat(timeoutInSeconds * 1e3, "ms)"));
              }
              _context.next = 19;
              return new Promise(function(res) {
                return setTimeout(res, waitTime);
              });
            case 19:
              waitTime *= exponentialFactor;
              if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
                waitTime = waitUntil - Date.now();
                if (verbose) {
                  console.info("was gonna wait too long; new waitTime: ".concat(waitTime, "ms"));
                }
              }
              totalWaitTime = waitTime + totalWaitTime;
              _context.t2 = attempts;
              _context.next = 25;
              return fn(attempts[attempts.length - 1]);
            case 25:
              _context.t3 = _context.sent;
              _context.t2.push.call(_context.t2, _context.t3);
              if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {
                console.info("".concat(count, ". Called ").concat(fn, "; ").concat(attempts.length, " prev attempts. Most recent: ").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));
              }
              _context.next = 14;
              break;
            case 30:
              return _context.abrupt("return", attempts);
            case 31:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _withExponentialBackoff.apply(this, arguments);
    }
    var contractErrorPattern = exports.contractErrorPattern = /Error\(Contract, #(\d+)\)/;
    function implementsToString(obj) {
      return _typeof(obj) === "object" && obj !== null && "toString" in obj;
    }
    function processSpecEntryStream(buffer) {
      var reader = new _stellarBase.cereal.XdrReader(buffer);
      var res = [];
      while (!reader.eof) {
        res.push(_stellarBase.xdr.ScSpecEntry.read(reader));
      }
      return res;
    }
    function getAccount(_x4, _x5) {
      return _getAccount.apply(this, arguments);
    }
    function _getAccount() {
      _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(options, server) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", options.publicKey ? server.getAccount(options.publicKey) : new _stellarBase.Account(_types.NULL_ACCOUNT, "0"));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _getAccount.apply(this, arguments);
    }
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/sent_transaction.js
var require_sent_transaction = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/sent_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SentTransaction = void 0;
    var _rpc = require_rpc();
    var _api = require_api();
    var _utils = require_utils2();
    var _types = require_types2();
    var _SentTransaction;
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SentTransaction = exports.SentTransaction = function() {
      function SentTransaction2(assembled) {
        var _this = this, _this$assembled$optio2;
        _classCallCheck(this, SentTransaction2);
        _defineProperty(this, "send", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _this$assembled$optio;
          var hash2, timeoutInSeconds;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.server.sendTransaction(_this.assembled.signed);
              case 2:
                _this.sendTransactionResponse = _context.sent;
                if (!(_this.sendTransactionResponse.status !== "PENDING")) {
                  _context.next = 5;
                  break;
                }
                throw new SentTransaction2.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(_this.sendTransactionResponse, null, 2)));
              case 5:
                hash2 = _this.sendTransactionResponse.hash;
                timeoutInSeconds = (_this$assembled$optio = _this.assembled.options.timeoutInSeconds) !== null && _this$assembled$optio !== void 0 ? _this$assembled$optio : _types.DEFAULT_TIMEOUT;
                _context.next = 9;
                return (0, _utils.withExponentialBackoff)(function() {
                  return _this.server.getTransaction(hash2);
                }, function(resp) {
                  return resp.status === _api.Api.GetTransactionStatus.NOT_FOUND;
                }, timeoutInSeconds);
              case 9:
                _this.getTransactionResponseAll = _context.sent;
                _this.getTransactionResponse = _this.getTransactionResponseAll[_this.getTransactionResponseAll.length - 1];
                if (!(_this.getTransactionResponse.status === _api.Api.GetTransactionStatus.NOT_FOUND)) {
                  _context.next = 13;
                  break;
                }
                throw new SentTransaction2.Errors.TransactionStillPending("Waited ".concat(timeoutInSeconds, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(_this.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(_this.getTransactionResponseAll, null, 2)));
              case 13:
                return _context.abrupt("return", _this);
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        this.assembled = assembled;
        this.server = new _rpc.Server(this.assembled.options.rpcUrl, {
          allowHttp: (_this$assembled$optio2 = this.assembled.options.allowHttp) !== null && _this$assembled$optio2 !== void 0 ? _this$assembled$optio2 : false
        });
      }
      return _createClass(SentTransaction2, [{
        key: "result",
        get: function get() {
          if ("getTransactionResponse" in this && this.getTransactionResponse) {
            if ("returnValue" in this.getTransactionResponse) {
              return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
            }
            throw new Error("Transaction failed! Cannot parse result.");
          }
          if (this.sendTransactionResponse) {
            var _this$sendTransaction;
            var errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();
            if (errorResult) {
              throw new SentTransaction2.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(errorResult));
            }
            throw new SentTransaction2.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
          }
          throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
        }
      }]);
    }();
    _SentTransaction = SentTransaction;
    _defineProperty(SentTransaction, "Errors", {
      SendFailed: function(_Error) {
        function SendFailedError() {
          _classCallCheck(this, SendFailedError);
          return _callSuper(this, SendFailedError, arguments);
        }
        _inherits(SendFailedError, _Error);
        return _createClass(SendFailedError);
      }(_wrapNativeSuper(Error)),
      SendResultOnly: function(_Error2) {
        function SendResultOnlyError() {
          _classCallCheck(this, SendResultOnlyError);
          return _callSuper(this, SendResultOnlyError, arguments);
        }
        _inherits(SendResultOnlyError, _Error2);
        return _createClass(SendResultOnlyError);
      }(_wrapNativeSuper(Error)),
      TransactionStillPending: function(_Error3) {
        function TransactionStillPendingError() {
          _classCallCheck(this, TransactionStillPendingError);
          return _callSuper(this, TransactionStillPendingError, arguments);
        }
        _inherits(TransactionStillPendingError, _Error3);
        return _createClass(TransactionStillPendingError);
      }(_wrapNativeSuper(Error))
    });
    _defineProperty(SentTransaction, "init", function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(assembled) {
        var tx, sent;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              tx = new _SentTransaction(assembled);
              _context2.next = 3;
              return tx.send();
            case 3:
              sent = _context2.sent;
              return _context2.abrupt("return", sent);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/assembled_transaction.js
var require_assembled_transaction = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/assembled_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AssembledTransaction = void 0;
    var _stellarBase = require_lib();
    var _rpc = require_rpc();
    var _api = require_api();
    var _transaction = require_transaction2();
    var _rust_result = require_rust_result();
    var _utils = require_utils2();
    var _types = require_types2();
    var _sent_transaction = require_sent_transaction();
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var AssembledTransaction5 = exports.AssembledTransaction = function() {
      function AssembledTransaction6(options) {
        var _this = this, _this$options$simulat, _this$options$allowHt;
        _classCallCheck(this, AssembledTransaction6);
        _defineProperty(this, "simulate", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _ref2, restore, account, result, _this$options$fee, _this$options$args, _this$options$timeout, contract, _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, restore = _ref2.restore;
                if (_this.built) {
                  _context.next = 5;
                  break;
                }
                if (_this.raw) {
                  _context.next = 4;
                  break;
                }
                throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
              case 4:
                _this.built = _this.raw.build();
              case 5:
                restore = restore !== null && restore !== void 0 ? restore : _this.options.restore;
                delete _this.simulationResult;
                delete _this.simulationTransactionData;
                _context.next = 10;
                return _this.server.simulateTransaction(_this.built);
              case 10:
                _this.simulation = _context.sent;
                if (!(restore && _api.Api.isSimulationRestore(_this.simulation))) {
                  _context.next = 25;
                  break;
                }
                _context.next = 14;
                return (0, _utils.getAccount)(_this.options, _this.server);
              case 14:
                account = _context.sent;
                _context.next = 17;
                return _this.restoreFootprint(_this.simulation.restorePreamble, account);
              case 17:
                result = _context.sent;
                if (!(result.status === _api.Api.GetTransactionStatus.SUCCESS)) {
                  _context.next = 24;
                  break;
                }
                contract = new _stellarBase.Contract(_this.options.contractId);
                _this.raw = new _stellarBase.TransactionBuilder(account, {
                  fee: (_this$options$fee = _this.options.fee) !== null && _this$options$fee !== void 0 ? _this$options$fee : _stellarBase.BASE_FEE,
                  networkPassphrase: _this.options.networkPassphrase
                }).addOperation(contract.call.apply(contract, [_this.options.method].concat(_toConsumableArray((_this$options$args = _this.options.args) !== null && _this$options$args !== void 0 ? _this$options$args : [])))).setTimeout((_this$options$timeout = _this.options.timeoutInSeconds) !== null && _this$options$timeout !== void 0 ? _this$options$timeout : _types.DEFAULT_TIMEOUT);
                _context.next = 23;
                return _this.simulate();
              case 23:
                return _context.abrupt("return", _this);
              case 24:
                throw new AssembledTransaction6.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(result)));
              case 25:
                if (_api.Api.isSimulationSuccess(_this.simulation)) {
                  _this.built = (0, _transaction.assembleTransaction)(_this.built, _this.simulation).build();
                }
                return _context.abrupt("return", _this);
              case 27:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        _defineProperty(this, "sign", _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
          var _this$options$timeout2;
          var _ref4, _ref4$force, force, _ref4$signTransaction, signTransaction, sigsNeeded, timeoutInSeconds, signOpts, _yield$signTransactio, signature, error, _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _ref4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref4$force = _ref4.force, force = _ref4$force === void 0 ? false : _ref4$force, _ref4$signTransaction = _ref4.signTransaction, signTransaction = _ref4$signTransaction === void 0 ? _this.options.signTransaction : _ref4$signTransaction;
                if (_this.built) {
                  _context2.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been simulated");
              case 3:
                if (!(!force && _this.isReadCall)) {
                  _context2.next = 5;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
              case 5:
                if (signTransaction) {
                  _context2.next = 7;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
              case 7:
                sigsNeeded = _this.needsNonInvokerSigningBy().filter(function(id) {
                  return !id.startsWith("C");
                });
                if (!sigsNeeded.length) {
                  _context2.next = 10;
                  break;
                }
                throw new AssembledTransaction6.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(sigsNeeded, ". ") + "See `needsNonInvokerSigningBy` for details.");
              case 10:
                timeoutInSeconds = (_this$options$timeout2 = _this.options.timeoutInSeconds) !== null && _this$options$timeout2 !== void 0 ? _this$options$timeout2 : _types.DEFAULT_TIMEOUT;
                _this.built = _stellarBase.TransactionBuilder.cloneFrom(_this.built, {
                  fee: _this.built.fee,
                  timebounds: void 0,
                  sorobanData: _this.simulationData.transactionData
                }).setTimeout(timeoutInSeconds).build();
                signOpts = {
                  networkPassphrase: _this.options.networkPassphrase
                };
                if (_this.options.address) signOpts.address = _this.options.address;
                if (_this.options.submit !== void 0) signOpts.submit = _this.options.submit;
                if (_this.options.submitUrl) signOpts.submitUrl = _this.options.submitUrl;
                _context2.next = 18;
                return signTransaction(_this.built.toXDR(), signOpts);
              case 18:
                _yield$signTransactio = _context2.sent;
                signature = _yield$signTransactio.signedTxXdr;
                error = _yield$signTransactio.error;
                _this.handleWalletError(error);
                _this.signed = _stellarBase.TransactionBuilder.fromXDR(signature, _this.options.networkPassphrase);
              case 23:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        })));
        _defineProperty(this, "signAndSend", _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
          var _ref6, _ref6$force, force, _ref6$signTransaction, signTransaction, originalSubmit, _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _ref6 = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {}, _ref6$force = _ref6.force, force = _ref6$force === void 0 ? false : _ref6$force, _ref6$signTransaction = _ref6.signTransaction, signTransaction = _ref6$signTransaction === void 0 ? _this.options.signTransaction : _ref6$signTransaction;
                if (_this.signed) {
                  _context3.next = 10;
                  break;
                }
                originalSubmit = _this.options.submit;
                if (_this.options.submit) {
                  _this.options.submit = false;
                }
                _context3.prev = 4;
                _context3.next = 7;
                return _this.sign({
                  force,
                  signTransaction
                });
              case 7:
                _context3.prev = 7;
                _this.options.submit = originalSubmit;
                return _context3.finish(7);
              case 10:
                return _context3.abrupt("return", _this.send());
              case 11:
              case "end":
                return _context3.stop();
            }
          }, _callee3, null, [[4, , 7, 10]]);
        })));
        _defineProperty(this, "needsNonInvokerSigningBy", function() {
          var _rawInvokeHostFunctio;
          var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$includeAlreadyS = _ref7.includeAlreadySigned, includeAlreadySigned = _ref7$includeAlreadyS === void 0 ? false : _ref7$includeAlreadyS;
          if (!_this.built) {
            throw new Error("Transaction has not yet been simulated");
          }
          if (!("operations" in _this.built)) {
            throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(_this.built)));
          }
          var rawInvokeHostFunctionOp = _this.built.operations[0];
          return _toConsumableArray(new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(function(entry) {
            return entry.credentials().switch() === _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === "scvVoid");
          }).map(function(entry) {
            return _stellarBase.Address.fromScAddress(entry.credentials().address().address()).toString();
          })));
        });
        _defineProperty(this, "signAuthEntries", _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
          var _rawInvokeHostFunctio2;
          var _ref9, _ref9$expiration, expiration, _ref9$signAuthEntry, signAuthEntry, _ref9$address, address, _ref9$authorizeEntry, authorizeEntry, needsNonInvokerSigningBy, rawInvokeHostFunctionOp, authEntries, _iterator, _step, _loop, _ret, _args7 = arguments;
          return _regeneratorRuntime().wrap(function _callee6$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _ref9 = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {}, _ref9$expiration = _ref9.expiration, expiration = _ref9$expiration === void 0 ? _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _this.server.getLatestLedger();
                      case 2:
                        _context4.t0 = _context4.sent.sequence;
                        return _context4.abrupt("return", _context4.t0 + 100);
                      case 4:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }))() : _ref9$expiration, _ref9$signAuthEntry = _ref9.signAuthEntry, signAuthEntry = _ref9$signAuthEntry === void 0 ? _this.options.signAuthEntry : _ref9$signAuthEntry, _ref9$address = _ref9.address, address = _ref9$address === void 0 ? _this.options.publicKey : _ref9$address, _ref9$authorizeEntry = _ref9.authorizeEntry, authorizeEntry = _ref9$authorizeEntry === void 0 ? _stellarBase.authorizeEntry : _ref9$authorizeEntry;
                if (_this.built) {
                  _context7.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been assembled or simulated");
              case 3:
                if (!(authorizeEntry === _stellarBase.authorizeEntry)) {
                  _context7.next = 11;
                  break;
                }
                needsNonInvokerSigningBy = _this.needsNonInvokerSigningBy();
                if (!(needsNonInvokerSigningBy.length === 0)) {
                  _context7.next = 7;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
              case 7:
                if (!(needsNonInvokerSigningBy.indexOf(address !== null && address !== void 0 ? address : "") === -1)) {
                  _context7.next = 9;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(address, '"'));
              case 9:
                if (signAuthEntry) {
                  _context7.next = 11;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
              case 11:
                rawInvokeHostFunctionOp = _this.built.operations[0];
                authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];
                _iterator = _createForOfIteratorHelper(authEntries.entries());
                _context7.prev = 14;
                _loop = _regeneratorRuntime().mark(function _loop2() {
                  var _step$value, i, entry, credentials, authEntryAddress, sign;
                  return _regeneratorRuntime().wrap(function _loop$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _step$value = _slicedToArray(_step.value, 2), i = _step$value[0], entry = _step$value[1];
                        credentials = _stellarBase.xdr.SorobanCredentials.fromXDR(entry.credentials().toXDR());
                        if (!(credentials.switch() !== _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress())) {
                          _context6.next = 4;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 4:
                        authEntryAddress = _stellarBase.Address.fromScAddress(credentials.address().address()).toString();
                        if (!(authEntryAddress !== address)) {
                          _context6.next = 7;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 7:
                        sign = signAuthEntry !== null && signAuthEntry !== void 0 ? signAuthEntry : Promise.resolve;
                        _context6.t0 = authorizeEntry;
                        _context6.t1 = entry;
                        _context6.t2 = function() {
                          var _ref11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(preimage) {
                            var _yield$sign, signedAuthEntry, error;
                            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                              while (1) switch (_context5.prev = _context5.next) {
                                case 0:
                                  _context5.next = 2;
                                  return sign(preimage.toXDR("base64"), {
                                    address
                                  });
                                case 2:
                                  _yield$sign = _context5.sent;
                                  signedAuthEntry = _yield$sign.signedAuthEntry;
                                  error = _yield$sign.error;
                                  _this.handleWalletError(error);
                                  return _context5.abrupt("return", Buffer.from(signedAuthEntry, "base64"));
                                case 7:
                                case "end":
                                  return _context5.stop();
                              }
                            }, _callee5);
                          }));
                          return function(_x) {
                            return _ref11.apply(this, arguments);
                          };
                        }();
                        _context6.next = 13;
                        return expiration;
                      case 13:
                        _context6.t3 = _context6.sent;
                        _context6.t4 = _this.options.networkPassphrase;
                        _context6.next = 17;
                        return (0, _context6.t0)(_context6.t1, _context6.t2, _context6.t3, _context6.t4);
                      case 17:
                        authEntries[i] = _context6.sent;
                      case 18:
                      case "end":
                        return _context6.stop();
                    }
                  }, _loop2);
                });
                _iterator.s();
              case 17:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 24;
                  break;
                }
                return _context7.delegateYield(_loop(), "t0", 19);
              case 19:
                _ret = _context7.t0;
                if (!(_ret === 0)) {
                  _context7.next = 22;
                  break;
                }
                return _context7.abrupt("continue", 22);
              case 22:
                _context7.next = 17;
                break;
              case 24:
                _context7.next = 29;
                break;
              case 26:
                _context7.prev = 26;
                _context7.t1 = _context7["catch"](14);
                _iterator.e(_context7.t1);
              case 29:
                _context7.prev = 29;
                _iterator.f();
                return _context7.finish(29);
              case 32:
              case "end":
                return _context7.stop();
            }
          }, _callee6, null, [[14, 26, 29, 32]]);
        })));
        this.options = options;
        this.options.simulate = (_this$options$simulat = this.options.simulate) !== null && _this$options$simulat !== void 0 ? _this$options$simulat : true;
        this.server = new _rpc.Server(this.options.rpcUrl, {
          allowHttp: (_this$options$allowHt = this.options.allowHttp) !== null && _this$options$allowHt !== void 0 ? _this$options$allowHt : false
        });
      }
      return _createClass(AssembledTransaction6, [{
        key: "toJSON",
        value: function toJSON() {
          var _this$built;
          return JSON.stringify({
            method: this.options.method,
            tx: (_this$built = this.built) === null || _this$built === void 0 ? void 0 : _this$built.toXDR(),
            simulationResult: {
              auth: this.simulationData.result.auth.map(function(a) {
                return a.toXDR("base64");
              }),
              retval: this.simulationData.result.retval.toXDR("base64")
            },
            simulationTransactionData: this.simulationData.transactionData.toXDR("base64")
          });
        }
      }, {
        key: "toXDR",
        value: function toXDR() {
          var _this$built2;
          if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
          return (_this$built2 = this.built) === null || _this$built2 === void 0 ? void 0 : _this$built2.toEnvelope().toXDR("base64");
        }
      }, {
        key: "handleWalletError",
        value: function handleWalletError(error) {
          if (!error) return;
          var message = error.message, code = error.code;
          var fullMessage = "".concat(message).concat(error.ext ? " (".concat(error.ext.join(", "), ")") : "");
          switch (code) {
            case -1:
              throw new AssembledTransaction6.Errors.InternalWalletError(fullMessage);
            case -2:
              throw new AssembledTransaction6.Errors.ExternalServiceError(fullMessage);
            case -3:
              throw new AssembledTransaction6.Errors.InvalidClientRequest(fullMessage);
            case -4:
              throw new AssembledTransaction6.Errors.UserRejected(fullMessage);
            default:
              throw new Error("Unhandled error: ".concat(fullMessage));
          }
        }
      }, {
        key: "simulationData",
        get: function get() {
          var _simulation$result;
          if (this.simulationResult && this.simulationTransactionData) {
            return {
              result: this.simulationResult,
              transactionData: this.simulationTransactionData
            };
          }
          var simulation = this.simulation;
          if (!simulation) {
            throw new AssembledTransaction6.Errors.NotYetSimulated("Transaction has not yet been simulated");
          }
          if (_api.Api.isSimulationError(simulation)) {
            throw new AssembledTransaction6.Errors.SimulationFailed('Transaction simulation failed: "'.concat(simulation.error, '"'));
          }
          if (_api.Api.isSimulationRestore(simulation)) {
            throw new AssembledTransaction6.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
          }
          this.simulationResult = (_simulation$result = simulation.result) !== null && _simulation$result !== void 0 ? _simulation$result : {
            auth: [],
            retval: _stellarBase.xdr.ScVal.scvVoid()
          };
          this.simulationTransactionData = simulation.transactionData.build();
          return {
            result: this.simulationResult,
            transactionData: this.simulationTransactionData
          };
        }
      }, {
        key: "result",
        get: function get() {
          try {
            if (!this.simulationData.result) {
              throw new Error("No simulation result!");
            }
            return this.options.parseResultXdr(this.simulationData.result.retval);
          } catch (e) {
            if (!(0, _utils.implementsToString)(e)) throw e;
            var err = this.parseError(e.toString());
            if (err) return err;
            throw e;
          }
        }
      }, {
        key: "parseError",
        value: function parseError(errorMessage) {
          if (!this.options.errorTypes) return void 0;
          var match = errorMessage.match(_utils.contractErrorPattern);
          if (!match) return void 0;
          var i = parseInt(match[1], 10);
          var err = this.options.errorTypes[i];
          if (!err) return void 0;
          return new _rust_result.Err(err);
        }
      }, {
        key: "send",
        value: function() {
          var _send = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var sent;
            return _regeneratorRuntime().wrap(function _callee7$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  if (this.signed) {
                    _context8.next = 2;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 2:
                  _context8.next = 4;
                  return _sent_transaction.SentTransaction.init(this);
                case 4:
                  sent = _context8.sent;
                  return _context8.abrupt("return", sent);
                case 6:
                case "end":
                  return _context8.stop();
              }
            }, _callee7, this);
          }));
          function send() {
            return _send.apply(this, arguments);
          }
          return send;
        }()
      }, {
        key: "isReadCall",
        get: function get() {
          var authsCount = this.simulationData.result.auth.length;
          var writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;
          return authsCount === 0 && writeLength === 0;
        }
      }, {
        key: "restoreFootprint",
        value: function() {
          var _restoreFootprint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(restorePreamble, account) {
            var restoreTx, sentTransaction;
            return _regeneratorRuntime().wrap(function _callee8$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  if (this.options.signTransaction) {
                    _context9.next = 2;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 2:
                  if (!(account !== null && account !== void 0)) {
                    _context9.next = 6;
                    break;
                  }
                  _context9.t0 = account;
                  _context9.next = 9;
                  break;
                case 6:
                  _context9.next = 8;
                  return (0, _utils.getAccount)(this.options, this.server);
                case 8:
                  _context9.t0 = _context9.sent;
                case 9:
                  account = _context9.t0;
                  _context9.next = 12;
                  return AssembledTransaction6.buildFootprintRestoreTransaction(_objectSpread({}, this.options), restorePreamble.transactionData, account, restorePreamble.minResourceFee);
                case 12:
                  restoreTx = _context9.sent;
                  _context9.next = 15;
                  return restoreTx.signAndSend();
                case 15:
                  sentTransaction = _context9.sent;
                  if (sentTransaction.getTransactionResponse) {
                    _context9.next = 18;
                    break;
                  }
                  throw new AssembledTransaction6.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(sentTransaction)));
                case 18:
                  return _context9.abrupt("return", sentTransaction.getTransactionResponse);
                case 19:
                case "end":
                  return _context9.stop();
              }
            }, _callee8, this);
          }));
          function restoreFootprint(_x2, _x3) {
            return _restoreFootprint.apply(this, arguments);
          }
          return restoreFootprint;
        }()
      }], [{
        key: "fromJSON",
        value: function fromJSON(options, _ref12) {
          var tx = _ref12.tx, simulationResult = _ref12.simulationResult, simulationTransactionData = _ref12.simulationTransactionData;
          var txn = new AssembledTransaction6(options);
          txn.built = _stellarBase.TransactionBuilder.fromXDR(tx, options.networkPassphrase);
          txn.simulationResult = {
            auth: simulationResult.auth.map(function(a) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
            }),
            retval: _stellarBase.xdr.ScVal.fromXDR(simulationResult.retval, "base64")
          };
          txn.simulationTransactionData = _stellarBase.xdr.SorobanTransactionData.fromXDR(simulationTransactionData, "base64");
          return txn;
        }
      }, {
        key: "fromXDR",
        value: function fromXDR(options, encodedXDR, spec) {
          var _operation$func;
          var envelope = _stellarBase.xdr.TransactionEnvelope.fromXDR(encodedXDR, "base64");
          var built = _stellarBase.TransactionBuilder.fromXDR(envelope, options.networkPassphrase);
          var operation = built.operations[0];
          if (!(operation !== null && operation !== void 0 && (_operation$func = operation.func) !== null && _operation$func !== void 0 && _operation$func.value) || typeof operation.func.value !== "function") {
            throw new Error("Could not extract the method from the transaction envelope.");
          }
          var invokeContractArgs = operation.func.value();
          if (!(invokeContractArgs !== null && invokeContractArgs !== void 0 && invokeContractArgs.functionName)) {
            throw new Error("Could not extract the method name from the transaction envelope.");
          }
          var method = invokeContractArgs.functionName().toString("utf-8");
          var txn = new AssembledTransaction6(_objectSpread(_objectSpread({}, options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return spec.funcResToNative(method, result);
            }
          }));
          txn.built = built;
          return txn;
        }
      }, {
        key: "build",
        value: function build(options) {
          var _options$args;
          var contract = new _stellarBase.Contract(options.contractId);
          return AssembledTransaction6.buildWithOp(contract.call.apply(contract, [options.method].concat(_toConsumableArray((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))), options);
        }
      }, {
        key: "buildWithOp",
        value: function() {
          var _buildWithOp = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(operation, options) {
            var _options$fee, _options$timeoutInSec;
            var tx, account;
            return _regeneratorRuntime().wrap(function _callee9$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  tx = new AssembledTransaction6(options);
                  _context10.next = 3;
                  return (0, _utils.getAccount)(options, tx.server);
                case 3:
                  account = _context10.sent;
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee: (_options$fee = options.fee) !== null && _options$fee !== void 0 ? _options$fee : _stellarBase.BASE_FEE,
                    networkPassphrase: options.networkPassphrase
                  }).setTimeout((_options$timeoutInSec = options.timeoutInSeconds) !== null && _options$timeoutInSec !== void 0 ? _options$timeoutInSec : _types.DEFAULT_TIMEOUT).addOperation(operation);
                  if (!options.simulate) {
                    _context10.next = 8;
                    break;
                  }
                  _context10.next = 8;
                  return tx.simulate();
                case 8:
                  return _context10.abrupt("return", tx);
                case 9:
                case "end":
                  return _context10.stop();
              }
            }, _callee9);
          }));
          function buildWithOp(_x4, _x5) {
            return _buildWithOp.apply(this, arguments);
          }
          return buildWithOp;
        }()
      }, {
        key: "buildFootprintRestoreTransaction",
        value: function() {
          var _buildFootprintRestoreTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(options, sorobanData, account, fee) {
            var _options$timeoutInSec2;
            var tx;
            return _regeneratorRuntime().wrap(function _callee10$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  tx = new AssembledTransaction6(options);
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee,
                    networkPassphrase: options.networkPassphrase
                  }).setSorobanData(sorobanData instanceof _stellarBase.SorobanDataBuilder ? sorobanData.build() : sorobanData).addOperation(_stellarBase.Operation.restoreFootprint({})).setTimeout((_options$timeoutInSec2 = options.timeoutInSeconds) !== null && _options$timeoutInSec2 !== void 0 ? _options$timeoutInSec2 : _types.DEFAULT_TIMEOUT);
                  _context11.next = 4;
                  return tx.simulate({
                    restore: false
                  });
                case 4:
                  return _context11.abrupt("return", tx);
                case 5:
                case "end":
                  return _context11.stop();
              }
            }, _callee10);
          }));
          function buildFootprintRestoreTransaction(_x6, _x7, _x8, _x9) {
            return _buildFootprintRestoreTransaction.apply(this, arguments);
          }
          return buildFootprintRestoreTransaction;
        }()
      }]);
    }();
    _defineProperty(AssembledTransaction5, "Errors", {
      ExpiredState: function(_Error) {
        function ExpiredStateError() {
          _classCallCheck(this, ExpiredStateError);
          return _callSuper(this, ExpiredStateError, arguments);
        }
        _inherits(ExpiredStateError, _Error);
        return _createClass(ExpiredStateError);
      }(_wrapNativeSuper(Error)),
      RestorationFailure: function(_Error2) {
        function RestoreFailureError() {
          _classCallCheck(this, RestoreFailureError);
          return _callSuper(this, RestoreFailureError, arguments);
        }
        _inherits(RestoreFailureError, _Error2);
        return _createClass(RestoreFailureError);
      }(_wrapNativeSuper(Error)),
      NeedsMoreSignatures: function(_Error3) {
        function NeedsMoreSignaturesError() {
          _classCallCheck(this, NeedsMoreSignaturesError);
          return _callSuper(this, NeedsMoreSignaturesError, arguments);
        }
        _inherits(NeedsMoreSignaturesError, _Error3);
        return _createClass(NeedsMoreSignaturesError);
      }(_wrapNativeSuper(Error)),
      NoSignatureNeeded: function(_Error4) {
        function NoSignatureNeededError() {
          _classCallCheck(this, NoSignatureNeededError);
          return _callSuper(this, NoSignatureNeededError, arguments);
        }
        _inherits(NoSignatureNeededError, _Error4);
        return _createClass(NoSignatureNeededError);
      }(_wrapNativeSuper(Error)),
      NoUnsignedNonInvokerAuthEntries: function(_Error5) {
        function NoUnsignedNonInvokerAuthEntriesError() {
          _classCallCheck(this, NoUnsignedNonInvokerAuthEntriesError);
          return _callSuper(this, NoUnsignedNonInvokerAuthEntriesError, arguments);
        }
        _inherits(NoUnsignedNonInvokerAuthEntriesError, _Error5);
        return _createClass(NoUnsignedNonInvokerAuthEntriesError);
      }(_wrapNativeSuper(Error)),
      NoSigner: function(_Error6) {
        function NoSignerError() {
          _classCallCheck(this, NoSignerError);
          return _callSuper(this, NoSignerError, arguments);
        }
        _inherits(NoSignerError, _Error6);
        return _createClass(NoSignerError);
      }(_wrapNativeSuper(Error)),
      NotYetSimulated: function(_Error7) {
        function NotYetSimulatedError() {
          _classCallCheck(this, NotYetSimulatedError);
          return _callSuper(this, NotYetSimulatedError, arguments);
        }
        _inherits(NotYetSimulatedError, _Error7);
        return _createClass(NotYetSimulatedError);
      }(_wrapNativeSuper(Error)),
      FakeAccount: function(_Error8) {
        function FakeAccountError() {
          _classCallCheck(this, FakeAccountError);
          return _callSuper(this, FakeAccountError, arguments);
        }
        _inherits(FakeAccountError, _Error8);
        return _createClass(FakeAccountError);
      }(_wrapNativeSuper(Error)),
      SimulationFailed: function(_Error9) {
        function SimulationFailedError() {
          _classCallCheck(this, SimulationFailedError);
          return _callSuper(this, SimulationFailedError, arguments);
        }
        _inherits(SimulationFailedError, _Error9);
        return _createClass(SimulationFailedError);
      }(_wrapNativeSuper(Error)),
      InternalWalletError: function(_Error10) {
        function InternalWalletError() {
          _classCallCheck(this, InternalWalletError);
          return _callSuper(this, InternalWalletError, arguments);
        }
        _inherits(InternalWalletError, _Error10);
        return _createClass(InternalWalletError);
      }(_wrapNativeSuper(Error)),
      ExternalServiceError: function(_Error11) {
        function ExternalServiceError() {
          _classCallCheck(this, ExternalServiceError);
          return _callSuper(this, ExternalServiceError, arguments);
        }
        _inherits(ExternalServiceError, _Error11);
        return _createClass(ExternalServiceError);
      }(_wrapNativeSuper(Error)),
      InvalidClientRequest: function(_Error12) {
        function InvalidClientRequestError() {
          _classCallCheck(this, InvalidClientRequestError);
          return _callSuper(this, InvalidClientRequestError, arguments);
        }
        _inherits(InvalidClientRequestError, _Error12);
        return _createClass(InvalidClientRequestError);
      }(_wrapNativeSuper(Error)),
      UserRejected: function(_Error13) {
        function UserRejectedError() {
          _classCallCheck(this, UserRejectedError);
          return _callSuper(this, UserRejectedError, arguments);
        }
        _inherits(UserRejectedError, _Error13);
        return _createClass(UserRejectedError);
      }(_wrapNativeSuper(Error))
    });
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/basic_node_signer.js
var require_basic_node_signer = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/basic_node_signer.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.basicNodeSigner = void 0;
    var _stellarBase = require_lib();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var basicNodeSigner2 = exports.basicNodeSigner = function basicNodeSigner3(keypair, networkPassphrase) {
      return {
        signTransaction: function() {
          var _signTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(xdr3, opts) {
            var t;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  t = _stellarBase.TransactionBuilder.fromXDR(xdr3, (opts === null || opts === void 0 ? void 0 : opts.networkPassphrase) || networkPassphrase);
                  t.sign(keypair);
                  return _context.abrupt("return", {
                    signedTxXdr: t.toXDR(),
                    signerAddress: keypair.publicKey()
                  });
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function signTransaction(_x, _x2) {
            return _signTransaction.apply(this, arguments);
          }
          return signTransaction;
        }(),
        signAuthEntry: function() {
          var _signAuthEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(authEntry) {
            var signedAuthEntry;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  signedAuthEntry = keypair.sign((0, _stellarBase.hash)(Buffer.from(authEntry, "base64"))).toString("base64");
                  return _context2.abrupt("return", {
                    signedAuthEntry,
                    signerAddress: keypair.publicKey()
                  });
                case 2:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function signAuthEntry(_x3) {
            return _signAuthEntry.apply(this, arguments);
          }
          return signAuthEntry;
        }()
      };
    };
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/spec.js
var require_spec = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/spec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Spec = void 0;
    var _stellarBase = require_lib();
    var _rust_result = require_rust_result();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function enumToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        var title = aCase.name().toString();
        var desc = aCase.doc().toString();
        oneOf.push({
          description: desc,
          title,
          enum: [aCase.value()],
          type: "number"
        });
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    function isNumeric(field) {
      return /^\d+$/.test(field.name().toString());
    }
    function readObj(args, input) {
      var inputName = input.name().toString();
      var entry = Object.entries(args).find(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), name = _ref2[0];
        return name === inputName;
      });
      if (!entry) {
        throw new Error("Missing field ".concat(inputName));
      }
      return entry[1];
    }
    function findCase(name) {
      return function matches(entry) {
        switch (entry.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var tuple = entry.tupleCase();
            return tuple.name().toString() === name;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var voidCase = entry.voidCase();
            return voidCase.name().toString() === name;
          }
          default:
            return false;
        }
      };
    }
    function stringToScVal(str, ty) {
      switch (ty.value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value:
          return _stellarBase.xdr.ScVal.scvString(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value:
          return _stellarBase.xdr.ScVal.scvSymbol(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value:
          return _stellarBase.Address.fromString(str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
          return new _stellarBase.XdrLargeInt("u64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
          return new _stellarBase.XdrLargeInt("i64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
          return new _stellarBase.XdrLargeInt("u128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
          return new _stellarBase.XdrLargeInt("i128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
          return new _stellarBase.XdrLargeInt("u256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
          return new _stellarBase.XdrLargeInt("i256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value:
          return _stellarBase.xdr.ScVal.scvBytes(Buffer.from(str, "base64"));
        default:
          throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
      }
    }
    var PRIMITIVE_DEFINITONS = {
      U32: {
        type: "integer",
        minimum: 0,
        maximum: 4294967295
      },
      I32: {
        type: "integer",
        minimum: -2147483648,
        maximum: 2147483647
      },
      U64: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      I64: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 21
      },
      U128: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 39
      },
      I128: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 40
      },
      U256: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 78
      },
      I256: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 79
      },
      Address: {
        type: "string",
        format: "address",
        description: "Address can be a public key or contract id"
      },
      ScString: {
        type: "string",
        description: "ScString is a string"
      },
      ScSymbol: {
        type: "string",
        description: "ScSymbol is a string"
      },
      DataUrl: {
        type: "string",
        pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$"
      }
    };
    function typeRef(typeDef) {
      var t = typeDef.switch();
      var value = t.value;
      var ref;
      switch (value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal().value: {
          ref = "Val";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool().value: {
          return {
            type: "boolean"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value: {
          return {
            type: "null"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeError().value: {
          ref = "Error";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value: {
          ref = "U32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value: {
          ref = "I32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value: {
          ref = "U64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value: {
          ref = "I64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value: {
          throw new Error("Timepoint type not supported");
          ref = "Timepoint";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
          throw new Error("Duration not supported");
          ref = "Duration";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value: {
          ref = "U128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value: {
          ref = "I128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value: {
          ref = "U256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
          ref = "I256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value: {
          ref = "DataUrl";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value: {
          ref = "ScString";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value: {
          ref = "ScSymbol";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value: {
          ref = "Address";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value: {
          var opt = typeDef.option();
          return typeRef(opt.valueType());
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult().value: {
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
          var arr = typeDef.vec();
          var reference = typeRef(arr.elementType());
          return {
            type: "array",
            items: reference
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
          var map = typeDef.map();
          var items = [typeRef(map.keyType()), typeRef(map.valueType())];
          return {
            type: "array",
            items: {
              type: "array",
              items,
              minItems: 2,
              maxItems: 2
            }
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
          var tuple = typeDef.tuple();
          var minItems = tuple.valueTypes().length;
          var maxItems = minItems;
          var _items = tuple.valueTypes().map(typeRef);
          return {
            type: "array",
            items: _items,
            minItems,
            maxItems
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
          var _arr = typeDef.bytesN();
          return {
            $ref: "#/definitions/DataUrl",
            maxLength: _arr.n()
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value: {
          var udt = typeDef.udt();
          ref = udt.name().toString();
          break;
        }
      }
      return {
        $ref: "#/definitions/".concat(ref)
      };
    }
    function isRequired(typeDef) {
      return typeDef.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeOption().value;
    }
    function argsAndRequired(input) {
      var properties = {};
      var required = [];
      input.forEach(function(arg) {
        var aType = arg.type();
        var name = arg.name().toString();
        properties[name] = typeRef(aType);
        if (isRequired(aType)) {
          required.push(name);
        }
      });
      var res = {
        properties
      };
      if (required.length > 0) {
        res.required = required;
      }
      return res;
    }
    function structToJsonSchema(udt) {
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error("mixed numeric and non-numeric field names are not allowed");
        }
        var items = fields.map(function(_, i) {
          return typeRef(fields[i].type());
        });
        return {
          type: "array",
          items,
          minItems: fields.length,
          maxItems: fields.length
        };
      }
      var description = udt.doc().toString();
      var _argsAndRequired = argsAndRequired(fields), properties = _argsAndRequired.properties, required = _argsAndRequired.required;
      properties.additionalProperties = false;
      return {
        description,
        properties,
        required,
        type: "object"
      };
    }
    function functionToJsonSchema(func) {
      var _argsAndRequired2 = argsAndRequired(func.inputs()), properties = _argsAndRequired2.properties, required = _argsAndRequired2.required;
      var args = {
        additionalProperties: false,
        properties,
        type: "object"
      };
      if ((required === null || required === void 0 ? void 0 : required.length) > 0) {
        args.required = required;
      }
      var input = {
        properties: {
          args
        }
      };
      var outputs = func.outputs();
      var output = outputs.length > 0 ? typeRef(outputs[0]) : typeRef(_stellarBase.xdr.ScSpecTypeDef.scSpecTypeVoid());
      var description = func.doc().toString();
      if (description.length > 0) {
        input.description = description;
      }
      input.additionalProperties = false;
      output.additionalProperties = false;
      return {
        input,
        output
      };
    }
    function unionToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        switch (aCase.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var c = aCase.voidCase();
            var title = c.name().toString();
            oneOf.push({
              type: "object",
              title,
              properties: {
                tag: title
              },
              additionalProperties: false,
              required: ["tag"]
            });
            break;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var _c = aCase.tupleCase();
            var _title = _c.name().toString();
            oneOf.push({
              type: "object",
              title: _title,
              properties: {
                tag: _title,
                values: {
                  type: "array",
                  items: _c.type().map(typeRef)
                }
              },
              required: ["tag", "values"],
              additionalProperties: false
            });
          }
        }
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    var Spec = exports.Spec = function() {
      function Spec2(entries) {
        _classCallCheck(this, Spec2);
        _defineProperty(this, "entries", []);
        if (entries.length === 0) {
          throw new Error("Contract spec must have at least one entry");
        }
        var entry = entries[0];
        if (typeof entry === "string") {
          this.entries = entries.map(function(s) {
            return _stellarBase.xdr.ScSpecEntry.fromXDR(s, "base64");
          });
        } else {
          this.entries = entries;
        }
      }
      return _createClass(Spec2, [{
        key: "funcs",
        value: function funcs() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(entry) {
            return entry.functionV0();
          });
        }
      }, {
        key: "getFunc",
        value: function getFunc(name) {
          var entry = this.findEntry(name);
          if (entry.switch().value !== _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
            throw new Error("".concat(name, " is not a function"));
          }
          return entry.functionV0();
        }
      }, {
        key: "funcArgsToScVals",
        value: function funcArgsToScVals(name, args) {
          var _this = this;
          var fn = this.getFunc(name);
          return fn.inputs().map(function(input) {
            return _this.nativeToScVal(readObj(args, input), input.type());
          });
        }
      }, {
        key: "funcResToNative",
        value: function funcResToNative(name, val_or_base64) {
          var val = typeof val_or_base64 === "string" ? _stellarBase.xdr.ScVal.fromXDR(val_or_base64, "base64") : val_or_base64;
          var func = this.getFunc(name);
          var outputs = func.outputs();
          if (outputs.length === 0) {
            var type = val.switch();
            if (type.value !== _stellarBase.xdr.ScValType.scvVoid().value) {
              throw new Error("Expected void, got ".concat(type.name));
            }
            return null;
          }
          if (outputs.length > 1) {
            throw new Error("Multiple outputs not supported");
          }
          var output = outputs[0];
          if (output.switch().value === _stellarBase.xdr.ScSpecType.scSpecTypeResult().value) {
            return new _rust_result.Ok(this.scValToNative(val, output.result().okType()));
          }
          return this.scValToNative(val, output);
        }
      }, {
        key: "findEntry",
        value: function findEntry(name) {
          var entry = this.entries.find(function(e) {
            return e.value().name().toString() === name;
          });
          if (!entry) {
            throw new Error("no such entry: ".concat(name));
          }
          return entry;
        }
      }, {
        key: "nativeToScVal",
        value: function nativeToScVal(val, ty) {
          var _this2 = this;
          var t = ty.switch();
          var value = t.value;
          if (t.value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            var udt = ty.udt();
            return this.nativeToUdt(val, udt.name().toString());
          }
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
            var opt = ty.option();
            if (val === void 0) {
              return _stellarBase.xdr.ScVal.scvVoid();
            }
            return this.nativeToScVal(val, opt.valueType());
          }
          switch (_typeof(val)) {
            case "object": {
              var _val$constructor$name, _val$constructor;
              if (val === null) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                    return _stellarBase.xdr.ScVal.scvVoid();
                  default:
                    throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
                }
              }
              if (val instanceof _stellarBase.xdr.ScVal) {
                return val;
              }
              if (val instanceof _stellarBase.Address) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.toScVal();
              }
              if (val instanceof _stellarBase.Contract) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.address().toScVal();
              }
              if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
                var copy = Uint8Array.from(val);
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
                    var bytesN = ty.bytesN();
                    if (copy.length !== bytesN.n()) {
                      throw new TypeError("expected ".concat(bytesN.n(), " bytes, but got ").concat(copy.length));
                    }
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  default:
                    throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(val)) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
                    var vec = ty.vec();
                    var elementType = vec.elementType();
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2) {
                      return _this2.nativeToScVal(v2, elementType);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
                    var tup = ty.tuple();
                    var valTypes = tup.valueTypes();
                    if (val.length !== valTypes.length) {
                      throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                    }
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2, i) {
                      return _this2.nativeToScVal(v2, valTypes[i]);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
                    var map = ty.map();
                    var keyType = map.keyType();
                    var valueType = map.valueType();
                    return _stellarBase.xdr.ScVal.scvMap(val.map(function(entry) {
                      var key2 = _this2.nativeToScVal(entry[0], keyType);
                      var mapVal = _this2.nativeToScVal(entry[1], valueType);
                      return new _stellarBase.xdr.ScMapEntry({
                        key: key2,
                        val: mapVal
                      });
                    }));
                  }
                  default:
                    throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
                }
              }
              if (val.constructor === Map) {
                if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                  throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
                }
                var scMap = ty.map();
                var _map = val;
                var entries = [];
                var values = _map.entries();
                var res = values.next();
                while (!res.done) {
                  var _res$value = _slicedToArray(res.value, 2), k = _res$value[0], v = _res$value[1];
                  var key = this.nativeToScVal(k, scMap.keyType());
                  var mapval = this.nativeToScVal(v, scMap.valueType());
                  entries.push(new _stellarBase.xdr.ScMapEntry({
                    key,
                    val: mapval
                  }));
                  res = values.next();
                }
                return _stellarBase.xdr.ScVal.scvMap(entries);
              }
              if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
                var _val$constructor2;
                throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
              }
              throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
            }
            case "number":
            case "bigint": {
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value:
                  return _stellarBase.xdr.ScVal.scvU32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value:
                  return _stellarBase.xdr.ScVal.scvI32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
                  var intType = t.name.substring(10).toLowerCase();
                  return new _stellarBase.XdrLargeInt(intType, val).toScVal();
                }
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
              }
            }
            case "string":
              return stringToScVal(val, t);
            case "boolean": {
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeBool().value) {
                throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
              }
              return _stellarBase.xdr.ScVal.scvBool(val);
            }
            case "undefined": {
              if (!ty) {
                return _stellarBase.xdr.ScVal.scvVoid();
              }
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value:
                  return _stellarBase.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
              }
            }
            case "function":
              return this.nativeToScVal(val(), ty);
            default:
              throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
          }
        }
      }, {
        key: "nativeToUdt",
        value: function nativeToUdt(val, name) {
          var entry = this.findEntry(name);
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if (typeof val !== "number") {
                throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(_typeof(val)));
              }
              return this.nativeToEnum(val, entry.udtEnumV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(val, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(val, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(name));
          }
        }
      }, {
        key: "nativeToUnion",
        value: function nativeToUnion(val, union_) {
          var _this3 = this;
          var entryName = val.tag;
          var caseFound = union_.cases().find(function(entry) {
            var caseN = entry.value().name().toString();
            return caseN === entryName;
          });
          if (!caseFound) {
            throw new TypeError("no such enum entry: ".concat(entryName, " in ").concat(union_));
          }
          var key = _stellarBase.xdr.ScVal.scvSymbol(entryName);
          switch (caseFound.switch()) {
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0(): {
              return _stellarBase.xdr.ScVal.scvVec([key]);
            }
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0(): {
              var types = caseFound.tupleCase().type();
              if (Array.isArray(val.values)) {
                if (val.values.length !== types.length) {
                  throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
                }
                var scvals = val.values.map(function(v, i) {
                  return _this3.nativeToScVal(v, types[i]);
                });
                scvals.unshift(key);
                return _stellarBase.xdr.ScVal.scvVec(scvals);
              }
              throw new Error("failed to parse union case ".concat(caseFound, " with ").concat(val));
            }
            default:
              throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
          }
        }
      }, {
        key: "nativeToStruct",
        value: function nativeToStruct(val, struct) {
          var _this4 = this;
          var fields = struct.fields();
          if (fields.some(isNumeric)) {
            if (!fields.every(isNumeric)) {
              throw new Error("mixed numeric and non-numeric field names are not allowed");
            }
            return _stellarBase.xdr.ScVal.scvVec(fields.map(function(_, i) {
              return _this4.nativeToScVal(val[i], fields[i].type());
            }));
          }
          return _stellarBase.xdr.ScVal.scvMap(fields.map(function(field) {
            var name = field.name().toString();
            return new _stellarBase.xdr.ScMapEntry({
              key: _this4.nativeToScVal(name, _stellarBase.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
              val: _this4.nativeToScVal(val[name], field.type())
            });
          }));
        }
      }, {
        key: "nativeToEnum",
        value: function nativeToEnum(val, enum_) {
          if (enum_.cases().some(function(entry) {
            return entry.value() === val;
          })) {
            return _stellarBase.xdr.ScVal.scvU32(val);
          }
          throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
        }
      }, {
        key: "scValStrToNative",
        value: function scValStrToNative(scv, typeDef) {
          return this.scValToNative(_stellarBase.xdr.ScVal.fromXDR(scv, "base64"), typeDef);
        }
      }, {
        key: "scValToNative",
        value: function scValToNative(scv, typeDef) {
          var _this5 = this;
          var t = typeDef.switch();
          var value = t.value;
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            return this.scValUdtToNative(scv, typeDef.udt());
          }
          switch (scv.switch().value) {
            case _stellarBase.xdr.ScValType.scvVoid().value:
              return void 0;
            case _stellarBase.xdr.ScValType.scvU64().value:
            case _stellarBase.xdr.ScValType.scvI64().value:
            case _stellarBase.xdr.ScValType.scvU128().value:
            case _stellarBase.xdr.ScValType.scvI128().value:
            case _stellarBase.xdr.ScValType.scvU256().value:
            case _stellarBase.xdr.ScValType.scvI256().value:
              return (0, _stellarBase.scValToBigInt)(scv);
            case _stellarBase.xdr.ScValType.scvVec().value: {
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeVec().value) {
                var _scv$vec;
                var vec = typeDef.vec();
                return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function(elm) {
                  return _this5.scValToNative(elm, vec.elementType());
                });
              }
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value) {
                var _scv$vec2;
                var tuple = typeDef.tuple();
                var valTypes = tuple.valueTypes();
                return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function(elm, i) {
                  return _this5.scValToNative(elm, valTypes[i]);
                });
              }
              throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
            }
            case _stellarBase.xdr.ScValType.scvAddress().value:
              return _stellarBase.Address.fromScVal(scv).toString();
            case _stellarBase.xdr.ScValType.scvMap().value: {
              var _scv$map;
              var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                var typed = typeDef.map();
                var keyType = typed.keyType();
                var valueType = typed.valueType();
                var res = map.map(function(entry) {
                  return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
                });
                return res;
              }
              throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            case _stellarBase.xdr.ScValType.scvBool().value:
            case _stellarBase.xdr.ScValType.scvU32().value:
            case _stellarBase.xdr.ScValType.scvI32().value:
            case _stellarBase.xdr.ScValType.scvBytes().value:
              return scv.value();
            case _stellarBase.xdr.ScValType.scvString().value:
            case _stellarBase.xdr.ScValType.scvSymbol().value: {
              var _scv$value;
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeString().value && value !== _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value) {
                throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
              }
              return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
            }
            case _stellarBase.xdr.ScValType.scvTimepoint().value:
            case _stellarBase.xdr.ScValType.scvDuration().value:
              return (0, _stellarBase.scValToBigInt)(_stellarBase.xdr.ScVal.scvU64(scv.u64()));
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
          }
        }
      }, {
        key: "scValUdtToNative",
        value: function scValUdtToNative(scv, udt) {
          var entry = this.findEntry(udt.name().toString());
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(scv);
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(scv, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(scv, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
          }
        }
      }, {
        key: "unionToNative",
        value: function unionToNative(val, udt) {
          var _this6 = this;
          var vec = val.vec();
          if (!vec) {
            throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
          }
          if (vec.length === 0 && udt.cases.length !== 0) {
            throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
          }
          var name = vec[0].sym().toString();
          if (vec[0].switch().value !== _stellarBase.xdr.ScValType.scvSymbol().value) {
            throw new Error("{vec[0]} is not a symbol");
          }
          var entry = udt.cases().find(findCase(name));
          if (!entry) {
            throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
          }
          var res = {
            tag: name
          };
          if (entry.switch().value === _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var tuple = entry.tupleCase();
            var ty = tuple.type();
            var values = ty.map(function(e, i) {
              return _this6.scValToNative(vec[i + 1], e);
            });
            res.values = values;
          }
          return res;
        }
      }, {
        key: "structToNative",
        value: function structToNative(val, udt) {
          var _this7 = this, _val$map;
          var res = {};
          var fields = udt.fields();
          if (fields.some(isNumeric)) {
            var _val$vec;
            var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function(entry, i) {
              return _this7.scValToNative(entry, fields[i].type());
            });
            return r;
          }
          (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function(entry, i) {
            var field = fields[i];
            res[field.name().toString()] = _this7.scValToNative(entry.val(), field.type());
          });
          return res;
        }
      }, {
        key: "enumToNative",
        value: function enumToNative(scv) {
          if (scv.switch().value !== _stellarBase.xdr.ScValType.scvU32().value) {
            throw new Error("Enum must have a u32 value");
          }
          var num = scv.u32();
          return num;
        }
      }, {
        key: "errorCases",
        value: function errorCases() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(entry) {
            return entry.value().cases();
          });
        }
      }, {
        key: "jsonSchema",
        value: function jsonSchema(funcName) {
          var definitions = {};
          this.entries.forEach(function(entry) {
            switch (entry.switch().value) {
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value: {
                var udt = entry.udtEnumV0();
                definitions[udt.name().toString()] = enumToJsonSchema(udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value: {
                var _udt = entry.udtStructV0();
                definitions[_udt.name().toString()] = structToJsonSchema(_udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value: {
                var _udt2 = entry.udtUnionV0();
                definitions[_udt2.name().toString()] = unionToJsonSchema(_udt2);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value: {
                var fn = entry.functionV0();
                var fnName = fn.name().toString();
                var _functionToJsonSchema = functionToJsonSchema(fn), input = _functionToJsonSchema.input;
                definitions[fnName] = input;
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value: {
              }
            }
          });
          var res = {
            $schema: "http://json-schema.org/draft-07/schema#",
            definitions: _objectSpread(_objectSpread({}, PRIMITIVE_DEFINITONS), definitions)
          };
          if (funcName) {
            res.$ref = "#/definitions/".concat(funcName);
          }
          return res;
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/client.js
var require_client = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/client.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _stellarBase = require_lib();
    var _spec = require_spec();
    var _rpc = require_rpc();
    var _assembled_transaction = require_assembled_transaction();
    var _utils = require_utils2();
    var _excluded = ["method"];
    var _excluded2 = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o, r, i = _objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var CONSTRUCTOR_FUNC = "__constructor";
    function specFromWasm(_x) {
      return _specFromWasm.apply(this, arguments);
    }
    function _specFromWasm() {
      _specFromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasm) {
        var xdrSections, wasmModule, customData, bufferSection, specEntryArray, spec;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return WebAssembly.compile(wasm);
            case 3:
              wasmModule = _context5.sent;
              xdrSections = WebAssembly.Module.customSections(wasmModule, "contractspecv0");
              _context5.next = 11;
              break;
            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](0);
              customData = parseWasmCustomSections(wasm);
              xdrSections = customData.get("contractspecv0");
            case 11:
              if (!(!xdrSections || xdrSections.length === 0)) {
                _context5.next = 13;
                break;
              }
              throw new Error("Could not obtain contract spec from wasm");
            case 13:
              bufferSection = Buffer.from(xdrSections[0]);
              specEntryArray = (0, _utils.processSpecEntryStream)(bufferSection);
              spec = new _spec.Spec(specEntryArray);
              return _context5.abrupt("return", spec);
            case 17:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 7]]);
      }));
      return _specFromWasm.apply(this, arguments);
    }
    function parseWasmCustomSections(buffer) {
      var sections = /* @__PURE__ */ new Map();
      var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
      var offset = 0;
      var read = function read2(length) {
        if (offset + length > buffer.byteLength) throw new Error("Buffer overflow");
        var bytes = new Uint8Array(arrayBuffer, offset, length);
        offset += length;
        return bytes;
      };
      if (_toConsumableArray(read(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
      if (_toConsumableArray(read(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
      while (offset < buffer.byteLength) {
        var sectionId = read(1)[0];
        var sectionLength = readVarUint32();
        var start = offset;
        if (sectionId === 0) {
          var nameLen = readVarUint32();
          if (nameLen === 0 || offset + nameLen > start + sectionLength) continue;
          var nameBytes = read(nameLen);
          var payload = read(sectionLength - (offset - start));
          try {
            var name = new TextDecoder("utf-8", {
              fatal: true
            }).decode(nameBytes);
            if (payload.length > 0) {
              sections.set(name, (sections.get(name) || []).concat(payload));
            }
          } catch (_unused) {
          }
        } else {
          offset += sectionLength;
        }
      }
      function readVarUint32() {
        var value = 0, shift = 0;
        while (true) {
          var byte = read(1)[0];
          value |= (byte & 127) << shift;
          if ((byte & 128) === 0) break;
          if ((shift += 7) >= 32) throw new Error("Invalid WASM value");
        }
        return value >>> 0;
      }
      return sections;
    }
    function specFromWasmHash(_x2, _x3) {
      return _specFromWasmHash.apply(this, arguments);
    }
    function _specFromWasmHash() {
      _specFromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(wasmHash, options) {
        var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              format = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : "hex";
              if (!(!options || !options.rpcUrl)) {
                _context6.next = 3;
                break;
              }
              throw new TypeError("options must contain rpcUrl");
            case 3:
              rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
              serverOpts = {
                allowHttp
              };
              server = new _rpc.Server(rpcUrl, serverOpts);
              _context6.next = 8;
              return server.getContractWasmByHash(wasmHash, format);
            case 8:
              wasm = _context6.sent;
              return _context6.abrupt("return", specFromWasm(wasm));
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return _specFromWasmHash.apply(this, arguments);
    }
    var Client3 = exports.Client = function() {
      function Client4(spec, options) {
        var _this = this;
        _classCallCheck(this, Client4);
        _defineProperty(this, "txFromJSON", function(json) {
          var _JSON$parse = JSON.parse(json), method = _JSON$parse.method, tx = _objectWithoutProperties(_JSON$parse, _excluded);
          return _assembled_transaction.AssembledTransaction.fromJSON(_objectSpread(_objectSpread({}, _this.options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return _this.spec.funcResToNative(method, result);
            }
          }), tx);
        });
        _defineProperty(this, "txFromXDR", function(xdrBase64) {
          return _assembled_transaction.AssembledTransaction.fromXDR(_this.options, xdrBase64, _this.spec);
        });
        this.spec = spec;
        this.options = options;
        this.spec.funcs().forEach(function(xdrFn) {
          var method = xdrFn.name().toString();
          if (method === CONSTRUCTOR_FUNC) {
            return;
          }
          var assembleTransaction = function assembleTransaction2(args, methodOptions) {
            return _assembled_transaction.AssembledTransaction.build(_objectSpread(_objectSpread(_objectSpread({
              method,
              args: args && spec.funcArgsToScVals(method, args)
            }, options), methodOptions), {}, {
              errorTypes: spec.errorCases().reduce(function(acc, curr) {
                return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, curr.value(), {
                  message: curr.doc().toString()
                }));
              }, {}),
              parseResultXdr: function parseResultXdr(result) {
                return spec.funcResToNative(method, result);
              }
            }));
          };
          _this[method] = spec.getFunc(method).inputs().length === 0 ? function(opts) {
            return assembleTransaction(void 0, opts);
          } : assembleTransaction;
        });
      }
      return _createClass(Client4, null, [{
        key: "deploy",
        value: function() {
          var _deploy = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(args, options) {
            var wasmHash, salt, format, fee, timeoutInSeconds, simulate, clientOptions, spec, operation;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  wasmHash = options.wasmHash, salt = options.salt, format = options.format, fee = options.fee, timeoutInSeconds = options.timeoutInSeconds, simulate = options.simulate, clientOptions = _objectWithoutProperties(options, _excluded2);
                  _context.next = 3;
                  return specFromWasmHash(wasmHash, clientOptions, format);
                case 3:
                  spec = _context.sent;
                  operation = _stellarBase.Operation.createCustomContract({
                    address: new _stellarBase.Address(options.address || options.publicKey),
                    wasmHash: typeof wasmHash === "string" ? Buffer.from(wasmHash, format !== null && format !== void 0 ? format : "hex") : wasmHash,
                    salt,
                    constructorArgs: args ? spec.funcArgsToScVals(CONSTRUCTOR_FUNC, args) : []
                  });
                  return _context.abrupt("return", _assembled_transaction.AssembledTransaction.buildWithOp(operation, _objectSpread(_objectSpread({
                    fee,
                    timeoutInSeconds,
                    simulate
                  }, clientOptions), {}, {
                    contractId: "ignored",
                    method: CONSTRUCTOR_FUNC,
                    parseResultXdr: function parseResultXdr(result) {
                      return new Client4(spec, _objectSpread(_objectSpread({}, clientOptions), {}, {
                        contractId: _stellarBase.Address.fromScVal(result).toString()
                      }));
                    }
                  })));
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function deploy(_x4, _x5) {
            return _deploy.apply(this, arguments);
          }
          return deploy;
        }()
      }, {
        key: "fromWasmHash",
        value: function() {
          var _fromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(wasmHash, options) {
            var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args2 = arguments;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  format = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : "hex";
                  if (!(!options || !options.rpcUrl)) {
                    _context2.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context2.next = 8;
                  return server.getContractWasmByHash(wasmHash, format);
                case 8:
                  wasm = _context2.sent;
                  return _context2.abrupt("return", Client4.fromWasm(wasm, options));
                case 10:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function fromWasmHash(_x6, _x7) {
            return _fromWasmHash.apply(this, arguments);
          }
          return fromWasmHash;
        }()
      }, {
        key: "fromWasm",
        value: function() {
          var _fromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(wasm, options) {
            var spec;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return specFromWasm(wasm);
                case 2:
                  spec = _context3.sent;
                  return _context3.abrupt("return", new Client4(spec, options));
                case 4:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function fromWasm(_x8, _x9) {
            return _fromWasm.apply(this, arguments);
          }
          return fromWasm;
        }()
      }, {
        key: "from",
        value: function() {
          var _from = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(options) {
            var rpcUrl, contractId, allowHttp, serverOpts, server, wasm;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  if (!(!options || !options.rpcUrl || !options.contractId)) {
                    _context4.next = 2;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 2:
                  rpcUrl = options.rpcUrl, contractId = options.contractId, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context4.next = 7;
                  return server.getContractWasmByContractId(contractId);
                case 7:
                  wasm = _context4.sent;
                  return _context4.abrupt("return", Client4.fromWasm(wasm, options));
                case 9:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }));
          function from(_x10) {
            return _from.apply(this, arguments);
          }
          return from;
        }()
      }]);
    }();
  }
});

// node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/index.js
var require_contract2 = __commonJS({
  "node_modules/passkey-kit-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _assembled_transaction = require_assembled_transaction();
    Object.keys(_assembled_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _assembled_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _assembled_transaction[key];
        }
      });
    });
    var _basic_node_signer = require_basic_node_signer();
    Object.keys(_basic_node_signer).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _basic_node_signer[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _basic_node_signer[key];
        }
      });
    });
    var _client = require_client();
    Object.keys(_client).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _client[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _client[key];
        }
      });
    });
    var _rust_result = require_rust_result();
    Object.keys(_rust_result).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _rust_result[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _rust_result[key];
        }
      });
    });
    var _sent_transaction = require_sent_transaction();
    Object.keys(_sent_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _sent_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sent_transaction[key];
        }
      });
    });
    var _spec = require_spec();
    Object.keys(_spec).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _spec[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _spec[key];
        }
      });
    });
    var _types = require_types2();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/dist/stellar-sdk-minimal.min.js
var require_stellar_sdk_minimal_min = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/dist/stellar-sdk-minimal.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("StellarSdk", [], t) : "object" == typeof exports ? exports.StellarSdk = t() : e.StellarSdk = t();
    }(self, () => (() => {
      var e = { 15: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FastSigning = void 0, t2.generate = function(e3) {
          return o.generate(e3);
        }, t2.sign = function(e3, t3) {
          return o.sign(e3, t3);
        }, t2.verify = function(e3, t3, r3) {
          return o.verify(e3, t3, r3);
        };
        var o = {};
        t2.FastSigning = "undefined" == typeof window ? function() {
          var e3;
          try {
            e3 = r2(Object(function() {
              var e4 = new Error("Cannot find module 'sodium-native'");
              throw e4.code = "MODULE_NOT_FOUND", e4;
            }()));
          } catch (e4) {
            return i();
          }
          return Object.keys(e3).length ? (o.generate = function(t3) {
            var r3 = n.alloc(e3.crypto_sign_PUBLICKEYBYTES), o2 = n.alloc(e3.crypto_sign_SECRETKEYBYTES);
            return e3.crypto_sign_seed_keypair(r3, o2, t3), r3;
          }, o.sign = function(t3, r3) {
            t3 = n.from(t3);
            var o2 = n.alloc(e3.crypto_sign_BYTES);
            return e3.crypto_sign_detached(o2, t3, r3), o2;
          }, o.verify = function(t3, r3, o2) {
            t3 = n.from(t3);
            try {
              return e3.crypto_sign_verify_detached(r3, t3, o2);
            } catch (e4) {
              return false;
            }
          }, true) : i();
        }() : i();
        function i() {
          var e3 = r2(4940);
          return o.generate = function(t3) {
            var r3 = new Uint8Array(t3), o2 = e3.sign.keyPair.fromSeed(r3);
            return n.from(o2.publicKey);
          }, o.sign = function(t3, r3) {
            t3 = n.from(t3), t3 = new Uint8Array(t3.toJSON().data), r3 = new Uint8Array(r3.toJSON().data);
            var o2 = e3.sign.detached(t3, r3);
            return n.from(o2);
          }, o.verify = function(t3, r3, o2) {
            return t3 = n.from(t3), t3 = new Uint8Array(t3.toJSON().data), r3 = new Uint8Array(r3.toJSON().data), o2 = new Uint8Array(o2.toJSON().data), e3.sign.detached.verify(t3, r3, o2);
          }, false;
        }
      }, 149: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.restoreFootprint = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = new o.default.RestoreFootprintOp({ ext: new o.default.ExtensionPoint(0) }), r3 = { body: o.default.OperationBody.restoreFootprint(t3) };
          return this.setSourceAccount(r3, null != e3 ? e3 : {}), new o.default.Operation(r3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 225: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SignerKey = void 0;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(7120);
        function a(e3) {
          return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, a(e3);
        }
        function u(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, s(n2.key), n2);
          }
        }
        function s(e3) {
          var t3 = function(e4, t4) {
            if ("object" != a(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != a(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == a(t3) ? t3 : t3 + "";
        }
        t2.SignerKey = function() {
          return function(e3, t3, r3) {
            return t3 && u(e3.prototype, t3), r3 && u(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3() {
            !function(e4, t3) {
              if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
            }(this, e3);
          }, null, [{ key: "decodeAddress", value: function(e3) {
            var t3 = { ed25519PublicKey: o.default.SignerKey.signerKeyTypeEd25519, preAuthTx: o.default.SignerKey.signerKeyTypePreAuthTx, sha256Hash: o.default.SignerKey.signerKeyTypeHashX, signedPayload: o.default.SignerKey.signerKeyTypeEd25519SignedPayload }, r3 = i.StrKey.getVersionByteForPrefix(e3), n2 = t3[r3];
            if (!n2) throw new Error("invalid signer key type (".concat(r3, ")"));
            var a2 = (0, i.decodeCheck)(r3, e3);
            return n2("signedPayload" === r3 ? new o.default.SignerKeyEd25519SignedPayload({ ed25519: a2.slice(0, 32), payload: a2.slice(36) }) : a2);
          } }, { key: "encodeSignerKey", value: function(e3) {
            var t3, r3;
            switch (e3.switch()) {
              case o.default.SignerKeyType.signerKeyTypeEd25519():
                t3 = "ed25519PublicKey", r3 = e3.value();
                break;
              case o.default.SignerKeyType.signerKeyTypePreAuthTx():
                t3 = "preAuthTx", r3 = e3.value();
                break;
              case o.default.SignerKeyType.signerKeyTypeHashX():
                t3 = "sha256Hash", r3 = e3.value();
                break;
              case o.default.SignerKeyType.signerKeyTypeEd25519SignedPayload():
                t3 = "signedPayload", r3 = e3.ed25519SignedPayload().toXDR("raw");
                break;
              default:
                throw new Error("invalid SignerKey (type: ".concat(e3.switch(), ")"));
            }
            return (0, i.encodeCheck)(t3, r3);
          } }]);
        }();
      }, 251: (e2, t2) => {
        t2.read = function(e3, t3, r2, n, o) {
          var i, a, u = 8 * o - n - 1, s = (1 << u) - 1, c = s >> 1, l = -7, f = r2 ? o - 1 : 0, p = r2 ? -1 : 1, d = e3[t3 + f];
          for (f += p, i = d & (1 << -l) - 1, d >>= -l, l += u; l > 0; i = 256 * i + e3[t3 + f], f += p, l -= 8) ;
          for (a = i & (1 << -l) - 1, i >>= -l, l += n; l > 0; a = 256 * a + e3[t3 + f], f += p, l -= 8) ;
          if (0 === i) i = 1 - c;
          else {
            if (i === s) return a ? NaN : 1 / 0 * (d ? -1 : 1);
            a += Math.pow(2, n), i -= c;
          }
          return (d ? -1 : 1) * a * Math.pow(2, i - n);
        }, t2.write = function(e3, t3, r2, n, o, i) {
          var a, u, s, c = 8 * i - o - 1, l = (1 << c) - 1, f = l >> 1, p = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : i - 1, h = n ? 1 : -1, y = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (u = isNaN(t3) ? 1 : 0, a = l) : (a = Math.floor(Math.log(t3) / Math.LN2), t3 * (s = Math.pow(2, -a)) < 1 && (a--, s *= 2), (t3 += a + f >= 1 ? p / s : p * Math.pow(2, 1 - f)) * s >= 2 && (a++, s /= 2), a + f >= l ? (u = 0, a = l) : a + f >= 1 ? (u = (t3 * s - 1) * Math.pow(2, o), a += f) : (u = t3 * Math.pow(2, f - 1) * Math.pow(2, o), a = 0)); o >= 8; e3[r2 + d] = 255 & u, d += h, u /= 256, o -= 8) ;
          for (a = a << o | u, c += o; c > 0; e3[r2 + d] = 255 & a, d += h, a /= 256, c -= 8) ;
          e3[r2 + d - h] |= 128 * y;
        };
      }, 356: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = { xdr: true, cereal: true, hash: true, sign: true, verify: true, FastSigning: true, getLiquidityPoolId: true, LiquidityPoolFeeV18: true, Keypair: true, UnsignedHyper: true, Hyper: true, TransactionBase: true, Transaction: true, FeeBumpTransaction: true, TransactionBuilder: true, TimeoutInfinite: true, BASE_FEE: true, Asset: true, LiquidityPoolAsset: true, LiquidityPoolId: true, Operation: true, AuthRequiredFlag: true, AuthRevocableFlag: true, AuthImmutableFlag: true, AuthClawbackEnabledFlag: true, Account: true, MuxedAccount: true, Claimant: true, Networks: true, StrKey: true, SignerKey: true, Soroban: true, decodeAddressToMuxedAccount: true, encodeMuxedAccountToAddress: true, extractBaseAddress: true, encodeMuxedAccount: true, Contract: true, Address: true };
        Object.defineProperty(t2, "Account", { enumerable: true, get: function() {
          return w.Account;
        } }), Object.defineProperty(t2, "Address", { enumerable: true, get: function() {
          return P.Address;
        } }), Object.defineProperty(t2, "Asset", { enumerable: true, get: function() {
          return y.Asset;
        } }), Object.defineProperty(t2, "AuthClawbackEnabledFlag", { enumerable: true, get: function() {
          return g.AuthClawbackEnabledFlag;
        } }), Object.defineProperty(t2, "AuthImmutableFlag", { enumerable: true, get: function() {
          return g.AuthImmutableFlag;
        } }), Object.defineProperty(t2, "AuthRequiredFlag", { enumerable: true, get: function() {
          return g.AuthRequiredFlag;
        } }), Object.defineProperty(t2, "AuthRevocableFlag", { enumerable: true, get: function() {
          return g.AuthRevocableFlag;
        } }), Object.defineProperty(t2, "BASE_FEE", { enumerable: true, get: function() {
          return h.BASE_FEE;
        } }), Object.defineProperty(t2, "Claimant", { enumerable: true, get: function() {
          return k.Claimant;
        } }), Object.defineProperty(t2, "Contract", { enumerable: true, get: function() {
          return A.Contract;
        } }), Object.defineProperty(t2, "FastSigning", { enumerable: true, get: function() {
          return u.FastSigning;
        } }), Object.defineProperty(t2, "FeeBumpTransaction", { enumerable: true, get: function() {
          return d.FeeBumpTransaction;
        } }), Object.defineProperty(t2, "Hyper", { enumerable: true, get: function() {
          return l.Hyper;
        } }), Object.defineProperty(t2, "Keypair", { enumerable: true, get: function() {
          return c.Keypair;
        } }), Object.defineProperty(t2, "LiquidityPoolAsset", { enumerable: true, get: function() {
          return m.LiquidityPoolAsset;
        } }), Object.defineProperty(t2, "LiquidityPoolFeeV18", { enumerable: true, get: function() {
          return s.LiquidityPoolFeeV18;
        } }), Object.defineProperty(t2, "LiquidityPoolId", { enumerable: true, get: function() {
          return v.LiquidityPoolId;
        } }), Object.defineProperty(t2, "MuxedAccount", { enumerable: true, get: function() {
          return S.MuxedAccount;
        } }), Object.defineProperty(t2, "Networks", { enumerable: true, get: function() {
          return E.Networks;
        } }), Object.defineProperty(t2, "Operation", { enumerable: true, get: function() {
          return g.Operation;
        } }), Object.defineProperty(t2, "SignerKey", { enumerable: true, get: function() {
          return T.SignerKey;
        } }), Object.defineProperty(t2, "Soroban", { enumerable: true, get: function() {
          return O.Soroban;
        } }), Object.defineProperty(t2, "StrKey", { enumerable: true, get: function() {
          return _.StrKey;
        } }), Object.defineProperty(t2, "TimeoutInfinite", { enumerable: true, get: function() {
          return h.TimeoutInfinite;
        } }), Object.defineProperty(t2, "Transaction", { enumerable: true, get: function() {
          return p.Transaction;
        } }), Object.defineProperty(t2, "TransactionBase", { enumerable: true, get: function() {
          return f.TransactionBase;
        } }), Object.defineProperty(t2, "TransactionBuilder", { enumerable: true, get: function() {
          return h.TransactionBuilder;
        } }), Object.defineProperty(t2, "UnsignedHyper", { enumerable: true, get: function() {
          return l.UnsignedHyper;
        } }), Object.defineProperty(t2, "cereal", { enumerable: true, get: function() {
          return i.default;
        } }), Object.defineProperty(t2, "decodeAddressToMuxedAccount", { enumerable: true, get: function() {
          return x.decodeAddressToMuxedAccount;
        } }), t2.default = void 0, Object.defineProperty(t2, "encodeMuxedAccount", { enumerable: true, get: function() {
          return x.encodeMuxedAccount;
        } }), Object.defineProperty(t2, "encodeMuxedAccountToAddress", { enumerable: true, get: function() {
          return x.encodeMuxedAccountToAddress;
        } }), Object.defineProperty(t2, "extractBaseAddress", { enumerable: true, get: function() {
          return x.extractBaseAddress;
        } }), Object.defineProperty(t2, "getLiquidityPoolId", { enumerable: true, get: function() {
          return s.getLiquidityPoolId;
        } }), Object.defineProperty(t2, "hash", { enumerable: true, get: function() {
          return a.hash;
        } }), Object.defineProperty(t2, "sign", { enumerable: true, get: function() {
          return u.sign;
        } }), Object.defineProperty(t2, "verify", { enumerable: true, get: function() {
          return u.verify;
        } }), Object.defineProperty(t2, "xdr", { enumerable: true, get: function() {
          return o.default;
        } });
        var o = N(r2(1918)), i = N(r2(3335)), a = r2(9152), u = r2(15), s = r2(5578), c = r2(6691), l = r2(3740), f = r2(3758), p = r2(380), d = r2(9260), h = r2(6396), y = r2(1764), m = r2(2262), v = r2(9353), g = r2(7237), b = r2(4172);
        Object.keys(b).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === b[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return b[e3];
          } }));
        });
        var w = r2(2135), S = r2(2243), k = r2(1387), E = r2(6202), _ = r2(7120), T = r2(225), O = r2(4062), x = r2(6160), A = r2(7452), P = r2(1180), I = r2(8549);
        Object.keys(I).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === I[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return I[e3];
          } }));
        });
        var R = r2(7177);
        Object.keys(R).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === R[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return R[e3];
          } }));
        });
        var C = r2(3919);
        Object.keys(C).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === C[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return C[e3];
          } }));
        });
        var j = r2(4842);
        Object.keys(j).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === j[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return j[e3];
          } }));
        });
        var B = r2(5328);
        Object.keys(B).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === B[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return B[e3];
          } }));
        });
        var L = r2(3564);
        function N(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        Object.keys(L).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === L[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return L[e3];
          } }));
        });
        t2.default = e2.exports;
      }, 380: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        function o(e3) {
          return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, o(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Transaction = void 0;
        var i, a = (i = r2(1918)) && i.__esModule ? i : { default: i }, u = r2(9152), s = r2(7120), c = r2(7237), l = r2(4172), f = r2(3758), p = r2(6160);
        function d(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, h(n2.key), n2);
          }
        }
        function h(e3) {
          var t3 = function(e4, t4) {
            if ("object" != o(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != o(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == o(t3) ? t3 : t3 + "";
        }
        function y(e3, t3, r3) {
          return t3 = v(t3), function(e4, t4) {
            if (t4 && ("object" == o(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, m() ? Reflect.construct(t3, r3 || [], v(e3).constructor) : t3.apply(e3, r3));
        }
        function m() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (m = function() {
            return !!e3;
          })();
        }
        function v(e3) {
          return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, v(e3);
        }
        function g(e3, t3) {
          return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, g(e3, t3);
        }
        t2.Transaction = function(e3) {
          function t3(e4, r3) {
            var o2;
            if (function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), "string" == typeof e4) {
              var i2 = n.from(e4, "base64");
              e4 = a.default.TransactionEnvelope.fromXDR(i2);
            }
            var u2 = e4.switch();
            if (u2 !== a.default.EnvelopeType.envelopeTypeTxV0() && u2 !== a.default.EnvelopeType.envelopeTypeTx()) throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(u2.name, "."));
            var l2 = e4.value(), f2 = l2.tx(), d2 = f2.fee().toString();
            if ((o2 = y(this, t3, [f2, (l2.signatures() || []).slice(), d2, r3]))._envelopeType = u2, o2._memo = f2.memo(), o2._sequence = f2.seqNum().toString(), o2._envelopeType === a.default.EnvelopeType.envelopeTypeTxV0()) o2._source = s.StrKey.encodeEd25519PublicKey(o2.tx.sourceAccountEd25519());
            else o2._source = (0, p.encodeMuxedAccountToAddress)(o2.tx.sourceAccount());
            var h2 = null, m2 = null;
            switch (o2._envelopeType) {
              case a.default.EnvelopeType.envelopeTypeTxV0():
                m2 = f2.timeBounds();
                break;
              case a.default.EnvelopeType.envelopeTypeTx():
                switch (f2.cond().switch()) {
                  case a.default.PreconditionType.precondTime():
                    m2 = f2.cond().timeBounds();
                    break;
                  case a.default.PreconditionType.precondV2():
                    m2 = (h2 = f2.cond().v2()).timeBounds();
                }
            }
            if (m2 && (o2._timeBounds = { minTime: m2.minTime().toString(), maxTime: m2.maxTime().toString() }), h2) {
              var v2 = h2.ledgerBounds();
              v2 && (o2._ledgerBounds = { minLedger: v2.minLedger(), maxLedger: v2.maxLedger() });
              var g2 = h2.minSeqNum();
              g2 && (o2._minAccountSequence = g2.toString()), o2._minAccountSequenceAge = h2.minSeqAge(), o2._minAccountSequenceLedgerGap = h2.minSeqLedgerGap(), o2._extraSigners = h2.extraSigners();
            }
            var b = f2.operations() || [];
            return o2._operations = b.map(function(e5) {
              return c.Operation.fromXDRObject(e5);
            }), o2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && g(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && d(e4.prototype, t4), r3 && d(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "timeBounds", get: function() {
            return this._timeBounds;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "ledgerBounds", get: function() {
            return this._ledgerBounds;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "minAccountSequence", get: function() {
            return this._minAccountSequence;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "minAccountSequenceAge", get: function() {
            return this._minAccountSequenceAge;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "minAccountSequenceLedgerGap", get: function() {
            return this._minAccountSequenceLedgerGap;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "extraSigners", get: function() {
            return this._extraSigners;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "sequence", get: function() {
            return this._sequence;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "source", get: function() {
            return this._source;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "operations", get: function() {
            return this._operations;
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "memo", get: function() {
            return l.Memo.fromXDRObject(this._memo);
          }, set: function(e4) {
            throw new Error("Transaction is immutable");
          } }, { key: "signatureBase", value: function() {
            var e4 = this.tx;
            this._envelopeType === a.default.EnvelopeType.envelopeTypeTxV0() && (e4 = a.default.Transaction.fromXDR(n.concat([a.default.PublicKeyType.publicKeyTypeEd25519().toXDR(), e4.toXDR()])));
            var t4 = new a.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(e4);
            return new a.default.TransactionSignaturePayload({ networkId: a.default.Hash.fromXDR((0, u.hash)(this.networkPassphrase)), taggedTransaction: t4 }).toXDR();
          } }, { key: "toEnvelope", value: function() {
            var e4, t4 = this.tx.toXDR(), r3 = this.signatures.slice();
            switch (this._envelopeType) {
              case a.default.EnvelopeType.envelopeTypeTxV0():
                e4 = new a.default.TransactionEnvelope.envelopeTypeTxV0(new a.default.TransactionV0Envelope({ tx: a.default.TransactionV0.fromXDR(t4), signatures: r3 }));
                break;
              case a.default.EnvelopeType.envelopeTypeTx():
                e4 = new a.default.TransactionEnvelope.envelopeTypeTx(new a.default.TransactionV1Envelope({ tx: a.default.Transaction.fromXDR(t4), signatures: r3 }));
                break;
              default:
                throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
            }
            return e4;
          } }, { key: "getClaimableBalanceId", value: function(e4) {
            if (!Number.isInteger(e4) || e4 < 0 || e4 >= this.operations.length) throw new RangeError("invalid operation index");
            var t4 = this.operations[e4];
            try {
              t4 = c.Operation.createClaimableBalance(t4);
            } catch (e5) {
              throw new TypeError("expected createClaimableBalance, got ".concat(t4.type, ": ").concat(e5));
            }
            var r3 = s.StrKey.decodeEd25519PublicKey((0, p.extractBaseAddress)(this.source)), n2 = a.default.HashIdPreimage.envelopeTypeOpId(new a.default.HashIdPreimageOperationId({ sourceAccount: a.default.AccountId.publicKeyTypeEd25519(r3), seqNum: a.default.SequenceNumber.fromString(this.sequence), opNum: e4 })), o2 = (0, u.hash)(n2.toXDR("raw"));
            return a.default.ClaimableBalanceId.claimableBalanceIdTypeV0(o2).toXDR("hex");
          } }]);
        }(f.TransactionBase);
      }, 392: (e2, t2, r2) => {
        var n = r2(2861).Buffer;
        function o(e3, t3) {
          this._block = n.alloc(e3), this._finalSize = t3, this._blockSize = e3, this._len = 0;
        }
        o.prototype.update = function(e3, t3) {
          "string" == typeof e3 && (t3 = t3 || "utf8", e3 = n.from(e3, t3));
          for (var r3 = this._block, o2 = this._blockSize, i = e3.length, a = this._len, u = 0; u < i; ) {
            for (var s = a % o2, c = Math.min(i - u, o2 - s), l = 0; l < c; l++) r3[s + l] = e3[u + l];
            u += c, (a += c) % o2 == 0 && this._update(r3);
          }
          return this._len += i, this;
        }, o.prototype.digest = function(e3) {
          var t3 = this._len % this._blockSize;
          this._block[t3] = 128, this._block.fill(0, t3 + 1), t3 >= this._finalSize && (this._update(this._block), this._block.fill(0));
          var r3 = 8 * this._len;
          if (r3 <= 4294967295) this._block.writeUInt32BE(r3, this._blockSize - 4);
          else {
            var n2 = (4294967295 & r3) >>> 0, o2 = (r3 - n2) / 4294967296;
            this._block.writeUInt32BE(o2, this._blockSize - 8), this._block.writeUInt32BE(n2, this._blockSize - 4);
          }
          this._update(this._block);
          var i = this._hash();
          return e3 ? i.toString(e3) : i;
        }, o.prototype._update = function() {
          throw new Error("_update must be implemented by subclass");
        }, e2.exports = o;
      }, 645: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.trimEnd = void 0;
        t2.trimEnd = function(e3, t3) {
          for (var r2 = "number" == typeof e3, n = String(e3); n.endsWith(t3); ) n = n.slice(0, -1);
          return r2 ? Number(n) : n;
        };
      }, 721: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.endSponsoringFutureReserves = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = {};
          return t3.body = o.default.OperationBody.endSponsoringFutureReserves(), this.setSourceAccount(t3, e3), new o.default.Operation(t3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 784: (e2, t2, r2) => {
        "use strict";
        r2.d(t2, { $D: () => d, Af: () => c, WC: () => l, fG: () => p, jr: () => h, tR: () => f });
        var n = r2(356), o = r2(4076);
        function i(e3) {
          return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, i(e3);
        }
        function a(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function u(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? a(Object(r3), true).forEach(function(t4) {
              s(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : a(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function s(e3, t3, r3) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" != i(e5) || !e5) return e5;
              var r4 = e5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n2 = r4.call(e5, t5 || "default");
                if ("object" != i(n2)) return n2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t5 ? String : Number)(e5);
            }(e4, "string");
            return "symbol" == i(t4) ? t4 : t4 + "";
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function c(e3) {
          var t3 = e3.errorResultXdr, r3 = e3.diagnosticEventsXdr;
          return delete e3.errorResultXdr, delete e3.diagnosticEventsXdr, t3 ? u(u(u({}, e3), void 0 !== r3 && r3.length > 0 && { diagnosticEvents: r3.map(function(e4) {
            return n.xdr.DiagnosticEvent.fromXDR(e4, "base64");
          }) }), {}, { errorResult: n.xdr.TransactionResult.fromXDR(t3, "base64") }) : u({}, e3);
        }
        function l(e3) {
          var t3, r3 = n.xdr.TransactionMeta.fromXDR(e3.resultMetaXdr, "base64"), o2 = { ledger: e3.ledger, createdAt: e3.createdAt, applicationOrder: e3.applicationOrder, feeBump: e3.feeBump, envelopeXdr: n.xdr.TransactionEnvelope.fromXDR(e3.envelopeXdr, "base64"), resultXdr: n.xdr.TransactionResult.fromXDR(e3.resultXdr, "base64"), resultMetaXdr: r3 };
          3 === r3.switch() && null !== r3.v3().sorobanMeta() && (o2.returnValue = null === (t3 = r3.v3().sorobanMeta()) || void 0 === t3 ? void 0 : t3.returnValue());
          return "diagnosticEventsXdr" in e3 && e3.diagnosticEventsXdr && (o2.diagnosticEventsXdr = e3.diagnosticEventsXdr.map(function(e4) {
            return n.xdr.DiagnosticEvent.fromXDR(e4, "base64");
          })), o2;
        }
        function f(e3) {
          return u({ status: e3.status, txHash: e3.txHash }, l(e3));
        }
        function p(e3) {
          var t3;
          return { latestLedger: e3.latestLedger, cursor: e3.cursor, events: (null !== (t3 = e3.events) && void 0 !== t3 ? t3 : []).map(function(e4) {
            var t4 = u({}, e4);
            return delete t4.contractId, u(u(u({}, t4), "" !== e4.contractId && { contractId: new n.Contract(e4.contractId) }), {}, { topic: e4.topic.map(function(e5) {
              return n.xdr.ScVal.fromXDR(e5, "base64");
            }), value: n.xdr.ScVal.fromXDR(e4.value, "base64") });
          }) };
        }
        function d(e3) {
          var t3;
          return { latestLedger: e3.latestLedger, entries: (null !== (t3 = e3.entries) && void 0 !== t3 ? t3 : []).map(function(e4) {
            if (!e4.key || !e4.xdr) throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(e4)));
            return u({ lastModifiedLedgerSeq: e4.lastModifiedLedgerSeq, key: n.xdr.LedgerKey.fromXDR(e4.key, "base64"), val: n.xdr.LedgerEntryData.fromXDR(e4.xdr, "base64") }, void 0 !== e4.liveUntilLedgerSeq && { liveUntilLedgerSeq: e4.liveUntilLedgerSeq });
          }) };
        }
        function h(e3) {
          var t3, r3;
          if (!o.j.isSimulationRaw(e3)) return e3;
          var i2 = { _parsed: true, id: e3.id, latestLedger: e3.latestLedger, events: null !== (t3 = null === (r3 = e3.events) || void 0 === r3 ? void 0 : r3.map(function(e4) {
            return n.xdr.DiagnosticEvent.fromXDR(e4, "base64");
          })) && void 0 !== t3 ? t3 : [] };
          return "string" == typeof e3.error ? u(u({}, i2), {}, { error: e3.error }) : function(e4, t4) {
            var r4, o2, i3, a2, s2, c2 = u(u(u({}, t4), {}, { transactionData: new n.SorobanDataBuilder(e4.transactionData), minResourceFee: e4.minResourceFee }, null !== (r4 = null === (o2 = e4.results) || void 0 === o2 ? void 0 : o2.length) && void 0 !== r4 && r4 && { result: e4.results.map(function(e5) {
              var t5;
              return { auth: (null !== (t5 = e5.auth) && void 0 !== t5 ? t5 : []).map(function(e6) {
                return n.xdr.SorobanAuthorizationEntry.fromXDR(e6, "base64");
              }), retval: e5.xdr ? n.xdr.ScVal.fromXDR(e5.xdr, "base64") : n.xdr.ScVal.scvVoid() };
            })[0] }), null !== (i3 = null === (a2 = e4.stateChanges) || void 0 === a2 ? void 0 : a2.length) && void 0 !== i3 && i3 && { stateChanges: null === (s2 = e4.stateChanges) || void 0 === s2 ? void 0 : s2.map(function(e5) {
              return { type: e5.type, key: n.xdr.LedgerKey.fromXDR(e5.key, "base64"), before: e5.before ? n.xdr.LedgerEntry.fromXDR(e5.before, "base64") : null, after: e5.after ? n.xdr.LedgerEntry.fromXDR(e5.after, "base64") : null };
            }) });
            return e4.restorePreamble && "" !== e4.restorePreamble.transactionData ? u(u({}, c2), {}, { restorePreamble: { minResourceFee: e4.restorePreamble.minResourceFee, transactionData: new n.SorobanDataBuilder(e4.restorePreamble.transactionData) } }) : c2;
          }(e3, i2);
        }
      }, 862: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.manageSellOffer = function(e3) {
          var t3 = {};
          if (t3.selling = e3.selling.toXDRObject(), t3.buying = e3.buying.toXDRObject(), !this.isValidAmount(e3.amount, true)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (t3.amount = this._toXDRAmount(e3.amount), void 0 === e3.price) throw new TypeError("price argument is required");
          t3.price = this._toXDRPrice(e3.price), void 0 !== e3.offerId ? e3.offerId = e3.offerId.toString() : e3.offerId = "0";
          t3.offerId = o.Hyper.fromString(e3.offerId);
          var r3 = new i.default.ManageSellOfferOp(t3), n2 = {};
          return n2.body = i.default.OperationBody.manageSellOffer(r3), this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        };
        var n, o = r2(3740), i = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 1180: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Address = void 0;
        var n, o = r2(7120), i = (n = r2(1918)) && n.__esModule ? n : { default: n };
        function a(e3) {
          return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, a(e3);
        }
        function u(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, s(n2.key), n2);
          }
        }
        function s(e3) {
          var t3 = function(e4, t4) {
            if ("object" != a(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != a(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == a(t3) ? t3 : t3 + "";
        }
        t2.Address = function() {
          function e3(t3) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), o.StrKey.isValidEd25519PublicKey(t3)) this._type = "account", this._key = o.StrKey.decodeEd25519PublicKey(t3);
            else {
              if (!o.StrKey.isValidContract(t3)) throw new Error("Unsupported address type: ".concat(t3));
              this._type = "contract", this._key = o.StrKey.decodeContract(t3);
            }
          }
          return function(e4, t3, r3) {
            return t3 && u(e4.prototype, t3), r3 && u(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(e3, [{ key: "toString", value: function() {
            switch (this._type) {
              case "account":
                return o.StrKey.encodeEd25519PublicKey(this._key);
              case "contract":
                return o.StrKey.encodeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          } }, { key: "toScVal", value: function() {
            return i.default.ScVal.scvAddress(this.toScAddress());
          } }, { key: "toScAddress", value: function() {
            switch (this._type) {
              case "account":
                return i.default.ScAddress.scAddressTypeAccount(i.default.PublicKey.publicKeyTypeEd25519(this._key));
              case "contract":
                return i.default.ScAddress.scAddressTypeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          } }, { key: "toBuffer", value: function() {
            return this._key;
          } }], [{ key: "fromString", value: function(t3) {
            return new e3(t3);
          } }, { key: "account", value: function(t3) {
            return new e3(o.StrKey.encodeEd25519PublicKey(t3));
          } }, { key: "contract", value: function(t3) {
            return new e3(o.StrKey.encodeContract(t3));
          } }, { key: "fromScVal", value: function(t3) {
            return e3.fromScAddress(t3.address());
          } }, { key: "fromScAddress", value: function(t3) {
            switch (t3.switch().value) {
              case i.default.ScAddressType.scAddressTypeAccount().value:
                return e3.account(t3.accountId().ed25519());
              case i.default.ScAddressType.scAddressTypeContract().value:
                return e3.contract(t3.contractId());
              default:
                throw new Error("Unsupported address type");
            }
          } }]);
        }();
      }, 1242: (e2, t2, r2) => {
        "use strict";
        var n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var o = ((n = r2(7963)) && n.__esModule ? n : { default: n }).default.clone();
        o.DEBUG = true;
        t2.default = o;
      }, 1293: (e2, t2, r2) => {
        var n = r2(5546), o = r2(2708);
        e2.exports = { parse: function(e3) {
          var t3 = n.parse(e3.toString());
          return o.compile(t3);
        } };
      }, 1346: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.verifyChecksum = function(e3, t3) {
          if (e3.length !== t3.length) return false;
          if (0 === e3.length) return true;
          for (var r2 = 0; r2 < e3.length; r2 += 1) if (e3[r2] !== t3[r2]) return false;
          return true;
        };
      }, 1387: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Claimant = void 0;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6691), a = r2(7120);
        function u(e3) {
          return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, u(e3);
        }
        function s(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, c(n2.key), n2);
          }
        }
        function c(e3) {
          var t3 = function(e4, t4) {
            if ("object" != u(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != u(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == u(t3) ? t3 : t3 + "";
        }
        t2.Claimant = function() {
          return function(e3, t3, r3) {
            return t3 && s(e3.prototype, t3), r3 && s(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3, r3) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), t3 && !a.StrKey.isValidEd25519PublicKey(t3)) throw new Error("Destination is invalid");
            if (this._destination = t3, r3) {
              if (!(r3 instanceof o.default.ClaimPredicate)) throw new Error("Predicate should be an xdr.ClaimPredicate");
              this._predicate = r3;
            } else this._predicate = o.default.ClaimPredicate.claimPredicateUnconditional();
          }, [{ key: "toXDRObject", value: function() {
            var e3 = new o.default.ClaimantV0({ destination: i.Keypair.fromPublicKey(this._destination).xdrAccountId(), predicate: this._predicate });
            return o.default.Claimant.claimantTypeV0(e3);
          } }, { key: "destination", get: function() {
            return this._destination;
          }, set: function(e3) {
            throw new Error("Claimant is immutable");
          } }, { key: "predicate", get: function() {
            return this._predicate;
          }, set: function(e3) {
            throw new Error("Claimant is immutable");
          } }], [{ key: "predicateUnconditional", value: function() {
            return o.default.ClaimPredicate.claimPredicateUnconditional();
          } }, { key: "predicateAnd", value: function(e3, t3) {
            if (!(e3 instanceof o.default.ClaimPredicate)) throw new Error("left Predicate should be an xdr.ClaimPredicate");
            if (!(t3 instanceof o.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
            return o.default.ClaimPredicate.claimPredicateAnd([e3, t3]);
          } }, { key: "predicateOr", value: function(e3, t3) {
            if (!(e3 instanceof o.default.ClaimPredicate)) throw new Error("left Predicate should be an xdr.ClaimPredicate");
            if (!(t3 instanceof o.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
            return o.default.ClaimPredicate.claimPredicateOr([e3, t3]);
          } }, { key: "predicateNot", value: function(e3) {
            if (!(e3 instanceof o.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
            return o.default.ClaimPredicate.claimPredicateNot(e3);
          } }, { key: "predicateBeforeAbsoluteTime", value: function(e3) {
            return o.default.ClaimPredicate.claimPredicateBeforeAbsoluteTime(o.default.Int64.fromString(e3));
          } }, { key: "predicateBeforeRelativeTime", value: function(e3) {
            return o.default.ClaimPredicate.claimPredicateBeforeRelativeTime(o.default.Int64.fromString(e3));
          } }, { key: "fromXDR", value: function(e3) {
            var t3;
            if (e3.switch() === o.default.ClaimantType.claimantTypeV0()) return t3 = e3.v0(), new this(a.StrKey.encodeEd25519PublicKey(t3.destination().ed25519()), t3.predicate());
            throw new Error("Invalid claimant type: ".concat(e3.switch().name));
          } }]);
        }();
      }, 1411: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.manageData = function(e3) {
          var t3 = {};
          if (!("string" == typeof e3.name && e3.name.length <= 64)) throw new Error("name must be a string, up to 64 characters");
          if (t3.dataName = e3.name, "string" != typeof e3.value && !n.isBuffer(e3.value) && null !== e3.value) throw new Error("value must be a string, Buffer or null");
          "string" == typeof e3.value ? t3.dataValue = n.from(e3.value) : t3.dataValue = e3.value;
          if (null !== t3.dataValue && t3.dataValue.length > 64) throw new Error("value cannot be longer that 64 bytes");
          var r3 = new i.default.ManageDataOp(t3), o2 = {};
          return o2.body = i.default.OperationBody.manageData(r3), this.setSourceAccount(o2, e3), new i.default.Operation(o2);
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o };
      }, 1430: function(e2, t2, r2) {
        var n, o;
        !function(i, a) {
          "use strict";
          e2.exports ? e2.exports = a() : void 0 === (o = "function" == typeof (n = a) ? n.call(t2, r2, t2, e2) : n) || (e2.exports = o);
        }(0, function(e3) {
          "use strict";
          var t3 = e3 && e3.IPv6;
          return { best: function(e4) {
            var t4, r3, n2 = e4.toLowerCase().split(":"), o2 = n2.length, i = 8;
            for ("" === n2[0] && "" === n2[1] && "" === n2[2] ? (n2.shift(), n2.shift()) : "" === n2[0] && "" === n2[1] ? n2.shift() : "" === n2[o2 - 1] && "" === n2[o2 - 2] && n2.pop(), -1 !== n2[(o2 = n2.length) - 1].indexOf(".") && (i = 7), t4 = 0; t4 < o2 && "" !== n2[t4]; t4++) ;
            if (t4 < i) for (n2.splice(t4, 1, "0000"); n2.length < i; ) n2.splice(t4, 0, "0000");
            for (var a = 0; a < i; a++) {
              r3 = n2[a].split("");
              for (var u = 0; u < 3 && ("0" === r3[0] && r3.length > 1); u++) r3.splice(0, 1);
              n2[a] = r3.join("");
            }
            var s = -1, c = 0, l = 0, f = -1, p = false;
            for (a = 0; a < i; a++) p ? "0" === n2[a] ? l += 1 : (p = false, l > c && (s = f, c = l)) : "0" === n2[a] && (p = true, f = a, l = 1);
            l > c && (s = f, c = l), c > 1 && n2.splice(s, c, ""), o2 = n2.length;
            var d = "";
            for ("" === n2[0] && (d = ":"), a = 0; a < o2 && (d += n2[a], a !== o2 - 1); a++) d += ":";
            return "" === n2[o2 - 1] && (d += ":"), d;
          }, noConflict: function() {
            return e3.IPv6 === this && (e3.IPv6 = t3), this;
          } };
        });
      }, 1764: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Asset = void 0;
        var o, i = r2(645), a = (o = r2(1918)) && o.__esModule ? o : { default: o }, u = r2(6691), s = r2(7120), c = r2(9152);
        function l(e3) {
          return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, l(e3);
        }
        function f(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, p(n2.key), n2);
          }
        }
        function p(e3) {
          var t3 = function(e4, t4) {
            if ("object" != l(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != l(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == l(t3) ? t3 : t3 + "";
        }
        t2.Asset = function() {
          function e3(t3, r3) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), !/^[a-zA-Z0-9]{1,12}$/.test(t3)) throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
            if ("xlm" !== String(t3).toLowerCase() && !r3) throw new Error("Issuer cannot be null");
            if (r3 && !s.StrKey.isValidEd25519PublicKey(r3)) throw new Error("Issuer is invalid");
            "xlm" === String(t3).toLowerCase() ? this.code = "XLM" : this.code = t3, this.issuer = r3;
          }
          return function(e4, t3, r3) {
            return t3 && f(e4.prototype, t3), r3 && f(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(e3, [{ key: "toXDRObject", value: function() {
            return this._toXDRObject(a.default.Asset);
          } }, { key: "toChangeTrustXDRObject", value: function() {
            return this._toXDRObject(a.default.ChangeTrustAsset);
          } }, { key: "toTrustLineXDRObject", value: function() {
            return this._toXDRObject(a.default.TrustLineAsset);
          } }, { key: "contractId", value: function(e4) {
            var t3 = (0, c.hash)(n.from(e4)), r3 = a.default.HashIdPreimage.envelopeTypeContractId(new a.default.HashIdPreimageContractId({ networkId: t3, contractIdPreimage: a.default.ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject()) }));
            return s.StrKey.encodeContract((0, c.hash)(r3.toXDR()));
          } }, { key: "_toXDRObject", value: function() {
            var e4, t3, r3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a.default.Asset;
            if (this.isNative()) return r3.assetTypeNative();
            this.code.length <= 4 ? (e4 = a.default.AlphaNum4, t3 = "assetTypeCreditAlphanum4") : (e4 = a.default.AlphaNum12, t3 = "assetTypeCreditAlphanum12");
            var n2 = this.code.length <= 4 ? 4 : 12;
            return new r3(t3, new e4({ assetCode: this.code.padEnd(n2, "\0"), issuer: u.Keypair.fromPublicKey(this.issuer).xdrAccountId() }));
          } }, { key: "getCode", value: function() {
            if (void 0 !== this.code) return String(this.code);
          } }, { key: "getIssuer", value: function() {
            if (void 0 !== this.issuer) return String(this.issuer);
          } }, { key: "getAssetType", value: function() {
            switch (this.getRawAssetType().value) {
              case a.default.AssetType.assetTypeNative().value:
                return "native";
              case a.default.AssetType.assetTypeCreditAlphanum4().value:
                return "credit_alphanum4";
              case a.default.AssetType.assetTypeCreditAlphanum12().value:
                return "credit_alphanum12";
              default:
                return "unknown";
            }
          } }, { key: "getRawAssetType", value: function() {
            return this.isNative() ? a.default.AssetType.assetTypeNative() : this.code.length <= 4 ? a.default.AssetType.assetTypeCreditAlphanum4() : a.default.AssetType.assetTypeCreditAlphanum12();
          } }, { key: "isNative", value: function() {
            return !this.issuer;
          } }, { key: "equals", value: function(e4) {
            return this.code === e4.getCode() && this.issuer === e4.getIssuer();
          } }, { key: "toString", value: function() {
            return this.isNative() ? "native" : "".concat(this.getCode(), ":").concat(this.getIssuer());
          } }], [{ key: "native", value: function() {
            return new e3("XLM");
          } }, { key: "fromOperation", value: function(e4) {
            var t3, r3;
            switch (e4.switch()) {
              case a.default.AssetType.assetTypeNative():
                return this.native();
              case a.default.AssetType.assetTypeCreditAlphanum4():
                t3 = e4.alphaNum4();
              case a.default.AssetType.assetTypeCreditAlphanum12():
                return t3 = t3 || e4.alphaNum12(), r3 = s.StrKey.encodeEd25519PublicKey(t3.issuer().ed25519()), new this((0, i.trimEnd)(t3.assetCode(), "\0"), r3);
              default:
                throw new Error("Invalid asset type: ".concat(e4.switch().name));
            }
          } }, { key: "compare", value: function(t3, r3) {
            if (!(t3 && t3 instanceof e3)) throw new Error("assetA is invalid");
            if (!(r3 && r3 instanceof e3)) throw new Error("assetB is invalid");
            if (t3.equals(r3)) return 0;
            var n2 = t3.getRawAssetType().value, o2 = r3.getRawAssetType().value;
            if (n2 !== o2) return n2 < o2 ? -1 : 1;
            var i2 = d(t3.getCode(), r3.getCode());
            return 0 !== i2 ? i2 : d(t3.getIssuer(), r3.getIssuer());
          } }]);
        }();
        function d(e3, t3) {
          return n.compare(n.from(e3, "ascii"), n.from(t3, "ascii"));
        }
      }, 1804: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.setTrustLineFlags = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = {};
          if ("object" !== a(e3.flags) || 0 === Object.keys(e3.flags).length) throw new Error("opts.flags must be a map of boolean flags to modify");
          var r3 = { authorized: o.default.TrustLineFlags.authorizedFlag(), authorizedToMaintainLiabilities: o.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(), clawbackEnabled: o.default.TrustLineFlags.trustlineClawbackEnabledFlag() }, n2 = 0, u = 0;
          Object.keys(e3.flags).forEach(function(t4) {
            if (!Object.prototype.hasOwnProperty.call(r3, t4)) throw new Error("unsupported flag name specified: ".concat(t4));
            var o2 = e3.flags[t4], i2 = r3[t4].value;
            true === o2 ? u |= i2 : false === o2 && (n2 |= i2);
          }), t3.trustor = i.Keypair.fromPublicKey(e3.trustor).xdrAccountId(), t3.asset = e3.asset.toXDRObject(), t3.clearFlags = n2, t3.setFlags = u;
          var s = { body: o.default.OperationBody.setTrustLineFlags(new o.default.SetTrustLineFlagsOp(t3)) };
          return this.setSourceAccount(s, e3), new o.default.Operation(s);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6691);
        function a(e3) {
          return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, a(e3);
        }
      }, 1918: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n, o = (n = r2(7938)) && n.__esModule ? n : { default: n };
        t2.default = o.default;
      }, 1922: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.manageBuyOffer = function(e3) {
          var t3 = {};
          if (t3.selling = e3.selling.toXDRObject(), t3.buying = e3.buying.toXDRObject(), !this.isValidAmount(e3.buyAmount, true)) throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
          if (t3.buyAmount = this._toXDRAmount(e3.buyAmount), void 0 === e3.price) throw new TypeError("price argument is required");
          t3.price = this._toXDRPrice(e3.price), void 0 !== e3.offerId ? e3.offerId = e3.offerId.toString() : e3.offerId = "0";
          t3.offerId = o.Hyper.fromString(e3.offerId);
          var r3 = new i.default.ManageBuyOfferOp(t3), n2 = {};
          return n2.body = i.default.OperationBody.manageBuyOffer(r3), this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        };
        var n, o = r2(3740), i = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 1924: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { StellarBase: () => a, default: () => u, httpClient: () => n.ok });
        var n = r2(6371), o = r2(4356), i = {};
        for (const e3 in o) ["default", "StellarBase", "httpClient"].indexOf(e3) < 0 && (i[e3] = () => o[e3]);
        r2.d(t2, i);
        var a = r2(356);
        const u = (e2 = r2.hmd(e2)).exports;
      }, 2018: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.setOptions = function(e3) {
          var t3 = {};
          if (e3.inflationDest) {
            if (!u.StrKey.isValidEd25519PublicKey(e3.inflationDest)) throw new Error("inflationDest is invalid");
            t3.inflationDest = a.Keypair.fromPublicKey(e3.inflationDest).xdrAccountId();
          }
          if (t3.clearFlags = this._checkUnsignedIntValue("clearFlags", e3.clearFlags), t3.setFlags = this._checkUnsignedIntValue("setFlags", e3.setFlags), t3.masterWeight = this._checkUnsignedIntValue("masterWeight", e3.masterWeight, s), t3.lowThreshold = this._checkUnsignedIntValue("lowThreshold", e3.lowThreshold, s), t3.medThreshold = this._checkUnsignedIntValue("medThreshold", e3.medThreshold, s), t3.highThreshold = this._checkUnsignedIntValue("highThreshold", e3.highThreshold, s), void 0 !== e3.homeDomain && "string" != typeof e3.homeDomain) throw new TypeError("homeDomain argument must be of type String");
          if (t3.homeDomain = e3.homeDomain, e3.signer) {
            var r3, o2 = this._checkUnsignedIntValue("signer.weight", e3.signer.weight, s), c = 0;
            if (e3.signer.ed25519PublicKey) {
              if (!u.StrKey.isValidEd25519PublicKey(e3.signer.ed25519PublicKey)) throw new Error("signer.ed25519PublicKey is invalid.");
              var l = u.StrKey.decodeEd25519PublicKey(e3.signer.ed25519PublicKey);
              r3 = new i.default.SignerKey.signerKeyTypeEd25519(l), c += 1;
            }
            if (e3.signer.preAuthTx) {
              if ("string" == typeof e3.signer.preAuthTx && (e3.signer.preAuthTx = n.from(e3.signer.preAuthTx, "hex")), !n.isBuffer(e3.signer.preAuthTx) || 32 !== e3.signer.preAuthTx.length) throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
              r3 = new i.default.SignerKey.signerKeyTypePreAuthTx(e3.signer.preAuthTx), c += 1;
            }
            if (e3.signer.sha256Hash) {
              if ("string" == typeof e3.signer.sha256Hash && (e3.signer.sha256Hash = n.from(e3.signer.sha256Hash, "hex")), !n.isBuffer(e3.signer.sha256Hash) || 32 !== e3.signer.sha256Hash.length) throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
              r3 = new i.default.SignerKey.signerKeyTypeHashX(e3.signer.sha256Hash), c += 1;
            }
            if (e3.signer.ed25519SignedPayload) {
              if (!u.StrKey.isValidSignedPayload(e3.signer.ed25519SignedPayload)) throw new Error("signer.ed25519SignedPayload is invalid.");
              var f = u.StrKey.decodeSignedPayload(e3.signer.ed25519SignedPayload), p = i.default.SignerKeyEd25519SignedPayload.fromXDR(f);
              r3 = i.default.SignerKey.signerKeyTypeEd25519SignedPayload(p), c += 1;
            }
            if (1 !== c) throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
            t3.signer = new i.default.Signer({ key: r3, weight: o2 });
          }
          var d = new i.default.SetOptionsOp(t3), h = {};
          return h.body = i.default.OperationBody.setOptions(d), this.setSourceAccount(h, e3), new i.default.Operation(h);
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(6691), u = r2(7120);
        function s(e3, t3) {
          if (e3 >= 0 && e3 <= 255) return true;
          throw new Error("".concat(t3, " value must be between 0 and 255"));
        }
      }, 2075: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.pathPaymentStrictReceive = function(e3) {
          switch (true) {
            case !e3.sendAsset:
              throw new Error("Must specify a send asset");
            case !this.isValidAmount(e3.sendMax):
              throw new TypeError(this.constructAmountRequirementsError("sendMax"));
            case !e3.destAsset:
              throw new Error("Must provide a destAsset for a payment operation");
            case !this.isValidAmount(e3.destAmount):
              throw new TypeError(this.constructAmountRequirementsError("destAmount"));
          }
          var t3 = {};
          t3.sendAsset = e3.sendAsset.toXDRObject(), t3.sendMax = this._toXDRAmount(e3.sendMax);
          try {
            t3.destination = (0, i.decodeAddressToMuxedAccount)(e3.destination);
          } catch (e4) {
            throw new Error("destination is invalid");
          }
          t3.destAsset = e3.destAsset.toXDRObject(), t3.destAmount = this._toXDRAmount(e3.destAmount);
          var r3 = e3.path ? e3.path : [];
          t3.path = r3.map(function(e4) {
            return e4.toXDRObject();
          });
          var n2 = new o.default.PathPaymentStrictReceiveOp(t3), a = {};
          return a.body = o.default.OperationBody.pathPaymentStrictReceive(n2), this.setSourceAccount(a, e3), new o.default.Operation(a);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6160);
      }, 2115: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createAccount = function(e3) {
          if (!a.StrKey.isValidEd25519PublicKey(e3.destination)) throw new Error("destination is invalid");
          if (!this.isValidAmount(e3.startingBalance, true)) throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
          var t3 = {};
          t3.destination = i.Keypair.fromPublicKey(e3.destination).xdrAccountId(), t3.startingBalance = this._toXDRAmount(e3.startingBalance);
          var r3 = new o.default.CreateAccountOp(t3), n2 = {};
          return n2.body = o.default.OperationBody.createAccount(r3), this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6691), a = r2(7120);
      }, 2135: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Account = void 0;
        var n, o = (n = r2(1242)) && n.__esModule ? n : { default: n }, i = r2(7120);
        function a(e3) {
          return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, a(e3);
        }
        function u(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, s(n2.key), n2);
          }
        }
        function s(e3) {
          var t3 = function(e4, t4) {
            if ("object" != a(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != a(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == a(t3) ? t3 : t3 + "";
        }
        t2.Account = function() {
          return function(e3, t3, r3) {
            return t3 && u(e3.prototype, t3), r3 && u(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3, r3) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), i.StrKey.isValidMed25519PublicKey(t3)) throw new Error("accountId is an M-address; use MuxedAccount instead");
            if (!i.StrKey.isValidEd25519PublicKey(t3)) throw new Error("accountId is invalid");
            if ("string" != typeof r3) throw new Error("sequence must be of type string");
            this._accountId = t3, this.sequence = new o.default(r3);
          }, [{ key: "accountId", value: function() {
            return this._accountId;
          } }, { key: "sequenceNumber", value: function() {
            return this.sequence.toString();
          } }, { key: "incrementSequenceNumber", value: function() {
            this.sequence = this.sequence.plus(1);
          } }]);
        }();
      }, 2203: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.clawbackClaimableBalance = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          (0, i.validateClaimableBalanceId)(e3.balanceId);
          var t3 = { balanceId: o.default.ClaimableBalanceId.fromXDR(e3.balanceId, "hex") }, r3 = { body: o.default.OperationBody.clawbackClaimableBalance(new o.default.ClawbackClaimableBalanceOp(t3)) };
          return this.setSourceAccount(r3, e3), new o.default.Operation(r3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(7239);
      }, 2243: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.MuxedAccount = void 0;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(2135), a = r2(7120), u = r2(6160);
        function s(e3) {
          return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, s(e3);
        }
        function c(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, l(n2.key), n2);
          }
        }
        function l(e3) {
          var t3 = function(e4, t4) {
            if ("object" != s(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != s(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == s(t3) ? t3 : t3 + "";
        }
        t2.MuxedAccount = function() {
          function e3(t3, r3) {
            !function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3);
            var n2 = t3.accountId();
            if (!a.StrKey.isValidEd25519PublicKey(n2)) throw new Error("accountId is invalid");
            this.account = t3, this._muxedXdr = (0, u.encodeMuxedAccount)(n2, r3), this._mAddress = (0, u.encodeMuxedAccountToAddress)(this._muxedXdr), this._id = r3;
          }
          return function(e4, t3, r3) {
            return t3 && c(e4.prototype, t3), r3 && c(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(e3, [{ key: "baseAccount", value: function() {
            return this.account;
          } }, { key: "accountId", value: function() {
            return this._mAddress;
          } }, { key: "id", value: function() {
            return this._id;
          } }, { key: "setId", value: function(e4) {
            if ("string" != typeof e4) throw new Error("id should be a string representing a number (uint64)");
            return this._muxedXdr.med25519().id(o.default.Uint64.fromString(e4)), this._mAddress = (0, u.encodeMuxedAccountToAddress)(this._muxedXdr), this._id = e4, this;
          } }, { key: "sequenceNumber", value: function() {
            return this.account.sequenceNumber();
          } }, { key: "incrementSequenceNumber", value: function() {
            return this.account.incrementSequenceNumber();
          } }, { key: "toXDRObject", value: function() {
            return this._muxedXdr;
          } }, { key: "equals", value: function(e4) {
            return this.accountId() === e4.accountId();
          } }], [{ key: "fromAddress", value: function(t3, r3) {
            var n2 = (0, u.decodeAddressToMuxedAccount)(t3), o2 = (0, u.extractBaseAddress)(t3), a2 = n2.med25519().id().toString();
            return new e3(new i.Account(o2, r3), a2);
          } }]);
        }();
      }, 2262: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LiquidityPoolAsset = void 0;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(1764), a = r2(5578);
        function u(e3) {
          return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, u(e3);
        }
        function s(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function c(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? s(Object(r3), true).forEach(function(t4) {
              l(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : s(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function l(e3, t3, r3) {
          return (t3 = p(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function f(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, p(n2.key), n2);
          }
        }
        function p(e3) {
          var t3 = function(e4, t4) {
            if ("object" != u(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != u(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == u(t3) ? t3 : t3 + "";
        }
        t2.LiquidityPoolAsset = function() {
          return function(e3, t3, r3) {
            return t3 && f(e3.prototype, t3), r3 && f(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3, r3, n2) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), !(t3 && t3 instanceof i.Asset)) throw new Error("assetA is invalid");
            if (!(r3 && r3 instanceof i.Asset)) throw new Error("assetB is invalid");
            if (-1 !== i.Asset.compare(t3, r3)) throw new Error("Assets are not in lexicographic order");
            if (!n2 || n2 !== a.LiquidityPoolFeeV18) throw new Error("fee is invalid");
            this.assetA = t3, this.assetB = r3, this.fee = n2;
          }, [{ key: "toXDRObject", value: function() {
            var e3 = new o.default.LiquidityPoolConstantProductParameters({ assetA: this.assetA.toXDRObject(), assetB: this.assetB.toXDRObject(), fee: this.fee }), t3 = new o.default.LiquidityPoolParameters("liquidityPoolConstantProduct", e3);
            return new o.default.ChangeTrustAsset("assetTypePoolShare", t3);
          } }, { key: "getLiquidityPoolParameters", value: function() {
            return c(c({}, this), {}, { assetA: this.assetA, assetB: this.assetB, fee: this.fee });
          } }, { key: "getAssetType", value: function() {
            return "liquidity_pool_shares";
          } }, { key: "equals", value: function(e3) {
            return this.assetA.equals(e3.assetA) && this.assetB.equals(e3.assetB) && this.fee === e3.fee;
          } }, { key: "toString", value: function() {
            var e3 = (0, a.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
            return "liquidity_pool:".concat(e3);
          } }], [{ key: "fromOperation", value: function(e3) {
            var t3 = e3.switch();
            if (t3 === o.default.AssetType.assetTypePoolShare()) {
              var r3 = e3.liquidityPool().constantProduct();
              return new this(i.Asset.fromOperation(r3.assetA()), i.Asset.fromOperation(r3.assetB()), r3.fee());
            }
            throw new Error("Invalid asset type: ".concat(t3.name));
          } }]);
        }();
      }, 2708: (e2) => {
        "use strict";
        e2.exports = { compile: function(e3) {
          var t2 = [], r2 = [], n = "", o = /* @__PURE__ */ Object.create(null), i = o;
          return function(e4) {
            for (var t3, r3 = 0; r3 < e4.length; r3++) switch ((t3 = e4[r3]).type) {
              case "Assign":
                u(t3);
                break;
              case "ObjectPath":
                f(t3);
                break;
              case "ArrayPath":
                p(t3);
            }
            return o;
          }(e3);
          function a(e4, t3, r3) {
            var n2 = new Error(e4);
            throw n2.line = t3, n2.column = r3, n2;
          }
          function u(e4) {
            var o2, u2 = e4.key, l2 = e4.value, f2 = e4.line, p2 = e4.column;
            o2 = n ? n + "." + u2 : u2, void 0 !== i[u2] && a("Cannot redefine existing key '" + o2 + "'.", f2, p2), i[u2] = c(l2), s(o2) || (t2.push(o2), r2.push(o2));
          }
          function s(e4) {
            return -1 !== t2.indexOf(e4);
          }
          function c(e4) {
            return "Array" === e4.type ? function(e5) {
              for (var t3 = null, r3 = 0; r3 < e5.length; r3++) {
                var n2 = e5[r3];
                null === t3 ? t3 = n2.type : n2.type !== t3 && a("Cannot add value of type " + n2.type + " to array of type " + t3 + ".", n2.line, n2.column);
              }
              return e5.map(c);
            }(e4.value) : "InlineTable" === e4.type ? l(e4.value) : e4.value;
          }
          function l(e4) {
            for (var t3 = /* @__PURE__ */ Object.create(null), r3 = 0; r3 < e4.length; r3++) {
              var n2 = e4[r3];
              "InlineTable" === n2.value.type ? t3[n2.key] = l(n2.value.value) : "InlineTableValue" === n2.type && (t3[n2.key] = c(n2.value));
            }
            return t3;
          }
          function f(e4) {
            var r3 = e4.value, u2 = r3.map(h).join("."), c2 = e4.line, l2 = e4.column;
            s(u2) && a("Cannot redefine existing key '" + r3 + "'.", c2, l2), t2.push(u2), i = d(o, r3, /* @__PURE__ */ Object.create(null), c2, l2), n = r3;
          }
          function p(e4) {
            var r3 = e4.value, u2 = r3.map(h).join("."), c2 = e4.line, l2 = e4.column;
            if (s(u2) || t2.push(u2), (t2 = t2.filter(function(e5) {
              return 0 !== e5.indexOf(u2);
            })).push(u2), i = d(o, r3, [], c2, l2), n = u2, i instanceof Array) {
              var f2 = /* @__PURE__ */ Object.create(null);
              i.push(f2), i = f2;
            } else a("Cannot redefine existing key '" + r3 + "'.", c2, l2);
          }
          function d(e4, t3, n2, o2, i2) {
            for (var u2 = [], s2 = "", c2 = (t3.join("."), e4), l2 = 0; l2 < t3.length; l2++) {
              var f2 = t3[l2];
              u2.push(f2), s2 = u2.join("."), void 0 === c2[f2] ? l2 === t3.length - 1 ? c2[f2] = n2 : c2[f2] = /* @__PURE__ */ Object.create(null) : l2 !== t3.length - 1 && r2.indexOf(s2) > -1 && a("Cannot redefine existing key '" + s2 + "'.", o2, i2), (c2 = c2[f2]) instanceof Array && c2.length && l2 < t3.length - 1 && (c2 = c2[c2.length - 1]);
            }
            return c2;
          }
          function h(e4) {
            return e4.indexOf(".") > -1 ? '"' + e4 + '"' : e4;
          }
        } };
      }, 2802: (e2, t2, r2) => {
        var n = e2.exports = function(e3) {
          e3 = e3.toLowerCase();
          var t3 = n[e3];
          if (!t3) throw new Error(e3 + " is not supported (we accept pull requests)");
          return new t3();
        };
        n.sha = r2(7816), n.sha1 = r2(3737), n.sha224 = r2(6710), n.sha256 = r2(4107), n.sha384 = r2(2827), n.sha512 = r2(2890);
      }, 2810: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.changeTrust = function(e3) {
          var t3 = {};
          if (e3.asset instanceof a.Asset) t3.line = e3.asset.toChangeTrustXDRObject();
          else {
            if (!(e3.asset instanceof u.LiquidityPoolAsset)) throw new TypeError("asset must be Asset or LiquidityPoolAsset");
            t3.line = e3.asset.toXDRObject();
          }
          if (void 0 !== e3.limit && !this.isValidAmount(e3.limit, true)) throw new TypeError(this.constructAmountRequirementsError("limit"));
          e3.limit ? t3.limit = this._toXDRAmount(e3.limit) : t3.limit = n.Hyper.fromString(new o.default(c).toString());
          e3.source && (t3.source = e3.source.masterKeypair);
          var r3 = new i.default.ChangeTrustOp(t3), s2 = {};
          return s2.body = i.default.OperationBody.changeTrust(r3), this.setSourceAccount(s2, e3), new i.default.Operation(s2);
        };
        var n = r2(3740), o = s(r2(1242)), i = s(r2(1918)), a = r2(1764), u = r2(2262);
        function s(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var c = "9223372036854775807";
      }, 2827: (e2, t2, r2) => {
        var n = r2(6698), o = r2(2890), i = r2(392), a = r2(2861).Buffer, u = new Array(160);
        function s() {
          this.init(), this._w = u, i.call(this, 128, 112);
        }
        n(s, o), s.prototype.init = function() {
          return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
        }, s.prototype._hash = function() {
          var e3 = a.allocUnsafe(48);
          function t3(t4, r3, n2) {
            e3.writeInt32BE(t4, n2), e3.writeInt32BE(r3, n2 + 4);
          }
          return t3(this._ah, this._al, 0), t3(this._bh, this._bl, 8), t3(this._ch, this._cl, 16), t3(this._dh, this._dl, 24), t3(this._eh, this._el, 32), t3(this._fh, this._fl, 40), e3;
        }, e2.exports = s;
      }, 2861: (e2, t2, r2) => {
        var n = r2(8287), o = n.Buffer;
        function i(e3, t3) {
          for (var r3 in e3) t3[r3] = e3[r3];
        }
        function a(e3, t3, r3) {
          return o(e3, t3, r3);
        }
        o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e2.exports = n : (i(n, t2), t2.Buffer = a), a.prototype = Object.create(o.prototype), i(o, a), a.from = function(e3, t3, r3) {
          if ("number" == typeof e3) throw new TypeError("Argument must not be a number");
          return o(e3, t3, r3);
        }, a.alloc = function(e3, t3, r3) {
          if ("number" != typeof e3) throw new TypeError("Argument must be a number");
          var n2 = o(e3);
          return void 0 !== t3 ? "string" == typeof r3 ? n2.fill(t3, r3) : n2.fill(t3) : n2.fill(0), n2;
        }, a.allocUnsafe = function(e3) {
          if ("number" != typeof e3) throw new TypeError("Argument must be a number");
          return o(e3);
        }, a.allocUnsafeSlow = function(e3) {
          if ("number" != typeof e3) throw new TypeError("Argument must be a number");
          return n.SlowBuffer(e3);
        };
      }, 2890: (e2, t2, r2) => {
        var n = r2(6698), o = r2(392), i = r2(2861).Buffer, a = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], u = new Array(160);
        function s() {
          this.init(), this._w = u, o.call(this, 128, 112);
        }
        function c(e3, t3, r3) {
          return r3 ^ e3 & (t3 ^ r3);
        }
        function l(e3, t3, r3) {
          return e3 & t3 | r3 & (e3 | t3);
        }
        function f(e3, t3) {
          return (e3 >>> 28 | t3 << 4) ^ (t3 >>> 2 | e3 << 30) ^ (t3 >>> 7 | e3 << 25);
        }
        function p(e3, t3) {
          return (e3 >>> 14 | t3 << 18) ^ (e3 >>> 18 | t3 << 14) ^ (t3 >>> 9 | e3 << 23);
        }
        function d(e3, t3) {
          return (e3 >>> 1 | t3 << 31) ^ (e3 >>> 8 | t3 << 24) ^ e3 >>> 7;
        }
        function h(e3, t3) {
          return (e3 >>> 1 | t3 << 31) ^ (e3 >>> 8 | t3 << 24) ^ (e3 >>> 7 | t3 << 25);
        }
        function y(e3, t3) {
          return (e3 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e3 << 3) ^ e3 >>> 6;
        }
        function m(e3, t3) {
          return (e3 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e3 << 3) ^ (e3 >>> 6 | t3 << 26);
        }
        function v(e3, t3) {
          return e3 >>> 0 < t3 >>> 0 ? 1 : 0;
        }
        n(s, o), s.prototype.init = function() {
          return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
        }, s.prototype._update = function(e3) {
          for (var t3 = this._w, r3 = 0 | this._ah, n2 = 0 | this._bh, o2 = 0 | this._ch, i2 = 0 | this._dh, u2 = 0 | this._eh, s2 = 0 | this._fh, g = 0 | this._gh, b = 0 | this._hh, w = 0 | this._al, S = 0 | this._bl, k = 0 | this._cl, E = 0 | this._dl, _ = 0 | this._el, T = 0 | this._fl, O = 0 | this._gl, x = 0 | this._hl, A = 0; A < 32; A += 2) t3[A] = e3.readInt32BE(4 * A), t3[A + 1] = e3.readInt32BE(4 * A + 4);
          for (; A < 160; A += 2) {
            var P = t3[A - 30], I = t3[A - 30 + 1], R = d(P, I), C = h(I, P), j = y(P = t3[A - 4], I = t3[A - 4 + 1]), B = m(I, P), L = t3[A - 14], N = t3[A - 14 + 1], U = t3[A - 32], M = t3[A - 32 + 1], F = C + N | 0, D = R + L + v(F, C) | 0;
            D = (D = D + j + v(F = F + B | 0, B) | 0) + U + v(F = F + M | 0, M) | 0, t3[A] = D, t3[A + 1] = F;
          }
          for (var V = 0; V < 160; V += 2) {
            D = t3[V], F = t3[V + 1];
            var q = l(r3, n2, o2), K = l(w, S, k), H = f(r3, w), z = f(w, r3), X = p(u2, _), G = p(_, u2), $ = a[V], Q = a[V + 1], W = c(u2, s2, g), Y = c(_, T, O), J = x + G | 0, Z = b + X + v(J, x) | 0;
            Z = (Z = (Z = Z + W + v(J = J + Y | 0, Y) | 0) + $ + v(J = J + Q | 0, Q) | 0) + D + v(J = J + F | 0, F) | 0;
            var ee = z + K | 0, te = H + q + v(ee, z) | 0;
            b = g, x = O, g = s2, O = T, s2 = u2, T = _, u2 = i2 + Z + v(_ = E + J | 0, E) | 0, i2 = o2, E = k, o2 = n2, k = S, n2 = r3, S = w, r3 = Z + te + v(w = J + ee | 0, J) | 0;
          }
          this._al = this._al + w | 0, this._bl = this._bl + S | 0, this._cl = this._cl + k | 0, this._dl = this._dl + E | 0, this._el = this._el + _ | 0, this._fl = this._fl + T | 0, this._gl = this._gl + O | 0, this._hl = this._hl + x | 0, this._ah = this._ah + r3 + v(this._al, w) | 0, this._bh = this._bh + n2 + v(this._bl, S) | 0, this._ch = this._ch + o2 + v(this._cl, k) | 0, this._dh = this._dh + i2 + v(this._dl, E) | 0, this._eh = this._eh + u2 + v(this._el, _) | 0, this._fh = this._fh + s2 + v(this._fl, T) | 0, this._gh = this._gh + g + v(this._gl, O) | 0, this._hh = this._hh + b + v(this._hl, x) | 0;
        }, s.prototype._hash = function() {
          var e3 = i.allocUnsafe(64);
          function t3(t4, r3, n2) {
            e3.writeInt32BE(t4, n2), e3.writeInt32BE(r3, n2 + 4);
          }
          return t3(this._ah, this._al, 0), t3(this._bh, this._bl, 8), t3(this._ch, this._cl, 16), t3(this._dh, this._dl, 24), t3(this._eh, this._el, 32), t3(this._fh, this._fl, 40), t3(this._gh, this._gl, 48), t3(this._hh, this._hl, 56), e3;
        }, e2.exports = s;
      }, 2894: () => {
      }, 3121: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        function o(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, i(n2.key), n2);
          }
        }
        function i(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        r2.d(t2, { A: () => c });
        var a, u, s, c = (a = function e3() {
          !function(e4, t3) {
            if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
          }(this, e3);
        }, s = [{ key: "validateTimebounds", value: function(e3) {
          var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          if (!e3.timeBounds) return false;
          var r3 = Math.floor(Date.now() / 1e3), n2 = e3.timeBounds, o2 = n2.minTime, i2 = n2.maxTime;
          return r3 >= Number.parseInt(o2, 10) - t3 && r3 <= Number.parseInt(i2, 10) + t3;
        } }, { key: "sleep", value: function(e3) {
          return new Promise(function(t3) {
            return setTimeout(t3, e3);
          });
        } }], (u = null) && o(a.prototype, u), s && o(a, s), Object.defineProperty(a, "prototype", { writable: false }), a);
      }, 3209: (e2, t2, r2) => {
        "use strict";
        var n = 65536, o = 4294967295;
        var i = r2(2861).Buffer, a = r2.g.crypto || r2.g.msCrypto;
        a && a.getRandomValues ? e2.exports = function(e3, t3) {
          if (e3 > o) throw new RangeError("requested too many random bytes");
          var r3 = i.allocUnsafe(e3);
          if (e3 > 0) if (e3 > n) for (var u = 0; u < e3; u += n) a.getRandomValues(r3.slice(u, u + n));
          else a.getRandomValues(r3);
          if ("function" == typeof t3) return process.nextTick(function() {
            t3(null, r3);
          });
          return r3;
        } : e2.exports = function() {
          throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
        };
      }, 3317: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ScInt = void 0;
        var o = r2(7429);
        function i(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, a(n2.key), n2);
          }
        }
        function a(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        function u(e3, t3, r3) {
          return t3 = c(t3), function(e4, t4) {
            if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, s() ? Reflect.construct(t3, r3 || [], c(e3).constructor) : t3.apply(e3, r3));
        }
        function s() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (s = function() {
            return !!e3;
          })();
        }
        function c(e3) {
          return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, c(e3);
        }
        function l(e3, t3) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, l(e3, t3);
        }
        t2.ScInt = function(e3) {
          function t3(e4, r4) {
            var n3;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var o3 = e4 < 0, i2 = null !== (n3 = null == r4 ? void 0 : r4.type) && void 0 !== n3 ? n3 : "";
            if (i2.startsWith("u") && o3) throw TypeError("specified type ".concat(r4.type, " yet negative (").concat(e4, ")"));
            if ("" === i2) {
              i2 = o3 ? "i" : "u";
              var a2 = function(e5) {
                var t4, r5 = e5.toString(2).length;
                return null !== (t4 = [64, 128, 256].find(function(e6) {
                  return r5 <= e6;
                })) && void 0 !== t4 ? t4 : r5;
              }(e4);
              switch (a2) {
                case 64:
                case 128:
                case 256:
                  i2 += a2.toString();
                  break;
                default:
                  throw RangeError("expected 64/128/256 bits for input (".concat(e4, "), got ").concat(a2));
              }
            }
            return u(this, t3, [i2, e4]);
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && l(e4, t4);
          }(t3, e3), r3 = t3, n2 && i(r3.prototype, n2), o2 && i(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(o.XdrLargeInt);
      }, 3335: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2(3740), o = { XdrWriter: n.XdrWriter, XdrReader: n.XdrReader };
        t2.default = o;
      }, 3496: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { Api: () => n.j, AxiosClient: () => u, BasicSleepStrategy: () => x, Durability: () => O, LinearSleepStrategy: () => A, Server: () => oe, assembleTransaction: () => d.X, default: () => ie, parseRawEvents: () => h.fG, parseRawSimulation: () => h.jr });
        var n = r2(4076), o = r2(4193), i = r2.n(o), a = r2(356);
        const u = (0, r2(6371).vt)({ headers: { "X-Client-Name": "js-soroban-client", "X-Client-Version": "13.3.0" } });
        function s(e3) {
          return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, s(e3);
        }
        function c() {
          c = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", l2 = i2.toStringTag || "@@toStringTag";
          function f2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            f2({}, "");
          } catch (e4) {
            f2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function p2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof b2 ? t4 : b2, a3 = Object.create(i3.prototype), u3 = new C2(n3 || []);
            return o2(a3, "_invoke", { value: A2(e4, r4, u3) }), a3;
          }
          function d2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = p2;
          var h2 = "suspendedStart", y2 = "suspendedYield", m2 = "executing", v2 = "completed", g2 = {};
          function b2() {
          }
          function w2() {
          }
          function S2() {
          }
          var k2 = {};
          f2(k2, a2, function() {
            return this;
          });
          var E2 = Object.getPrototypeOf, _2 = E2 && E2(E2(j2([])));
          _2 && _2 !== r3 && n2.call(_2, a2) && (k2 = _2);
          var T2 = S2.prototype = b2.prototype = Object.create(k2);
          function O2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              f2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function x2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var c2 = d2(e4[o3], e4, i4);
              if ("throw" !== c2.type) {
                var l3 = c2.arg, f3 = l3.value;
                return f3 && "object" == s(f3) && n2.call(f3, "__await") ? t4.resolve(f3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(f3).then(function(e5) {
                  l3.value = e5, a3(l3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(c2.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A2(t4, r4, n3) {
            var o3 = h2;
            return function(i3, a3) {
              if (o3 === m2) throw Error("Generator is already running");
              if (o3 === v2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s2 = P2(u3, n3);
                  if (s2) {
                    if (s2 === g2) continue;
                    return s2;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === h2) throw o3 = v2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = m2;
                var c2 = d2(t4, r4, n3);
                if ("normal" === c2.type) {
                  if (o3 = n3.done ? v2 : y2, c2.arg === g2) continue;
                  return { value: c2.arg, done: n3.done };
                }
                "throw" === c2.type && (o3 = v2, n3.method = "throw", n3.arg = c2.arg);
              }
            };
          }
          function P2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, P2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g2;
            var i3 = d2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, g2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, g2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, g2);
          }
          function I2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function R2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function C2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(I2, this), this.reset(true);
          }
          function j2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(s(t4) + " is not iterable");
          }
          return w2.prototype = S2, o2(T2, "constructor", { value: S2, configurable: true }), o2(S2, "constructor", { value: w2, configurable: true }), w2.displayName = f2(S2, l2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === w2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, S2) : (e4.__proto__ = S2, f2(e4, l2, "GeneratorFunction")), e4.prototype = Object.create(T2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, O2(x2.prototype), f2(x2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = x2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new x2(p2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, O2(T2), f2(T2, l2, "Generator"), f2(T2, a2, function() {
            return this;
          }), f2(T2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = j2, C2.prototype = { constructor: C2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(R2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s2 = n2.call(a3, "catchLoc"), c2 = n2.call(a3, "finallyLoc");
                if (s2 && c2) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s2) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c2) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, g2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), g2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), R2(r4), g2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  R2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: j2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), g2;
          } }, t3;
        }
        function l(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function f(e3, t3) {
          return p.apply(this, arguments);
        }
        function p() {
          var e3;
          return e3 = c().mark(function e4(t3, r3) {
            var n2, o2, i2, a2 = arguments;
            return c().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  return n2 = a2.length > 2 && void 0 !== a2[2] ? a2[2] : null, e5.next = 3, u.post(t3, { jsonrpc: "2.0", id: 1, method: r3, params: n2 });
                case 3:
                  if (o2 = e5.sent, s2 = o2.data, c2 = "error", !s2.hasOwnProperty(c2)) {
                    e5.next = 8;
                    break;
                  }
                  throw o2.data.error;
                case 8:
                  return e5.abrupt("return", null === (i2 = o2.data) || void 0 === i2 ? void 0 : i2.result);
                case 9:
                case "end":
                  return e5.stop();
              }
              var s2, c2;
            }, e4);
          }), p = function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                l(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                l(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          }, p.apply(this, arguments);
        }
        var d = r2(8680), h = r2(784), y = r2(3121), m = r2(8287).Buffer;
        function v(e3) {
          return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, v(e3);
        }
        function g(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function b(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? g(Object(r3), true).forEach(function(t4) {
              w(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : g(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function w(e3, t3, r3) {
          return (t3 = T(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function S() {
          S = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof g2 ? t4 : g2, a3 = Object.create(i3.prototype), u3 = new C2(n3 || []);
            return o2(a3, "_invoke", { value: A2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function g2() {
          }
          function b2() {
          }
          function w2() {
          }
          var k2 = {};
          c2(k2, a2, function() {
            return this;
          });
          var E2 = Object.getPrototypeOf, _2 = E2 && E2(E2(j2([])));
          _2 && _2 !== r3 && n2.call(_2, a2) && (k2 = _2);
          var T2 = w2.prototype = g2.prototype = Object.create(k2);
          function O2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function x2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == v(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = P2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function P2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, P2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function I2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function R2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function C2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(I2, this), this.reset(true);
          }
          function j2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(v(t4) + " is not iterable");
          }
          return b2.prototype = w2, o2(T2, "constructor", { value: w2, configurable: true }), o2(w2, "constructor", { value: b2, configurable: true }), b2.displayName = c2(w2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === b2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, w2) : (e4.__proto__ = w2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(T2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, O2(x2.prototype), c2(x2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = x2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new x2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, O2(T2), c2(T2, s2, "Generator"), c2(T2, a2, function() {
            return this;
          }), c2(T2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = j2, C2.prototype = { constructor: C2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(R2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), R2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  R2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: j2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function k(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function E(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                k(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                k(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function _(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, T(n2.key), n2);
          }
        }
        function T(e3) {
          var t3 = function(e4, t4) {
            if ("object" != v(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != v(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == v(t3) ? t3 : t3 + "";
        }
        var O = function(e3) {
          return e3.Temporary = "temporary", e3.Persistent = "persistent", e3;
        }({}), x = function(e3) {
          return 1e3;
        }, A = function(e3) {
          return 1e3 * e3;
        };
        function P(e3) {
          var t3, r3 = [];
          switch (e3.switch()) {
            case 0:
              r3 = e3.operations();
              break;
            case 1:
            case 2:
            case 3:
              r3 = e3.value().operations();
              break;
            default:
              throw new Error("Unexpected transaction meta switch value");
          }
          var n2 = null === (t3 = r3.flatMap(function(e4) {
            return e4.changes();
          }).find(function(e4) {
            return e4.switch() === a.xdr.LedgerEntryChangeType.ledgerEntryCreated() && e4.created().data().switch() === a.xdr.LedgerEntryType.account();
          })) || void 0 === t3 || null === (t3 = t3.created()) || void 0 === t3 || null === (t3 = t3.data()) || void 0 === t3 || null === (t3 = t3.account()) || void 0 === t3 || null === (t3 = t3.seqNum()) || void 0 === t3 ? void 0 : t3.toString();
          if (n2) return n2;
          throw new Error("No account created in transaction");
        }
        var I, R, C, j, B, L, N, U, M, F, D, V, q, K, H, z, X, G, $, Q, W, Y, J, Z, ee, te, re, ne, oe = (I = function e3(t3) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), this.serverURL = i()(t3), r3.headers && 0 !== Object.keys(r3.headers).length && u.interceptors.request.use(function(e4) {
            return e4.headers = Object.assign(e4.headers, r3.headers), e4;
          }), "https" !== this.serverURL.protocol() && !r3.allowHttp) throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
        }, R = [{ key: "getAccount", value: (ne = E(S().mark(function e3(t3) {
          var r3, n2, o2;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return r3 = a.xdr.LedgerKey.account(new a.xdr.LedgerKeyAccount({ accountId: a.Keypair.fromPublicKey(t3).xdrPublicKey() })), e4.next = 3, this.getLedgerEntries(r3);
              case 3:
                if (0 !== (n2 = e4.sent).entries.length) {
                  e4.next = 6;
                  break;
                }
                return e4.abrupt("return", Promise.reject({ code: 404, message: "Account not found: ".concat(t3) }));
              case 6:
                return o2 = n2.entries[0].val.account(), e4.abrupt("return", new a.Account(t3, o2.seqNum().toString()));
              case 8:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return ne.apply(this, arguments);
        }) }, { key: "getHealth", value: (re = E(S().mark(function e3() {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getHealth"));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return re.apply(this, arguments);
        }) }, { key: "getContractData", value: (te = E(S().mark(function e3(t3, r3) {
          var n2, o2, i2, u2, s2 = arguments;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if (n2 = s2.length > 2 && void 0 !== s2[2] ? s2[2] : O.Persistent, "string" != typeof t3) {
                  e4.next = 5;
                  break;
                }
                o2 = new a.Contract(t3).address().toScAddress(), e4.next = 14;
                break;
              case 5:
                if (!(t3 instanceof a.Address)) {
                  e4.next = 9;
                  break;
                }
                o2 = t3.toScAddress(), e4.next = 14;
                break;
              case 9:
                if (!(t3 instanceof a.Contract)) {
                  e4.next = 13;
                  break;
                }
                o2 = t3.address().toScAddress(), e4.next = 14;
                break;
              case 13:
                throw new TypeError("unknown contract type: ".concat(t3));
              case 14:
                e4.t0 = n2, e4.next = e4.t0 === O.Temporary ? 17 : e4.t0 === O.Persistent ? 19 : 21;
                break;
              case 17:
                return i2 = a.xdr.ContractDataDurability.temporary(), e4.abrupt("break", 22);
              case 19:
                return i2 = a.xdr.ContractDataDurability.persistent(), e4.abrupt("break", 22);
              case 21:
                throw new TypeError("invalid durability: ".concat(n2));
              case 22:
                return u2 = a.xdr.LedgerKey.contractData(new a.xdr.LedgerKeyContractData({ key: r3, contract: o2, durability: i2 })), e4.abrupt("return", this.getLedgerEntries(u2).then(function(e5) {
                  return 0 === e5.entries.length ? Promise.reject({ code: 404, message: "Contract data not found. Contract: ".concat(a.Address.fromScAddress(o2).toString(), ", Key: ").concat(r3.toXDR("base64"), ", Durability: ").concat(n2) }) : e5.entries[0];
                }));
              case 24:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3, t3) {
          return te.apply(this, arguments);
        }) }, { key: "getContractWasmByContractId", value: (ee = E(S().mark(function e3(t3) {
          var r3, n2, o2, i2;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return n2 = new a.Contract(t3).getFootprint(), e4.next = 3, this.getLedgerEntries(n2);
              case 3:
                if ((o2 = e4.sent).entries.length && null !== (r3 = o2.entries[0]) && void 0 !== r3 && r3.val) {
                  e4.next = 6;
                  break;
                }
                return e4.abrupt("return", Promise.reject({ code: 404, message: "Could not obtain contract hash from server" }));
              case 6:
                return i2 = o2.entries[0].val.contractData().val().instance().executable().wasmHash(), e4.abrupt("return", this.getContractWasmByHash(i2));
              case 8:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return ee.apply(this, arguments);
        }) }, { key: "getContractWasmByHash", value: (Z = E(S().mark(function e3(t3) {
          var r3, n2, o2, i2, u2, s2, c2 = arguments;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return n2 = c2.length > 1 && void 0 !== c2[1] ? c2[1] : void 0, o2 = "string" == typeof t3 ? m.from(t3, n2) : t3, i2 = a.xdr.LedgerKey.contractCode(new a.xdr.LedgerKeyContractCode({ hash: o2 })), e4.next = 5, this.getLedgerEntries(i2);
              case 5:
                if ((u2 = e4.sent).entries.length && null !== (r3 = u2.entries[0]) && void 0 !== r3 && r3.val) {
                  e4.next = 8;
                  break;
                }
                return e4.abrupt("return", Promise.reject({ code: 404, message: "Could not obtain contract wasm from server" }));
              case 8:
                return s2 = u2.entries[0].val.contractCode().code(), e4.abrupt("return", s2);
              case 10:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return Z.apply(this, arguments);
        }) }, { key: "getLedgerEntries", value: (J = E(S().mark(function e3() {
          var t3 = arguments;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", this._getLedgerEntries.apply(this, t3).then(h.$D));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return J.apply(this, arguments);
        }) }, { key: "_getLedgerEntries", value: (Y = E(S().mark(function e3() {
          var t3, r3, n2, o2 = arguments;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                for (t3 = o2.length, r3 = new Array(t3), n2 = 0; n2 < t3; n2++) r3[n2] = o2[n2];
                return e4.abrupt("return", f(this.serverURL.toString(), "getLedgerEntries", { keys: r3.map(function(e5) {
                  return e5.toXDR("base64");
                }) }));
              case 2:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return Y.apply(this, arguments);
        }) }, { key: "pollTransaction", value: (W = E(S().mark(function e3(t3, r3) {
          var o2, i2, a2, u2, s2, c2;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                a2 = (null !== (o2 = null == r3 ? void 0 : r3.attempts) && void 0 !== o2 ? o2 : 0) < 1 ? 30 : null !== (i2 = null == r3 ? void 0 : r3.attempts) && void 0 !== i2 ? i2 : 30, s2 = 1;
              case 2:
                if (!(s2 < a2)) {
                  e4.next = 13;
                  break;
                }
                return e4.next = 5, this.getTransaction(t3);
              case 5:
                if ((u2 = e4.sent).status === n.j.GetTransactionStatus.NOT_FOUND) {
                  e4.next = 8;
                  break;
                }
                return e4.abrupt("return", u2);
              case 8:
                return e4.next = 10, y.A.sleep((null !== (c2 = null == r3 ? void 0 : r3.sleepStrategy) && void 0 !== c2 ? c2 : x)(s2));
              case 10:
                s2++, e4.next = 2;
                break;
              case 13:
                return e4.abrupt("return", u2);
              case 14:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3, t3) {
          return W.apply(this, arguments);
        }) }, { key: "getTransaction", value: (Q = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", this._getTransaction(t3).then(function(e5) {
                  var r3 = {};
                  return e5.status !== n.j.GetTransactionStatus.NOT_FOUND && Object.assign(r3, (0, h.WC)(e5)), b({ status: e5.status, txHash: t3, latestLedger: e5.latestLedger, latestLedgerCloseTime: e5.latestLedgerCloseTime, oldestLedger: e5.oldestLedger, oldestLedgerCloseTime: e5.oldestLedgerCloseTime }, r3);
                }));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return Q.apply(this, arguments);
        }) }, { key: "_getTransaction", value: ($ = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getTransaction", { hash: t3 }));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return $.apply(this, arguments);
        }) }, { key: "getTransactions", value: (G = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", this._getTransactions(t3).then(function(e5) {
                  return { transactions: (e5.transactions || []).map(h.tR), latestLedger: e5.latestLedger, latestLedgerCloseTimestamp: e5.latestLedgerCloseTimestamp, oldestLedger: e5.oldestLedger, oldestLedgerCloseTimestamp: e5.oldestLedgerCloseTimestamp, cursor: e5.cursor };
                }));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return G.apply(this, arguments);
        }) }, { key: "_getTransactions", value: (X = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getTransactions", t3));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return X.apply(this, arguments);
        }) }, { key: "getEvents", value: (z = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", this._getEvents(t3).then(h.fG));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return z.apply(this, arguments);
        }) }, { key: "_getEvents", value: (H = E(S().mark(function e3(t3) {
          var r3;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getEvents", b(b({ filters: null !== (r3 = t3.filters) && void 0 !== r3 ? r3 : [], pagination: b(b({}, t3.cursor && { cursor: t3.cursor }), t3.limit && { limit: t3.limit }) }, t3.startLedger && { startLedger: t3.startLedger }), t3.endLedger && { endLedger: t3.endLedger })));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return H.apply(this, arguments);
        }) }, { key: "getNetwork", value: (K = E(S().mark(function e3() {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getNetwork"));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return K.apply(this, arguments);
        }) }, { key: "getLatestLedger", value: (q = E(S().mark(function e3() {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getLatestLedger"));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return q.apply(this, arguments);
        }) }, { key: "simulateTransaction", value: (V = E(S().mark(function e3(t3, r3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", this._simulateTransaction(t3, r3).then(h.jr));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3, t3) {
          return V.apply(this, arguments);
        }) }, { key: "_simulateTransaction", value: (D = E(S().mark(function e3(t3, r3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "simulateTransaction", b({ transaction: t3.toXDR() }, void 0 !== r3 && { resourceConfig: { instructionLeeway: r3.cpuInstructions } })));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3, t3) {
          return D.apply(this, arguments);
        }) }, { key: "prepareTransaction", value: (F = E(S().mark(function e3(t3) {
          var r3;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.next = 2, this.simulateTransaction(t3);
              case 2:
                if (r3 = e4.sent, !n.j.isSimulationError(r3)) {
                  e4.next = 5;
                  break;
                }
                throw new Error(r3.error);
              case 5:
                return e4.abrupt("return", (0, d.X)(t3, r3).build());
              case 6:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return F.apply(this, arguments);
        }) }, { key: "sendTransaction", value: (M = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", this._sendTransaction(t3).then(h.Af));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return M.apply(this, arguments);
        }) }, { key: "_sendTransaction", value: (U = E(S().mark(function e3(t3) {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "sendTransaction", { transaction: t3.toXDR() }));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return U.apply(this, arguments);
        }) }, { key: "requestAirdrop", value: (N = E(S().mark(function e3(t3, r3) {
          var o2, i2, s2, c2, l2, f2, p2;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if (o2 = "string" == typeof t3 ? t3 : t3.accountId(), e4.t0 = r3, e4.t0) {
                  e4.next = 6;
                  break;
                }
                return e4.next = 5, this.getNetwork();
              case 5:
                e4.t0 = e4.sent.friendbotUrl;
              case 6:
                if (r3 = e4.t0) {
                  e4.next = 9;
                  break;
                }
                throw new Error("No friendbot URL configured for current network");
              case 9:
                return e4.prev = 9, e4.next = 12, u.post("".concat(r3, "?addr=").concat(encodeURIComponent(o2)));
              case 12:
                if ((i2 = e4.sent).data.result_meta_xdr) {
                  e4.next = 22;
                  break;
                }
                return e4.next = 16, this.getTransaction(i2.data.hash);
              case 16:
                if ((c2 = e4.sent).status === n.j.GetTransactionStatus.SUCCESS) {
                  e4.next = 19;
                  break;
                }
                throw new Error("Funding account ".concat(t3, " failed"));
              case 19:
                s2 = c2.resultMetaXdr, e4.next = 23;
                break;
              case 22:
                s2 = a.xdr.TransactionMeta.fromXDR(i2.data.result_meta_xdr, "base64");
              case 23:
                return l2 = P(s2), e4.abrupt("return", new a.Account(o2, l2));
              case 27:
                if (e4.prev = 27, e4.t1 = e4.catch(9), 400 !== (null === (f2 = e4.t1.response) || void 0 === f2 ? void 0 : f2.status)) {
                  e4.next = 32;
                  break;
                }
                if (null === (p2 = e4.t1.response.detail) || void 0 === p2 || !p2.includes("createAccountAlreadyExist")) {
                  e4.next = 32;
                  break;
                }
                return e4.abrupt("return", this.getAccount(o2));
              case 32:
                throw e4.t1;
              case 33:
              case "end":
                return e4.stop();
            }
          }, e3, this, [[9, 27]]);
        })), function(e3, t3) {
          return N.apply(this, arguments);
        }) }, { key: "getFeeStats", value: (L = E(S().mark(function e3() {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getFeeStats"));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return L.apply(this, arguments);
        }) }, { key: "getVersionInfo", value: (B = E(S().mark(function e3() {
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.abrupt("return", f(this.serverURL.toString(), "getVersionInfo"));
              case 1:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return B.apply(this, arguments);
        }) }, { key: "getSACBalance", value: (j = E(S().mark(function e3(t3, r3, n2) {
          var o2, i2, u2, s2, c2, l2, f2, p2, d2, h2;
          return S().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if (a.StrKey.isValidContract(t3)) {
                  e4.next = 2;
                  break;
                }
                throw new TypeError("expected contract ID, got ".concat(t3));
              case 2:
                if (null == n2) {
                  e4.next = 6;
                  break;
                }
                e4.t0 = n2, e4.next = 9;
                break;
              case 6:
                return e4.next = 8, this.getNetwork().then(function(e5) {
                  return e5.passphrase;
                });
              case 8:
                e4.t0 = e4.sent;
              case 9:
                return o2 = e4.t0, i2 = r3.contractId(o2), u2 = a.xdr.ScVal.scvVec([(0, a.nativeToScVal)("Balance", { type: "symbol" }), (0, a.nativeToScVal)(t3, { type: "address" })]), s2 = a.xdr.LedgerKey.contractData(new a.xdr.LedgerKeyContractData({ contract: new a.Address(i2).toScAddress(), durability: a.xdr.ContractDataDurability.persistent(), key: u2 })), e4.next = 15, this.getLedgerEntries(s2);
              case 15:
                if (0 !== (c2 = e4.sent).entries.length) {
                  e4.next = 18;
                  break;
                }
                return e4.abrupt("return", { latestLedger: c2.latestLedger });
              case 18:
                if (l2 = c2.entries[0], f2 = l2.lastModifiedLedgerSeq, p2 = l2.liveUntilLedgerSeq, (d2 = l2.val).switch().value === a.xdr.LedgerEntryType.contractData().value) {
                  e4.next = 21;
                  break;
                }
                return e4.abrupt("return", { latestLedger: c2.latestLedger });
              case 21:
                return h2 = (0, a.scValToNative)(d2.contractData().val()), e4.abrupt("return", { latestLedger: c2.latestLedger, balanceEntry: { liveUntilLedgerSeq: p2, lastModifiedLedgerSeq: f2, amount: h2.amount.toString(), authorized: h2.authorized, clawback: h2.clawback } });
              case 23:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3, t3, r3) {
          return j.apply(this, arguments);
        }) }], R && _(I.prototype, R), C && _(I, C), Object.defineProperty(I, "prototype", { writable: false }), I);
        const ie = (e2 = r2.hmd(e2)).exports;
      }, 3533: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.payment = function(e3) {
          if (!e3.asset) throw new Error("Must provide an asset for a payment operation");
          if (!this.isValidAmount(e3.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          var t3 = {};
          try {
            t3.destination = (0, i.decodeAddressToMuxedAccount)(e3.destination);
          } catch (e4) {
            throw new Error("destination is invalid");
          }
          t3.asset = e3.asset.toXDRObject(), t3.amount = this._toXDRAmount(e3.amount);
          var r3 = new o.default.PaymentOp(t3), n2 = {};
          return n2.body = o.default.OperationBody.payment(r3), this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6160);
      }, 3564: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildInvocationTree = function e3(t3) {
          var r3 = t3.function(), a2 = {}, c2 = r3.value();
          switch (r3.switch().value) {
            case 0:
              a2.type = "execute", a2.args = { source: o.Address.fromScAddress(c2.contractAddress()).toString(), function: c2.functionName(), args: c2.args().map(function(e4) {
                return (0, i.scValToNative)(e4);
              }) };
              break;
            case 1:
            case 2:
              var l = 2 === r3.switch().value;
              a2.type = "create", a2.args = {};
              var f = [c2.executable(), c2.contractIdPreimage()], p = f[0], d = f[1];
              if (!!p.switch().value != !!d.switch().value) throw new Error("creation function appears invalid: ".concat(JSON.stringify(c2), " (should be wasm+address or token+asset)"));
              switch (p.switch().value) {
                case 0:
                  var h = d.fromAddress();
                  a2.args.type = "wasm", a2.args.wasm = function(e4) {
                    for (var t4 = 1; t4 < arguments.length; t4++) {
                      var r4 = null != arguments[t4] ? arguments[t4] : {};
                      t4 % 2 ? u(Object(r4), true).forEach(function(t5) {
                        s(e4, t5, r4[t5]);
                      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r4)) : u(Object(r4)).forEach(function(t5) {
                        Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r4, t5));
                      });
                    }
                    return e4;
                  }({ salt: h.salt().toString("hex"), hash: p.wasmHash().toString("hex"), address: o.Address.fromScAddress(h.address()).toString() }, l && { constructorArgs: c2.constructorArgs().map(function(e4) {
                    return (0, i.scValToNative)(e4);
                  }) });
                  break;
                case 1:
                  a2.args.type = "sac", a2.args.asset = n.Asset.fromOperation(d.fromAsset()).toString();
                  break;
                default:
                  throw new Error("unknown creation type: ".concat(JSON.stringify(p)));
              }
              break;
            default:
              throw new Error("unknown invocation type (".concat(r3.switch(), "): ").concat(JSON.stringify(r3)));
          }
          return a2.invocations = t3.subInvocations().map(function(t4) {
            return e3(t4);
          }), a2;
        }, t2.walkInvocationTree = function(e3, t3) {
          c(e3, 1, t3);
        };
        var n = r2(1764), o = r2(1180), i = r2(7177);
        function a(e3) {
          return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, a(e3);
        }
        function u(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function s(e3, t3, r3) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" != a(e5) || !e5) return e5;
              var r4 = e5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n2 = r4.call(e5, t5 || "default");
                if ("object" != a(n2)) return n2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t5 ? String : Number)(e5);
            }(e4, "string");
            return "symbol" == a(t4) ? t4 : t4 + "";
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function c(e3, t3, r3, n2) {
          false !== r3(e3, t3, n2) && e3.subInvocations().forEach(function(n3) {
            return c(n3, t3 + 1, r3, e3);
          });
        }
      }, 3683: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.allowTrust = function(e3) {
          if (!a.StrKey.isValidEd25519PublicKey(e3.trustor)) throw new Error("trustor is invalid");
          var t3 = {};
          if (t3.trustor = i.Keypair.fromPublicKey(e3.trustor).xdrAccountId(), e3.assetCode.length <= 4) {
            var r3 = e3.assetCode.padEnd(4, "\0");
            t3.asset = o.default.AssetCode.assetTypeCreditAlphanum4(r3);
          } else {
            if (!(e3.assetCode.length <= 12)) throw new Error("Asset code must be 12 characters at max.");
            var n2 = e3.assetCode.padEnd(12, "\0");
            t3.asset = o.default.AssetCode.assetTypeCreditAlphanum12(n2);
          }
          "boolean" == typeof e3.authorize ? e3.authorize ? t3.authorize = o.default.TrustLineFlags.authorizedFlag().value : t3.authorize = 0 : t3.authorize = e3.authorize;
          var u = new o.default.AllowTrustOp(t3), s = {};
          return s.body = o.default.OperationBody.allowTrust(u), this.setSourceAccount(s, e3), new o.default.Operation(s);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6691), a = r2(7120);
      }, 3737: (e2, t2, r2) => {
        var n = r2(6698), o = r2(392), i = r2(2861).Buffer, a = [1518500249, 1859775393, -1894007588, -899497514], u = new Array(80);
        function s() {
          this.init(), this._w = u, o.call(this, 64, 56);
        }
        function c(e3) {
          return e3 << 5 | e3 >>> 27;
        }
        function l(e3) {
          return e3 << 30 | e3 >>> 2;
        }
        function f(e3, t3, r3, n2) {
          return 0 === e3 ? t3 & r3 | ~t3 & n2 : 2 === e3 ? t3 & r3 | t3 & n2 | r3 & n2 : t3 ^ r3 ^ n2;
        }
        n(s, o), s.prototype.init = function() {
          return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, s.prototype._update = function(e3) {
          for (var t3, r3 = this._w, n2 = 0 | this._a, o2 = 0 | this._b, i2 = 0 | this._c, u2 = 0 | this._d, s2 = 0 | this._e, p = 0; p < 16; ++p) r3[p] = e3.readInt32BE(4 * p);
          for (; p < 80; ++p) r3[p] = (t3 = r3[p - 3] ^ r3[p - 8] ^ r3[p - 14] ^ r3[p - 16]) << 1 | t3 >>> 31;
          for (var d = 0; d < 80; ++d) {
            var h = ~~(d / 20), y = c(n2) + f(h, o2, i2, u2) + s2 + r3[d] + a[h] | 0;
            s2 = u2, u2 = i2, i2 = l(o2), o2 = n2, n2 = y;
          }
          this._a = n2 + this._a | 0, this._b = o2 + this._b | 0, this._c = i2 + this._c | 0, this._d = u2 + this._d | 0, this._e = s2 + this._e | 0;
        }, s.prototype._hash = function() {
          var e3 = i.allocUnsafe(20);
          return e3.writeInt32BE(0 | this._a, 0), e3.writeInt32BE(0 | this._b, 4), e3.writeInt32BE(0 | this._c, 8), e3.writeInt32BE(0 | this._d, 12), e3.writeInt32BE(0 | this._e, 16), e3;
        }, e2.exports = s;
      }, 3740: function(e2) {
        var t2;
        t2 = () => (() => {
          var e3 = { 616: (e4, t4, r3) => {
            "use strict";
            r3.d(t4, { A: () => o });
            var n = r3(287);
            n.hp.alloc(1).subarray(0, 1) instanceof n.hp || (n.hp.prototype.subarray = function(e5, t5) {
              const r4 = Uint8Array.prototype.subarray.call(this, e5, t5);
              return Object.setPrototypeOf(r4, n.hp.prototype), r4;
            });
            const o = n.hp;
          }, 281: (e4, t4, r3) => {
            const n = r3(164);
            e4.exports = n;
          }, 164: (e4, t4, r3) => {
            "use strict";
            r3.r(t4), r3.d(t4, { Array: () => D, Bool: () => j, Double: () => R, Enum: () => H, Float: () => I, Hyper: () => O, Int: () => k, LargeInt: () => T, Opaque: () => U, Option: () => q, Quadruple: () => C, Reference: () => z, String: () => L, Struct: () => X, Union: () => $, UnsignedHyper: () => P, UnsignedInt: () => A, VarArray: () => V, VarOpaque: () => F, Void: () => K, XdrReader: () => s, XdrWriter: () => f, config: () => ne });
            class n extends TypeError {
              constructor(e5) {
                super(`XDR Write Error: ${e5}`);
              }
            }
            class o extends TypeError {
              constructor(e5) {
                super(`XDR Read Error: ${e5}`);
              }
            }
            class i extends TypeError {
              constructor(e5) {
                super(`XDR Type Definition Error: ${e5}`);
              }
            }
            class a extends i {
              constructor() {
                super("method not implemented, it should be overloaded in the descendant class.");
              }
            }
            var u = r3(616).A;
            class s {
              constructor(e5) {
                __publicField(this, "_buffer");
                __publicField(this, "_length");
                __publicField(this, "_index");
                if (!u.isBuffer(e5)) {
                  if (!(e5 instanceof Array || Array.isArray(e5) || ArrayBuffer.isView(e5))) throw new o(`source invalid: ${e5}`);
                  e5 = u.from(e5);
                }
                this._buffer = e5, this._length = e5.length, this._index = 0;
              }
              get eof() {
                return this._index === this._length;
              }
              advance(e5) {
                const t5 = this._index;
                if (this._index += e5, this._length < this._index) throw new o("attempt to read outside the boundary of the buffer");
                const r4 = 4 - (e5 % 4 || 4);
                if (r4 > 0) {
                  for (let e6 = 0; e6 < r4; e6++) if (0 !== this._buffer[this._index + e6]) throw new o("invalid padding");
                  this._index += r4;
                }
                return t5;
              }
              rewind() {
                this._index = 0;
              }
              read(e5) {
                const t5 = this.advance(e5);
                return this._buffer.subarray(t5, t5 + e5);
              }
              readInt32BE() {
                return this._buffer.readInt32BE(this.advance(4));
              }
              readUInt32BE() {
                return this._buffer.readUInt32BE(this.advance(4));
              }
              readBigInt64BE() {
                return this._buffer.readBigInt64BE(this.advance(8));
              }
              readBigUInt64BE() {
                return this._buffer.readBigUInt64BE(this.advance(8));
              }
              readFloatBE() {
                return this._buffer.readFloatBE(this.advance(4));
              }
              readDoubleBE() {
                return this._buffer.readDoubleBE(this.advance(8));
              }
              ensureInputConsumed() {
                if (this._index !== this._length) throw new o("invalid XDR contract typecast - source buffer not entirely consumed");
              }
            }
            var c = r3(616).A;
            const l = 8192;
            class f {
              constructor(e5) {
                __publicField(this, "_buffer");
                __publicField(this, "_length");
                __publicField(this, "_index", 0);
                "number" == typeof e5 ? e5 = c.allocUnsafe(e5) : e5 instanceof c || (e5 = c.allocUnsafe(l)), this._buffer = e5, this._length = e5.length;
              }
              alloc(e5) {
                const t5 = this._index;
                return this._index += e5, this._length < this._index && this.resize(this._index), t5;
              }
              resize(e5) {
                const t5 = Math.ceil(e5 / l) * l, r4 = c.allocUnsafe(t5);
                this._buffer.copy(r4, 0, 0, this._length), this._buffer = r4, this._length = t5;
              }
              finalize() {
                return this._buffer.subarray(0, this._index);
              }
              toArray() {
                return [...this.finalize()];
              }
              write(e5, t5) {
                if ("string" == typeof e5) {
                  const r5 = this.alloc(t5);
                  this._buffer.write(e5, r5, "utf8");
                } else {
                  e5 instanceof c || (e5 = c.from(e5));
                  const r5 = this.alloc(t5);
                  e5.copy(this._buffer, r5, 0, t5);
                }
                const r4 = 4 - (t5 % 4 || 4);
                if (r4 > 0) {
                  const e6 = this.alloc(r4);
                  this._buffer.fill(0, e6, this._index);
                }
              }
              writeInt32BE(e5) {
                const t5 = this.alloc(4);
                this._buffer.writeInt32BE(e5, t5);
              }
              writeUInt32BE(e5) {
                const t5 = this.alloc(4);
                this._buffer.writeUInt32BE(e5, t5);
              }
              writeBigInt64BE(e5) {
                const t5 = this.alloc(8);
                this._buffer.writeBigInt64BE(e5, t5);
              }
              writeBigUInt64BE(e5) {
                const t5 = this.alloc(8);
                this._buffer.writeBigUInt64BE(e5, t5);
              }
              writeFloatBE(e5) {
                const t5 = this.alloc(4);
                this._buffer.writeFloatBE(e5, t5);
              }
              writeDoubleBE(e5) {
                const t5 = this.alloc(8);
                this._buffer.writeDoubleBE(e5, t5);
              }
            }
            __publicField(f, "bufferChunkSize", l);
            var p = r3(616).A;
            class d {
              toXDR(e5 = "raw") {
                if (!this.write) return this.constructor.toXDR(this, e5);
                const t5 = new f();
                return this.write(this, t5), v(t5.finalize(), e5);
              }
              fromXDR(e5, t5 = "raw") {
                if (!this.read) return this.constructor.fromXDR(e5, t5);
                const r4 = new s(g(e5, t5)), n2 = this.read(r4);
                return r4.ensureInputConsumed(), n2;
              }
              validateXDR(e5, t5 = "raw") {
                try {
                  return this.fromXDR(e5, t5), true;
                } catch (e6) {
                  return false;
                }
              }
              static toXDR(e5, t5 = "raw") {
                const r4 = new f();
                return this.write(e5, r4), v(r4.finalize(), t5);
              }
              static fromXDR(e5, t5 = "raw") {
                const r4 = new s(g(e5, t5)), n2 = this.read(r4);
                return r4.ensureInputConsumed(), n2;
              }
              static validateXDR(e5, t5 = "raw") {
                try {
                  return this.fromXDR(e5, t5), true;
                } catch (e6) {
                  return false;
                }
              }
            }
            class h extends d {
              static read(e5) {
                throw new a();
              }
              static write(e5, t5) {
                throw new a();
              }
              static isValid(e5) {
                return false;
              }
            }
            class y extends d {
              isValid(e5) {
                return false;
              }
            }
            class m extends TypeError {
              constructor(e5) {
                super(`Invalid format ${e5}, must be one of "raw", "hex", "base64"`);
              }
            }
            function v(e5, t5) {
              switch (t5) {
                case "raw":
                  return e5;
                case "hex":
                  return e5.toString("hex");
                case "base64":
                  return e5.toString("base64");
                default:
                  throw new m(t5);
              }
            }
            function g(e5, t5) {
              switch (t5) {
                case "raw":
                  return e5;
                case "hex":
                  return p.from(e5, "hex");
                case "base64":
                  return p.from(e5, "base64");
                default:
                  throw new m(t5);
              }
            }
            function b(e5, t5) {
              return null != e5 && (e5 instanceof t5 || w(e5, t5) && "function" == typeof e5.constructor.read && "function" == typeof e5.constructor.write && w(e5, "XdrType"));
            }
            function w(e5, t5) {
              do {
                if (e5.constructor.name === t5) return true;
              } while (e5 = Object.getPrototypeOf(e5));
              return false;
            }
            const S = 2147483647;
            class k extends h {
              static read(e5) {
                return e5.readInt32BE();
              }
              static write(e5, t5) {
                if ("number" != typeof e5) throw new n("not a number");
                if ((0 | e5) !== e5) throw new n("invalid i32 value");
                t5.writeInt32BE(e5);
              }
              static isValid(e5) {
                return "number" == typeof e5 && (0 | e5) === e5 && e5 >= -2147483648 && e5 <= S;
              }
            }
            function E(e5, t5, r4) {
              if ("bigint" != typeof e5) throw new TypeError("Expected bigint 'value', got " + typeof e5);
              const n2 = t5 / r4;
              if (1 === n2) return [e5];
              if (r4 < 32 || r4 > 128 || 2 !== n2 && 4 !== n2 && 8 !== n2) throw new TypeError(`invalid bigint (${e5}) and slice size (${t5} -> ${r4}) combination`);
              const o2 = BigInt(r4), i2 = new Array(n2);
              for (let t6 = 0; t6 < n2; t6++) i2[t6] = BigInt.asIntN(r4, e5), e5 >>= o2;
              return i2;
            }
            function _(e5, t5) {
              if (t5) return [0n, (1n << BigInt(e5)) - 1n];
              const r4 = 1n << BigInt(e5 - 1);
              return [0n - r4, r4 - 1n];
            }
            k.MAX_VALUE = S, k.MIN_VALUE = 2147483648;
            class T extends h {
              constructor(e5) {
                super(), this._value = function(e6, t5, r4) {
                  e6 instanceof Array ? e6.length && e6[0] instanceof Array && (e6 = e6[0]) : e6 = [e6];
                  const n2 = t5 / e6.length;
                  switch (n2) {
                    case 32:
                    case 64:
                    case 128:
                    case 256:
                      break;
                    default:
                      throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${e6}`);
                  }
                  try {
                    for (let t6 = 0; t6 < e6.length; t6++) "bigint" != typeof e6[t6] && (e6[t6] = BigInt(e6[t6].valueOf()));
                  } catch (t6) {
                    throw new TypeError(`expected bigint-like values, got: ${e6} (${t6})`);
                  }
                  if (r4 && 1 === e6.length && e6[0] < 0n) throw new RangeError(`expected a positive value, got: ${e6}`);
                  let o2 = BigInt.asUintN(n2, e6[0]);
                  for (let t6 = 1; t6 < e6.length; t6++) o2 |= BigInt.asUintN(n2, e6[t6]) << BigInt(t6 * n2);
                  r4 || (o2 = BigInt.asIntN(t5, o2));
                  const [i2, a2] = _(t5, r4);
                  if (o2 >= i2 && o2 <= a2) return o2;
                  throw new TypeError(`bigint values [${e6}] for ${function(e7, t6) {
                    return `${t6 ? "u" : "i"}${e7}`;
                  }(t5, r4)} out of range [${i2}, ${a2}]: ${o2}`);
                }(e5, this.size, this.unsigned);
              }
              get unsigned() {
                throw new a();
              }
              get size() {
                throw new a();
              }
              slice(e5) {
                return E(this._value, this.size, e5);
              }
              toString() {
                return this._value.toString();
              }
              toJSON() {
                return { _value: this._value.toString() };
              }
              toBigInt() {
                return BigInt(this._value);
              }
              static read(e5) {
                const { size: t5 } = this.prototype;
                return 64 === t5 ? new this(e5.readBigUInt64BE()) : new this(...Array.from({ length: t5 / 64 }, () => e5.readBigUInt64BE()).reverse());
              }
              static write(e5, t5) {
                if (e5 instanceof this) e5 = e5._value;
                else if ("bigint" != typeof e5 || e5 > this.MAX_VALUE || e5 < this.MIN_VALUE) throw new n(`${e5} is not a ${this.name}`);
                const { unsigned: r4, size: o2 } = this.prototype;
                if (64 === o2) r4 ? t5.writeBigUInt64BE(e5) : t5.writeBigInt64BE(e5);
                else for (const n2 of E(e5, o2, 64).reverse()) r4 ? t5.writeBigUInt64BE(n2) : t5.writeBigInt64BE(n2);
              }
              static isValid(e5) {
                return "bigint" == typeof e5 || e5 instanceof this;
              }
              static fromString(e5) {
                return new this(e5);
              }
              static defineIntBoundaries() {
                const [e5, t5] = _(this.prototype.size, this.prototype.unsigned);
                this.MIN_VALUE = e5, this.MAX_VALUE = t5;
              }
            }
            __publicField(T, "MAX_VALUE", 0n);
            __publicField(T, "MIN_VALUE", 0n);
            class O extends T {
              constructor(...e5) {
                super(e5);
              }
              get low() {
                return 0 | Number(0xffffffffn & this._value);
              }
              get high() {
                return 0 | Number(this._value >> 32n);
              }
              get size() {
                return 64;
              }
              get unsigned() {
                return false;
              }
              static fromBits(e5, t5) {
                return new this(e5, t5);
              }
            }
            O.defineIntBoundaries();
            const x = 4294967295;
            class A extends h {
              static read(e5) {
                return e5.readUInt32BE();
              }
              static write(e5, t5) {
                if ("number" != typeof e5 || !(e5 >= 0 && e5 <= x) || e5 % 1 != 0) throw new n("invalid u32 value");
                t5.writeUInt32BE(e5);
              }
              static isValid(e5) {
                return "number" == typeof e5 && e5 % 1 == 0 && e5 >= 0 && e5 <= x;
              }
            }
            A.MAX_VALUE = x, A.MIN_VALUE = 0;
            class P extends T {
              constructor(...e5) {
                super(e5);
              }
              get low() {
                return 0 | Number(0xffffffffn & this._value);
              }
              get high() {
                return 0 | Number(this._value >> 32n);
              }
              get size() {
                return 64;
              }
              get unsigned() {
                return true;
              }
              static fromBits(e5, t5) {
                return new this(e5, t5);
              }
            }
            P.defineIntBoundaries();
            class I extends h {
              static read(e5) {
                return e5.readFloatBE();
              }
              static write(e5, t5) {
                if ("number" != typeof e5) throw new n("not a number");
                t5.writeFloatBE(e5);
              }
              static isValid(e5) {
                return "number" == typeof e5;
              }
            }
            class R extends h {
              static read(e5) {
                return e5.readDoubleBE();
              }
              static write(e5, t5) {
                if ("number" != typeof e5) throw new n("not a number");
                t5.writeDoubleBE(e5);
              }
              static isValid(e5) {
                return "number" == typeof e5;
              }
            }
            class C extends h {
              static read() {
                throw new i("quadruple not supported");
              }
              static write() {
                throw new i("quadruple not supported");
              }
              static isValid() {
                return false;
              }
            }
            class j extends h {
              static read(e5) {
                const t5 = k.read(e5);
                switch (t5) {
                  case 0:
                    return false;
                  case 1:
                    return true;
                  default:
                    throw new o(`got ${t5} when trying to read a bool`);
                }
              }
              static write(e5, t5) {
                const r4 = e5 ? 1 : 0;
                k.write(r4, t5);
              }
              static isValid(e5) {
                return "boolean" == typeof e5;
              }
            }
            var B = r3(616).A;
            class L extends y {
              constructor(e5 = A.MAX_VALUE) {
                super(), this._maxLength = e5;
              }
              read(e5) {
                const t5 = A.read(e5);
                if (t5 > this._maxLength) throw new o(`saw ${t5} length String, max allowed is ${this._maxLength}`);
                return e5.read(t5);
              }
              readString(e5) {
                return this.read(e5).toString("utf8");
              }
              write(e5, t5) {
                const r4 = "string" == typeof e5 ? B.byteLength(e5, "utf8") : e5.length;
                if (r4 > this._maxLength) throw new n(`got ${e5.length} bytes, max allowed is ${this._maxLength}`);
                A.write(r4, t5), t5.write(e5, r4);
              }
              isValid(e5) {
                return "string" == typeof e5 ? B.byteLength(e5, "utf8") <= this._maxLength : !!(e5 instanceof Array || B.isBuffer(e5)) && e5.length <= this._maxLength;
              }
            }
            var N = r3(616).A;
            class U extends y {
              constructor(e5) {
                super(), this._length = e5;
              }
              read(e5) {
                return e5.read(this._length);
              }
              write(e5, t5) {
                const { length: r4 } = e5;
                if (r4 !== this._length) throw new n(`got ${e5.length} bytes, expected ${this._length}`);
                t5.write(e5, r4);
              }
              isValid(e5) {
                return N.isBuffer(e5) && e5.length === this._length;
              }
            }
            var M = r3(616).A;
            class F extends y {
              constructor(e5 = A.MAX_VALUE) {
                super(), this._maxLength = e5;
              }
              read(e5) {
                const t5 = A.read(e5);
                if (t5 > this._maxLength) throw new o(`saw ${t5} length VarOpaque, max allowed is ${this._maxLength}`);
                return e5.read(t5);
              }
              write(e5, t5) {
                const { length: r4 } = e5;
                if (e5.length > this._maxLength) throw new n(`got ${e5.length} bytes, max allowed is ${this._maxLength}`);
                A.write(r4, t5), t5.write(e5, r4);
              }
              isValid(e5) {
                return M.isBuffer(e5) && e5.length <= this._maxLength;
              }
            }
            class D extends y {
              constructor(e5, t5) {
                super(), this._childType = e5, this._length = t5;
              }
              read(e5) {
                const t5 = new r3.g.Array(this._length);
                for (let r4 = 0; r4 < this._length; r4++) t5[r4] = this._childType.read(e5);
                return t5;
              }
              write(e5, t5) {
                if (!r3.g.Array.isArray(e5)) throw new n("value is not array");
                if (e5.length !== this._length) throw new n(`got array of size ${e5.length}, expected ${this._length}`);
                for (const r4 of e5) this._childType.write(r4, t5);
              }
              isValid(e5) {
                if (!(e5 instanceof r3.g.Array) || e5.length !== this._length) return false;
                for (const t5 of e5) if (!this._childType.isValid(t5)) return false;
                return true;
              }
            }
            class V extends y {
              constructor(e5, t5 = A.MAX_VALUE) {
                super(), this._childType = e5, this._maxLength = t5;
              }
              read(e5) {
                const t5 = A.read(e5);
                if (t5 > this._maxLength) throw new o(`saw ${t5} length VarArray, max allowed is ${this._maxLength}`);
                const r4 = new Array(t5);
                for (let n2 = 0; n2 < t5; n2++) r4[n2] = this._childType.read(e5);
                return r4;
              }
              write(e5, t5) {
                if (!(e5 instanceof Array)) throw new n("value is not array");
                if (e5.length > this._maxLength) throw new n(`got array of size ${e5.length}, max allowed is ${this._maxLength}`);
                A.write(e5.length, t5);
                for (const r4 of e5) this._childType.write(r4, t5);
              }
              isValid(e5) {
                if (!(e5 instanceof Array) || e5.length > this._maxLength) return false;
                for (const t5 of e5) if (!this._childType.isValid(t5)) return false;
                return true;
              }
            }
            class q extends h {
              constructor(e5) {
                super(), this._childType = e5;
              }
              read(e5) {
                if (j.read(e5)) return this._childType.read(e5);
              }
              write(e5, t5) {
                const r4 = null != e5;
                j.write(r4, t5), r4 && this._childType.write(e5, t5);
              }
              isValid(e5) {
                return null == e5 || this._childType.isValid(e5);
              }
            }
            class K extends h {
              static read() {
              }
              static write(e5) {
                if (void 0 !== e5) throw new n("trying to write value to a void slot");
              }
              static isValid(e5) {
                return void 0 === e5;
              }
            }
            class H extends h {
              constructor(e5, t5) {
                super(), this.name = e5, this.value = t5;
              }
              static read(e5) {
                const t5 = k.read(e5), r4 = this._byValue[t5];
                if (void 0 === r4) throw new o(`unknown ${this.enumName} member for value ${t5}`);
                return r4;
              }
              static write(e5, t5) {
                if (!this.isValid(e5)) throw new n(`${e5} has enum name ${e5 == null ? void 0 : e5.enumName}, not ${this.enumName}: ${JSON.stringify(e5)}`);
                k.write(e5.value, t5);
              }
              static isValid(e5) {
                var _a;
                return ((_a = e5 == null ? void 0 : e5.constructor) == null ? void 0 : _a.enumName) === this.enumName || b(e5, this);
              }
              static members() {
                return this._members;
              }
              static values() {
                return Object.values(this._members);
              }
              static fromName(e5) {
                const t5 = this._members[e5];
                if (!t5) throw new TypeError(`${e5} is not a member of ${this.enumName}`);
                return t5;
              }
              static fromValue(e5) {
                const t5 = this._byValue[e5];
                if (void 0 === t5) throw new TypeError(`${e5} is not a value of any member of ${this.enumName}`);
                return t5;
              }
              static create(e5, t5, r4) {
                const n2 = class extends H {
                };
                n2.enumName = t5, e5.results[t5] = n2, n2._members = {}, n2._byValue = {};
                for (const [e6, t6] of Object.entries(r4)) {
                  const r5 = new n2(e6, t6);
                  n2._members[e6] = r5, n2._byValue[t6] = r5, n2[e6] = () => r5;
                }
                return n2;
              }
            }
            class z extends h {
              resolve() {
                throw new i('"resolve" method should be implemented in the descendant class');
              }
            }
            class X extends y {
              constructor(e5) {
                super(), this._attributes = e5 || {};
              }
              static read(e5) {
                const t5 = {};
                for (const [r4, n2] of this._fields) t5[r4] = n2.read(e5);
                return new this(t5);
              }
              static write(e5, t5) {
                var _a;
                if (!this.isValid(e5)) throw new n(`${e5} has struct name ${(_a = e5 == null ? void 0 : e5.constructor) == null ? void 0 : _a.structName}, not ${this.structName}: ${JSON.stringify(e5)}`);
                for (const [r4, n2] of this._fields) {
                  const o2 = e5._attributes[r4];
                  n2.write(o2, t5);
                }
              }
              static isValid(e5) {
                var _a;
                return ((_a = e5 == null ? void 0 : e5.constructor) == null ? void 0 : _a.structName) === this.structName || b(e5, this);
              }
              static create(e5, t5, r4) {
                const n2 = class extends X {
                };
                n2.structName = t5, e5.results[t5] = n2;
                const o2 = new Array(r4.length);
                for (let t6 = 0; t6 < r4.length; t6++) {
                  const i2 = r4[t6], a2 = i2[0];
                  let u2 = i2[1];
                  u2 instanceof z && (u2 = u2.resolve(e5)), o2[t6] = [a2, u2], n2.prototype[a2] = G(a2);
                }
                return n2._fields = o2, n2;
              }
            }
            function G(e5) {
              return function(t5) {
                return void 0 !== t5 && (this._attributes[e5] = t5), this._attributes[e5];
              };
            }
            class $ extends y {
              constructor(e5, t5) {
                super(), this.set(e5, t5);
              }
              set(e5, t5) {
                "string" == typeof e5 && (e5 = this.constructor._switchOn.fromName(e5)), this._switch = e5;
                const r4 = this.constructor.armForSwitch(this._switch);
                this._arm = r4, this._armType = r4 === K ? K : this.constructor._arms[r4], this._value = t5;
              }
              get(e5 = this._arm) {
                if (this._arm !== K && this._arm !== e5) throw new TypeError(`${e5} not set`);
                return this._value;
              }
              switch() {
                return this._switch;
              }
              arm() {
                return this._arm;
              }
              armType() {
                return this._armType;
              }
              value() {
                return this._value;
              }
              static armForSwitch(e5) {
                const t5 = this._switches.get(e5);
                if (void 0 !== t5) return t5;
                if (this._defaultArm) return this._defaultArm;
                throw new TypeError(`Bad union switch: ${e5}`);
              }
              static armTypeForArm(e5) {
                return e5 === K ? K : this._arms[e5];
              }
              static read(e5) {
                const t5 = this._switchOn.read(e5), r4 = this.armForSwitch(t5), n2 = r4 === K ? K : this._arms[r4];
                let o2;
                return o2 = void 0 !== n2 ? n2.read(e5) : r4.read(e5), new this(t5, o2);
              }
              static write(e5, t5) {
                if (!this.isValid(e5)) throw new n(`${e5} has union name ${e5 == null ? void 0 : e5.unionName}, not ${this.unionName}: ${JSON.stringify(e5)}`);
                this._switchOn.write(e5.switch(), t5), e5.armType().write(e5.value(), t5);
              }
              static isValid(e5) {
                var _a;
                return ((_a = e5 == null ? void 0 : e5.constructor) == null ? void 0 : _a.unionName) === this.unionName || b(e5, this);
              }
              static create(e5, t5, r4) {
                const n2 = class extends $ {
                };
                n2.unionName = t5, e5.results[t5] = n2, r4.switchOn instanceof z ? n2._switchOn = r4.switchOn.resolve(e5) : n2._switchOn = r4.switchOn, n2._switches = /* @__PURE__ */ new Map(), n2._arms = {};
                let o2 = r4.defaultArm;
                o2 instanceof z && (o2 = o2.resolve(e5)), n2._defaultArm = o2;
                for (const [e6, t6] of r4.switches) {
                  const r5 = "string" == typeof e6 ? n2._switchOn.fromName(e6) : e6;
                  n2._switches.set(r5, t6);
                }
                if (void 0 !== n2._switchOn.values) for (const e6 of n2._switchOn.values()) n2[e6.name] = function(t6) {
                  return new n2(e6, t6);
                }, n2.prototype[e6.name] = function(t6) {
                  return this.set(e6, t6);
                };
                if (r4.arms) for (const [t6, o3] of Object.entries(r4.arms)) n2._arms[t6] = o3 instanceof z ? o3.resolve(e5) : o3, o3 !== K && (n2.prototype[t6] = function() {
                  return this.get(t6);
                });
                return n2;
              }
            }
            class Q extends z {
              constructor(e5) {
                super(), this.name = e5;
              }
              resolve(e5) {
                return e5.definitions[this.name].resolve(e5);
              }
            }
            class W extends z {
              constructor(e5, t5, r4 = false) {
                super(), this.childReference = e5, this.length = t5, this.variable = r4;
              }
              resolve(e5) {
                let t5 = this.childReference, r4 = this.length;
                return t5 instanceof z && (t5 = t5.resolve(e5)), r4 instanceof z && (r4 = r4.resolve(e5)), this.variable ? new V(t5, r4) : new D(t5, r4);
              }
            }
            class Y extends z {
              constructor(e5) {
                super(), this.childReference = e5, this.name = e5.name;
              }
              resolve(e5) {
                let t5 = this.childReference;
                return t5 instanceof z && (t5 = t5.resolve(e5)), new q(t5);
              }
            }
            class J extends z {
              constructor(e5, t5) {
                super(), this.sizedType = e5, this.length = t5;
              }
              resolve(e5) {
                let t5 = this.length;
                return t5 instanceof z && (t5 = t5.resolve(e5)), new this.sizedType(t5);
              }
            }
            class Z {
              constructor(e5, t5, r4) {
                this.constructor = e5, this.name = t5, this.config = r4;
              }
              resolve(e5) {
                return this.name in e5.results ? e5.results[this.name] : this.constructor(e5, this.name, this.config);
              }
            }
            function ee(e5, t5, r4) {
              return r4 instanceof z && (r4 = r4.resolve(e5)), e5.results[t5] = r4, r4;
            }
            function te(e5, t5, r4) {
              return e5.results[t5] = r4, r4;
            }
            class re {
              constructor(e5) {
                this._destination = e5, this._definitions = {};
              }
              enum(e5, t5) {
                const r4 = new Z(H.create, e5, t5);
                this.define(e5, r4);
              }
              struct(e5, t5) {
                const r4 = new Z(X.create, e5, t5);
                this.define(e5, r4);
              }
              union(e5, t5) {
                const r4 = new Z($.create, e5, t5);
                this.define(e5, r4);
              }
              typedef(e5, t5) {
                const r4 = new Z(ee, e5, t5);
                this.define(e5, r4);
              }
              const(e5, t5) {
                const r4 = new Z(te, e5, t5);
                this.define(e5, r4);
              }
              void() {
                return K;
              }
              bool() {
                return j;
              }
              int() {
                return k;
              }
              hyper() {
                return O;
              }
              uint() {
                return A;
              }
              uhyper() {
                return P;
              }
              float() {
                return I;
              }
              double() {
                return R;
              }
              quadruple() {
                return C;
              }
              string(e5) {
                return new J(L, e5);
              }
              opaque(e5) {
                return new J(U, e5);
              }
              varOpaque(e5) {
                return new J(F, e5);
              }
              array(e5, t5) {
                return new W(e5, t5);
              }
              varArray(e5, t5) {
                return new W(e5, t5, true);
              }
              option(e5) {
                return new Y(e5);
              }
              define(e5, t5) {
                if (void 0 !== this._destination[e5]) throw new i(`${e5} is already defined`);
                this._definitions[e5] = t5;
              }
              lookup(e5) {
                return new Q(e5);
              }
              resolve() {
                for (const e5 of Object.values(this._definitions)) e5.resolve({ definitions: this._definitions, results: this._destination });
              }
            }
            function ne(e5, t5 = {}) {
              if (e5) {
                const r4 = new re(t5);
                e5(r4), r4.resolve();
              }
              return t5;
            }
          }, 526: (e4, t4) => {
            "use strict";
            t4.byteLength = function(e5) {
              var t5 = u(e5), r4 = t5[0], n2 = t5[1];
              return 3 * (r4 + n2) / 4 - n2;
            }, t4.toByteArray = function(e5) {
              var t5, r4, i2 = u(e5), a2 = i2[0], s2 = i2[1], c = new o(function(e6, t6, r5) {
                return 3 * (t6 + r5) / 4 - r5;
              }(0, a2, s2)), l = 0, f = s2 > 0 ? a2 - 4 : a2;
              for (r4 = 0; r4 < f; r4 += 4) t5 = n[e5.charCodeAt(r4)] << 18 | n[e5.charCodeAt(r4 + 1)] << 12 | n[e5.charCodeAt(r4 + 2)] << 6 | n[e5.charCodeAt(r4 + 3)], c[l++] = t5 >> 16 & 255, c[l++] = t5 >> 8 & 255, c[l++] = 255 & t5;
              return 2 === s2 && (t5 = n[e5.charCodeAt(r4)] << 2 | n[e5.charCodeAt(r4 + 1)] >> 4, c[l++] = 255 & t5), 1 === s2 && (t5 = n[e5.charCodeAt(r4)] << 10 | n[e5.charCodeAt(r4 + 1)] << 4 | n[e5.charCodeAt(r4 + 2)] >> 2, c[l++] = t5 >> 8 & 255, c[l++] = 255 & t5), c;
            }, t4.fromByteArray = function(e5) {
              for (var t5, n2 = e5.length, o2 = n2 % 3, i2 = [], a2 = 16383, u2 = 0, c = n2 - o2; u2 < c; u2 += a2) i2.push(s(e5, u2, u2 + a2 > c ? c : u2 + a2));
              return 1 === o2 ? (t5 = e5[n2 - 1], i2.push(r3[t5 >> 2] + r3[t5 << 4 & 63] + "==")) : 2 === o2 && (t5 = (e5[n2 - 2] << 8) + e5[n2 - 1], i2.push(r3[t5 >> 10] + r3[t5 >> 4 & 63] + r3[t5 << 2 & 63] + "=")), i2.join("");
            };
            for (var r3 = [], n = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0; a < 64; ++a) r3[a] = i[a], n[i.charCodeAt(a)] = a;
            function u(e5) {
              var t5 = e5.length;
              if (t5 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
              var r4 = e5.indexOf("=");
              return -1 === r4 && (r4 = t5), [r4, r4 === t5 ? 0 : 4 - r4 % 4];
            }
            function s(e5, t5, n2) {
              for (var o2, i2, a2 = [], u2 = t5; u2 < n2; u2 += 3) o2 = (e5[u2] << 16 & 16711680) + (e5[u2 + 1] << 8 & 65280) + (255 & e5[u2 + 2]), a2.push(r3[(i2 = o2) >> 18 & 63] + r3[i2 >> 12 & 63] + r3[i2 >> 6 & 63] + r3[63 & i2]);
              return a2.join("");
            }
            n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
          }, 287: (e4, t4, r3) => {
            "use strict";
            const n = r3(526), o = r3(251), i = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            t4.hp = s, t4.IS = 50;
            const a = 2147483647;
            function u(e5) {
              if (e5 > a) throw new RangeError('The value "' + e5 + '" is invalid for option "size"');
              const t5 = new Uint8Array(e5);
              return Object.setPrototypeOf(t5, s.prototype), t5;
            }
            function s(e5, t5, r4) {
              if ("number" == typeof e5) {
                if ("string" == typeof t5) throw new TypeError('The "string" argument must be of type string. Received type number');
                return f(e5);
              }
              return c(e5, t5, r4);
            }
            function c(e5, t5, r4) {
              if ("string" == typeof e5) return function(e6, t6) {
                if ("string" == typeof t6 && "" !== t6 || (t6 = "utf8"), !s.isEncoding(t6)) throw new TypeError("Unknown encoding: " + t6);
                const r5 = 0 | y(e6, t6);
                let n3 = u(r5);
                const o3 = n3.write(e6, t6);
                return o3 !== r5 && (n3 = n3.slice(0, o3)), n3;
              }(e5, t5);
              if (ArrayBuffer.isView(e5)) return function(e6) {
                if (Q(e6, Uint8Array)) {
                  const t6 = new Uint8Array(e6);
                  return d(t6.buffer, t6.byteOffset, t6.byteLength);
                }
                return p(e6);
              }(e5);
              if (null == e5) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e5);
              if (Q(e5, ArrayBuffer) || e5 && Q(e5.buffer, ArrayBuffer)) return d(e5, t5, r4);
              if ("undefined" != typeof SharedArrayBuffer && (Q(e5, SharedArrayBuffer) || e5 && Q(e5.buffer, SharedArrayBuffer))) return d(e5, t5, r4);
              if ("number" == typeof e5) throw new TypeError('The "value" argument must not be of type number. Received type number');
              const n2 = e5.valueOf && e5.valueOf();
              if (null != n2 && n2 !== e5) return s.from(n2, t5, r4);
              const o2 = function(e6) {
                if (s.isBuffer(e6)) {
                  const t6 = 0 | h(e6.length), r5 = u(t6);
                  return 0 === r5.length || e6.copy(r5, 0, 0, t6), r5;
                }
                return void 0 !== e6.length ? "number" != typeof e6.length || W(e6.length) ? u(0) : p(e6) : "Buffer" === e6.type && Array.isArray(e6.data) ? p(e6.data) : void 0;
              }(e5);
              if (o2) return o2;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e5[Symbol.toPrimitive]) return s.from(e5[Symbol.toPrimitive]("string"), t5, r4);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e5);
            }
            function l(e5) {
              if ("number" != typeof e5) throw new TypeError('"size" argument must be of type number');
              if (e5 < 0) throw new RangeError('The value "' + e5 + '" is invalid for option "size"');
            }
            function f(e5) {
              return l(e5), u(e5 < 0 ? 0 : 0 | h(e5));
            }
            function p(e5) {
              const t5 = e5.length < 0 ? 0 : 0 | h(e5.length), r4 = u(t5);
              for (let n2 = 0; n2 < t5; n2 += 1) r4[n2] = 255 & e5[n2];
              return r4;
            }
            function d(e5, t5, r4) {
              if (t5 < 0 || e5.byteLength < t5) throw new RangeError('"offset" is outside of buffer bounds');
              if (e5.byteLength < t5 + (r4 || 0)) throw new RangeError('"length" is outside of buffer bounds');
              let n2;
              return n2 = void 0 === t5 && void 0 === r4 ? new Uint8Array(e5) : void 0 === r4 ? new Uint8Array(e5, t5) : new Uint8Array(e5, t5, r4), Object.setPrototypeOf(n2, s.prototype), n2;
            }
            function h(e5) {
              if (e5 >= a) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
              return 0 | e5;
            }
            function y(e5, t5) {
              if (s.isBuffer(e5)) return e5.length;
              if (ArrayBuffer.isView(e5) || Q(e5, ArrayBuffer)) return e5.byteLength;
              if ("string" != typeof e5) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e5);
              const r4 = e5.length, n2 = arguments.length > 2 && true === arguments[2];
              if (!n2 && 0 === r4) return 0;
              let o2 = false;
              for (; ; ) switch (t5) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r4;
                case "utf8":
                case "utf-8":
                  return X(e5).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r4;
                case "hex":
                  return r4 >>> 1;
                case "base64":
                  return G(e5).length;
                default:
                  if (o2) return n2 ? -1 : X(e5).length;
                  t5 = ("" + t5).toLowerCase(), o2 = true;
              }
            }
            function m(e5, t5, r4) {
              let n2 = false;
              if ((void 0 === t5 || t5 < 0) && (t5 = 0), t5 > this.length) return "";
              if ((void 0 === r4 || r4 > this.length) && (r4 = this.length), r4 <= 0) return "";
              if ((r4 >>>= 0) <= (t5 >>>= 0)) return "";
              for (e5 || (e5 = "utf8"); ; ) switch (e5) {
                case "hex":
                  return I(this, t5, r4);
                case "utf8":
                case "utf-8":
                  return O(this, t5, r4);
                case "ascii":
                  return A(this, t5, r4);
                case "latin1":
                case "binary":
                  return P(this, t5, r4);
                case "base64":
                  return T(this, t5, r4);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return R(this, t5, r4);
                default:
                  if (n2) throw new TypeError("Unknown encoding: " + e5);
                  e5 = (e5 + "").toLowerCase(), n2 = true;
              }
            }
            function v(e5, t5, r4) {
              const n2 = e5[t5];
              e5[t5] = e5[r4], e5[r4] = n2;
            }
            function g(e5, t5, r4, n2, o2) {
              if (0 === e5.length) return -1;
              if ("string" == typeof r4 ? (n2 = r4, r4 = 0) : r4 > 2147483647 ? r4 = 2147483647 : r4 < -2147483648 && (r4 = -2147483648), W(r4 = +r4) && (r4 = o2 ? 0 : e5.length - 1), r4 < 0 && (r4 = e5.length + r4), r4 >= e5.length) {
                if (o2) return -1;
                r4 = e5.length - 1;
              } else if (r4 < 0) {
                if (!o2) return -1;
                r4 = 0;
              }
              if ("string" == typeof t5 && (t5 = s.from(t5, n2)), s.isBuffer(t5)) return 0 === t5.length ? -1 : b(e5, t5, r4, n2, o2);
              if ("number" == typeof t5) return t5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o2 ? Uint8Array.prototype.indexOf.call(e5, t5, r4) : Uint8Array.prototype.lastIndexOf.call(e5, t5, r4) : b(e5, [t5], r4, n2, o2);
              throw new TypeError("val must be string, number or Buffer");
            }
            function b(e5, t5, r4, n2, o2) {
              let i2, a2 = 1, u2 = e5.length, s2 = t5.length;
              if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
                if (e5.length < 2 || t5.length < 2) return -1;
                a2 = 2, u2 /= 2, s2 /= 2, r4 /= 2;
              }
              function c2(e6, t6) {
                return 1 === a2 ? e6[t6] : e6.readUInt16BE(t6 * a2);
              }
              if (o2) {
                let n3 = -1;
                for (i2 = r4; i2 < u2; i2++) if (c2(e5, i2) === c2(t5, -1 === n3 ? 0 : i2 - n3)) {
                  if (-1 === n3 && (n3 = i2), i2 - n3 + 1 === s2) return n3 * a2;
                } else -1 !== n3 && (i2 -= i2 - n3), n3 = -1;
              } else for (r4 + s2 > u2 && (r4 = u2 - s2), i2 = r4; i2 >= 0; i2--) {
                let r5 = true;
                for (let n3 = 0; n3 < s2; n3++) if (c2(e5, i2 + n3) !== c2(t5, n3)) {
                  r5 = false;
                  break;
                }
                if (r5) return i2;
              }
              return -1;
            }
            function w(e5, t5, r4, n2) {
              r4 = Number(r4) || 0;
              const o2 = e5.length - r4;
              n2 ? (n2 = Number(n2)) > o2 && (n2 = o2) : n2 = o2;
              const i2 = t5.length;
              let a2;
              for (n2 > i2 / 2 && (n2 = i2 / 2), a2 = 0; a2 < n2; ++a2) {
                const n3 = parseInt(t5.substr(2 * a2, 2), 16);
                if (W(n3)) return a2;
                e5[r4 + a2] = n3;
              }
              return a2;
            }
            function S(e5, t5, r4, n2) {
              return $(X(t5, e5.length - r4), e5, r4, n2);
            }
            function k(e5, t5, r4, n2) {
              return $(function(e6) {
                const t6 = [];
                for (let r5 = 0; r5 < e6.length; ++r5) t6.push(255 & e6.charCodeAt(r5));
                return t6;
              }(t5), e5, r4, n2);
            }
            function E(e5, t5, r4, n2) {
              return $(G(t5), e5, r4, n2);
            }
            function _(e5, t5, r4, n2) {
              return $(function(e6, t6) {
                let r5, n3, o2;
                const i2 = [];
                for (let a2 = 0; a2 < e6.length && !((t6 -= 2) < 0); ++a2) r5 = e6.charCodeAt(a2), n3 = r5 >> 8, o2 = r5 % 256, i2.push(o2), i2.push(n3);
                return i2;
              }(t5, e5.length - r4), e5, r4, n2);
            }
            function T(e5, t5, r4) {
              return 0 === t5 && r4 === e5.length ? n.fromByteArray(e5) : n.fromByteArray(e5.slice(t5, r4));
            }
            function O(e5, t5, r4) {
              r4 = Math.min(e5.length, r4);
              const n2 = [];
              let o2 = t5;
              for (; o2 < r4; ) {
                const t6 = e5[o2];
                let i2 = null, a2 = t6 > 239 ? 4 : t6 > 223 ? 3 : t6 > 191 ? 2 : 1;
                if (o2 + a2 <= r4) {
                  let r5, n3, u2, s2;
                  switch (a2) {
                    case 1:
                      t6 < 128 && (i2 = t6);
                      break;
                    case 2:
                      r5 = e5[o2 + 1], 128 == (192 & r5) && (s2 = (31 & t6) << 6 | 63 & r5, s2 > 127 && (i2 = s2));
                      break;
                    case 3:
                      r5 = e5[o2 + 1], n3 = e5[o2 + 2], 128 == (192 & r5) && 128 == (192 & n3) && (s2 = (15 & t6) << 12 | (63 & r5) << 6 | 63 & n3, s2 > 2047 && (s2 < 55296 || s2 > 57343) && (i2 = s2));
                      break;
                    case 4:
                      r5 = e5[o2 + 1], n3 = e5[o2 + 2], u2 = e5[o2 + 3], 128 == (192 & r5) && 128 == (192 & n3) && 128 == (192 & u2) && (s2 = (15 & t6) << 18 | (63 & r5) << 12 | (63 & n3) << 6 | 63 & u2, s2 > 65535 && s2 < 1114112 && (i2 = s2));
                  }
                }
                null === i2 ? (i2 = 65533, a2 = 1) : i2 > 65535 && (i2 -= 65536, n2.push(i2 >>> 10 & 1023 | 55296), i2 = 56320 | 1023 & i2), n2.push(i2), o2 += a2;
              }
              return function(e6) {
                const t6 = e6.length;
                if (t6 <= x) return String.fromCharCode.apply(String, e6);
                let r5 = "", n3 = 0;
                for (; n3 < t6; ) r5 += String.fromCharCode.apply(String, e6.slice(n3, n3 += x));
                return r5;
              }(n2);
            }
            s.TYPED_ARRAY_SUPPORT = function() {
              try {
                const e5 = new Uint8Array(1), t5 = { foo: function() {
                  return 42;
                } };
                return Object.setPrototypeOf(t5, Uint8Array.prototype), Object.setPrototypeOf(e5, t5), 42 === e5.foo();
              } catch (e5) {
                return false;
              }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              if (s.isBuffer(this)) return this.buffer;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              if (s.isBuffer(this)) return this.byteOffset;
            } }), s.poolSize = 8192, s.from = function(e5, t5, r4) {
              return c(e5, t5, r4);
            }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array), s.alloc = function(e5, t5, r4) {
              return function(e6, t6, r5) {
                return l(e6), e6 <= 0 ? u(e6) : void 0 !== t6 ? "string" == typeof r5 ? u(e6).fill(t6, r5) : u(e6).fill(t6) : u(e6);
              }(e5, t5, r4);
            }, s.allocUnsafe = function(e5) {
              return f(e5);
            }, s.allocUnsafeSlow = function(e5) {
              return f(e5);
            }, s.isBuffer = function(e5) {
              return null != e5 && true === e5._isBuffer && e5 !== s.prototype;
            }, s.compare = function(e5, t5) {
              if (Q(e5, Uint8Array) && (e5 = s.from(e5, e5.offset, e5.byteLength)), Q(t5, Uint8Array) && (t5 = s.from(t5, t5.offset, t5.byteLength)), !s.isBuffer(e5) || !s.isBuffer(t5)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e5 === t5) return 0;
              let r4 = e5.length, n2 = t5.length;
              for (let o2 = 0, i2 = Math.min(r4, n2); o2 < i2; ++o2) if (e5[o2] !== t5[o2]) {
                r4 = e5[o2], n2 = t5[o2];
                break;
              }
              return r4 < n2 ? -1 : n2 < r4 ? 1 : 0;
            }, s.isEncoding = function(e5) {
              switch (String(e5).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e5, t5) {
              if (!Array.isArray(e5)) throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e5.length) return s.alloc(0);
              let r4;
              if (void 0 === t5) for (t5 = 0, r4 = 0; r4 < e5.length; ++r4) t5 += e5[r4].length;
              const n2 = s.allocUnsafe(t5);
              let o2 = 0;
              for (r4 = 0; r4 < e5.length; ++r4) {
                let t6 = e5[r4];
                if (Q(t6, Uint8Array)) o2 + t6.length > n2.length ? (s.isBuffer(t6) || (t6 = s.from(t6)), t6.copy(n2, o2)) : Uint8Array.prototype.set.call(n2, t6, o2);
                else {
                  if (!s.isBuffer(t6)) throw new TypeError('"list" argument must be an Array of Buffers');
                  t6.copy(n2, o2);
                }
                o2 += t6.length;
              }
              return n2;
            }, s.byteLength = y, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              const e5 = this.length;
              if (e5 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (let t5 = 0; t5 < e5; t5 += 2) v(this, t5, t5 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              const e5 = this.length;
              if (e5 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (let t5 = 0; t5 < e5; t5 += 4) v(this, t5, t5 + 3), v(this, t5 + 1, t5 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              const e5 = this.length;
              if (e5 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (let t5 = 0; t5 < e5; t5 += 8) v(this, t5, t5 + 7), v(this, t5 + 1, t5 + 6), v(this, t5 + 2, t5 + 5), v(this, t5 + 3, t5 + 4);
              return this;
            }, s.prototype.toString = function() {
              const e5 = this.length;
              return 0 === e5 ? "" : 0 === arguments.length ? O(this, 0, e5) : m.apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e5) {
              if (!s.isBuffer(e5)) throw new TypeError("Argument must be a Buffer");
              return this === e5 || 0 === s.compare(this, e5);
            }, s.prototype.inspect = function() {
              let e5 = "";
              const r4 = t4.IS;
              return e5 = this.toString("hex", 0, r4).replace(/(.{2})/g, "$1 ").trim(), this.length > r4 && (e5 += " ... "), "<Buffer " + e5 + ">";
            }, i && (s.prototype[i] = s.prototype.inspect), s.prototype.compare = function(e5, t5, r4, n2, o2) {
              if (Q(e5, Uint8Array) && (e5 = s.from(e5, e5.offset, e5.byteLength)), !s.isBuffer(e5)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e5);
              if (void 0 === t5 && (t5 = 0), void 0 === r4 && (r4 = e5 ? e5.length : 0), void 0 === n2 && (n2 = 0), void 0 === o2 && (o2 = this.length), t5 < 0 || r4 > e5.length || n2 < 0 || o2 > this.length) throw new RangeError("out of range index");
              if (n2 >= o2 && t5 >= r4) return 0;
              if (n2 >= o2) return -1;
              if (t5 >= r4) return 1;
              if (this === e5) return 0;
              let i2 = (o2 >>>= 0) - (n2 >>>= 0), a2 = (r4 >>>= 0) - (t5 >>>= 0);
              const u2 = Math.min(i2, a2), c2 = this.slice(n2, o2), l2 = e5.slice(t5, r4);
              for (let e6 = 0; e6 < u2; ++e6) if (c2[e6] !== l2[e6]) {
                i2 = c2[e6], a2 = l2[e6];
                break;
              }
              return i2 < a2 ? -1 : a2 < i2 ? 1 : 0;
            }, s.prototype.includes = function(e5, t5, r4) {
              return -1 !== this.indexOf(e5, t5, r4);
            }, s.prototype.indexOf = function(e5, t5, r4) {
              return g(this, e5, t5, r4, true);
            }, s.prototype.lastIndexOf = function(e5, t5, r4) {
              return g(this, e5, t5, r4, false);
            }, s.prototype.write = function(e5, t5, r4, n2) {
              if (void 0 === t5) n2 = "utf8", r4 = this.length, t5 = 0;
              else if (void 0 === r4 && "string" == typeof t5) n2 = t5, r4 = this.length, t5 = 0;
              else {
                if (!isFinite(t5)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t5 >>>= 0, isFinite(r4) ? (r4 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r4, r4 = void 0);
              }
              const o2 = this.length - t5;
              if ((void 0 === r4 || r4 > o2) && (r4 = o2), e5.length > 0 && (r4 < 0 || t5 < 0) || t5 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
              n2 || (n2 = "utf8");
              let i2 = false;
              for (; ; ) switch (n2) {
                case "hex":
                  return w(this, e5, t5, r4);
                case "utf8":
                case "utf-8":
                  return S(this, e5, t5, r4);
                case "ascii":
                case "latin1":
                case "binary":
                  return k(this, e5, t5, r4);
                case "base64":
                  return E(this, e5, t5, r4);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return _(this, e5, t5, r4);
                default:
                  if (i2) throw new TypeError("Unknown encoding: " + n2);
                  n2 = ("" + n2).toLowerCase(), i2 = true;
              }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            const x = 4096;
            function A(e5, t5, r4) {
              let n2 = "";
              r4 = Math.min(e5.length, r4);
              for (let o2 = t5; o2 < r4; ++o2) n2 += String.fromCharCode(127 & e5[o2]);
              return n2;
            }
            function P(e5, t5, r4) {
              let n2 = "";
              r4 = Math.min(e5.length, r4);
              for (let o2 = t5; o2 < r4; ++o2) n2 += String.fromCharCode(e5[o2]);
              return n2;
            }
            function I(e5, t5, r4) {
              const n2 = e5.length;
              (!t5 || t5 < 0) && (t5 = 0), (!r4 || r4 < 0 || r4 > n2) && (r4 = n2);
              let o2 = "";
              for (let n3 = t5; n3 < r4; ++n3) o2 += Y[e5[n3]];
              return o2;
            }
            function R(e5, t5, r4) {
              const n2 = e5.slice(t5, r4);
              let o2 = "";
              for (let e6 = 0; e6 < n2.length - 1; e6 += 2) o2 += String.fromCharCode(n2[e6] + 256 * n2[e6 + 1]);
              return o2;
            }
            function C(e5, t5, r4) {
              if (e5 % 1 != 0 || e5 < 0) throw new RangeError("offset is not uint");
              if (e5 + t5 > r4) throw new RangeError("Trying to access beyond buffer length");
            }
            function j(e5, t5, r4, n2, o2, i2) {
              if (!s.isBuffer(e5)) throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t5 > o2 || t5 < i2) throw new RangeError('"value" argument is out of bounds');
              if (r4 + n2 > e5.length) throw new RangeError("Index out of range");
            }
            function B(e5, t5, r4, n2, o2) {
              q(t5, n2, o2, e5, r4, 7);
              let i2 = Number(t5 & BigInt(4294967295));
              e5[r4++] = i2, i2 >>= 8, e5[r4++] = i2, i2 >>= 8, e5[r4++] = i2, i2 >>= 8, e5[r4++] = i2;
              let a2 = Number(t5 >> BigInt(32) & BigInt(4294967295));
              return e5[r4++] = a2, a2 >>= 8, e5[r4++] = a2, a2 >>= 8, e5[r4++] = a2, a2 >>= 8, e5[r4++] = a2, r4;
            }
            function L(e5, t5, r4, n2, o2) {
              q(t5, n2, o2, e5, r4, 7);
              let i2 = Number(t5 & BigInt(4294967295));
              e5[r4 + 7] = i2, i2 >>= 8, e5[r4 + 6] = i2, i2 >>= 8, e5[r4 + 5] = i2, i2 >>= 8, e5[r4 + 4] = i2;
              let a2 = Number(t5 >> BigInt(32) & BigInt(4294967295));
              return e5[r4 + 3] = a2, a2 >>= 8, e5[r4 + 2] = a2, a2 >>= 8, e5[r4 + 1] = a2, a2 >>= 8, e5[r4] = a2, r4 + 8;
            }
            function N(e5, t5, r4, n2, o2, i2) {
              if (r4 + n2 > e5.length) throw new RangeError("Index out of range");
              if (r4 < 0) throw new RangeError("Index out of range");
            }
            function U(e5, t5, r4, n2, i2) {
              return t5 = +t5, r4 >>>= 0, i2 || N(e5, 0, r4, 4), o.write(e5, t5, r4, n2, 23, 4), r4 + 4;
            }
            function M(e5, t5, r4, n2, i2) {
              return t5 = +t5, r4 >>>= 0, i2 || N(e5, 0, r4, 8), o.write(e5, t5, r4, n2, 52, 8), r4 + 8;
            }
            s.prototype.slice = function(e5, t5) {
              const r4 = this.length;
              (e5 = ~~e5) < 0 ? (e5 += r4) < 0 && (e5 = 0) : e5 > r4 && (e5 = r4), (t5 = void 0 === t5 ? r4 : ~~t5) < 0 ? (t5 += r4) < 0 && (t5 = 0) : t5 > r4 && (t5 = r4), t5 < e5 && (t5 = e5);
              const n2 = this.subarray(e5, t5);
              return Object.setPrototypeOf(n2, s.prototype), n2;
            }, s.prototype.readUintLE = s.prototype.readUIntLE = function(e5, t5, r4) {
              e5 >>>= 0, t5 >>>= 0, r4 || C(e5, t5, this.length);
              let n2 = this[e5], o2 = 1, i2 = 0;
              for (; ++i2 < t5 && (o2 *= 256); ) n2 += this[e5 + i2] * o2;
              return n2;
            }, s.prototype.readUintBE = s.prototype.readUIntBE = function(e5, t5, r4) {
              e5 >>>= 0, t5 >>>= 0, r4 || C(e5, t5, this.length);
              let n2 = this[e5 + --t5], o2 = 1;
              for (; t5 > 0 && (o2 *= 256); ) n2 += this[e5 + --t5] * o2;
              return n2;
            }, s.prototype.readUint8 = s.prototype.readUInt8 = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 1, this.length), this[e5];
            }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 2, this.length), this[e5] | this[e5 + 1] << 8;
            }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 2, this.length), this[e5] << 8 | this[e5 + 1];
            }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 4, this.length), (this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16) + 16777216 * this[e5 + 3];
            }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 4, this.length), 16777216 * this[e5] + (this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3]);
            }, s.prototype.readBigUInt64LE = J(function(e5) {
              K(e5 >>>= 0, "offset");
              const t5 = this[e5], r4 = this[e5 + 7];
              void 0 !== t5 && void 0 !== r4 || H(e5, this.length - 8);
              const n2 = t5 + 256 * this[++e5] + 65536 * this[++e5] + this[++e5] * 2 ** 24, o2 = this[++e5] + 256 * this[++e5] + 65536 * this[++e5] + r4 * 2 ** 24;
              return BigInt(n2) + (BigInt(o2) << BigInt(32));
            }), s.prototype.readBigUInt64BE = J(function(e5) {
              K(e5 >>>= 0, "offset");
              const t5 = this[e5], r4 = this[e5 + 7];
              void 0 !== t5 && void 0 !== r4 || H(e5, this.length - 8);
              const n2 = t5 * 2 ** 24 + 65536 * this[++e5] + 256 * this[++e5] + this[++e5], o2 = this[++e5] * 2 ** 24 + 65536 * this[++e5] + 256 * this[++e5] + r4;
              return (BigInt(n2) << BigInt(32)) + BigInt(o2);
            }), s.prototype.readIntLE = function(e5, t5, r4) {
              e5 >>>= 0, t5 >>>= 0, r4 || C(e5, t5, this.length);
              let n2 = this[e5], o2 = 1, i2 = 0;
              for (; ++i2 < t5 && (o2 *= 256); ) n2 += this[e5 + i2] * o2;
              return o2 *= 128, n2 >= o2 && (n2 -= Math.pow(2, 8 * t5)), n2;
            }, s.prototype.readIntBE = function(e5, t5, r4) {
              e5 >>>= 0, t5 >>>= 0, r4 || C(e5, t5, this.length);
              let n2 = t5, o2 = 1, i2 = this[e5 + --n2];
              for (; n2 > 0 && (o2 *= 256); ) i2 += this[e5 + --n2] * o2;
              return o2 *= 128, i2 >= o2 && (i2 -= Math.pow(2, 8 * t5)), i2;
            }, s.prototype.readInt8 = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 1, this.length), 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
            }, s.prototype.readInt16LE = function(e5, t5) {
              e5 >>>= 0, t5 || C(e5, 2, this.length);
              const r4 = this[e5] | this[e5 + 1] << 8;
              return 32768 & r4 ? 4294901760 | r4 : r4;
            }, s.prototype.readInt16BE = function(e5, t5) {
              e5 >>>= 0, t5 || C(e5, 2, this.length);
              const r4 = this[e5 + 1] | this[e5] << 8;
              return 32768 & r4 ? 4294901760 | r4 : r4;
            }, s.prototype.readInt32LE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 4, this.length), this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16 | this[e5 + 3] << 24;
            }, s.prototype.readInt32BE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 4, this.length), this[e5] << 24 | this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3];
            }, s.prototype.readBigInt64LE = J(function(e5) {
              K(e5 >>>= 0, "offset");
              const t5 = this[e5], r4 = this[e5 + 7];
              void 0 !== t5 && void 0 !== r4 || H(e5, this.length - 8);
              const n2 = this[e5 + 4] + 256 * this[e5 + 5] + 65536 * this[e5 + 6] + (r4 << 24);
              return (BigInt(n2) << BigInt(32)) + BigInt(t5 + 256 * this[++e5] + 65536 * this[++e5] + this[++e5] * 2 ** 24);
            }), s.prototype.readBigInt64BE = J(function(e5) {
              K(e5 >>>= 0, "offset");
              const t5 = this[e5], r4 = this[e5 + 7];
              void 0 !== t5 && void 0 !== r4 || H(e5, this.length - 8);
              const n2 = (t5 << 24) + 65536 * this[++e5] + 256 * this[++e5] + this[++e5];
              return (BigInt(n2) << BigInt(32)) + BigInt(this[++e5] * 2 ** 24 + 65536 * this[++e5] + 256 * this[++e5] + r4);
            }), s.prototype.readFloatLE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 4, this.length), o.read(this, e5, true, 23, 4);
            }, s.prototype.readFloatBE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 4, this.length), o.read(this, e5, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 8, this.length), o.read(this, e5, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e5, t5) {
              return e5 >>>= 0, t5 || C(e5, 8, this.length), o.read(this, e5, false, 52, 8);
            }, s.prototype.writeUintLE = s.prototype.writeUIntLE = function(e5, t5, r4, n2) {
              e5 = +e5, t5 >>>= 0, r4 >>>= 0, n2 || j(this, e5, t5, r4, Math.pow(2, 8 * r4) - 1, 0);
              let o2 = 1, i2 = 0;
              for (this[t5] = 255 & e5; ++i2 < r4 && (o2 *= 256); ) this[t5 + i2] = e5 / o2 & 255;
              return t5 + r4;
            }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(e5, t5, r4, n2) {
              e5 = +e5, t5 >>>= 0, r4 >>>= 0, n2 || j(this, e5, t5, r4, Math.pow(2, 8 * r4) - 1, 0);
              let o2 = r4 - 1, i2 = 1;
              for (this[t5 + o2] = 255 & e5; --o2 >= 0 && (i2 *= 256); ) this[t5 + o2] = e5 / i2 & 255;
              return t5 + r4;
            }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 1, 255, 0), this[t5] = 255 & e5, t5 + 1;
            }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 2, 65535, 0), this[t5] = 255 & e5, this[t5 + 1] = e5 >>> 8, t5 + 2;
            }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 2, 65535, 0), this[t5] = e5 >>> 8, this[t5 + 1] = 255 & e5, t5 + 2;
            }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 4, 4294967295, 0), this[t5 + 3] = e5 >>> 24, this[t5 + 2] = e5 >>> 16, this[t5 + 1] = e5 >>> 8, this[t5] = 255 & e5, t5 + 4;
            }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 4, 4294967295, 0), this[t5] = e5 >>> 24, this[t5 + 1] = e5 >>> 16, this[t5 + 2] = e5 >>> 8, this[t5 + 3] = 255 & e5, t5 + 4;
            }, s.prototype.writeBigUInt64LE = J(function(e5, t5 = 0) {
              return B(this, e5, t5, BigInt(0), BigInt("0xffffffffffffffff"));
            }), s.prototype.writeBigUInt64BE = J(function(e5, t5 = 0) {
              return L(this, e5, t5, BigInt(0), BigInt("0xffffffffffffffff"));
            }), s.prototype.writeIntLE = function(e5, t5, r4, n2) {
              if (e5 = +e5, t5 >>>= 0, !n2) {
                const n3 = Math.pow(2, 8 * r4 - 1);
                j(this, e5, t5, r4, n3 - 1, -n3);
              }
              let o2 = 0, i2 = 1, a2 = 0;
              for (this[t5] = 255 & e5; ++o2 < r4 && (i2 *= 256); ) e5 < 0 && 0 === a2 && 0 !== this[t5 + o2 - 1] && (a2 = 1), this[t5 + o2] = (e5 / i2 | 0) - a2 & 255;
              return t5 + r4;
            }, s.prototype.writeIntBE = function(e5, t5, r4, n2) {
              if (e5 = +e5, t5 >>>= 0, !n2) {
                const n3 = Math.pow(2, 8 * r4 - 1);
                j(this, e5, t5, r4, n3 - 1, -n3);
              }
              let o2 = r4 - 1, i2 = 1, a2 = 0;
              for (this[t5 + o2] = 255 & e5; --o2 >= 0 && (i2 *= 256); ) e5 < 0 && 0 === a2 && 0 !== this[t5 + o2 + 1] && (a2 = 1), this[t5 + o2] = (e5 / i2 | 0) - a2 & 255;
              return t5 + r4;
            }, s.prototype.writeInt8 = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 1, 127, -128), e5 < 0 && (e5 = 255 + e5 + 1), this[t5] = 255 & e5, t5 + 1;
            }, s.prototype.writeInt16LE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 2, 32767, -32768), this[t5] = 255 & e5, this[t5 + 1] = e5 >>> 8, t5 + 2;
            }, s.prototype.writeInt16BE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 2, 32767, -32768), this[t5] = e5 >>> 8, this[t5 + 1] = 255 & e5, t5 + 2;
            }, s.prototype.writeInt32LE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 4, 2147483647, -2147483648), this[t5] = 255 & e5, this[t5 + 1] = e5 >>> 8, this[t5 + 2] = e5 >>> 16, this[t5 + 3] = e5 >>> 24, t5 + 4;
            }, s.prototype.writeInt32BE = function(e5, t5, r4) {
              return e5 = +e5, t5 >>>= 0, r4 || j(this, e5, t5, 4, 2147483647, -2147483648), e5 < 0 && (e5 = 4294967295 + e5 + 1), this[t5] = e5 >>> 24, this[t5 + 1] = e5 >>> 16, this[t5 + 2] = e5 >>> 8, this[t5 + 3] = 255 & e5, t5 + 4;
            }, s.prototype.writeBigInt64LE = J(function(e5, t5 = 0) {
              return B(this, e5, t5, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            }), s.prototype.writeBigInt64BE = J(function(e5, t5 = 0) {
              return L(this, e5, t5, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            }), s.prototype.writeFloatLE = function(e5, t5, r4) {
              return U(this, e5, t5, true, r4);
            }, s.prototype.writeFloatBE = function(e5, t5, r4) {
              return U(this, e5, t5, false, r4);
            }, s.prototype.writeDoubleLE = function(e5, t5, r4) {
              return M(this, e5, t5, true, r4);
            }, s.prototype.writeDoubleBE = function(e5, t5, r4) {
              return M(this, e5, t5, false, r4);
            }, s.prototype.copy = function(e5, t5, r4, n2) {
              if (!s.isBuffer(e5)) throw new TypeError("argument should be a Buffer");
              if (r4 || (r4 = 0), n2 || 0 === n2 || (n2 = this.length), t5 >= e5.length && (t5 = e5.length), t5 || (t5 = 0), n2 > 0 && n2 < r4 && (n2 = r4), n2 === r4) return 0;
              if (0 === e5.length || 0 === this.length) return 0;
              if (t5 < 0) throw new RangeError("targetStart out of bounds");
              if (r4 < 0 || r4 >= this.length) throw new RangeError("Index out of range");
              if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
              n2 > this.length && (n2 = this.length), e5.length - t5 < n2 - r4 && (n2 = e5.length - t5 + r4);
              const o2 = n2 - r4;
              return this === e5 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t5, r4, n2) : Uint8Array.prototype.set.call(e5, this.subarray(r4, n2), t5), o2;
            }, s.prototype.fill = function(e5, t5, r4, n2) {
              if ("string" == typeof e5) {
                if ("string" == typeof t5 ? (n2 = t5, t5 = 0, r4 = this.length) : "string" == typeof r4 && (n2 = r4, r4 = this.length), void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
                if ("string" == typeof n2 && !s.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
                if (1 === e5.length) {
                  const t6 = e5.charCodeAt(0);
                  ("utf8" === n2 && t6 < 128 || "latin1" === n2) && (e5 = t6);
                }
              } else "number" == typeof e5 ? e5 &= 255 : "boolean" == typeof e5 && (e5 = Number(e5));
              if (t5 < 0 || this.length < t5 || this.length < r4) throw new RangeError("Out of range index");
              if (r4 <= t5) return this;
              let o2;
              if (t5 >>>= 0, r4 = void 0 === r4 ? this.length : r4 >>> 0, e5 || (e5 = 0), "number" == typeof e5) for (o2 = t5; o2 < r4; ++o2) this[o2] = e5;
              else {
                const i2 = s.isBuffer(e5) ? e5 : s.from(e5, n2), a2 = i2.length;
                if (0 === a2) throw new TypeError('The value "' + e5 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < r4 - t5; ++o2) this[o2 + t5] = i2[o2 % a2];
              }
              return this;
            };
            const F = {};
            function D(e5, t5, r4) {
              F[e5] = class extends r4 {
                constructor() {
                  super(), Object.defineProperty(this, "message", { value: t5.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e5}]`, this.stack, delete this.name;
                }
                get code() {
                  return e5;
                }
                set code(e6) {
                  Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e6, writable: true });
                }
                toString() {
                  return `${this.name} [${e5}]: ${this.message}`;
                }
              };
            }
            function V(e5) {
              let t5 = "", r4 = e5.length;
              const n2 = "-" === e5[0] ? 1 : 0;
              for (; r4 >= n2 + 4; r4 -= 3) t5 = `_${e5.slice(r4 - 3, r4)}${t5}`;
              return `${e5.slice(0, r4)}${t5}`;
            }
            function q(e5, t5, r4, n2, o2, i2) {
              if (e5 > r4 || e5 < t5) {
                const n3 = "bigint" == typeof t5 ? "n" : "";
                let o3;
                throw o3 = i2 > 3 ? 0 === t5 || t5 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (i2 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (i2 + 1) - 1}${n3}) and < 2 ** ${8 * (i2 + 1) - 1}${n3}` : `>= ${t5}${n3} and <= ${r4}${n3}`, new F.ERR_OUT_OF_RANGE("value", o3, e5);
              }
              !function(e6, t6, r5) {
                K(t6, "offset"), void 0 !== e6[t6] && void 0 !== e6[t6 + r5] || H(t6, e6.length - (r5 + 1));
              }(n2, o2, i2);
            }
            function K(e5, t5) {
              if ("number" != typeof e5) throw new F.ERR_INVALID_ARG_TYPE(t5, "number", e5);
            }
            function H(e5, t5, r4) {
              if (Math.floor(e5) !== e5) throw K(e5, r4), new F.ERR_OUT_OF_RANGE(r4 || "offset", "an integer", e5);
              if (t5 < 0) throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
              throw new F.ERR_OUT_OF_RANGE(r4 || "offset", `>= ${r4 ? 1 : 0} and <= ${t5}`, e5);
            }
            D("ERR_BUFFER_OUT_OF_BOUNDS", function(e5) {
              return e5 ? `${e5} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
            }, RangeError), D("ERR_INVALID_ARG_TYPE", function(e5, t5) {
              return `The "${e5}" argument must be of type number. Received type ${typeof t5}`;
            }, TypeError), D("ERR_OUT_OF_RANGE", function(e5, t5, r4) {
              let n2 = `The value of "${e5}" is out of range.`, o2 = r4;
              return Number.isInteger(r4) && Math.abs(r4) > 2 ** 32 ? o2 = V(String(r4)) : "bigint" == typeof r4 && (o2 = String(r4), (r4 > BigInt(2) ** BigInt(32) || r4 < -(BigInt(2) ** BigInt(32))) && (o2 = V(o2)), o2 += "n"), n2 += ` It must be ${t5}. Received ${o2}`, n2;
            }, RangeError);
            const z = /[^+/0-9A-Za-z-_]/g;
            function X(e5, t5) {
              let r4;
              t5 = t5 || 1 / 0;
              const n2 = e5.length;
              let o2 = null;
              const i2 = [];
              for (let a2 = 0; a2 < n2; ++a2) {
                if (r4 = e5.charCodeAt(a2), r4 > 55295 && r4 < 57344) {
                  if (!o2) {
                    if (r4 > 56319) {
                      (t5 -= 3) > -1 && i2.push(239, 191, 189);
                      continue;
                    }
                    if (a2 + 1 === n2) {
                      (t5 -= 3) > -1 && i2.push(239, 191, 189);
                      continue;
                    }
                    o2 = r4;
                    continue;
                  }
                  if (r4 < 56320) {
                    (t5 -= 3) > -1 && i2.push(239, 191, 189), o2 = r4;
                    continue;
                  }
                  r4 = 65536 + (o2 - 55296 << 10 | r4 - 56320);
                } else o2 && (t5 -= 3) > -1 && i2.push(239, 191, 189);
                if (o2 = null, r4 < 128) {
                  if ((t5 -= 1) < 0) break;
                  i2.push(r4);
                } else if (r4 < 2048) {
                  if ((t5 -= 2) < 0) break;
                  i2.push(r4 >> 6 | 192, 63 & r4 | 128);
                } else if (r4 < 65536) {
                  if ((t5 -= 3) < 0) break;
                  i2.push(r4 >> 12 | 224, r4 >> 6 & 63 | 128, 63 & r4 | 128);
                } else {
                  if (!(r4 < 1114112)) throw new Error("Invalid code point");
                  if ((t5 -= 4) < 0) break;
                  i2.push(r4 >> 18 | 240, r4 >> 12 & 63 | 128, r4 >> 6 & 63 | 128, 63 & r4 | 128);
                }
              }
              return i2;
            }
            function G(e5) {
              return n.toByteArray(function(e6) {
                if ((e6 = (e6 = e6.split("=")[0]).trim().replace(z, "")).length < 2) return "";
                for (; e6.length % 4 != 0; ) e6 += "=";
                return e6;
              }(e5));
            }
            function $(e5, t5, r4, n2) {
              let o2;
              for (o2 = 0; o2 < n2 && !(o2 + r4 >= t5.length || o2 >= e5.length); ++o2) t5[o2 + r4] = e5[o2];
              return o2;
            }
            function Q(e5, t5) {
              return e5 instanceof t5 || null != e5 && null != e5.constructor && null != e5.constructor.name && e5.constructor.name === t5.name;
            }
            function W(e5) {
              return e5 != e5;
            }
            const Y = function() {
              const e5 = "0123456789abcdef", t5 = new Array(256);
              for (let r4 = 0; r4 < 16; ++r4) {
                const n2 = 16 * r4;
                for (let o2 = 0; o2 < 16; ++o2) t5[n2 + o2] = e5[r4] + e5[o2];
              }
              return t5;
            }();
            function J(e5) {
              return "undefined" == typeof BigInt ? Z : e5;
            }
            function Z() {
              throw new Error("BigInt not supported");
            }
          }, 251: (e4, t4) => {
            t4.read = function(e5, t5, r3, n, o) {
              var i, a, u = 8 * o - n - 1, s = (1 << u) - 1, c = s >> 1, l = -7, f = r3 ? o - 1 : 0, p = r3 ? -1 : 1, d = e5[t5 + f];
              for (f += p, i = d & (1 << -l) - 1, d >>= -l, l += u; l > 0; i = 256 * i + e5[t5 + f], f += p, l -= 8) ;
              for (a = i & (1 << -l) - 1, i >>= -l, l += n; l > 0; a = 256 * a + e5[t5 + f], f += p, l -= 8) ;
              if (0 === i) i = 1 - c;
              else {
                if (i === s) return a ? NaN : 1 / 0 * (d ? -1 : 1);
                a += Math.pow(2, n), i -= c;
              }
              return (d ? -1 : 1) * a * Math.pow(2, i - n);
            }, t4.write = function(e5, t5, r3, n, o, i) {
              var a, u, s, c = 8 * i - o - 1, l = (1 << c) - 1, f = l >> 1, p = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : i - 1, h = n ? 1 : -1, y = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
              for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (u = isNaN(t5) ? 1 : 0, a = l) : (a = Math.floor(Math.log(t5) / Math.LN2), t5 * (s = Math.pow(2, -a)) < 1 && (a--, s *= 2), (t5 += a + f >= 1 ? p / s : p * Math.pow(2, 1 - f)) * s >= 2 && (a++, s /= 2), a + f >= l ? (u = 0, a = l) : a + f >= 1 ? (u = (t5 * s - 1) * Math.pow(2, o), a += f) : (u = t5 * Math.pow(2, f - 1) * Math.pow(2, o), a = 0)); o >= 8; e5[r3 + d] = 255 & u, d += h, u /= 256, o -= 8) ;
              for (a = a << o | u, c += o; c > 0; e5[r3 + d] = 255 & a, d += h, a /= 256, c -= 8) ;
              e5[r3 + d - h] |= 128 * y;
            };
          } }, t3 = {};
          function r2(n) {
            var o = t3[n];
            if (void 0 !== o) return o.exports;
            var i = t3[n] = { exports: {} };
            return e3[n](i, i.exports, r2), i.exports;
          }
          return r2.d = (e4, t4) => {
            for (var n in t4) r2.o(t4, n) && !r2.o(e4, n) && Object.defineProperty(e4, n, { enumerable: true, get: t4[n] });
          }, r2.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e4) {
              if ("object" == typeof window) return window;
            }
          }(), r2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), r2.r = (e4) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          }, r2(281);
        })(), e2.exports = t2();
      }, 3758: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TransactionBase = void 0;
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(9152), u = r2(6691);
        function s(e3) {
          return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, s(e3);
        }
        function c(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, l(n2.key), n2);
          }
        }
        function l(e3) {
          var t3 = function(e4, t4) {
            if ("object" != s(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != s(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == s(t3) ? t3 : t3 + "";
        }
        t2.TransactionBase = function() {
          return function(e3, t3, r3) {
            return t3 && c(e3.prototype, t3), r3 && c(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3, r3, n2, o2) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), "string" != typeof o2) throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(s(o2)));
            this._networkPassphrase = o2, this._tx = t3, this._signatures = r3, this._fee = n2;
          }, [{ key: "signatures", get: function() {
            return this._signatures;
          }, set: function(e3) {
            throw new Error("Transaction is immutable");
          } }, { key: "tx", get: function() {
            return this._tx;
          }, set: function(e3) {
            throw new Error("Transaction is immutable");
          } }, { key: "fee", get: function() {
            return this._fee;
          }, set: function(e3) {
            throw new Error("Transaction is immutable");
          } }, { key: "networkPassphrase", get: function() {
            return this._networkPassphrase;
          }, set: function(e3) {
            this._networkPassphrase = e3;
          } }, { key: "sign", value: function() {
            for (var e3 = this, t3 = this.hash(), r3 = arguments.length, n2 = new Array(r3), o2 = 0; o2 < r3; o2++) n2[o2] = arguments[o2];
            n2.forEach(function(r4) {
              var n3 = r4.signDecorated(t3);
              e3.signatures.push(n3);
            });
          } }, { key: "getKeypairSignature", value: function(e3) {
            return e3.sign(this.hash()).toString("base64");
          } }, { key: "addSignature", value: function() {
            var e3, t3, r3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", o2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            if (!o2 || "string" != typeof o2) throw new Error("Invalid signature");
            if (!r3 || "string" != typeof r3) throw new Error("Invalid publicKey");
            var a2 = n.from(o2, "base64");
            try {
              t3 = (e3 = u.Keypair.fromPublicKey(r3)).signatureHint();
            } catch (e4) {
              throw new Error("Invalid publicKey");
            }
            if (!e3.verify(this.hash(), a2)) throw new Error("Invalid signature");
            this.signatures.push(new i.default.DecoratedSignature({ hint: t3, signature: a2 }));
          } }, { key: "addDecoratedSignature", value: function(e3) {
            this.signatures.push(e3);
          } }, { key: "signHashX", value: function(e3) {
            if ("string" == typeof e3 && (e3 = n.from(e3, "hex")), e3.length > 64) throw new Error("preimage cannnot be longer than 64 bytes");
            var t3 = e3, r3 = (0, a.hash)(e3), o2 = r3.slice(r3.length - 4);
            this.signatures.push(new i.default.DecoratedSignature({ hint: o2, signature: t3 }));
          } }, { key: "hash", value: function() {
            return (0, a.hash)(this.signatureBase());
          } }, { key: "signatureBase", value: function() {
            throw new Error("Implement in subclass");
          } }, { key: "toEnvelope", value: function() {
            throw new Error("Implement in subclass");
          } }, { key: "toXDR", value: function() {
            return this.toEnvelope().toXDR().toString("base64");
          } }]);
        }();
      }, 3874: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.pathPaymentStrictSend = function(e3) {
          switch (true) {
            case !e3.sendAsset:
              throw new Error("Must specify a send asset");
            case !this.isValidAmount(e3.sendAmount):
              throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
            case !e3.destAsset:
              throw new Error("Must provide a destAsset for a payment operation");
            case !this.isValidAmount(e3.destMin):
              throw new TypeError(this.constructAmountRequirementsError("destMin"));
          }
          var t3 = {};
          t3.sendAsset = e3.sendAsset.toXDRObject(), t3.sendAmount = this._toXDRAmount(e3.sendAmount);
          try {
            t3.destination = (0, i.decodeAddressToMuxedAccount)(e3.destination);
          } catch (e4) {
            throw new Error("destination is invalid");
          }
          t3.destAsset = e3.destAsset.toXDRObject(), t3.destMin = this._toXDRAmount(e3.destMin);
          var r3 = e3.path ? e3.path : [];
          t3.path = r3.map(function(e4) {
            return e4.toXDRObject();
          });
          var n2 = new o.default.PathPaymentStrictSendOp(t3), a = {};
          return a.body = o.default.OperationBody.pathPaymentStrictSend(n2), this.setSourceAccount(a, e3), new o.default.Operation(a);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6160);
      }, 3898: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { Api: () => {
        }, Resolver: () => b, STELLAR_TOML_MAX_SIZE: () => v });
        var n = r2(1293), o = r2.n(n), i = r2(6371), a = r2(8732);
        function u(e3) {
          return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, u(e3);
        }
        function s() {
          s = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", c2 = i2.asyncIterator || "@@asyncIterator", l2 = i2.toStringTag || "@@toStringTag";
          function f2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            f2({}, "");
          } catch (e4) {
            f2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function p2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof b2 ? t4 : b2, a3 = Object.create(i3.prototype), u2 = new C(n3 || []);
            return o2(a3, "_invoke", { value: A(e4, r4, u2) }), a3;
          }
          function d2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = p2;
          var h2 = "suspendedStart", y2 = "suspendedYield", m2 = "executing", v2 = "completed", g2 = {};
          function b2() {
          }
          function w() {
          }
          function S() {
          }
          var k = {};
          f2(k, a2, function() {
            return this;
          });
          var E = Object.getPrototypeOf, _ = E && E(E(j([])));
          _ && _ !== r3 && n2.call(_, a2) && (k = _);
          var T = S.prototype = b2.prototype = Object.create(k);
          function O(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              f2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function x(e4, t4) {
            function r4(o3, i4, a3, s2) {
              var c3 = d2(e4[o3], e4, i4);
              if ("throw" !== c3.type) {
                var l3 = c3.arg, f3 = l3.value;
                return f3 && "object" == u(f3) && n2.call(f3, "__await") ? t4.resolve(f3.__await).then(function(e5) {
                  r4("next", e5, a3, s2);
                }, function(e5) {
                  r4("throw", e5, a3, s2);
                }) : t4.resolve(f3).then(function(e5) {
                  l3.value = e5, a3(l3);
                }, function(e5) {
                  return r4("throw", e5, a3, s2);
                });
              }
              s2(c3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A(t4, r4, n3) {
            var o3 = h2;
            return function(i3, a3) {
              if (o3 === m2) throw Error("Generator is already running");
              if (o3 === v2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u2 = n3.delegate;
                if (u2) {
                  var s2 = P(u2, n3);
                  if (s2) {
                    if (s2 === g2) continue;
                    return s2;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === h2) throw o3 = v2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = m2;
                var c3 = d2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? v2 : y2, c3.arg === g2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = v2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function P(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, P(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g2;
            var i3 = d2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, g2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, g2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, g2);
          }
          function I(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function R(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function C(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(I, this), this.reset(true);
          }
          function j(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(u(t4) + " is not iterable");
          }
          return w.prototype = S, o2(T, "constructor", { value: S, configurable: true }), o2(S, "constructor", { value: w, configurable: true }), w.displayName = f2(S, l2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === w || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, S) : (e4.__proto__ = S, f2(e4, l2, "GeneratorFunction")), e4.prototype = Object.create(T), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, O(x.prototype), f2(x.prototype, c2, function() {
            return this;
          }), t3.AsyncIterator = x, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new x(p2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, O(T), f2(T, l2, "Generator"), f2(T, a2, function() {
            return this;
          }), f2(T, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = j, C.prototype = { constructor: C, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(R), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u2.type = "throw", u2.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u2 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s2 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s2 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s2) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, g2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), g2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), R(r4), g2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  R(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: j(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), g2;
          } }, t3;
        }
        function c(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function l(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, f(n2.key), n2);
          }
        }
        function f(e3) {
          var t3 = function(e4, t4) {
            if ("object" != u(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != u(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == u(t3) ? t3 : t3 + "";
        }
        var p, d, h, y, m, v = 102400, g = i.ok.CancelToken, b = (p = function e3() {
          !function(e4, t3) {
            if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
          }(this, e3);
        }, d = null, h = [{ key: "resolve", value: (y = s().mark(function e3(t3) {
          var r3, n2, u2, c2, l2, f2 = arguments;
          return s().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return u2 = void 0 === (n2 = f2.length > 1 && void 0 !== f2[1] ? f2[1] : {}).allowHttp ? a.T.isAllowHttp() : n2.allowHttp, c2 = void 0 === n2.timeout ? a.T.getTimeout() : n2.timeout, l2 = u2 ? "http" : "https", e4.abrupt("return", i.ok.get("".concat(l2, "://").concat(t3, "/.well-known/stellar.toml"), { maxRedirects: null !== (r3 = n2.allowedRedirects) && void 0 !== r3 ? r3 : 0, maxContentLength: v, cancelToken: c2 ? new g(function(e5) {
                  return setTimeout(function() {
                    return e5("timeout of ".concat(c2, "ms exceeded"));
                  }, c2);
                }) : void 0, timeout: c2 }).then(function(e5) {
                  try {
                    var t4 = o().parse(e5.data);
                    return Promise.resolve(t4);
                  } catch (e6) {
                    return Promise.reject(new Error("stellar.toml is invalid - Parsing error on line ".concat(e6.line, ", column ").concat(e6.column, ": ").concat(e6.message)));
                  }
                }).catch(function(e5) {
                  throw e5.message.match(/^maxContentLength size/) ? new Error("stellar.toml file exceeds allowed size of ".concat(v)) : e5;
                }));
              case 5:
              case "end":
                return e4.stop();
            }
          }, e3);
        }), m = function() {
          var e3 = this, t3 = arguments;
          return new Promise(function(r3, n2) {
            var o2 = y.apply(e3, t3);
            function i2(e4) {
              c(o2, r3, n2, i2, a2, "next", e4);
            }
            function a2(e4) {
              c(o2, r3, n2, i2, a2, "throw", e4);
            }
            i2(void 0);
          });
        }, function(e3) {
          return m.apply(this, arguments);
        }) }], d && l(p.prototype, d), h && l(p, h), Object.defineProperty(p, "prototype", { writable: false }), p);
      }, 3919: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.humanizeEvents = function(e3) {
          return e3.map(function(e4) {
            return e4.inSuccessfulContractCall ? c(e4.event()) : c(e4);
          });
        };
        var n = r2(7120), o = r2(7177);
        function i(e3) {
          return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, i(e3);
        }
        function a(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function u(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? a(Object(r3), true).forEach(function(t4) {
              s(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : a(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function s(e3, t3, r3) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" != i(e5) || !e5) return e5;
              var r4 = e5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n2 = r4.call(e5, t5 || "default");
                if ("object" != i(n2)) return n2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t5 ? String : Number)(e5);
            }(e4, "string");
            return "symbol" == i(t4) ? t4 : t4 + "";
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function c(e3) {
          return u(u({}, "function" == typeof e3.contractId && null != e3.contractId() && { contractId: n.StrKey.encodeContract(e3.contractId()) }), {}, { type: e3.type().name, topics: e3.body().value().topics().map(function(e4) {
            return (0, o.scValToNative)(e4);
          }), data: (0, o.scValToNative)(e3.body().value().data()) });
        }
      }, 4062: (e2, t2) => {
        "use strict";
        function r2(e3) {
          return r2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, r2(e3);
        }
        function n(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return o(e4, t3);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? o(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function o(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function i(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, a(n2.key), n2);
          }
        }
        function a(e3) {
          var t3 = function(e4, t4) {
            if ("object" != r2(e4) || !e4) return e4;
            var n2 = e4[Symbol.toPrimitive];
            if (void 0 !== n2) {
              var o2 = n2.call(e4, t4 || "default");
              if ("object" != r2(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == r2(t3) ? t3 : t3 + "";
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Soroban = void 0;
        t2.Soroban = function() {
          return e3 = function e4() {
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e4);
          }, r3 = [{ key: "formatTokenAmount", value: function(e4, t4) {
            if (e4.includes(".")) throw new TypeError("No decimals are allowed");
            var r4 = e4;
            return t4 > 0 && (r4 = t4 > r4.length ? ["0", r4.toString().padStart(t4, "0")].join(".") : [r4.slice(0, -t4), r4.slice(-t4)].join(".")), r4.replace(/(\.\d*?)0+$/, "$1");
          } }, { key: "parseTokenAmount", value: function(e4, t4) {
            var r4, o2 = n(e4.split(".").slice()), i2 = o2[0], a2 = o2[1];
            if (o2.slice(2).length) throw new Error("Invalid decimal value: ".concat(e4));
            return BigInt(i2 + (null !== (r4 = null == a2 ? void 0 : a2.padEnd(t4, "0")) && void 0 !== r4 ? r4 : "0".repeat(t4))).toString();
          } }], (t3 = null) && i(e3.prototype, t3), r3 && i(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          var e3, t3, r3;
        }();
      }, 4063: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Int256 = void 0;
        var o = r2(3740);
        function i(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, a(n2.key), n2);
          }
        }
        function a(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        function u(e3, t3, r3) {
          return t3 = c(t3), function(e4, t4) {
            if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, s() ? Reflect.construct(t3, r3 || [], c(e3).constructor) : t3.apply(e3, r3));
        }
        function s() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (s = function() {
            return !!e3;
          })();
        }
        function c(e3) {
          return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, c(e3);
        }
        function l(e3, t3) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, l(e3, t3);
        }
        (t2.Int256 = function(e3) {
          function t3() {
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            for (var e4 = arguments.length, r4 = new Array(e4), n3 = 0; n3 < e4; n3++) r4[n3] = arguments[n3];
            return u(this, t3, [r4]);
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && l(e4, t4);
          }(t3, e3), r3 = t3, (n2 = [{ key: "unsigned", get: function() {
            return false;
          } }, { key: "size", get: function() {
            return 256;
          } }]) && i(r3.prototype, n2), o2 && i(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(o.LargeInt)).defineIntBoundaries();
      }, 4076: (e2, t2, r2) => {
        "use strict";
        var n;
        r2.d(t2, { j: () => n }), function(e3) {
          var t3 = function(e4) {
            return e4.SUCCESS = "SUCCESS", e4.NOT_FOUND = "NOT_FOUND", e4.FAILED = "FAILED", e4;
          }({});
          function r3(e4) {
            return "transactionData" in e4;
          }
          e3.GetTransactionStatus = t3, e3.isSimulationError = function(e4) {
            return "error" in e4;
          }, e3.isSimulationSuccess = r3, e3.isSimulationRestore = function(e4) {
            return r3(e4) && "restorePreamble" in e4 && !!e4.restorePreamble.transactionData;
          }, e3.isSimulationRaw = function(e4) {
            return !e4._parsed;
          };
        }(n || (n = {}));
      }, 4107: (e2, t2, r2) => {
        var n = r2(6698), o = r2(392), i = r2(2861).Buffer, a = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], u = new Array(64);
        function s() {
          this.init(), this._w = u, o.call(this, 64, 56);
        }
        function c(e3, t3, r3) {
          return r3 ^ e3 & (t3 ^ r3);
        }
        function l(e3, t3, r3) {
          return e3 & t3 | r3 & (e3 | t3);
        }
        function f(e3) {
          return (e3 >>> 2 | e3 << 30) ^ (e3 >>> 13 | e3 << 19) ^ (e3 >>> 22 | e3 << 10);
        }
        function p(e3) {
          return (e3 >>> 6 | e3 << 26) ^ (e3 >>> 11 | e3 << 21) ^ (e3 >>> 25 | e3 << 7);
        }
        function d(e3) {
          return (e3 >>> 7 | e3 << 25) ^ (e3 >>> 18 | e3 << 14) ^ e3 >>> 3;
        }
        n(s, o), s.prototype.init = function() {
          return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
        }, s.prototype._update = function(e3) {
          for (var t3, r3 = this._w, n2 = 0 | this._a, o2 = 0 | this._b, i2 = 0 | this._c, u2 = 0 | this._d, s2 = 0 | this._e, h = 0 | this._f, y = 0 | this._g, m = 0 | this._h, v = 0; v < 16; ++v) r3[v] = e3.readInt32BE(4 * v);
          for (; v < 64; ++v) r3[v] = 0 | (((t3 = r3[v - 2]) >>> 17 | t3 << 15) ^ (t3 >>> 19 | t3 << 13) ^ t3 >>> 10) + r3[v - 7] + d(r3[v - 15]) + r3[v - 16];
          for (var g = 0; g < 64; ++g) {
            var b = m + p(s2) + c(s2, h, y) + a[g] + r3[g] | 0, w = f(n2) + l(n2, o2, i2) | 0;
            m = y, y = h, h = s2, s2 = u2 + b | 0, u2 = i2, i2 = o2, o2 = n2, n2 = b + w | 0;
          }
          this._a = n2 + this._a | 0, this._b = o2 + this._b | 0, this._c = i2 + this._c | 0, this._d = u2 + this._d | 0, this._e = s2 + this._e | 0, this._f = h + this._f | 0, this._g = y + this._g | 0, this._h = m + this._h | 0;
        }, s.prototype._hash = function() {
          var e3 = i.allocUnsafe(32);
          return e3.writeInt32BE(this._a, 0), e3.writeInt32BE(this._b, 4), e3.writeInt32BE(this._c, 8), e3.writeInt32BE(this._d, 12), e3.writeInt32BE(this._e, 16), e3.writeInt32BE(this._f, 20), e3.writeInt32BE(this._g, 24), e3.writeInt32BE(this._h, 28), e3;
        }, e2.exports = s;
      }, 4151: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.best_r = function(e3) {
          var t3, r3, n2 = new o.default(e3), u = [[new o.default(0), new o.default(1)], [new o.default(1), new o.default(0)]], s = 2;
          for (; !n2.gt(a); ) {
            t3 = n2.integerValue(o.default.ROUND_FLOOR), r3 = n2.minus(t3);
            var c = t3.times(u[s - 1][0]).plus(u[s - 2][0]), l = t3.times(u[s - 1][1]).plus(u[s - 2][1]);
            if (c.gt(a) || l.gt(a)) break;
            if (u.push([c, l]), r3.eq(0)) break;
            n2 = new o.default(1).div(r3), s += 1;
          }
          var f = (h = u[u.length - 1], y = 2, function(e4) {
            if (Array.isArray(e4)) return e4;
          }(h) || function(e4, t4) {
            var r4 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != r4) {
              var n3, o2, i2, a2, u2 = [], s2 = true, c2 = false;
              try {
                if (i2 = (r4 = r4.call(e4)).next, 0 === t4) {
                  if (Object(r4) !== r4) return;
                  s2 = false;
                } else for (; !(s2 = (n3 = i2.call(r4)).done) && (u2.push(n3.value), u2.length !== t4); s2 = true) ;
              } catch (e5) {
                c2 = true, o2 = e5;
              } finally {
                try {
                  if (!s2 && null != r4.return && (a2 = r4.return(), Object(a2) !== a2)) return;
                } finally {
                  if (c2) throw o2;
                }
              }
              return u2;
            }
          }(h, y) || function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return i(e4, t4);
              var r4 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r4 && e4.constructor && (r4 = e4.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(e4) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i(e4, t4) : void 0;
            }
          }(h, y) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }()), p = f[0], d = f[1];
          var h, y;
          if (p.isZero() || d.isZero()) throw new Error("Couldn't find approximation");
          return [p.toNumber(), d.toNumber()];
        };
        var n, o = (n = r2(1242)) && n.__esModule ? n : { default: n };
        function i(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        var a = 2147483647;
      }, 4172: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.MemoText = t2.MemoReturn = t2.MemoNone = t2.MemoID = t2.MemoHash = t2.Memo = void 0;
        var o = r2(3740), i = u(r2(1242)), a = u(r2(1918));
        function u(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        function s(e3) {
          return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, s(e3);
        }
        function c(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, l(n2.key), n2);
          }
        }
        function l(e3) {
          var t3 = function(e4, t4) {
            if ("object" != s(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != s(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == s(t3) ? t3 : t3 + "";
        }
        var f = t2.MemoNone = "none", p = t2.MemoID = "id", d = t2.MemoText = "text", h = t2.MemoHash = "hash", y = t2.MemoReturn = "return";
        t2.Memo = function() {
          function e3(t4) {
            var r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            switch (function(e4, t5) {
              if (!(e4 instanceof t5)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), this._type = t4, this._value = r4, this._type) {
              case f:
                break;
              case p:
                e3._validateIdValue(r4);
                break;
              case d:
                e3._validateTextValue(r4);
                break;
              case h:
              case y:
                e3._validateHashValue(r4), "string" == typeof r4 && (this._value = n.from(r4, "hex"));
                break;
              default:
                throw new Error("Invalid memo type");
            }
          }
          return t3 = e3, u2 = [{ key: "_validateIdValue", value: function(e4) {
            var t4, r4 = new Error("Expects a int64 as a string. Got ".concat(e4));
            if ("string" != typeof e4) throw r4;
            try {
              t4 = new i.default(e4);
            } catch (e5) {
              throw r4;
            }
            if (!t4.isFinite()) throw r4;
            if (t4.isNaN()) throw r4;
          } }, { key: "_validateTextValue", value: function(e4) {
            if (!a.default.Memo.armTypeForArm("text").isValid(e4)) throw new Error("Expects string, array or buffer, max 28 bytes");
          } }, { key: "_validateHashValue", value: function(e4) {
            var t4, r4 = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(e4));
            if (null == e4) throw r4;
            if ("string" == typeof e4) {
              if (!/^[0-9A-Fa-f]{64}$/g.test(e4)) throw r4;
              t4 = n.from(e4, "hex");
            } else {
              if (!n.isBuffer(e4)) throw r4;
              t4 = n.from(e4);
            }
            if (!t4.length || 32 !== t4.length) throw r4;
          } }, { key: "none", value: function() {
            return new e3(f);
          } }, { key: "text", value: function(t4) {
            return new e3(d, t4);
          } }, { key: "id", value: function(t4) {
            return new e3(p, t4);
          } }, { key: "hash", value: function(t4) {
            return new e3(h, t4);
          } }, { key: "return", value: function(t4) {
            return new e3(y, t4);
          } }, { key: "fromXDRObject", value: function(t4) {
            switch (t4.arm()) {
              case "id":
                return e3.id(t4.value().toString());
              case "text":
                return e3.text(t4.value());
              case "hash":
                return e3.hash(t4.value());
              case "retHash":
                return e3.return(t4.value());
            }
            if (void 0 === t4.value()) return e3.none();
            throw new Error("Unknown type");
          } }], (r3 = [{ key: "type", get: function() {
            return this._type;
          }, set: function(e4) {
            throw new Error("Memo is immutable");
          } }, { key: "value", get: function() {
            switch (this._type) {
              case f:
                return null;
              case p:
              case d:
                return this._value;
              case h:
              case y:
                return n.from(this._value);
              default:
                throw new Error("Invalid memo type");
            }
          }, set: function(e4) {
            throw new Error("Memo is immutable");
          } }, { key: "toXDRObject", value: function() {
            switch (this._type) {
              case f:
                return a.default.Memo.memoNone();
              case p:
                return a.default.Memo.memoId(o.UnsignedHyper.fromString(this._value));
              case d:
                return a.default.Memo.memoText(this._value);
              case h:
                return a.default.Memo.memoHash(this._value);
              case y:
                return a.default.Memo.memoReturn(this._value);
              default:
                return null;
            }
          } }]) && c(t3.prototype, r3), u2 && c(t3, u2), Object.defineProperty(t3, "prototype", { writable: false }), t3;
          var t3, r3, u2;
        }();
      }, 4193: function(e2, t2, r2) {
        var n, o, i;
        !function(a, u) {
          "use strict";
          e2.exports ? e2.exports = u(r2(9340), r2(1430), r2(4704)) : (o = [r2(9340), r2(1430), r2(4704)], void 0 === (i = "function" == typeof (n = u) ? n.apply(t2, o) : n) || (e2.exports = i));
        }(0, function(e3, t3, r3, n2) {
          "use strict";
          var o2 = n2 && n2.URI;
          function i2(e4, t4) {
            var r4 = arguments.length >= 1;
            if (!(this instanceof i2)) return r4 ? arguments.length >= 2 ? new i2(e4, t4) : new i2(e4) : new i2();
            if (void 0 === e4) {
              if (r4) throw new TypeError("undefined is not a valid argument for URI");
              e4 = "undefined" != typeof location ? location.href + "" : "";
            }
            if (null === e4 && r4) throw new TypeError("null is not a valid argument for URI");
            return this.href(e4), void 0 !== t4 ? this.absoluteTo(t4) : this;
          }
          i2.version = "1.19.11";
          var a = i2.prototype, u = Object.prototype.hasOwnProperty;
          function s(e4) {
            return e4.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          function c(e4) {
            return void 0 === e4 ? "Undefined" : String(Object.prototype.toString.call(e4)).slice(8, -1);
          }
          function l(e4) {
            return "Array" === c(e4);
          }
          function f(e4, t4) {
            var r4, n3, o3 = {};
            if ("RegExp" === c(t4)) o3 = null;
            else if (l(t4)) for (r4 = 0, n3 = t4.length; r4 < n3; r4++) o3[t4[r4]] = true;
            else o3[t4] = true;
            for (r4 = 0, n3 = e4.length; r4 < n3; r4++) {
              (o3 && void 0 !== o3[e4[r4]] || !o3 && t4.test(e4[r4])) && (e4.splice(r4, 1), n3--, r4--);
            }
            return e4;
          }
          function p(e4, t4) {
            var r4, n3;
            if (l(t4)) {
              for (r4 = 0, n3 = t4.length; r4 < n3; r4++) if (!p(e4, t4[r4])) return false;
              return true;
            }
            var o3 = c(t4);
            for (r4 = 0, n3 = e4.length; r4 < n3; r4++) if ("RegExp" === o3) {
              if ("string" == typeof e4[r4] && e4[r4].match(t4)) return true;
            } else if (e4[r4] === t4) return true;
            return false;
          }
          function d(e4, t4) {
            if (!l(e4) || !l(t4)) return false;
            if (e4.length !== t4.length) return false;
            e4.sort(), t4.sort();
            for (var r4 = 0, n3 = e4.length; r4 < n3; r4++) if (e4[r4] !== t4[r4]) return false;
            return true;
          }
          function h(e4) {
            return e4.replace(/^\/+|\/+$/g, "");
          }
          function y(e4) {
            return escape(e4);
          }
          function m(e4) {
            return encodeURIComponent(e4).replace(/[!'()*]/g, y).replace(/\*/g, "%2A");
          }
          i2._parts = function() {
            return { protocol: null, username: null, password: null, hostname: null, urn: null, port: null, path: null, query: null, fragment: null, preventInvalidHostname: i2.preventInvalidHostname, duplicateQueryParameters: i2.duplicateQueryParameters, escapeQuerySpace: i2.escapeQuerySpace };
          }, i2.preventInvalidHostname = false, i2.duplicateQueryParameters = false, i2.escapeQuerySpace = true, i2.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, i2.idn_expression = /[^a-z0-9\._-]/i, i2.punycode_expression = /(xn--)/i, i2.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, i2.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, i2.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?\xab\xbb\u201c\u201d\u2018\u2019]))/gi, i2.findUri = { start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi, end: /[\s\r\n]|$/, trim: /[`!()\[\]{};:'".,<>?\xab\xbb\u201c\u201d\u201e\u2018\u2019]+$/, parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g }, i2.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, i2.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g, i2.defaultPorts = { http: "80", https: "443", ftp: "21", gopher: "70", ws: "80", wss: "443" }, i2.hostProtocols = ["http", "https"], i2.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/, i2.domAttributes = { a: "href", blockquote: "cite", link: "href", base: "href", script: "src", form: "action", img: "src", area: "href", iframe: "src", embed: "src", source: "src", track: "src", input: "src", audio: "src", video: "src" }, i2.getDomAttribute = function(e4) {
            if (e4 && e4.nodeName) {
              var t4 = e4.nodeName.toLowerCase();
              if ("input" !== t4 || "image" === e4.type) return i2.domAttributes[t4];
            }
          }, i2.encode = m, i2.decode = decodeURIComponent, i2.iso8859 = function() {
            i2.encode = escape, i2.decode = unescape;
          }, i2.unicode = function() {
            i2.encode = m, i2.decode = decodeURIComponent;
          }, i2.characters = { pathname: { encode: { expression: /%(24|26|2B|2C|3B|3D|3A|40)/gi, map: { "%24": "$", "%26": "&", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%3A": ":", "%40": "@" } }, decode: { expression: /[\/\?#]/g, map: { "/": "%2F", "?": "%3F", "#": "%23" } } }, reserved: { encode: { expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi, map: { "%3A": ":", "%2F": "/", "%3F": "?", "%23": "#", "%5B": "[", "%5D": "]", "%40": "@", "%21": "!", "%24": "$", "%26": "&", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=" } } }, urnpath: { encode: { expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi, map: { "%21": "!", "%24": "$", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%40": "@" } }, decode: { expression: /[\/\?#:]/g, map: { "/": "%2F", "?": "%3F", "#": "%23", ":": "%3A" } } } }, i2.encodeQuery = function(e4, t4) {
            var r4 = i2.encode(e4 + "");
            return void 0 === t4 && (t4 = i2.escapeQuerySpace), t4 ? r4.replace(/%20/g, "+") : r4;
          }, i2.decodeQuery = function(e4, t4) {
            e4 += "", void 0 === t4 && (t4 = i2.escapeQuerySpace);
            try {
              return i2.decode(t4 ? e4.replace(/\+/g, "%20") : e4);
            } catch (t5) {
              return e4;
            }
          };
          var v, g = { encode: "encode", decode: "decode" }, b = function(e4, t4) {
            return function(r4) {
              try {
                return i2[t4](r4 + "").replace(i2.characters[e4][t4].expression, function(r5) {
                  return i2.characters[e4][t4].map[r5];
                });
              } catch (e5) {
                return r4;
              }
            };
          };
          for (v in g) i2[v + "PathSegment"] = b("pathname", g[v]), i2[v + "UrnPathSegment"] = b("urnpath", g[v]);
          var w = function(e4, t4, r4) {
            return function(n3) {
              var o3;
              o3 = r4 ? function(e5) {
                return i2[t4](i2[r4](e5));
              } : i2[t4];
              for (var a2 = (n3 + "").split(e4), u2 = 0, s2 = a2.length; u2 < s2; u2++) a2[u2] = o3(a2[u2]);
              return a2.join(e4);
            };
          };
          function S(e4) {
            return function(t4, r4) {
              return void 0 === t4 ? this._parts[e4] || "" : (this._parts[e4] = t4 || null, this.build(!r4), this);
            };
          }
          function k(e4, t4) {
            return function(r4, n3) {
              return void 0 === r4 ? this._parts[e4] || "" : (null !== r4 && (r4 += "").charAt(0) === t4 && (r4 = r4.substring(1)), this._parts[e4] = r4, this.build(!n3), this);
            };
          }
          i2.decodePath = w("/", "decodePathSegment"), i2.decodeUrnPath = w(":", "decodeUrnPathSegment"), i2.recodePath = w("/", "encodePathSegment", "decode"), i2.recodeUrnPath = w(":", "encodeUrnPathSegment", "decode"), i2.encodeReserved = b("reserved", "encode"), i2.parse = function(e4, t4) {
            var r4;
            return t4 || (t4 = { preventInvalidHostname: i2.preventInvalidHostname }), (r4 = (e4 = (e4 = e4.replace(i2.leading_whitespace_expression, "")).replace(i2.ascii_tab_whitespace, "")).indexOf("#")) > -1 && (t4.fragment = e4.substring(r4 + 1) || null, e4 = e4.substring(0, r4)), (r4 = e4.indexOf("?")) > -1 && (t4.query = e4.substring(r4 + 1) || null, e4 = e4.substring(0, r4)), "//" === (e4 = (e4 = e4.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://")).replace(/^[/\\]{2,}/i, "//")).substring(0, 2) ? (t4.protocol = null, e4 = e4.substring(2), e4 = i2.parseAuthority(e4, t4)) : (r4 = e4.indexOf(":")) > -1 && (t4.protocol = e4.substring(0, r4) || null, t4.protocol && !t4.protocol.match(i2.protocol_expression) ? t4.protocol = void 0 : "//" === e4.substring(r4 + 1, r4 + 3).replace(/\\/g, "/") ? (e4 = e4.substring(r4 + 3), e4 = i2.parseAuthority(e4, t4)) : (e4 = e4.substring(r4 + 1), t4.urn = true)), t4.path = e4, t4;
          }, i2.parseHost = function(e4, t4) {
            e4 || (e4 = "");
            var r4, n3, o3 = (e4 = e4.replace(/\\/g, "/")).indexOf("/");
            if (-1 === o3 && (o3 = e4.length), "[" === e4.charAt(0)) r4 = e4.indexOf("]"), t4.hostname = e4.substring(1, r4) || null, t4.port = e4.substring(r4 + 2, o3) || null, "/" === t4.port && (t4.port = null);
            else {
              var a2 = e4.indexOf(":"), u2 = e4.indexOf("/"), s2 = e4.indexOf(":", a2 + 1);
              -1 !== s2 && (-1 === u2 || s2 < u2) ? (t4.hostname = e4.substring(0, o3) || null, t4.port = null) : (n3 = e4.substring(0, o3).split(":"), t4.hostname = n3[0] || null, t4.port = n3[1] || null);
            }
            return t4.hostname && "/" !== e4.substring(o3).charAt(0) && (o3++, e4 = "/" + e4), t4.preventInvalidHostname && i2.ensureValidHostname(t4.hostname, t4.protocol), t4.port && i2.ensureValidPort(t4.port), e4.substring(o3) || "/";
          }, i2.parseAuthority = function(e4, t4) {
            return e4 = i2.parseUserinfo(e4, t4), i2.parseHost(e4, t4);
          }, i2.parseUserinfo = function(e4, t4) {
            var r4 = e4;
            -1 !== e4.indexOf("\\") && (e4 = e4.replace(/\\/g, "/"));
            var n3, o3 = e4.indexOf("/"), a2 = e4.lastIndexOf("@", o3 > -1 ? o3 : e4.length - 1);
            return a2 > -1 && (-1 === o3 || a2 < o3) ? (n3 = e4.substring(0, a2).split(":"), t4.username = n3[0] ? i2.decode(n3[0]) : null, n3.shift(), t4.password = n3[0] ? i2.decode(n3.join(":")) : null, e4 = r4.substring(a2 + 1)) : (t4.username = null, t4.password = null), e4;
          }, i2.parseQuery = function(e4, t4) {
            if (!e4) return {};
            if (!(e4 = e4.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""))) return {};
            for (var r4, n3, o3, a2 = {}, s2 = e4.split("&"), c2 = s2.length, l2 = 0; l2 < c2; l2++) r4 = s2[l2].split("="), n3 = i2.decodeQuery(r4.shift(), t4), o3 = r4.length ? i2.decodeQuery(r4.join("="), t4) : null, "__proto__" !== n3 && (u.call(a2, n3) ? ("string" != typeof a2[n3] && null !== a2[n3] || (a2[n3] = [a2[n3]]), a2[n3].push(o3)) : a2[n3] = o3);
            return a2;
          }, i2.build = function(e4) {
            var t4 = "", r4 = false;
            return e4.protocol && (t4 += e4.protocol + ":"), e4.urn || !t4 && !e4.hostname || (t4 += "//", r4 = true), t4 += i2.buildAuthority(e4) || "", "string" == typeof e4.path && ("/" !== e4.path.charAt(0) && r4 && (t4 += "/"), t4 += e4.path), "string" == typeof e4.query && e4.query && (t4 += "?" + e4.query), "string" == typeof e4.fragment && e4.fragment && (t4 += "#" + e4.fragment), t4;
          }, i2.buildHost = function(e4) {
            var t4 = "";
            return e4.hostname ? (i2.ip6_expression.test(e4.hostname) ? t4 += "[" + e4.hostname + "]" : t4 += e4.hostname, e4.port && (t4 += ":" + e4.port), t4) : "";
          }, i2.buildAuthority = function(e4) {
            return i2.buildUserinfo(e4) + i2.buildHost(e4);
          }, i2.buildUserinfo = function(e4) {
            var t4 = "";
            return e4.username && (t4 += i2.encode(e4.username)), e4.password && (t4 += ":" + i2.encode(e4.password)), t4 && (t4 += "@"), t4;
          }, i2.buildQuery = function(e4, t4, r4) {
            var n3, o3, a2, s2, c2 = "";
            for (o3 in e4) if ("__proto__" !== o3 && u.call(e4, o3)) if (l(e4[o3])) for (n3 = {}, a2 = 0, s2 = e4[o3].length; a2 < s2; a2++) void 0 !== e4[o3][a2] && void 0 === n3[e4[o3][a2] + ""] && (c2 += "&" + i2.buildQueryParameter(o3, e4[o3][a2], r4), true !== t4 && (n3[e4[o3][a2] + ""] = true));
            else void 0 !== e4[o3] && (c2 += "&" + i2.buildQueryParameter(o3, e4[o3], r4));
            return c2.substring(1);
          }, i2.buildQueryParameter = function(e4, t4, r4) {
            return i2.encodeQuery(e4, r4) + (null !== t4 ? "=" + i2.encodeQuery(t4, r4) : "");
          }, i2.addQuery = function(e4, t4, r4) {
            if ("object" == typeof t4) for (var n3 in t4) u.call(t4, n3) && i2.addQuery(e4, n3, t4[n3]);
            else {
              if ("string" != typeof t4) throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
              if (void 0 === e4[t4]) return void (e4[t4] = r4);
              "string" == typeof e4[t4] && (e4[t4] = [e4[t4]]), l(r4) || (r4 = [r4]), e4[t4] = (e4[t4] || []).concat(r4);
            }
          }, i2.setQuery = function(e4, t4, r4) {
            if ("object" == typeof t4) for (var n3 in t4) u.call(t4, n3) && i2.setQuery(e4, n3, t4[n3]);
            else {
              if ("string" != typeof t4) throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
              e4[t4] = void 0 === r4 ? null : r4;
            }
          }, i2.removeQuery = function(e4, t4, r4) {
            var n3, o3, a2;
            if (l(t4)) for (n3 = 0, o3 = t4.length; n3 < o3; n3++) e4[t4[n3]] = void 0;
            else if ("RegExp" === c(t4)) for (a2 in e4) t4.test(a2) && (e4[a2] = void 0);
            else if ("object" == typeof t4) for (a2 in t4) u.call(t4, a2) && i2.removeQuery(e4, a2, t4[a2]);
            else {
              if ("string" != typeof t4) throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
              void 0 !== r4 ? "RegExp" === c(r4) ? !l(e4[t4]) && r4.test(e4[t4]) ? e4[t4] = void 0 : e4[t4] = f(e4[t4], r4) : e4[t4] !== String(r4) || l(r4) && 1 !== r4.length ? l(e4[t4]) && (e4[t4] = f(e4[t4], r4)) : e4[t4] = void 0 : e4[t4] = void 0;
            }
          }, i2.hasQuery = function(e4, t4, r4, n3) {
            switch (c(t4)) {
              case "String":
                break;
              case "RegExp":
                for (var o3 in e4) if (u.call(e4, o3) && t4.test(o3) && (void 0 === r4 || i2.hasQuery(e4, o3, r4))) return true;
                return false;
              case "Object":
                for (var a2 in t4) if (u.call(t4, a2) && !i2.hasQuery(e4, a2, t4[a2])) return false;
                return true;
              default:
                throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
            }
            switch (c(r4)) {
              case "Undefined":
                return t4 in e4;
              case "Boolean":
                return r4 === Boolean(l(e4[t4]) ? e4[t4].length : e4[t4]);
              case "Function":
                return !!r4(e4[t4], t4, e4);
              case "Array":
                return !!l(e4[t4]) && (n3 ? p : d)(e4[t4], r4);
              case "RegExp":
                return l(e4[t4]) ? !!n3 && p(e4[t4], r4) : Boolean(e4[t4] && e4[t4].match(r4));
              case "Number":
                r4 = String(r4);
              case "String":
                return l(e4[t4]) ? !!n3 && p(e4[t4], r4) : e4[t4] === r4;
              default:
                throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
            }
          }, i2.joinPaths = function() {
            for (var e4 = [], t4 = [], r4 = 0, n3 = 0; n3 < arguments.length; n3++) {
              var o3 = new i2(arguments[n3]);
              e4.push(o3);
              for (var a2 = o3.segment(), u2 = 0; u2 < a2.length; u2++) "string" == typeof a2[u2] && t4.push(a2[u2]), a2[u2] && r4++;
            }
            if (!t4.length || !r4) return new i2("");
            var s2 = new i2("").segment(t4);
            return "" !== e4[0].path() && "/" !== e4[0].path().slice(0, 1) || s2.path("/" + s2.path()), s2.normalize();
          }, i2.commonPath = function(e4, t4) {
            var r4, n3 = Math.min(e4.length, t4.length);
            for (r4 = 0; r4 < n3; r4++) if (e4.charAt(r4) !== t4.charAt(r4)) {
              r4--;
              break;
            }
            return r4 < 1 ? e4.charAt(0) === t4.charAt(0) && "/" === e4.charAt(0) ? "/" : "" : ("/" === e4.charAt(r4) && "/" === t4.charAt(r4) || (r4 = e4.substring(0, r4).lastIndexOf("/")), e4.substring(0, r4 + 1));
          }, i2.withinString = function(e4, t4, r4) {
            r4 || (r4 = {});
            var n3 = r4.start || i2.findUri.start, o3 = r4.end || i2.findUri.end, a2 = r4.trim || i2.findUri.trim, u2 = r4.parens || i2.findUri.parens, s2 = /[a-z0-9-]=["']?$/i;
            for (n3.lastIndex = 0; ; ) {
              var c2 = n3.exec(e4);
              if (!c2) break;
              var l2 = c2.index;
              if (r4.ignoreHtml) {
                var f2 = e4.slice(Math.max(l2 - 3, 0), l2);
                if (f2 && s2.test(f2)) continue;
              }
              for (var p2 = l2 + e4.slice(l2).search(o3), d2 = e4.slice(l2, p2), h2 = -1; ; ) {
                var y2 = u2.exec(d2);
                if (!y2) break;
                var m2 = y2.index + y2[0].length;
                h2 = Math.max(h2, m2);
              }
              if (!((d2 = h2 > -1 ? d2.slice(0, h2) + d2.slice(h2).replace(a2, "") : d2.replace(a2, "")).length <= c2[0].length || r4.ignore && r4.ignore.test(d2))) {
                var v2 = t4(d2, l2, p2 = l2 + d2.length, e4);
                void 0 !== v2 ? (v2 = String(v2), e4 = e4.slice(0, l2) + v2 + e4.slice(p2), n3.lastIndex = l2 + v2.length) : n3.lastIndex = p2;
              }
            }
            return n3.lastIndex = 0, e4;
          }, i2.ensureValidHostname = function(t4, r4) {
            var n3 = !!t4, o3 = false;
            if (!!r4 && (o3 = p(i2.hostProtocols, r4)), o3 && !n3) throw new TypeError("Hostname cannot be empty, if protocol is " + r4);
            if (t4 && t4.match(i2.invalid_hostname_characters)) {
              if (!e3) throw new TypeError('Hostname "' + t4 + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
              if (e3.toASCII(t4).match(i2.invalid_hostname_characters)) throw new TypeError('Hostname "' + t4 + '" contains characters other than [A-Z0-9.-:_]');
            }
          }, i2.ensureValidPort = function(e4) {
            if (e4) {
              var t4 = Number(e4);
              if (!(/^[0-9]+$/.test(t4) && t4 > 0 && t4 < 65536)) throw new TypeError('Port "' + e4 + '" is not a valid port');
            }
          }, i2.noConflict = function(e4) {
            if (e4) {
              var t4 = { URI: this.noConflict() };
              return n2.URITemplate && "function" == typeof n2.URITemplate.noConflict && (t4.URITemplate = n2.URITemplate.noConflict()), n2.IPv6 && "function" == typeof n2.IPv6.noConflict && (t4.IPv6 = n2.IPv6.noConflict()), n2.SecondLevelDomains && "function" == typeof n2.SecondLevelDomains.noConflict && (t4.SecondLevelDomains = n2.SecondLevelDomains.noConflict()), t4;
            }
            return n2.URI === this && (n2.URI = o2), this;
          }, a.build = function(e4) {
            return true === e4 ? this._deferred_build = true : (void 0 === e4 || this._deferred_build) && (this._string = i2.build(this._parts), this._deferred_build = false), this;
          }, a.clone = function() {
            return new i2(this);
          }, a.valueOf = a.toString = function() {
            return this.build(false)._string;
          }, a.protocol = S("protocol"), a.username = S("username"), a.password = S("password"), a.hostname = S("hostname"), a.port = S("port"), a.query = k("query", "?"), a.fragment = k("fragment", "#"), a.search = function(e4, t4) {
            var r4 = this.query(e4, t4);
            return "string" == typeof r4 && r4.length ? "?" + r4 : r4;
          }, a.hash = function(e4, t4) {
            var r4 = this.fragment(e4, t4);
            return "string" == typeof r4 && r4.length ? "#" + r4 : r4;
          }, a.pathname = function(e4, t4) {
            if (void 0 === e4 || true === e4) {
              var r4 = this._parts.path || (this._parts.hostname ? "/" : "");
              return e4 ? (this._parts.urn ? i2.decodeUrnPath : i2.decodePath)(r4) : r4;
            }
            return this._parts.urn ? this._parts.path = e4 ? i2.recodeUrnPath(e4) : "" : this._parts.path = e4 ? i2.recodePath(e4) : "/", this.build(!t4), this;
          }, a.path = a.pathname, a.href = function(e4, t4) {
            var r4;
            if (void 0 === e4) return this.toString();
            this._string = "", this._parts = i2._parts();
            var n3 = e4 instanceof i2, o3 = "object" == typeof e4 && (e4.hostname || e4.path || e4.pathname);
            e4.nodeName && (e4 = e4[i2.getDomAttribute(e4)] || "", o3 = false);
            if (!n3 && o3 && void 0 !== e4.pathname && (e4 = e4.toString()), "string" == typeof e4 || e4 instanceof String) this._parts = i2.parse(String(e4), this._parts);
            else {
              if (!n3 && !o3) throw new TypeError("invalid input");
              var a2 = n3 ? e4._parts : e4;
              for (r4 in a2) "query" !== r4 && u.call(this._parts, r4) && (this._parts[r4] = a2[r4]);
              a2.query && this.query(a2.query, false);
            }
            return this.build(!t4), this;
          }, a.is = function(e4) {
            var t4 = false, n3 = false, o3 = false, a2 = false, u2 = false, s2 = false, c2 = false, l2 = !this._parts.urn;
            switch (this._parts.hostname && (l2 = false, n3 = i2.ip4_expression.test(this._parts.hostname), o3 = i2.ip6_expression.test(this._parts.hostname), u2 = (a2 = !(t4 = n3 || o3)) && r3 && r3.has(this._parts.hostname), s2 = a2 && i2.idn_expression.test(this._parts.hostname), c2 = a2 && i2.punycode_expression.test(this._parts.hostname)), e4.toLowerCase()) {
              case "relative":
                return l2;
              case "absolute":
                return !l2;
              case "domain":
              case "name":
                return a2;
              case "sld":
                return u2;
              case "ip":
                return t4;
              case "ip4":
              case "ipv4":
              case "inet4":
                return n3;
              case "ip6":
              case "ipv6":
              case "inet6":
                return o3;
              case "idn":
                return s2;
              case "url":
                return !this._parts.urn;
              case "urn":
                return !!this._parts.urn;
              case "punycode":
                return c2;
            }
            return null;
          };
          var E = a.protocol, _ = a.port, T = a.hostname;
          a.protocol = function(e4, t4) {
            if (e4 && !(e4 = e4.replace(/:(\/\/)?$/, "")).match(i2.protocol_expression)) throw new TypeError('Protocol "' + e4 + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
            return E.call(this, e4, t4);
          }, a.scheme = a.protocol, a.port = function(e4, t4) {
            return this._parts.urn ? void 0 === e4 ? "" : this : (void 0 !== e4 && (0 === e4 && (e4 = null), e4 && (":" === (e4 += "").charAt(0) && (e4 = e4.substring(1)), i2.ensureValidPort(e4))), _.call(this, e4, t4));
          }, a.hostname = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 !== e4) {
              var r4 = { preventInvalidHostname: this._parts.preventInvalidHostname };
              if ("/" !== i2.parseHost(e4, r4)) throw new TypeError('Hostname "' + e4 + '" contains characters other than [A-Z0-9.-]');
              e4 = r4.hostname, this._parts.preventInvalidHostname && i2.ensureValidHostname(e4, this._parts.protocol);
            }
            return T.call(this, e4, t4);
          }, a.origin = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4) {
              var r4 = this.protocol();
              return this.authority() ? (r4 ? r4 + "://" : "") + this.authority() : "";
            }
            var n3 = i2(e4);
            return this.protocol(n3.protocol()).authority(n3.authority()).build(!t4), this;
          }, a.host = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4) return this._parts.hostname ? i2.buildHost(this._parts) : "";
            if ("/" !== i2.parseHost(e4, this._parts)) throw new TypeError('Hostname "' + e4 + '" contains characters other than [A-Z0-9.-]');
            return this.build(!t4), this;
          }, a.authority = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4) return this._parts.hostname ? i2.buildAuthority(this._parts) : "";
            if ("/" !== i2.parseAuthority(e4, this._parts)) throw new TypeError('Hostname "' + e4 + '" contains characters other than [A-Z0-9.-]');
            return this.build(!t4), this;
          }, a.userinfo = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4) {
              var r4 = i2.buildUserinfo(this._parts);
              return r4 ? r4.substring(0, r4.length - 1) : r4;
            }
            return "@" !== e4[e4.length - 1] && (e4 += "@"), i2.parseUserinfo(e4, this._parts), this.build(!t4), this;
          }, a.resource = function(e4, t4) {
            var r4;
            return void 0 === e4 ? this.path() + this.search() + this.hash() : (r4 = i2.parse(e4), this._parts.path = r4.path, this._parts.query = r4.query, this._parts.fragment = r4.fragment, this.build(!t4), this);
          }, a.subdomain = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4) {
              if (!this._parts.hostname || this.is("IP")) return "";
              var r4 = this._parts.hostname.length - this.domain().length - 1;
              return this._parts.hostname.substring(0, r4) || "";
            }
            var n3 = this._parts.hostname.length - this.domain().length, o3 = this._parts.hostname.substring(0, n3), a2 = new RegExp("^" + s(o3));
            if (e4 && "." !== e4.charAt(e4.length - 1) && (e4 += "."), -1 !== e4.indexOf(":")) throw new TypeError("Domains cannot contain colons");
            return e4 && i2.ensureValidHostname(e4, this._parts.protocol), this._parts.hostname = this._parts.hostname.replace(a2, e4), this.build(!t4), this;
          }, a.domain = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if ("boolean" == typeof e4 && (t4 = e4, e4 = void 0), void 0 === e4) {
              if (!this._parts.hostname || this.is("IP")) return "";
              var r4 = this._parts.hostname.match(/\./g);
              if (r4 && r4.length < 2) return this._parts.hostname;
              var n3 = this._parts.hostname.length - this.tld(t4).length - 1;
              return n3 = this._parts.hostname.lastIndexOf(".", n3 - 1) + 1, this._parts.hostname.substring(n3) || "";
            }
            if (!e4) throw new TypeError("cannot set domain empty");
            if (-1 !== e4.indexOf(":")) throw new TypeError("Domains cannot contain colons");
            if (i2.ensureValidHostname(e4, this._parts.protocol), !this._parts.hostname || this.is("IP")) this._parts.hostname = e4;
            else {
              var o3 = new RegExp(s(this.domain()) + "$");
              this._parts.hostname = this._parts.hostname.replace(o3, e4);
            }
            return this.build(!t4), this;
          }, a.tld = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if ("boolean" == typeof e4 && (t4 = e4, e4 = void 0), void 0 === e4) {
              if (!this._parts.hostname || this.is("IP")) return "";
              var n3 = this._parts.hostname.lastIndexOf("."), o3 = this._parts.hostname.substring(n3 + 1);
              return true !== t4 && r3 && r3.list[o3.toLowerCase()] && r3.get(this._parts.hostname) || o3;
            }
            var i3;
            if (!e4) throw new TypeError("cannot set TLD empty");
            if (e4.match(/[^a-zA-Z0-9-]/)) {
              if (!r3 || !r3.is(e4)) throw new TypeError('TLD "' + e4 + '" contains characters other than [A-Z0-9]');
              i3 = new RegExp(s(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(i3, e4);
            } else {
              if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host");
              i3 = new RegExp(s(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(i3, e4);
            }
            return this.build(!t4), this;
          }, a.directory = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4 || true === e4) {
              if (!this._parts.path && !this._parts.hostname) return "";
              if ("/" === this._parts.path) return "/";
              var r4 = this._parts.path.length - this.filename().length - 1, n3 = this._parts.path.substring(0, r4) || (this._parts.hostname ? "/" : "");
              return e4 ? i2.decodePath(n3) : n3;
            }
            var o3 = this._parts.path.length - this.filename().length, a2 = this._parts.path.substring(0, o3), u2 = new RegExp("^" + s(a2));
            return this.is("relative") || (e4 || (e4 = "/"), "/" !== e4.charAt(0) && (e4 = "/" + e4)), e4 && "/" !== e4.charAt(e4.length - 1) && (e4 += "/"), e4 = i2.recodePath(e4), this._parts.path = this._parts.path.replace(u2, e4), this.build(!t4), this;
          }, a.filename = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if ("string" != typeof e4) {
              if (!this._parts.path || "/" === this._parts.path) return "";
              var r4 = this._parts.path.lastIndexOf("/"), n3 = this._parts.path.substring(r4 + 1);
              return e4 ? i2.decodePathSegment(n3) : n3;
            }
            var o3 = false;
            "/" === e4.charAt(0) && (e4 = e4.substring(1)), e4.match(/\.?\//) && (o3 = true);
            var a2 = new RegExp(s(this.filename()) + "$");
            return e4 = i2.recodePath(e4), this._parts.path = this._parts.path.replace(a2, e4), o3 ? this.normalizePath(t4) : this.build(!t4), this;
          }, a.suffix = function(e4, t4) {
            if (this._parts.urn) return void 0 === e4 ? "" : this;
            if (void 0 === e4 || true === e4) {
              if (!this._parts.path || "/" === this._parts.path) return "";
              var r4, n3, o3 = this.filename(), a2 = o3.lastIndexOf(".");
              return -1 === a2 ? "" : (r4 = o3.substring(a2 + 1), n3 = /^[a-z0-9%]+$/i.test(r4) ? r4 : "", e4 ? i2.decodePathSegment(n3) : n3);
            }
            "." === e4.charAt(0) && (e4 = e4.substring(1));
            var u2, c2 = this.suffix();
            if (c2) u2 = e4 ? new RegExp(s(c2) + "$") : new RegExp(s("." + c2) + "$");
            else {
              if (!e4) return this;
              this._parts.path += "." + i2.recodePath(e4);
            }
            return u2 && (e4 = i2.recodePath(e4), this._parts.path = this._parts.path.replace(u2, e4)), this.build(!t4), this;
          }, a.segment = function(e4, t4, r4) {
            var n3 = this._parts.urn ? ":" : "/", o3 = this.path(), i3 = "/" === o3.substring(0, 1), a2 = o3.split(n3);
            if (void 0 !== e4 && "number" != typeof e4 && (r4 = t4, t4 = e4, e4 = void 0), void 0 !== e4 && "number" != typeof e4) throw new Error('Bad segment "' + e4 + '", must be 0-based integer');
            if (i3 && a2.shift(), e4 < 0 && (e4 = Math.max(a2.length + e4, 0)), void 0 === t4) return void 0 === e4 ? a2 : a2[e4];
            if (null === e4 || void 0 === a2[e4]) if (l(t4)) {
              a2 = [];
              for (var u2 = 0, s2 = t4.length; u2 < s2; u2++) (t4[u2].length || a2.length && a2[a2.length - 1].length) && (a2.length && !a2[a2.length - 1].length && a2.pop(), a2.push(h(t4[u2])));
            } else (t4 || "string" == typeof t4) && (t4 = h(t4), "" === a2[a2.length - 1] ? a2[a2.length - 1] = t4 : a2.push(t4));
            else t4 ? a2[e4] = h(t4) : a2.splice(e4, 1);
            return i3 && a2.unshift(""), this.path(a2.join(n3), r4);
          }, a.segmentCoded = function(e4, t4, r4) {
            var n3, o3, a2;
            if ("number" != typeof e4 && (r4 = t4, t4 = e4, e4 = void 0), void 0 === t4) {
              if (l(n3 = this.segment(e4, t4, r4))) for (o3 = 0, a2 = n3.length; o3 < a2; o3++) n3[o3] = i2.decode(n3[o3]);
              else n3 = void 0 !== n3 ? i2.decode(n3) : void 0;
              return n3;
            }
            if (l(t4)) for (o3 = 0, a2 = t4.length; o3 < a2; o3++) t4[o3] = i2.encode(t4[o3]);
            else t4 = "string" == typeof t4 || t4 instanceof String ? i2.encode(t4) : t4;
            return this.segment(e4, t4, r4);
          };
          var O = a.query;
          return a.query = function(e4, t4) {
            if (true === e4) return i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if ("function" == typeof e4) {
              var r4 = i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace), n3 = e4.call(this, r4);
              return this._parts.query = i2.buildQuery(n3 || r4, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!t4), this;
            }
            return void 0 !== e4 && "string" != typeof e4 ? (this._parts.query = i2.buildQuery(e4, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!t4), this) : O.call(this, e4, t4);
          }, a.setQuery = function(e4, t4, r4) {
            var n3 = i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if ("string" == typeof e4 || e4 instanceof String) n3[e4] = void 0 !== t4 ? t4 : null;
            else {
              if ("object" != typeof e4) throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
              for (var o3 in e4) u.call(e4, o3) && (n3[o3] = e4[o3]);
            }
            return this._parts.query = i2.buildQuery(n3, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), "string" != typeof e4 && (r4 = t4), this.build(!r4), this;
          }, a.addQuery = function(e4, t4, r4) {
            var n3 = i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return i2.addQuery(n3, e4, void 0 === t4 ? null : t4), this._parts.query = i2.buildQuery(n3, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), "string" != typeof e4 && (r4 = t4), this.build(!r4), this;
          }, a.removeQuery = function(e4, t4, r4) {
            var n3 = i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return i2.removeQuery(n3, e4, t4), this._parts.query = i2.buildQuery(n3, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), "string" != typeof e4 && (r4 = t4), this.build(!r4), this;
          }, a.hasQuery = function(e4, t4, r4) {
            var n3 = i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return i2.hasQuery(n3, e4, t4, r4);
          }, a.setSearch = a.setQuery, a.addSearch = a.addQuery, a.removeSearch = a.removeQuery, a.hasSearch = a.hasQuery, a.normalize = function() {
            return this._parts.urn ? this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build() : this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
          }, a.normalizeProtocol = function(e4) {
            return "string" == typeof this._parts.protocol && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!e4)), this;
          }, a.normalizeHostname = function(r4) {
            return this._parts.hostname && (this.is("IDN") && e3 ? this._parts.hostname = e3.toASCII(this._parts.hostname) : this.is("IPv6") && t3 && (this._parts.hostname = t3.best(this._parts.hostname)), this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!r4)), this;
          }, a.normalizePort = function(e4) {
            return "string" == typeof this._parts.protocol && this._parts.port === i2.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!e4)), this;
          }, a.normalizePath = function(e4) {
            var t4, r4 = this._parts.path;
            if (!r4) return this;
            if (this._parts.urn) return this._parts.path = i2.recodeUrnPath(this._parts.path), this.build(!e4), this;
            if ("/" === this._parts.path) return this;
            var n3, o3, a2 = "";
            for ("/" !== (r4 = i2.recodePath(r4)).charAt(0) && (t4 = true, r4 = "/" + r4), "/.." !== r4.slice(-3) && "/." !== r4.slice(-2) || (r4 += "/"), r4 = r4.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), t4 && (a2 = r4.substring(1).match(/^(\.\.\/)+/) || "") && (a2 = a2[0]); -1 !== (n3 = r4.search(/\/\.\.(\/|$)/)); ) 0 !== n3 ? (-1 === (o3 = r4.substring(0, n3).lastIndexOf("/")) && (o3 = n3), r4 = r4.substring(0, o3) + r4.substring(n3 + 3)) : r4 = r4.substring(3);
            return t4 && this.is("relative") && (r4 = a2 + r4.substring(1)), this._parts.path = r4, this.build(!e4), this;
          }, a.normalizePathname = a.normalizePath, a.normalizeQuery = function(e4) {
            return "string" == typeof this._parts.query && (this._parts.query.length ? this.query(i2.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, this.build(!e4)), this;
          }, a.normalizeFragment = function(e4) {
            return this._parts.fragment || (this._parts.fragment = null, this.build(!e4)), this;
          }, a.normalizeSearch = a.normalizeQuery, a.normalizeHash = a.normalizeFragment, a.iso8859 = function() {
            var e4 = i2.encode, t4 = i2.decode;
            i2.encode = escape, i2.decode = decodeURIComponent;
            try {
              this.normalize();
            } finally {
              i2.encode = e4, i2.decode = t4;
            }
            return this;
          }, a.unicode = function() {
            var e4 = i2.encode, t4 = i2.decode;
            i2.encode = m, i2.decode = unescape;
            try {
              this.normalize();
            } finally {
              i2.encode = e4, i2.decode = t4;
            }
            return this;
          }, a.readable = function() {
            var t4 = this.clone();
            t4.username("").password("").normalize();
            var r4 = "";
            if (t4._parts.protocol && (r4 += t4._parts.protocol + "://"), t4._parts.hostname && (t4.is("punycode") && e3 ? (r4 += e3.toUnicode(t4._parts.hostname), t4._parts.port && (r4 += ":" + t4._parts.port)) : r4 += t4.host()), t4._parts.hostname && t4._parts.path && "/" !== t4._parts.path.charAt(0) && (r4 += "/"), r4 += t4.path(true), t4._parts.query) {
              for (var n3 = "", o3 = 0, a2 = t4._parts.query.split("&"), u2 = a2.length; o3 < u2; o3++) {
                var s2 = (a2[o3] || "").split("=");
                n3 += "&" + i2.decodeQuery(s2[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), void 0 !== s2[1] && (n3 += "=" + i2.decodeQuery(s2[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"));
              }
              r4 += "?" + n3.substring(1);
            }
            return r4 += i2.decodeQuery(t4.hash(), true);
          }, a.absoluteTo = function(e4) {
            var t4, r4, n3, o3 = this.clone(), a2 = ["protocol", "username", "password", "hostname", "port"];
            if (this._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
            if (e4 instanceof i2 || (e4 = new i2(e4)), o3._parts.protocol) return o3;
            if (o3._parts.protocol = e4._parts.protocol, this._parts.hostname) return o3;
            for (r4 = 0; n3 = a2[r4]; r4++) o3._parts[n3] = e4._parts[n3];
            return o3._parts.path ? (".." === o3._parts.path.substring(-2) && (o3._parts.path += "/"), "/" !== o3.path().charAt(0) && (t4 = (t4 = e4.directory()) || (0 === e4.path().indexOf("/") ? "/" : ""), o3._parts.path = (t4 ? t4 + "/" : "") + o3._parts.path, o3.normalizePath())) : (o3._parts.path = e4._parts.path, o3._parts.query || (o3._parts.query = e4._parts.query)), o3.build(), o3;
          }, a.relativeTo = function(e4) {
            var t4, r4, n3, o3, a2, u2 = this.clone().normalize();
            if (u2._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
            if (e4 = new i2(e4).normalize(), t4 = u2._parts, r4 = e4._parts, o3 = u2.path(), a2 = e4.path(), "/" !== o3.charAt(0)) throw new Error("URI is already relative");
            if ("/" !== a2.charAt(0)) throw new Error("Cannot calculate a URI relative to another relative URI");
            if (t4.protocol === r4.protocol && (t4.protocol = null), t4.username !== r4.username || t4.password !== r4.password) return u2.build();
            if (null !== t4.protocol || null !== t4.username || null !== t4.password) return u2.build();
            if (t4.hostname !== r4.hostname || t4.port !== r4.port) return u2.build();
            if (t4.hostname = null, t4.port = null, o3 === a2) return t4.path = "", u2.build();
            if (!(n3 = i2.commonPath(o3, a2))) return u2.build();
            var s2 = r4.path.substring(n3.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
            return t4.path = s2 + t4.path.substring(n3.length) || "./", u2.build();
          }, a.equals = function(e4) {
            var t4, r4, n3, o3, a2, s2 = this.clone(), c2 = new i2(e4), f2 = {};
            if (s2.normalize(), c2.normalize(), s2.toString() === c2.toString()) return true;
            if (n3 = s2.query(), o3 = c2.query(), s2.query(""), c2.query(""), s2.toString() !== c2.toString()) return false;
            if (n3.length !== o3.length) return false;
            for (a2 in t4 = i2.parseQuery(n3, this._parts.escapeQuerySpace), r4 = i2.parseQuery(o3, this._parts.escapeQuerySpace), t4) if (u.call(t4, a2)) {
              if (l(t4[a2])) {
                if (!d(t4[a2], r4[a2])) return false;
              } else if (t4[a2] !== r4[a2]) return false;
              f2[a2] = true;
            }
            for (a2 in r4) if (u.call(r4, a2) && !f2[a2]) return false;
            return true;
          }, a.preventInvalidHostname = function(e4) {
            return this._parts.preventInvalidHostname = !!e4, this;
          }, a.duplicateQueryParameters = function(e4) {
            return this._parts.duplicateQueryParameters = !!e4, this;
          }, a.escapeQuerySpace = function(e4) {
            return this._parts.escapeQuerySpace = !!e4, this;
          }, i2;
        });
      }, 4295: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.accountMerge = function(e3) {
          var t3 = {};
          try {
            t3.body = o.default.OperationBody.accountMerge((0, i.decodeAddressToMuxedAccount)(e3.destination));
          } catch (e4) {
            throw new Error("destination is invalid");
          }
          return this.setSourceAccount(t3, e3), new o.default.Operation(t3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6160);
      }, 4356: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { AccountRequiresMemoError: () => n.Cu, BadRequestError: () => n.v7, BadResponseError: () => n.nS, Config: () => o.T, Federation: () => u, Friendbot: () => c, Horizon: () => l, NetworkError: () => n.Dr, NotFoundError: () => n.m_, StellarToml: () => a, Utils: () => i.A, WebAuth: () => s, contract: () => p, default: () => y, rpc: () => f });
        var n = r2(5976), o = r2(8732), i = r2(3121), a = r2(3898), u = r2(7600), s = r2(5479), c = r2(8242), l = r2(8733), f = r2(3496), p = r2(6299), d = r2(356), h = {};
        for (const e3 in d) ["default", "Config", "Utils", "StellarToml", "Federation", "WebAuth", "Friendbot", "Horizon", "rpc", "contract", "AccountRequiresMemoError", "BadRequestError", "BadResponseError", "NetworkError", "NotFoundError"].indexOf(e3) < 0 && (h[e3] = () => d[e3]);
        r2.d(t2, h);
        const y = (e2 = r2.hmd(e2)).exports;
        void 0 === r2.g.__USE_AXIOS__ && (r2.g.__USE_AXIOS__ = true), void 0 === r2.g.__USE_EVENTSOURCE__ && (r2.g.__USE_EVENTSOURCE__ = false);
      }, 4403: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createCustomContract = function(e3) {
          var t3, r3 = n.from(e3.salt || a.Keypair.random().xdrPublicKey().value());
          if (!e3.wasmHash || 32 !== e3.wasmHash.length) throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(e3.wasmHash));
          if (32 !== r3.length) throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(e3.wasmHash));
          return this.invokeHostFunction({ source: e3.source, auth: e3.auth, func: i.default.HostFunction.hostFunctionTypeCreateContractV2(new i.default.CreateContractArgsV2({ executable: i.default.ContractExecutable.contractExecutableWasm(n.from(e3.wasmHash)), contractIdPreimage: i.default.ContractIdPreimage.contractIdPreimageFromAddress(new i.default.ContractIdPreimageFromAddress({ address: e3.address.toScAddress(), salt: r3 })), constructorArgs: null !== (t3 = e3.constructorArgs) && void 0 !== t3 ? t3 : [] })) });
        }, t2.createStellarAssetContract = function(e3) {
          var t3 = e3.asset;
          if ("string" == typeof t3) {
            var r3 = t3.split(":"), n2 = (l = 2, function(e4) {
              if (Array.isArray(e4)) return e4;
            }(u2 = r3) || function(e4, t4) {
              var r4 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
              if (null != r4) {
                var n3, o3, i2, a3, u3 = [], s2 = true, c2 = false;
                try {
                  if (i2 = (r4 = r4.call(e4)).next, 0 === t4) {
                    if (Object(r4) !== r4) return;
                    s2 = false;
                  } else for (; !(s2 = (n3 = i2.call(r4)).done) && (u3.push(n3.value), u3.length !== t4); s2 = true) ;
                } catch (e5) {
                  c2 = true, o3 = e5;
                } finally {
                  try {
                    if (!s2 && null != r4.return && (a3 = r4.return(), Object(a3) !== a3)) return;
                  } finally {
                    if (c2) throw o3;
                  }
                }
                return u3;
              }
            }(u2, l) || function(e4, t4) {
              if (e4) {
                if ("string" == typeof e4) return c(e4, t4);
                var r4 = {}.toString.call(e4).slice(8, -1);
                return "Object" === r4 && e4.constructor && (r4 = e4.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(e4) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? c(e4, t4) : void 0;
              }
            }(u2, l) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }()), o2 = n2[0], a2 = n2[1];
            t3 = new s.Asset(o2, a2);
          }
          var u2, l;
          if (!(t3 instanceof s.Asset)) throw new TypeError("expected Asset in 'opts.asset', got ".concat(t3));
          return this.invokeHostFunction({ source: e3.source, auth: e3.auth, func: i.default.HostFunction.hostFunctionTypeCreateContract(new i.default.CreateContractArgs({ executable: i.default.ContractExecutable.contractExecutableStellarAsset(), contractIdPreimage: i.default.ContractIdPreimage.contractIdPreimageFromAsset(t3.toXDRObject()) })) });
        }, t2.invokeContractFunction = function(e3) {
          var t3 = new u.Address(e3.contract);
          if ("contract" !== t3._type) throw new TypeError("expected contract strkey instance, got ".concat(t3));
          return this.invokeHostFunction({ source: e3.source, auth: e3.auth, func: i.default.HostFunction.hostFunctionTypeInvokeContract(new i.default.InvokeContractArgs({ contractAddress: t3.toScAddress(), functionName: e3.function, args: e3.args })) });
        }, t2.invokeHostFunction = function(e3) {
          if (!e3.func) throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(e3), ")"));
          var t3 = new i.default.InvokeHostFunctionOp({ hostFunction: e3.func, auth: e3.auth || [] }), r3 = { body: i.default.OperationBody.invokeHostFunction(t3) };
          return this.setSourceAccount(r3, e3), new i.default.Operation(r3);
        }, t2.uploadContractWasm = function(e3) {
          return this.invokeHostFunction({ source: e3.source, auth: e3.auth, func: i.default.HostFunction.hostFunctionTypeUploadContractWasm(n.from(e3.wasm)) });
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(6691), u = r2(1180), s = r2(1764);
        function c(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
      }, 4704: function(e2, t2, r2) {
        var n, o;
        !function(i, a) {
          "use strict";
          e2.exports ? e2.exports = a() : void 0 === (o = "function" == typeof (n = a) ? n.call(t2, r2, t2, e2) : n) || (e2.exports = o);
        }(0, function(e3) {
          "use strict";
          var t3 = e3 && e3.SecondLevelDomains, r3 = { list: { ac: " com gov mil net org ", ae: " ac co gov mil name net org pro sch ", af: " com edu gov net org ", al: " com edu gov mil net org ", ao: " co ed gv it og pb ", ar: " com edu gob gov int mil net org tur ", at: " ac co gv or ", au: " asn com csiro edu gov id net org ", ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ", bb: " biz co com edu gov info net org store tv ", bh: " biz cc com edu gov info net org ", bn: " com edu gov net org ", bo: " com edu gob gov int mil net org tv ", br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ", bs: " com edu gov net org ", bz: " du et om ov rg ", ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ", ck: " biz co edu gen gov info net org ", cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ", co: " com edu gov mil net nom org ", cr: " ac c co ed fi go or sa ", cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ", do: " art com edu gob gov mil net org sld web ", dz: " art asso com edu gov net org pol ", ec: " com edu fin gov info med mil net org pro ", eg: " com edu eun gov mil name net org sci ", er: " com edu gov ind mil net org rochest w ", es: " com edu gob nom org ", et: " biz com edu gov info name net org ", fj: " ac biz com info mil name net org pro ", fk: " ac co gov net nom org ", fr: " asso com f gouv nom prd presse tm ", gg: " co net org ", gh: " com edu gov mil org ", gn: " ac com gov net org ", gr: " com edu gov mil net org ", gt: " com edu gob ind mil net org ", gu: " com edu gov net org ", hk: " com edu gov idv net org ", hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ", id: " ac co go mil net or sch web ", il: " ac co gov idf k12 muni net org ", in: " ac co edu ernet firm gen gov i ind mil net nic org res ", iq: " com edu gov i mil net org ", ir: " ac co dnssec gov i id net org sch ", it: " edu gov ", je: " co net org ", jo: " com edu gov mil name net org sch ", jp: " ac ad co ed go gr lg ne or ", ke: " ac co go info me mobi ne or sc ", kh: " com edu gov mil net org per ", ki: " biz com de edu gov info mob net org tel ", km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ", kn: " edu gov net org ", kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ", kw: " com edu gov net org ", ky: " com edu gov net org ", kz: " com edu gov mil net org ", lb: " com edu gov net org ", lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ", lr: " com edu gov net org ", lv: " asn com conf edu gov id mil net org ", ly: " com edu gov id med net org plc sch ", ma: " ac co gov m net org press ", mc: " asso tm ", me: " ac co edu gov its net org priv ", mg: " com edu gov mil nom org prd tm ", mk: " com edu gov inf name net org pro ", ml: " com edu gov net org presse ", mn: " edu gov org ", mo: " com edu gov net org ", mt: " com edu gov net org ", mv: " aero biz com coop edu gov info int mil museum name net org pro ", mw: " ac co com coop edu gov int museum net org ", mx: " com edu gob net org ", my: " com edu gov mil name net org sch ", nf: " arts com firm info net other per rec store web ", ng: " biz com edu gov mil mobi name net org sch ", ni: " ac co com edu gob mil net nom org ", np: " com edu gov mil net org ", nr: " biz com edu gov info net org ", om: " ac biz co com edu gov med mil museum net org pro sch ", pe: " com edu gob mil net nom org sld ", ph: " com edu gov i mil net ngo org ", pk: " biz com edu fam gob gok gon gop gos gov net org web ", pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ", pr: " ac biz com edu est gov info isla name net org pro prof ", ps: " com edu gov net org plo sec ", pw: " belau co ed go ne or ", ro: " arts com firm info nom nt org rec store tm www ", rs: " ac co edu gov in org ", sb: " com edu gov net org ", sc: " com edu gov net org ", sh: " co com edu gov net nom org ", sl: " com edu gov net org ", st: " co com consulado edu embaixada gov mil net org principe saotome store ", sv: " com edu gob org red ", sz: " ac co org ", tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ", tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ", tw: " club com ebiz edu game gov idv mil net org ", mu: " ac co com gov net or org ", mz: " ac co edu gov org ", na: " co com ", nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ", pa: " abo ac com edu gob ing med net nom org sld ", pt: " com edu gov int net nome org publ ", py: " com edu gov mil net org ", qa: " com edu gov mil net org ", re: " asso com nom ", ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ", rw: " ac co com edu gouv gov int mil net ", sa: " com edu gov med net org pub sch ", sd: " com edu gov info med net org tv ", se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ", sg: " com edu gov idn net org per ", sn: " art com edu gouv org perso univ ", sy: " com edu gov mil net news org ", th: " ac co go in mi net or ", tj: " ac biz co com edu go gov info int mil name net nic org test web ", tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ", tz: " ac co go ne or ", ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ", ug: " ac co go ne or org sc ", uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ", us: " dni fed isa kids nsn ", uy: " com edu gub mil net org ", ve: " co com edu gob info mil net org web ", vi: " co com k12 net org ", vn: " ac biz com edu gov health info int name net org pro ", ye: " co com gov ltd me net org plc ", yu: " ac co edu gov org ", za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ", zm: " ac co com edu gov net org sch ", com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ", net: "gb jp se uk ", org: "ae", de: "com " }, has: function(e4) {
            var t4 = e4.lastIndexOf(".");
            if (t4 <= 0 || t4 >= e4.length - 1) return false;
            var n2 = e4.lastIndexOf(".", t4 - 1);
            if (n2 <= 0 || n2 >= t4 - 1) return false;
            var o2 = r3.list[e4.slice(t4 + 1)];
            return !!o2 && o2.indexOf(" " + e4.slice(n2 + 1, t4) + " ") >= 0;
          }, is: function(e4) {
            var t4 = e4.lastIndexOf(".");
            if (t4 <= 0 || t4 >= e4.length - 1) return false;
            if (e4.lastIndexOf(".", t4 - 1) >= 0) return false;
            var n2 = r3.list[e4.slice(t4 + 1)];
            return !!n2 && n2.indexOf(" " + e4.slice(0, t4) + " ") >= 0;
          }, get: function(e4) {
            var t4 = e4.lastIndexOf(".");
            if (t4 <= 0 || t4 >= e4.length - 1) return null;
            var n2 = e4.lastIndexOf(".", t4 - 1);
            if (n2 <= 0 || n2 >= t4 - 1) return null;
            var o2 = r3.list[e4.slice(t4 + 1)];
            return o2 ? o2.indexOf(" " + e4.slice(n2 + 1, t4) + " ") < 0 ? null : e4.slice(n2 + 1) : null;
          }, noConflict: function() {
            return e3.SecondLevelDomains === this && (e3.SecondLevelDomains = t3), this;
          } };
          return r3;
        });
      }, 4737: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.liquidityPoolWithdraw = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = {};
          if (!e3.liquidityPoolId) throw new TypeError("liquidityPoolId argument is required");
          if (t3.liquidityPoolId = o.default.PoolId.fromXDR(e3.liquidityPoolId, "hex"), !this.isValidAmount(e3.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (t3.amount = this._toXDRAmount(e3.amount), !this.isValidAmount(e3.minAmountA, true)) throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
          if (t3.minAmountA = this._toXDRAmount(e3.minAmountA), !this.isValidAmount(e3.minAmountB, true)) throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
          t3.minAmountB = this._toXDRAmount(e3.minAmountB);
          var r3 = new o.default.LiquidityPoolWithdrawOp(t3), n2 = { body: o.default.OperationBody.liquidityPoolWithdraw(r3) };
          return this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 4831: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createClaimableBalance = function(e3) {
          if (!(e3.asset instanceof i.Asset)) throw new Error("must provide an asset for create claimable balance operation");
          if (!this.isValidAmount(e3.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (!Array.isArray(e3.claimants) || 0 === e3.claimants.length) throw new Error("must provide at least one claimant");
          var t3 = {};
          t3.asset = e3.asset.toXDRObject(), t3.amount = this._toXDRAmount(e3.amount), t3.claimants = Object.values(e3.claimants).map(function(e4) {
            return e4.toXDRObject();
          });
          var r3 = new o.default.CreateClaimableBalanceOp(t3), n2 = {};
          return n2.body = o.default.OperationBody.createClaimableBalance(r3), this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(1764);
      }, 4842: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SorobanDataBuilder = void 0;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
        function i(e3) {
          return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, i(e3);
        }
        function a(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, u(n2.key), n2);
          }
        }
        function u(e3) {
          var t3 = function(e4, t4) {
            if ("object" != i(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != i(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == i(t3) ? t3 : t3 + "";
        }
        t2.SorobanDataBuilder = function() {
          return function(e3, t3, r3) {
            return t3 && a(e3.prototype, t3), r3 && a(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3) {
            var r3;
            !function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), function(e4, t4, r4) {
              (t4 = u(t4)) in e4 ? Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }) : e4[t4] = r4;
            }(this, "_data", void 0), r3 = t3 ? "string" == typeof t3 || ArrayBuffer.isView(t3) ? e3.fromXDR(t3) : e3.fromXDR(t3.toXDR()) : new o.default.SorobanTransactionData({ resources: new o.default.SorobanResources({ footprint: new o.default.LedgerFootprint({ readOnly: [], readWrite: [] }), instructions: 0, readBytes: 0, writeBytes: 0 }), ext: new o.default.ExtensionPoint(0), resourceFee: new o.default.Int64(0) }), this._data = r3;
          }, [{ key: "setResourceFee", value: function(e3) {
            return this._data.resourceFee(new o.default.Int64(e3)), this;
          } }, { key: "setResources", value: function(e3, t3, r3) {
            return this._data.resources().instructions(e3), this._data.resources().readBytes(t3), this._data.resources().writeBytes(r3), this;
          } }, { key: "appendFootprint", value: function(e3, t3) {
            return this.setFootprint(this.getReadOnly().concat(e3), this.getReadWrite().concat(t3));
          } }, { key: "setFootprint", value: function(e3, t3) {
            return null !== e3 && this.setReadOnly(e3), null !== t3 && this.setReadWrite(t3), this;
          } }, { key: "setReadOnly", value: function(e3) {
            return this._data.resources().footprint().readOnly(null != e3 ? e3 : []), this;
          } }, { key: "setReadWrite", value: function(e3) {
            return this._data.resources().footprint().readWrite(null != e3 ? e3 : []), this;
          } }, { key: "build", value: function() {
            return o.default.SorobanTransactionData.fromXDR(this._data.toXDR());
          } }, { key: "getReadOnly", value: function() {
            return this.getFootprint().readOnly();
          } }, { key: "getReadWrite", value: function() {
            return this.getFootprint().readWrite();
          } }, { key: "getFootprint", value: function() {
            return this._data.resources().footprint();
          } }], [{ key: "fromXDR", value: function(e3) {
            return o.default.SorobanTransactionData.fromXDR(e3, "string" == typeof e3 ? "base64" : "raw");
          } }]);
        }();
      }, 4940: (e2, t2, r2) => {
        !function(e3) {
          "use strict";
          var t3 = function(e4) {
            var t4, r3 = new Float64Array(16);
            if (e4) for (t4 = 0; t4 < e4.length; t4++) r3[t4] = e4[t4];
            return r3;
          }, n = function() {
            throw new Error("no PRNG");
          }, o = new Uint8Array(16), i = new Uint8Array(32);
          i[0] = 9;
          var a = t3(), u = t3([1]), s = t3([56129, 1]), c = t3([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), l = t3([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), f = t3([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), p = t3([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), d = t3([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
          function h(e4, t4, r3, n2) {
            e4[t4] = r3 >> 24 & 255, e4[t4 + 1] = r3 >> 16 & 255, e4[t4 + 2] = r3 >> 8 & 255, e4[t4 + 3] = 255 & r3, e4[t4 + 4] = n2 >> 24 & 255, e4[t4 + 5] = n2 >> 16 & 255, e4[t4 + 6] = n2 >> 8 & 255, e4[t4 + 7] = 255 & n2;
          }
          function y(e4, t4, r3, n2, o2) {
            var i2, a2 = 0;
            for (i2 = 0; i2 < o2; i2++) a2 |= e4[t4 + i2] ^ r3[n2 + i2];
            return (1 & a2 - 1 >>> 8) - 1;
          }
          function m(e4, t4, r3, n2) {
            return y(e4, t4, r3, n2, 16);
          }
          function v(e4, t4, r3, n2) {
            return y(e4, t4, r3, n2, 32);
          }
          function g(e4, t4, r3, n2) {
            !function(e5, t5, r4, n3) {
              for (var o2, i2 = 255 & n3[0] | (255 & n3[1]) << 8 | (255 & n3[2]) << 16 | (255 & n3[3]) << 24, a2 = 255 & r4[0] | (255 & r4[1]) << 8 | (255 & r4[2]) << 16 | (255 & r4[3]) << 24, u2 = 255 & r4[4] | (255 & r4[5]) << 8 | (255 & r4[6]) << 16 | (255 & r4[7]) << 24, s2 = 255 & r4[8] | (255 & r4[9]) << 8 | (255 & r4[10]) << 16 | (255 & r4[11]) << 24, c2 = 255 & r4[12] | (255 & r4[13]) << 8 | (255 & r4[14]) << 16 | (255 & r4[15]) << 24, l2 = 255 & n3[4] | (255 & n3[5]) << 8 | (255 & n3[6]) << 16 | (255 & n3[7]) << 24, f2 = 255 & t5[0] | (255 & t5[1]) << 8 | (255 & t5[2]) << 16 | (255 & t5[3]) << 24, p2 = 255 & t5[4] | (255 & t5[5]) << 8 | (255 & t5[6]) << 16 | (255 & t5[7]) << 24, d2 = 255 & t5[8] | (255 & t5[9]) << 8 | (255 & t5[10]) << 16 | (255 & t5[11]) << 24, h2 = 255 & t5[12] | (255 & t5[13]) << 8 | (255 & t5[14]) << 16 | (255 & t5[15]) << 24, y2 = 255 & n3[8] | (255 & n3[9]) << 8 | (255 & n3[10]) << 16 | (255 & n3[11]) << 24, m2 = 255 & r4[16] | (255 & r4[17]) << 8 | (255 & r4[18]) << 16 | (255 & r4[19]) << 24, v2 = 255 & r4[20] | (255 & r4[21]) << 8 | (255 & r4[22]) << 16 | (255 & r4[23]) << 24, g2 = 255 & r4[24] | (255 & r4[25]) << 8 | (255 & r4[26]) << 16 | (255 & r4[27]) << 24, b2 = 255 & r4[28] | (255 & r4[29]) << 8 | (255 & r4[30]) << 16 | (255 & r4[31]) << 24, w2 = 255 & n3[12] | (255 & n3[13]) << 8 | (255 & n3[14]) << 16 | (255 & n3[15]) << 24, S2 = i2, k2 = a2, E2 = u2, _2 = s2, T2 = c2, O2 = l2, x2 = f2, A2 = p2, P2 = d2, I2 = h2, R2 = y2, C2 = m2, j2 = v2, B2 = g2, L2 = b2, N2 = w2, U2 = 0; U2 < 20; U2 += 2) S2 ^= (o2 = (j2 ^= (o2 = (P2 ^= (o2 = (T2 ^= (o2 = S2 + j2 | 0) << 7 | o2 >>> 25) + S2 | 0) << 9 | o2 >>> 23) + T2 | 0) << 13 | o2 >>> 19) + P2 | 0) << 18 | o2 >>> 14, O2 ^= (o2 = (k2 ^= (o2 = (B2 ^= (o2 = (I2 ^= (o2 = O2 + k2 | 0) << 7 | o2 >>> 25) + O2 | 0) << 9 | o2 >>> 23) + I2 | 0) << 13 | o2 >>> 19) + B2 | 0) << 18 | o2 >>> 14, R2 ^= (o2 = (x2 ^= (o2 = (E2 ^= (o2 = (L2 ^= (o2 = R2 + x2 | 0) << 7 | o2 >>> 25) + R2 | 0) << 9 | o2 >>> 23) + L2 | 0) << 13 | o2 >>> 19) + E2 | 0) << 18 | o2 >>> 14, N2 ^= (o2 = (C2 ^= (o2 = (A2 ^= (o2 = (_2 ^= (o2 = N2 + C2 | 0) << 7 | o2 >>> 25) + N2 | 0) << 9 | o2 >>> 23) + _2 | 0) << 13 | o2 >>> 19) + A2 | 0) << 18 | o2 >>> 14, S2 ^= (o2 = (_2 ^= (o2 = (E2 ^= (o2 = (k2 ^= (o2 = S2 + _2 | 0) << 7 | o2 >>> 25) + S2 | 0) << 9 | o2 >>> 23) + k2 | 0) << 13 | o2 >>> 19) + E2 | 0) << 18 | o2 >>> 14, O2 ^= (o2 = (T2 ^= (o2 = (A2 ^= (o2 = (x2 ^= (o2 = O2 + T2 | 0) << 7 | o2 >>> 25) + O2 | 0) << 9 | o2 >>> 23) + x2 | 0) << 13 | o2 >>> 19) + A2 | 0) << 18 | o2 >>> 14, R2 ^= (o2 = (I2 ^= (o2 = (P2 ^= (o2 = (C2 ^= (o2 = R2 + I2 | 0) << 7 | o2 >>> 25) + R2 | 0) << 9 | o2 >>> 23) + C2 | 0) << 13 | o2 >>> 19) + P2 | 0) << 18 | o2 >>> 14, N2 ^= (o2 = (L2 ^= (o2 = (B2 ^= (o2 = (j2 ^= (o2 = N2 + L2 | 0) << 7 | o2 >>> 25) + N2 | 0) << 9 | o2 >>> 23) + j2 | 0) << 13 | o2 >>> 19) + B2 | 0) << 18 | o2 >>> 14;
              S2 = S2 + i2 | 0, k2 = k2 + a2 | 0, E2 = E2 + u2 | 0, _2 = _2 + s2 | 0, T2 = T2 + c2 | 0, O2 = O2 + l2 | 0, x2 = x2 + f2 | 0, A2 = A2 + p2 | 0, P2 = P2 + d2 | 0, I2 = I2 + h2 | 0, R2 = R2 + y2 | 0, C2 = C2 + m2 | 0, j2 = j2 + v2 | 0, B2 = B2 + g2 | 0, L2 = L2 + b2 | 0, N2 = N2 + w2 | 0, e5[0] = S2 >>> 0 & 255, e5[1] = S2 >>> 8 & 255, e5[2] = S2 >>> 16 & 255, e5[3] = S2 >>> 24 & 255, e5[4] = k2 >>> 0 & 255, e5[5] = k2 >>> 8 & 255, e5[6] = k2 >>> 16 & 255, e5[7] = k2 >>> 24 & 255, e5[8] = E2 >>> 0 & 255, e5[9] = E2 >>> 8 & 255, e5[10] = E2 >>> 16 & 255, e5[11] = E2 >>> 24 & 255, e5[12] = _2 >>> 0 & 255, e5[13] = _2 >>> 8 & 255, e5[14] = _2 >>> 16 & 255, e5[15] = _2 >>> 24 & 255, e5[16] = T2 >>> 0 & 255, e5[17] = T2 >>> 8 & 255, e5[18] = T2 >>> 16 & 255, e5[19] = T2 >>> 24 & 255, e5[20] = O2 >>> 0 & 255, e5[21] = O2 >>> 8 & 255, e5[22] = O2 >>> 16 & 255, e5[23] = O2 >>> 24 & 255, e5[24] = x2 >>> 0 & 255, e5[25] = x2 >>> 8 & 255, e5[26] = x2 >>> 16 & 255, e5[27] = x2 >>> 24 & 255, e5[28] = A2 >>> 0 & 255, e5[29] = A2 >>> 8 & 255, e5[30] = A2 >>> 16 & 255, e5[31] = A2 >>> 24 & 255, e5[32] = P2 >>> 0 & 255, e5[33] = P2 >>> 8 & 255, e5[34] = P2 >>> 16 & 255, e5[35] = P2 >>> 24 & 255, e5[36] = I2 >>> 0 & 255, e5[37] = I2 >>> 8 & 255, e5[38] = I2 >>> 16 & 255, e5[39] = I2 >>> 24 & 255, e5[40] = R2 >>> 0 & 255, e5[41] = R2 >>> 8 & 255, e5[42] = R2 >>> 16 & 255, e5[43] = R2 >>> 24 & 255, e5[44] = C2 >>> 0 & 255, e5[45] = C2 >>> 8 & 255, e5[46] = C2 >>> 16 & 255, e5[47] = C2 >>> 24 & 255, e5[48] = j2 >>> 0 & 255, e5[49] = j2 >>> 8 & 255, e5[50] = j2 >>> 16 & 255, e5[51] = j2 >>> 24 & 255, e5[52] = B2 >>> 0 & 255, e5[53] = B2 >>> 8 & 255, e5[54] = B2 >>> 16 & 255, e5[55] = B2 >>> 24 & 255, e5[56] = L2 >>> 0 & 255, e5[57] = L2 >>> 8 & 255, e5[58] = L2 >>> 16 & 255, e5[59] = L2 >>> 24 & 255, e5[60] = N2 >>> 0 & 255, e5[61] = N2 >>> 8 & 255, e5[62] = N2 >>> 16 & 255, e5[63] = N2 >>> 24 & 255;
            }(e4, t4, r3, n2);
          }
          function b(e4, t4, r3, n2) {
            !function(e5, t5, r4, n3) {
              for (var o2, i2 = 255 & n3[0] | (255 & n3[1]) << 8 | (255 & n3[2]) << 16 | (255 & n3[3]) << 24, a2 = 255 & r4[0] | (255 & r4[1]) << 8 | (255 & r4[2]) << 16 | (255 & r4[3]) << 24, u2 = 255 & r4[4] | (255 & r4[5]) << 8 | (255 & r4[6]) << 16 | (255 & r4[7]) << 24, s2 = 255 & r4[8] | (255 & r4[9]) << 8 | (255 & r4[10]) << 16 | (255 & r4[11]) << 24, c2 = 255 & r4[12] | (255 & r4[13]) << 8 | (255 & r4[14]) << 16 | (255 & r4[15]) << 24, l2 = 255 & n3[4] | (255 & n3[5]) << 8 | (255 & n3[6]) << 16 | (255 & n3[7]) << 24, f2 = 255 & t5[0] | (255 & t5[1]) << 8 | (255 & t5[2]) << 16 | (255 & t5[3]) << 24, p2 = 255 & t5[4] | (255 & t5[5]) << 8 | (255 & t5[6]) << 16 | (255 & t5[7]) << 24, d2 = 255 & t5[8] | (255 & t5[9]) << 8 | (255 & t5[10]) << 16 | (255 & t5[11]) << 24, h2 = 255 & t5[12] | (255 & t5[13]) << 8 | (255 & t5[14]) << 16 | (255 & t5[15]) << 24, y2 = 255 & n3[8] | (255 & n3[9]) << 8 | (255 & n3[10]) << 16 | (255 & n3[11]) << 24, m2 = 255 & r4[16] | (255 & r4[17]) << 8 | (255 & r4[18]) << 16 | (255 & r4[19]) << 24, v2 = 255 & r4[20] | (255 & r4[21]) << 8 | (255 & r4[22]) << 16 | (255 & r4[23]) << 24, g2 = 255 & r4[24] | (255 & r4[25]) << 8 | (255 & r4[26]) << 16 | (255 & r4[27]) << 24, b2 = 255 & r4[28] | (255 & r4[29]) << 8 | (255 & r4[30]) << 16 | (255 & r4[31]) << 24, w2 = 255 & n3[12] | (255 & n3[13]) << 8 | (255 & n3[14]) << 16 | (255 & n3[15]) << 24, S2 = 0; S2 < 20; S2 += 2) i2 ^= (o2 = (v2 ^= (o2 = (d2 ^= (o2 = (c2 ^= (o2 = i2 + v2 | 0) << 7 | o2 >>> 25) + i2 | 0) << 9 | o2 >>> 23) + c2 | 0) << 13 | o2 >>> 19) + d2 | 0) << 18 | o2 >>> 14, l2 ^= (o2 = (a2 ^= (o2 = (g2 ^= (o2 = (h2 ^= (o2 = l2 + a2 | 0) << 7 | o2 >>> 25) + l2 | 0) << 9 | o2 >>> 23) + h2 | 0) << 13 | o2 >>> 19) + g2 | 0) << 18 | o2 >>> 14, y2 ^= (o2 = (f2 ^= (o2 = (u2 ^= (o2 = (b2 ^= (o2 = y2 + f2 | 0) << 7 | o2 >>> 25) + y2 | 0) << 9 | o2 >>> 23) + b2 | 0) << 13 | o2 >>> 19) + u2 | 0) << 18 | o2 >>> 14, w2 ^= (o2 = (m2 ^= (o2 = (p2 ^= (o2 = (s2 ^= (o2 = w2 + m2 | 0) << 7 | o2 >>> 25) + w2 | 0) << 9 | o2 >>> 23) + s2 | 0) << 13 | o2 >>> 19) + p2 | 0) << 18 | o2 >>> 14, i2 ^= (o2 = (s2 ^= (o2 = (u2 ^= (o2 = (a2 ^= (o2 = i2 + s2 | 0) << 7 | o2 >>> 25) + i2 | 0) << 9 | o2 >>> 23) + a2 | 0) << 13 | o2 >>> 19) + u2 | 0) << 18 | o2 >>> 14, l2 ^= (o2 = (c2 ^= (o2 = (p2 ^= (o2 = (f2 ^= (o2 = l2 + c2 | 0) << 7 | o2 >>> 25) + l2 | 0) << 9 | o2 >>> 23) + f2 | 0) << 13 | o2 >>> 19) + p2 | 0) << 18 | o2 >>> 14, y2 ^= (o2 = (h2 ^= (o2 = (d2 ^= (o2 = (m2 ^= (o2 = y2 + h2 | 0) << 7 | o2 >>> 25) + y2 | 0) << 9 | o2 >>> 23) + m2 | 0) << 13 | o2 >>> 19) + d2 | 0) << 18 | o2 >>> 14, w2 ^= (o2 = (b2 ^= (o2 = (g2 ^= (o2 = (v2 ^= (o2 = w2 + b2 | 0) << 7 | o2 >>> 25) + w2 | 0) << 9 | o2 >>> 23) + v2 | 0) << 13 | o2 >>> 19) + g2 | 0) << 18 | o2 >>> 14;
              e5[0] = i2 >>> 0 & 255, e5[1] = i2 >>> 8 & 255, e5[2] = i2 >>> 16 & 255, e5[3] = i2 >>> 24 & 255, e5[4] = l2 >>> 0 & 255, e5[5] = l2 >>> 8 & 255, e5[6] = l2 >>> 16 & 255, e5[7] = l2 >>> 24 & 255, e5[8] = y2 >>> 0 & 255, e5[9] = y2 >>> 8 & 255, e5[10] = y2 >>> 16 & 255, e5[11] = y2 >>> 24 & 255, e5[12] = w2 >>> 0 & 255, e5[13] = w2 >>> 8 & 255, e5[14] = w2 >>> 16 & 255, e5[15] = w2 >>> 24 & 255, e5[16] = f2 >>> 0 & 255, e5[17] = f2 >>> 8 & 255, e5[18] = f2 >>> 16 & 255, e5[19] = f2 >>> 24 & 255, e5[20] = p2 >>> 0 & 255, e5[21] = p2 >>> 8 & 255, e5[22] = p2 >>> 16 & 255, e5[23] = p2 >>> 24 & 255, e5[24] = d2 >>> 0 & 255, e5[25] = d2 >>> 8 & 255, e5[26] = d2 >>> 16 & 255, e5[27] = d2 >>> 24 & 255, e5[28] = h2 >>> 0 & 255, e5[29] = h2 >>> 8 & 255, e5[30] = h2 >>> 16 & 255, e5[31] = h2 >>> 24 & 255;
            }(e4, t4, r3, n2);
          }
          var w = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
          function S(e4, t4, r3, n2, o2, i2, a2) {
            var u2, s2, c2 = new Uint8Array(16), l2 = new Uint8Array(64);
            for (s2 = 0; s2 < 16; s2++) c2[s2] = 0;
            for (s2 = 0; s2 < 8; s2++) c2[s2] = i2[s2];
            for (; o2 >= 64; ) {
              for (g(l2, c2, a2, w), s2 = 0; s2 < 64; s2++) e4[t4 + s2] = r3[n2 + s2] ^ l2[s2];
              for (u2 = 1, s2 = 8; s2 < 16; s2++) u2 = u2 + (255 & c2[s2]) | 0, c2[s2] = 255 & u2, u2 >>>= 8;
              o2 -= 64, t4 += 64, n2 += 64;
            }
            if (o2 > 0) for (g(l2, c2, a2, w), s2 = 0; s2 < o2; s2++) e4[t4 + s2] = r3[n2 + s2] ^ l2[s2];
            return 0;
          }
          function k(e4, t4, r3, n2, o2) {
            var i2, a2, u2 = new Uint8Array(16), s2 = new Uint8Array(64);
            for (a2 = 0; a2 < 16; a2++) u2[a2] = 0;
            for (a2 = 0; a2 < 8; a2++) u2[a2] = n2[a2];
            for (; r3 >= 64; ) {
              for (g(s2, u2, o2, w), a2 = 0; a2 < 64; a2++) e4[t4 + a2] = s2[a2];
              for (i2 = 1, a2 = 8; a2 < 16; a2++) i2 = i2 + (255 & u2[a2]) | 0, u2[a2] = 255 & i2, i2 >>>= 8;
              r3 -= 64, t4 += 64;
            }
            if (r3 > 0) for (g(s2, u2, o2, w), a2 = 0; a2 < r3; a2++) e4[t4 + a2] = s2[a2];
            return 0;
          }
          function E(e4, t4, r3, n2, o2) {
            var i2 = new Uint8Array(32);
            b(i2, n2, o2, w);
            for (var a2 = new Uint8Array(8), u2 = 0; u2 < 8; u2++) a2[u2] = n2[u2 + 16];
            return k(e4, t4, r3, a2, i2);
          }
          function _(e4, t4, r3, n2, o2, i2, a2) {
            var u2 = new Uint8Array(32);
            b(u2, i2, a2, w);
            for (var s2 = new Uint8Array(8), c2 = 0; c2 < 8; c2++) s2[c2] = i2[c2 + 16];
            return S(e4, t4, r3, n2, o2, s2, u2);
          }
          var T = function(e4) {
            var t4, r3, n2, o2, i2, a2, u2, s2;
            this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, t4 = 255 & e4[0] | (255 & e4[1]) << 8, this.r[0] = 8191 & t4, r3 = 255 & e4[2] | (255 & e4[3]) << 8, this.r[1] = 8191 & (t4 >>> 13 | r3 << 3), n2 = 255 & e4[4] | (255 & e4[5]) << 8, this.r[2] = 7939 & (r3 >>> 10 | n2 << 6), o2 = 255 & e4[6] | (255 & e4[7]) << 8, this.r[3] = 8191 & (n2 >>> 7 | o2 << 9), i2 = 255 & e4[8] | (255 & e4[9]) << 8, this.r[4] = 255 & (o2 >>> 4 | i2 << 12), this.r[5] = i2 >>> 1 & 8190, a2 = 255 & e4[10] | (255 & e4[11]) << 8, this.r[6] = 8191 & (i2 >>> 14 | a2 << 2), u2 = 255 & e4[12] | (255 & e4[13]) << 8, this.r[7] = 8065 & (a2 >>> 11 | u2 << 5), s2 = 255 & e4[14] | (255 & e4[15]) << 8, this.r[8] = 8191 & (u2 >>> 8 | s2 << 8), this.r[9] = s2 >>> 5 & 127, this.pad[0] = 255 & e4[16] | (255 & e4[17]) << 8, this.pad[1] = 255 & e4[18] | (255 & e4[19]) << 8, this.pad[2] = 255 & e4[20] | (255 & e4[21]) << 8, this.pad[3] = 255 & e4[22] | (255 & e4[23]) << 8, this.pad[4] = 255 & e4[24] | (255 & e4[25]) << 8, this.pad[5] = 255 & e4[26] | (255 & e4[27]) << 8, this.pad[6] = 255 & e4[28] | (255 & e4[29]) << 8, this.pad[7] = 255 & e4[30] | (255 & e4[31]) << 8;
          };
          function O(e4, t4, r3, n2, o2, i2) {
            var a2 = new T(i2);
            return a2.update(r3, n2, o2), a2.finish(e4, t4), 0;
          }
          function x(e4, t4, r3, n2, o2, i2) {
            var a2 = new Uint8Array(16);
            return O(a2, 0, r3, n2, o2, i2), m(e4, t4, a2, 0);
          }
          function A(e4, t4, r3, n2, o2) {
            var i2;
            if (r3 < 32) return -1;
            for (_(e4, 0, t4, 0, r3, n2, o2), O(e4, 16, e4, 32, r3 - 32, e4), i2 = 0; i2 < 16; i2++) e4[i2] = 0;
            return 0;
          }
          function P(e4, t4, r3, n2, o2) {
            var i2, a2 = new Uint8Array(32);
            if (r3 < 32) return -1;
            if (E(a2, 0, 32, n2, o2), 0 !== x(t4, 16, t4, 32, r3 - 32, a2)) return -1;
            for (_(e4, 0, t4, 0, r3, n2, o2), i2 = 0; i2 < 32; i2++) e4[i2] = 0;
            return 0;
          }
          function I(e4, t4) {
            var r3;
            for (r3 = 0; r3 < 16; r3++) e4[r3] = 0 | t4[r3];
          }
          function R(e4) {
            var t4, r3, n2 = 1;
            for (t4 = 0; t4 < 16; t4++) r3 = e4[t4] + n2 + 65535, n2 = Math.floor(r3 / 65536), e4[t4] = r3 - 65536 * n2;
            e4[0] += n2 - 1 + 37 * (n2 - 1);
          }
          function C(e4, t4, r3) {
            for (var n2, o2 = ~(r3 - 1), i2 = 0; i2 < 16; i2++) n2 = o2 & (e4[i2] ^ t4[i2]), e4[i2] ^= n2, t4[i2] ^= n2;
          }
          function j(e4, r3) {
            var n2, o2, i2, a2 = t3(), u2 = t3();
            for (n2 = 0; n2 < 16; n2++) u2[n2] = r3[n2];
            for (R(u2), R(u2), R(u2), o2 = 0; o2 < 2; o2++) {
              for (a2[0] = u2[0] - 65517, n2 = 1; n2 < 15; n2++) a2[n2] = u2[n2] - 65535 - (a2[n2 - 1] >> 16 & 1), a2[n2 - 1] &= 65535;
              a2[15] = u2[15] - 32767 - (a2[14] >> 16 & 1), i2 = a2[15] >> 16 & 1, a2[14] &= 65535, C(u2, a2, 1 - i2);
            }
            for (n2 = 0; n2 < 16; n2++) e4[2 * n2] = 255 & u2[n2], e4[2 * n2 + 1] = u2[n2] >> 8;
          }
          function B(e4, t4) {
            var r3 = new Uint8Array(32), n2 = new Uint8Array(32);
            return j(r3, e4), j(n2, t4), v(r3, 0, n2, 0);
          }
          function L(e4) {
            var t4 = new Uint8Array(32);
            return j(t4, e4), 1 & t4[0];
          }
          function N(e4, t4) {
            var r3;
            for (r3 = 0; r3 < 16; r3++) e4[r3] = t4[2 * r3] + (t4[2 * r3 + 1] << 8);
            e4[15] &= 32767;
          }
          function U(e4, t4, r3) {
            for (var n2 = 0; n2 < 16; n2++) e4[n2] = t4[n2] + r3[n2];
          }
          function M(e4, t4, r3) {
            for (var n2 = 0; n2 < 16; n2++) e4[n2] = t4[n2] - r3[n2];
          }
          function F(e4, t4, r3) {
            var n2, o2, i2 = 0, a2 = 0, u2 = 0, s2 = 0, c2 = 0, l2 = 0, f2 = 0, p2 = 0, d2 = 0, h2 = 0, y2 = 0, m2 = 0, v2 = 0, g2 = 0, b2 = 0, w2 = 0, S2 = 0, k2 = 0, E2 = 0, _2 = 0, T2 = 0, O2 = 0, x2 = 0, A2 = 0, P2 = 0, I2 = 0, R2 = 0, C2 = 0, j2 = 0, B2 = 0, L2 = 0, N2 = r3[0], U2 = r3[1], M2 = r3[2], F2 = r3[3], D2 = r3[4], V2 = r3[5], q2 = r3[6], K2 = r3[7], H2 = r3[8], z2 = r3[9], X2 = r3[10], G2 = r3[11], $2 = r3[12], Q2 = r3[13], W2 = r3[14], Y2 = r3[15];
            i2 += (n2 = t4[0]) * N2, a2 += n2 * U2, u2 += n2 * M2, s2 += n2 * F2, c2 += n2 * D2, l2 += n2 * V2, f2 += n2 * q2, p2 += n2 * K2, d2 += n2 * H2, h2 += n2 * z2, y2 += n2 * X2, m2 += n2 * G2, v2 += n2 * $2, g2 += n2 * Q2, b2 += n2 * W2, w2 += n2 * Y2, a2 += (n2 = t4[1]) * N2, u2 += n2 * U2, s2 += n2 * M2, c2 += n2 * F2, l2 += n2 * D2, f2 += n2 * V2, p2 += n2 * q2, d2 += n2 * K2, h2 += n2 * H2, y2 += n2 * z2, m2 += n2 * X2, v2 += n2 * G2, g2 += n2 * $2, b2 += n2 * Q2, w2 += n2 * W2, S2 += n2 * Y2, u2 += (n2 = t4[2]) * N2, s2 += n2 * U2, c2 += n2 * M2, l2 += n2 * F2, f2 += n2 * D2, p2 += n2 * V2, d2 += n2 * q2, h2 += n2 * K2, y2 += n2 * H2, m2 += n2 * z2, v2 += n2 * X2, g2 += n2 * G2, b2 += n2 * $2, w2 += n2 * Q2, S2 += n2 * W2, k2 += n2 * Y2, s2 += (n2 = t4[3]) * N2, c2 += n2 * U2, l2 += n2 * M2, f2 += n2 * F2, p2 += n2 * D2, d2 += n2 * V2, h2 += n2 * q2, y2 += n2 * K2, m2 += n2 * H2, v2 += n2 * z2, g2 += n2 * X2, b2 += n2 * G2, w2 += n2 * $2, S2 += n2 * Q2, k2 += n2 * W2, E2 += n2 * Y2, c2 += (n2 = t4[4]) * N2, l2 += n2 * U2, f2 += n2 * M2, p2 += n2 * F2, d2 += n2 * D2, h2 += n2 * V2, y2 += n2 * q2, m2 += n2 * K2, v2 += n2 * H2, g2 += n2 * z2, b2 += n2 * X2, w2 += n2 * G2, S2 += n2 * $2, k2 += n2 * Q2, E2 += n2 * W2, _2 += n2 * Y2, l2 += (n2 = t4[5]) * N2, f2 += n2 * U2, p2 += n2 * M2, d2 += n2 * F2, h2 += n2 * D2, y2 += n2 * V2, m2 += n2 * q2, v2 += n2 * K2, g2 += n2 * H2, b2 += n2 * z2, w2 += n2 * X2, S2 += n2 * G2, k2 += n2 * $2, E2 += n2 * Q2, _2 += n2 * W2, T2 += n2 * Y2, f2 += (n2 = t4[6]) * N2, p2 += n2 * U2, d2 += n2 * M2, h2 += n2 * F2, y2 += n2 * D2, m2 += n2 * V2, v2 += n2 * q2, g2 += n2 * K2, b2 += n2 * H2, w2 += n2 * z2, S2 += n2 * X2, k2 += n2 * G2, E2 += n2 * $2, _2 += n2 * Q2, T2 += n2 * W2, O2 += n2 * Y2, p2 += (n2 = t4[7]) * N2, d2 += n2 * U2, h2 += n2 * M2, y2 += n2 * F2, m2 += n2 * D2, v2 += n2 * V2, g2 += n2 * q2, b2 += n2 * K2, w2 += n2 * H2, S2 += n2 * z2, k2 += n2 * X2, E2 += n2 * G2, _2 += n2 * $2, T2 += n2 * Q2, O2 += n2 * W2, x2 += n2 * Y2, d2 += (n2 = t4[8]) * N2, h2 += n2 * U2, y2 += n2 * M2, m2 += n2 * F2, v2 += n2 * D2, g2 += n2 * V2, b2 += n2 * q2, w2 += n2 * K2, S2 += n2 * H2, k2 += n2 * z2, E2 += n2 * X2, _2 += n2 * G2, T2 += n2 * $2, O2 += n2 * Q2, x2 += n2 * W2, A2 += n2 * Y2, h2 += (n2 = t4[9]) * N2, y2 += n2 * U2, m2 += n2 * M2, v2 += n2 * F2, g2 += n2 * D2, b2 += n2 * V2, w2 += n2 * q2, S2 += n2 * K2, k2 += n2 * H2, E2 += n2 * z2, _2 += n2 * X2, T2 += n2 * G2, O2 += n2 * $2, x2 += n2 * Q2, A2 += n2 * W2, P2 += n2 * Y2, y2 += (n2 = t4[10]) * N2, m2 += n2 * U2, v2 += n2 * M2, g2 += n2 * F2, b2 += n2 * D2, w2 += n2 * V2, S2 += n2 * q2, k2 += n2 * K2, E2 += n2 * H2, _2 += n2 * z2, T2 += n2 * X2, O2 += n2 * G2, x2 += n2 * $2, A2 += n2 * Q2, P2 += n2 * W2, I2 += n2 * Y2, m2 += (n2 = t4[11]) * N2, v2 += n2 * U2, g2 += n2 * M2, b2 += n2 * F2, w2 += n2 * D2, S2 += n2 * V2, k2 += n2 * q2, E2 += n2 * K2, _2 += n2 * H2, T2 += n2 * z2, O2 += n2 * X2, x2 += n2 * G2, A2 += n2 * $2, P2 += n2 * Q2, I2 += n2 * W2, R2 += n2 * Y2, v2 += (n2 = t4[12]) * N2, g2 += n2 * U2, b2 += n2 * M2, w2 += n2 * F2, S2 += n2 * D2, k2 += n2 * V2, E2 += n2 * q2, _2 += n2 * K2, T2 += n2 * H2, O2 += n2 * z2, x2 += n2 * X2, A2 += n2 * G2, P2 += n2 * $2, I2 += n2 * Q2, R2 += n2 * W2, C2 += n2 * Y2, g2 += (n2 = t4[13]) * N2, b2 += n2 * U2, w2 += n2 * M2, S2 += n2 * F2, k2 += n2 * D2, E2 += n2 * V2, _2 += n2 * q2, T2 += n2 * K2, O2 += n2 * H2, x2 += n2 * z2, A2 += n2 * X2, P2 += n2 * G2, I2 += n2 * $2, R2 += n2 * Q2, C2 += n2 * W2, j2 += n2 * Y2, b2 += (n2 = t4[14]) * N2, w2 += n2 * U2, S2 += n2 * M2, k2 += n2 * F2, E2 += n2 * D2, _2 += n2 * V2, T2 += n2 * q2, O2 += n2 * K2, x2 += n2 * H2, A2 += n2 * z2, P2 += n2 * X2, I2 += n2 * G2, R2 += n2 * $2, C2 += n2 * Q2, j2 += n2 * W2, B2 += n2 * Y2, w2 += (n2 = t4[15]) * N2, a2 += 38 * (k2 += n2 * M2), u2 += 38 * (E2 += n2 * F2), s2 += 38 * (_2 += n2 * D2), c2 += 38 * (T2 += n2 * V2), l2 += 38 * (O2 += n2 * q2), f2 += 38 * (x2 += n2 * K2), p2 += 38 * (A2 += n2 * H2), d2 += 38 * (P2 += n2 * z2), h2 += 38 * (I2 += n2 * X2), y2 += 38 * (R2 += n2 * G2), m2 += 38 * (C2 += n2 * $2), v2 += 38 * (j2 += n2 * Q2), g2 += 38 * (B2 += n2 * W2), b2 += 38 * (L2 += n2 * Y2), i2 = (n2 = (i2 += 38 * (S2 += n2 * U2)) + (o2 = 1) + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), a2 = (n2 = a2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), u2 = (n2 = u2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), s2 = (n2 = s2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), c2 = (n2 = c2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), l2 = (n2 = l2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), f2 = (n2 = f2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), p2 = (n2 = p2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), d2 = (n2 = d2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), h2 = (n2 = h2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), y2 = (n2 = y2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), m2 = (n2 = m2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), v2 = (n2 = v2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), g2 = (n2 = g2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), b2 = (n2 = b2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), w2 = (n2 = w2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), i2 = (n2 = (i2 += o2 - 1 + 37 * (o2 - 1)) + (o2 = 1) + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), a2 = (n2 = a2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), u2 = (n2 = u2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), s2 = (n2 = s2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), c2 = (n2 = c2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), l2 = (n2 = l2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), f2 = (n2 = f2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), p2 = (n2 = p2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), d2 = (n2 = d2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), h2 = (n2 = h2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), y2 = (n2 = y2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), m2 = (n2 = m2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), v2 = (n2 = v2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), g2 = (n2 = g2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), b2 = (n2 = b2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), w2 = (n2 = w2 + o2 + 65535) - 65536 * (o2 = Math.floor(n2 / 65536)), i2 += o2 - 1 + 37 * (o2 - 1), e4[0] = i2, e4[1] = a2, e4[2] = u2, e4[3] = s2, e4[4] = c2, e4[5] = l2, e4[6] = f2, e4[7] = p2, e4[8] = d2, e4[9] = h2, e4[10] = y2, e4[11] = m2, e4[12] = v2, e4[13] = g2, e4[14] = b2, e4[15] = w2;
          }
          function D(e4, t4) {
            F(e4, t4, t4);
          }
          function V(e4, r3) {
            var n2, o2 = t3();
            for (n2 = 0; n2 < 16; n2++) o2[n2] = r3[n2];
            for (n2 = 253; n2 >= 0; n2--) D(o2, o2), 2 !== n2 && 4 !== n2 && F(o2, o2, r3);
            for (n2 = 0; n2 < 16; n2++) e4[n2] = o2[n2];
          }
          function q(e4, r3) {
            var n2, o2 = t3();
            for (n2 = 0; n2 < 16; n2++) o2[n2] = r3[n2];
            for (n2 = 250; n2 >= 0; n2--) D(o2, o2), 1 !== n2 && F(o2, o2, r3);
            for (n2 = 0; n2 < 16; n2++) e4[n2] = o2[n2];
          }
          function K(e4, r3, n2) {
            var o2, i2, a2 = new Uint8Array(32), u2 = new Float64Array(80), c2 = t3(), l2 = t3(), f2 = t3(), p2 = t3(), d2 = t3(), h2 = t3();
            for (i2 = 0; i2 < 31; i2++) a2[i2] = r3[i2];
            for (a2[31] = 127 & r3[31] | 64, a2[0] &= 248, N(u2, n2), i2 = 0; i2 < 16; i2++) l2[i2] = u2[i2], p2[i2] = c2[i2] = f2[i2] = 0;
            for (c2[0] = p2[0] = 1, i2 = 254; i2 >= 0; --i2) C(c2, l2, o2 = a2[i2 >>> 3] >>> (7 & i2) & 1), C(f2, p2, o2), U(d2, c2, f2), M(c2, c2, f2), U(f2, l2, p2), M(l2, l2, p2), D(p2, d2), D(h2, c2), F(c2, f2, c2), F(f2, l2, d2), U(d2, c2, f2), M(c2, c2, f2), D(l2, c2), M(f2, p2, h2), F(c2, f2, s), U(c2, c2, p2), F(f2, f2, c2), F(c2, p2, h2), F(p2, l2, u2), D(l2, d2), C(c2, l2, o2), C(f2, p2, o2);
            for (i2 = 0; i2 < 16; i2++) u2[i2 + 16] = c2[i2], u2[i2 + 32] = f2[i2], u2[i2 + 48] = l2[i2], u2[i2 + 64] = p2[i2];
            var y2 = u2.subarray(32), m2 = u2.subarray(16);
            return V(y2, y2), F(m2, m2, y2), j(e4, m2), 0;
          }
          function H(e4, t4) {
            return K(e4, t4, i);
          }
          function z(e4, t4) {
            return n(t4, 32), H(e4, t4);
          }
          function X(e4, t4, r3) {
            var n2 = new Uint8Array(32);
            return K(n2, r3, t4), b(e4, o, n2, w);
          }
          T.prototype.blocks = function(e4, t4, r3) {
            for (var n2, o2, i2, a2, u2, s2, c2, l2, f2, p2, d2, h2, y2, m2, v2, g2, b2, w2, S2, k2 = this.fin ? 0 : 2048, E2 = this.h[0], _2 = this.h[1], T2 = this.h[2], O2 = this.h[3], x2 = this.h[4], A2 = this.h[5], P2 = this.h[6], I2 = this.h[7], R2 = this.h[8], C2 = this.h[9], j2 = this.r[0], B2 = this.r[1], L2 = this.r[2], N2 = this.r[3], U2 = this.r[4], M2 = this.r[5], F2 = this.r[6], D2 = this.r[7], V2 = this.r[8], q2 = this.r[9]; r3 >= 16; ) p2 = f2 = 0, p2 += (E2 += 8191 & (n2 = 255 & e4[t4 + 0] | (255 & e4[t4 + 1]) << 8)) * j2, p2 += (_2 += 8191 & (n2 >>> 13 | (o2 = 255 & e4[t4 + 2] | (255 & e4[t4 + 3]) << 8) << 3)) * (5 * q2), p2 += (T2 += 8191 & (o2 >>> 10 | (i2 = 255 & e4[t4 + 4] | (255 & e4[t4 + 5]) << 8) << 6)) * (5 * V2), p2 += (O2 += 8191 & (i2 >>> 7 | (a2 = 255 & e4[t4 + 6] | (255 & e4[t4 + 7]) << 8) << 9)) * (5 * D2), f2 = (p2 += (x2 += 8191 & (a2 >>> 4 | (u2 = 255 & e4[t4 + 8] | (255 & e4[t4 + 9]) << 8) << 12)) * (5 * F2)) >>> 13, p2 &= 8191, p2 += (A2 += u2 >>> 1 & 8191) * (5 * M2), p2 += (P2 += 8191 & (u2 >>> 14 | (s2 = 255 & e4[t4 + 10] | (255 & e4[t4 + 11]) << 8) << 2)) * (5 * U2), p2 += (I2 += 8191 & (s2 >>> 11 | (c2 = 255 & e4[t4 + 12] | (255 & e4[t4 + 13]) << 8) << 5)) * (5 * N2), p2 += (R2 += 8191 & (c2 >>> 8 | (l2 = 255 & e4[t4 + 14] | (255 & e4[t4 + 15]) << 8) << 8)) * (5 * L2), d2 = f2 += (p2 += (C2 += l2 >>> 5 | k2) * (5 * B2)) >>> 13, d2 += E2 * B2, d2 += _2 * j2, d2 += T2 * (5 * q2), d2 += O2 * (5 * V2), f2 = (d2 += x2 * (5 * D2)) >>> 13, d2 &= 8191, d2 += A2 * (5 * F2), d2 += P2 * (5 * M2), d2 += I2 * (5 * U2), d2 += R2 * (5 * N2), f2 += (d2 += C2 * (5 * L2)) >>> 13, d2 &= 8191, h2 = f2, h2 += E2 * L2, h2 += _2 * B2, h2 += T2 * j2, h2 += O2 * (5 * q2), f2 = (h2 += x2 * (5 * V2)) >>> 13, h2 &= 8191, h2 += A2 * (5 * D2), h2 += P2 * (5 * F2), h2 += I2 * (5 * M2), h2 += R2 * (5 * U2), y2 = f2 += (h2 += C2 * (5 * N2)) >>> 13, y2 += E2 * N2, y2 += _2 * L2, y2 += T2 * B2, y2 += O2 * j2, f2 = (y2 += x2 * (5 * q2)) >>> 13, y2 &= 8191, y2 += A2 * (5 * V2), y2 += P2 * (5 * D2), y2 += I2 * (5 * F2), y2 += R2 * (5 * M2), m2 = f2 += (y2 += C2 * (5 * U2)) >>> 13, m2 += E2 * U2, m2 += _2 * N2, m2 += T2 * L2, m2 += O2 * B2, f2 = (m2 += x2 * j2) >>> 13, m2 &= 8191, m2 += A2 * (5 * q2), m2 += P2 * (5 * V2), m2 += I2 * (5 * D2), m2 += R2 * (5 * F2), v2 = f2 += (m2 += C2 * (5 * M2)) >>> 13, v2 += E2 * M2, v2 += _2 * U2, v2 += T2 * N2, v2 += O2 * L2, f2 = (v2 += x2 * B2) >>> 13, v2 &= 8191, v2 += A2 * j2, v2 += P2 * (5 * q2), v2 += I2 * (5 * V2), v2 += R2 * (5 * D2), g2 = f2 += (v2 += C2 * (5 * F2)) >>> 13, g2 += E2 * F2, g2 += _2 * M2, g2 += T2 * U2, g2 += O2 * N2, f2 = (g2 += x2 * L2) >>> 13, g2 &= 8191, g2 += A2 * B2, g2 += P2 * j2, g2 += I2 * (5 * q2), g2 += R2 * (5 * V2), b2 = f2 += (g2 += C2 * (5 * D2)) >>> 13, b2 += E2 * D2, b2 += _2 * F2, b2 += T2 * M2, b2 += O2 * U2, f2 = (b2 += x2 * N2) >>> 13, b2 &= 8191, b2 += A2 * L2, b2 += P2 * B2, b2 += I2 * j2, b2 += R2 * (5 * q2), w2 = f2 += (b2 += C2 * (5 * V2)) >>> 13, w2 += E2 * V2, w2 += _2 * D2, w2 += T2 * F2, w2 += O2 * M2, f2 = (w2 += x2 * U2) >>> 13, w2 &= 8191, w2 += A2 * N2, w2 += P2 * L2, w2 += I2 * B2, w2 += R2 * j2, S2 = f2 += (w2 += C2 * (5 * q2)) >>> 13, S2 += E2 * q2, S2 += _2 * V2, S2 += T2 * D2, S2 += O2 * F2, f2 = (S2 += x2 * M2) >>> 13, S2 &= 8191, S2 += A2 * U2, S2 += P2 * N2, S2 += I2 * L2, S2 += R2 * B2, E2 = p2 = 8191 & (f2 = (f2 = ((f2 += (S2 += C2 * j2) >>> 13) << 2) + f2 | 0) + (p2 &= 8191) | 0), _2 = d2 += f2 >>>= 13, T2 = h2 &= 8191, O2 = y2 &= 8191, x2 = m2 &= 8191, A2 = v2 &= 8191, P2 = g2 &= 8191, I2 = b2 &= 8191, R2 = w2 &= 8191, C2 = S2 &= 8191, t4 += 16, r3 -= 16;
            this.h[0] = E2, this.h[1] = _2, this.h[2] = T2, this.h[3] = O2, this.h[4] = x2, this.h[5] = A2, this.h[6] = P2, this.h[7] = I2, this.h[8] = R2, this.h[9] = C2;
          }, T.prototype.finish = function(e4, t4) {
            var r3, n2, o2, i2, a2 = new Uint16Array(10);
            if (this.leftover) {
              for (i2 = this.leftover, this.buffer[i2++] = 1; i2 < 16; i2++) this.buffer[i2] = 0;
              this.fin = 1, this.blocks(this.buffer, 0, 16);
            }
            for (r3 = this.h[1] >>> 13, this.h[1] &= 8191, i2 = 2; i2 < 10; i2++) this.h[i2] += r3, r3 = this.h[i2] >>> 13, this.h[i2] &= 8191;
            for (this.h[0] += 5 * r3, r3 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += r3, r3 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += r3, a2[0] = this.h[0] + 5, r3 = a2[0] >>> 13, a2[0] &= 8191, i2 = 1; i2 < 10; i2++) a2[i2] = this.h[i2] + r3, r3 = a2[i2] >>> 13, a2[i2] &= 8191;
            for (a2[9] -= 8192, n2 = (1 ^ r3) - 1, i2 = 0; i2 < 10; i2++) a2[i2] &= n2;
            for (n2 = ~n2, i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & n2 | a2[i2];
            for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), o2 = this.h[0] + this.pad[0], this.h[0] = 65535 & o2, i2 = 1; i2 < 8; i2++) o2 = (this.h[i2] + this.pad[i2] | 0) + (o2 >>> 16) | 0, this.h[i2] = 65535 & o2;
            e4[t4 + 0] = this.h[0] >>> 0 & 255, e4[t4 + 1] = this.h[0] >>> 8 & 255, e4[t4 + 2] = this.h[1] >>> 0 & 255, e4[t4 + 3] = this.h[1] >>> 8 & 255, e4[t4 + 4] = this.h[2] >>> 0 & 255, e4[t4 + 5] = this.h[2] >>> 8 & 255, e4[t4 + 6] = this.h[3] >>> 0 & 255, e4[t4 + 7] = this.h[3] >>> 8 & 255, e4[t4 + 8] = this.h[4] >>> 0 & 255, e4[t4 + 9] = this.h[4] >>> 8 & 255, e4[t4 + 10] = this.h[5] >>> 0 & 255, e4[t4 + 11] = this.h[5] >>> 8 & 255, e4[t4 + 12] = this.h[6] >>> 0 & 255, e4[t4 + 13] = this.h[6] >>> 8 & 255, e4[t4 + 14] = this.h[7] >>> 0 & 255, e4[t4 + 15] = this.h[7] >>> 8 & 255;
          }, T.prototype.update = function(e4, t4, r3) {
            var n2, o2;
            if (this.leftover) {
              for ((o2 = 16 - this.leftover) > r3 && (o2 = r3), n2 = 0; n2 < o2; n2++) this.buffer[this.leftover + n2] = e4[t4 + n2];
              if (r3 -= o2, t4 += o2, this.leftover += o2, this.leftover < 16) return;
              this.blocks(this.buffer, 0, 16), this.leftover = 0;
            }
            if (r3 >= 16 && (o2 = r3 - r3 % 16, this.blocks(e4, t4, o2), t4 += o2, r3 -= o2), r3) {
              for (n2 = 0; n2 < r3; n2++) this.buffer[this.leftover + n2] = e4[t4 + n2];
              this.leftover += r3;
            }
          };
          var G = A, $ = P;
          var Q = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
          function W(e4, t4, r3, n2) {
            for (var o2, i2, a2, u2, s2, c2, l2, f2, p2, d2, h2, y2, m2, v2, g2, b2, w2, S2, k2, E2, _2, T2, O2, x2, A2, P2, I2 = new Int32Array(16), R2 = new Int32Array(16), C2 = e4[0], j2 = e4[1], B2 = e4[2], L2 = e4[3], N2 = e4[4], U2 = e4[5], M2 = e4[6], F2 = e4[7], D2 = t4[0], V2 = t4[1], q2 = t4[2], K2 = t4[3], H2 = t4[4], z2 = t4[5], X2 = t4[6], G2 = t4[7], $2 = 0; n2 >= 128; ) {
              for (k2 = 0; k2 < 16; k2++) E2 = 8 * k2 + $2, I2[k2] = r3[E2 + 0] << 24 | r3[E2 + 1] << 16 | r3[E2 + 2] << 8 | r3[E2 + 3], R2[k2] = r3[E2 + 4] << 24 | r3[E2 + 5] << 16 | r3[E2 + 6] << 8 | r3[E2 + 7];
              for (k2 = 0; k2 < 80; k2++) if (o2 = C2, i2 = j2, a2 = B2, u2 = L2, s2 = N2, c2 = U2, l2 = M2, F2, p2 = D2, d2 = V2, h2 = q2, y2 = K2, m2 = H2, v2 = z2, g2 = X2, G2, O2 = 65535 & (T2 = G2), x2 = T2 >>> 16, A2 = 65535 & (_2 = F2), P2 = _2 >>> 16, O2 += 65535 & (T2 = (H2 >>> 14 | N2 << 18) ^ (H2 >>> 18 | N2 << 14) ^ (N2 >>> 9 | H2 << 23)), x2 += T2 >>> 16, A2 += 65535 & (_2 = (N2 >>> 14 | H2 << 18) ^ (N2 >>> 18 | H2 << 14) ^ (H2 >>> 9 | N2 << 23)), P2 += _2 >>> 16, O2 += 65535 & (T2 = H2 & z2 ^ ~H2 & X2), x2 += T2 >>> 16, A2 += 65535 & (_2 = N2 & U2 ^ ~N2 & M2), P2 += _2 >>> 16, O2 += 65535 & (T2 = Q[2 * k2 + 1]), x2 += T2 >>> 16, A2 += 65535 & (_2 = Q[2 * k2]), P2 += _2 >>> 16, _2 = I2[k2 % 16], x2 += (T2 = R2[k2 % 16]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16, O2 = 65535 & (T2 = S2 = 65535 & O2 | x2 << 16), x2 = T2 >>> 16, A2 = 65535 & (_2 = w2 = 65535 & A2 | (P2 += A2 >>> 16) << 16), P2 = _2 >>> 16, O2 += 65535 & (T2 = (D2 >>> 28 | C2 << 4) ^ (C2 >>> 2 | D2 << 30) ^ (C2 >>> 7 | D2 << 25)), x2 += T2 >>> 16, A2 += 65535 & (_2 = (C2 >>> 28 | D2 << 4) ^ (D2 >>> 2 | C2 << 30) ^ (D2 >>> 7 | C2 << 25)), P2 += _2 >>> 16, x2 += (T2 = D2 & V2 ^ D2 & q2 ^ V2 & q2) >>> 16, A2 += 65535 & (_2 = C2 & j2 ^ C2 & B2 ^ j2 & B2), P2 += _2 >>> 16, f2 = 65535 & (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) | (P2 += A2 >>> 16) << 16, b2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = y2), x2 = T2 >>> 16, A2 = 65535 & (_2 = u2), P2 = _2 >>> 16, x2 += (T2 = S2) >>> 16, A2 += 65535 & (_2 = w2), P2 += _2 >>> 16, j2 = o2, B2 = i2, L2 = a2, N2 = u2 = 65535 & (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) | (P2 += A2 >>> 16) << 16, U2 = s2, M2 = c2, F2 = l2, C2 = f2, V2 = p2, q2 = d2, K2 = h2, H2 = y2 = 65535 & O2 | x2 << 16, z2 = m2, X2 = v2, G2 = g2, D2 = b2, k2 % 16 == 15) for (E2 = 0; E2 < 16; E2++) _2 = I2[E2], O2 = 65535 & (T2 = R2[E2]), x2 = T2 >>> 16, A2 = 65535 & _2, P2 = _2 >>> 16, _2 = I2[(E2 + 9) % 16], O2 += 65535 & (T2 = R2[(E2 + 9) % 16]), x2 += T2 >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, w2 = I2[(E2 + 1) % 16], O2 += 65535 & (T2 = ((S2 = R2[(E2 + 1) % 16]) >>> 1 | w2 << 31) ^ (S2 >>> 8 | w2 << 24) ^ (S2 >>> 7 | w2 << 25)), x2 += T2 >>> 16, A2 += 65535 & (_2 = (w2 >>> 1 | S2 << 31) ^ (w2 >>> 8 | S2 << 24) ^ w2 >>> 7), P2 += _2 >>> 16, w2 = I2[(E2 + 14) % 16], x2 += (T2 = ((S2 = R2[(E2 + 14) % 16]) >>> 19 | w2 << 13) ^ (w2 >>> 29 | S2 << 3) ^ (S2 >>> 6 | w2 << 26)) >>> 16, A2 += 65535 & (_2 = (w2 >>> 19 | S2 << 13) ^ (S2 >>> 29 | w2 << 3) ^ w2 >>> 6), P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, I2[E2] = 65535 & A2 | P2 << 16, R2[E2] = 65535 & O2 | x2 << 16;
              O2 = 65535 & (T2 = D2), x2 = T2 >>> 16, A2 = 65535 & (_2 = C2), P2 = _2 >>> 16, _2 = e4[0], x2 += (T2 = t4[0]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[0] = C2 = 65535 & A2 | P2 << 16, t4[0] = D2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = V2), x2 = T2 >>> 16, A2 = 65535 & (_2 = j2), P2 = _2 >>> 16, _2 = e4[1], x2 += (T2 = t4[1]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[1] = j2 = 65535 & A2 | P2 << 16, t4[1] = V2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = q2), x2 = T2 >>> 16, A2 = 65535 & (_2 = B2), P2 = _2 >>> 16, _2 = e4[2], x2 += (T2 = t4[2]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[2] = B2 = 65535 & A2 | P2 << 16, t4[2] = q2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = K2), x2 = T2 >>> 16, A2 = 65535 & (_2 = L2), P2 = _2 >>> 16, _2 = e4[3], x2 += (T2 = t4[3]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[3] = L2 = 65535 & A2 | P2 << 16, t4[3] = K2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = H2), x2 = T2 >>> 16, A2 = 65535 & (_2 = N2), P2 = _2 >>> 16, _2 = e4[4], x2 += (T2 = t4[4]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[4] = N2 = 65535 & A2 | P2 << 16, t4[4] = H2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = z2), x2 = T2 >>> 16, A2 = 65535 & (_2 = U2), P2 = _2 >>> 16, _2 = e4[5], x2 += (T2 = t4[5]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[5] = U2 = 65535 & A2 | P2 << 16, t4[5] = z2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = X2), x2 = T2 >>> 16, A2 = 65535 & (_2 = M2), P2 = _2 >>> 16, _2 = e4[6], x2 += (T2 = t4[6]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[6] = M2 = 65535 & A2 | P2 << 16, t4[6] = X2 = 65535 & O2 | x2 << 16, O2 = 65535 & (T2 = G2), x2 = T2 >>> 16, A2 = 65535 & (_2 = F2), P2 = _2 >>> 16, _2 = e4[7], x2 += (T2 = t4[7]) >>> 16, A2 += 65535 & _2, P2 += _2 >>> 16, P2 += (A2 += (x2 += (O2 += 65535 & T2) >>> 16) >>> 16) >>> 16, e4[7] = F2 = 65535 & A2 | P2 << 16, t4[7] = G2 = 65535 & O2 | x2 << 16, $2 += 128, n2 -= 128;
            }
            return n2;
          }
          function Y(e4, t4, r3) {
            var n2, o2 = new Int32Array(8), i2 = new Int32Array(8), a2 = new Uint8Array(256), u2 = r3;
            for (o2[0] = 1779033703, o2[1] = 3144134277, o2[2] = 1013904242, o2[3] = 2773480762, o2[4] = 1359893119, o2[5] = 2600822924, o2[6] = 528734635, o2[7] = 1541459225, i2[0] = 4089235720, i2[1] = 2227873595, i2[2] = 4271175723, i2[3] = 1595750129, i2[4] = 2917565137, i2[5] = 725511199, i2[6] = 4215389547, i2[7] = 327033209, W(o2, i2, t4, r3), r3 %= 128, n2 = 0; n2 < r3; n2++) a2[n2] = t4[u2 - r3 + n2];
            for (a2[r3] = 128, a2[(r3 = 256 - 128 * (r3 < 112 ? 1 : 0)) - 9] = 0, h(a2, r3 - 8, u2 / 536870912 | 0, u2 << 3), W(o2, i2, a2, r3), n2 = 0; n2 < 8; n2++) h(e4, 8 * n2, o2[n2], i2[n2]);
            return 0;
          }
          function J(e4, r3) {
            var n2 = t3(), o2 = t3(), i2 = t3(), a2 = t3(), u2 = t3(), s2 = t3(), c2 = t3(), f2 = t3(), p2 = t3();
            M(n2, e4[1], e4[0]), M(p2, r3[1], r3[0]), F(n2, n2, p2), U(o2, e4[0], e4[1]), U(p2, r3[0], r3[1]), F(o2, o2, p2), F(i2, e4[3], r3[3]), F(i2, i2, l), F(a2, e4[2], r3[2]), U(a2, a2, a2), M(u2, o2, n2), M(s2, a2, i2), U(c2, a2, i2), U(f2, o2, n2), F(e4[0], u2, s2), F(e4[1], f2, c2), F(e4[2], c2, s2), F(e4[3], u2, f2);
          }
          function Z(e4, t4, r3) {
            var n2;
            for (n2 = 0; n2 < 4; n2++) C(e4[n2], t4[n2], r3);
          }
          function ee(e4, r3) {
            var n2 = t3(), o2 = t3(), i2 = t3();
            V(i2, r3[2]), F(n2, r3[0], i2), F(o2, r3[1], i2), j(e4, o2), e4[31] ^= L(n2) << 7;
          }
          function te(e4, t4, r3) {
            var n2, o2;
            for (I(e4[0], a), I(e4[1], u), I(e4[2], u), I(e4[3], a), o2 = 255; o2 >= 0; --o2) Z(e4, t4, n2 = r3[o2 / 8 | 0] >> (7 & o2) & 1), J(t4, e4), J(e4, e4), Z(e4, t4, n2);
          }
          function re(e4, r3) {
            var n2 = [t3(), t3(), t3(), t3()];
            I(n2[0], f), I(n2[1], p), I(n2[2], u), F(n2[3], f, p), te(e4, n2, r3);
          }
          function ne(e4, r3, o2) {
            var i2, a2 = new Uint8Array(64), u2 = [t3(), t3(), t3(), t3()];
            for (o2 || n(r3, 32), Y(a2, r3, 32), a2[0] &= 248, a2[31] &= 127, a2[31] |= 64, re(u2, a2), ee(e4, u2), i2 = 0; i2 < 32; i2++) r3[i2 + 32] = e4[i2];
            return 0;
          }
          var oe = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
          function ie(e4, t4) {
            var r3, n2, o2, i2;
            for (n2 = 63; n2 >= 32; --n2) {
              for (r3 = 0, o2 = n2 - 32, i2 = n2 - 12; o2 < i2; ++o2) t4[o2] += r3 - 16 * t4[n2] * oe[o2 - (n2 - 32)], r3 = Math.floor((t4[o2] + 128) / 256), t4[o2] -= 256 * r3;
              t4[o2] += r3, t4[n2] = 0;
            }
            for (r3 = 0, o2 = 0; o2 < 32; o2++) t4[o2] += r3 - (t4[31] >> 4) * oe[o2], r3 = t4[o2] >> 8, t4[o2] &= 255;
            for (o2 = 0; o2 < 32; o2++) t4[o2] -= r3 * oe[o2];
            for (n2 = 0; n2 < 32; n2++) t4[n2 + 1] += t4[n2] >> 8, e4[n2] = 255 & t4[n2];
          }
          function ae(e4) {
            var t4, r3 = new Float64Array(64);
            for (t4 = 0; t4 < 64; t4++) r3[t4] = e4[t4];
            for (t4 = 0; t4 < 64; t4++) e4[t4] = 0;
            ie(e4, r3);
          }
          function ue(e4, r3, n2, o2) {
            var i2, a2, u2 = new Uint8Array(64), s2 = new Uint8Array(64), c2 = new Uint8Array(64), l2 = new Float64Array(64), f2 = [t3(), t3(), t3(), t3()];
            Y(u2, o2, 32), u2[0] &= 248, u2[31] &= 127, u2[31] |= 64;
            var p2 = n2 + 64;
            for (i2 = 0; i2 < n2; i2++) e4[64 + i2] = r3[i2];
            for (i2 = 0; i2 < 32; i2++) e4[32 + i2] = u2[32 + i2];
            for (Y(c2, e4.subarray(32), n2 + 32), ae(c2), re(f2, c2), ee(e4, f2), i2 = 32; i2 < 64; i2++) e4[i2] = o2[i2];
            for (Y(s2, e4, n2 + 64), ae(s2), i2 = 0; i2 < 64; i2++) l2[i2] = 0;
            for (i2 = 0; i2 < 32; i2++) l2[i2] = c2[i2];
            for (i2 = 0; i2 < 32; i2++) for (a2 = 0; a2 < 32; a2++) l2[i2 + a2] += s2[i2] * u2[a2];
            return ie(e4.subarray(32), l2), p2;
          }
          function se(e4, r3, n2, o2) {
            var i2, s2 = new Uint8Array(32), l2 = new Uint8Array(64), f2 = [t3(), t3(), t3(), t3()], p2 = [t3(), t3(), t3(), t3()];
            if (n2 < 64) return -1;
            if (function(e5, r4) {
              var n3 = t3(), o3 = t3(), i3 = t3(), s3 = t3(), l3 = t3(), f3 = t3(), p3 = t3();
              return I(e5[2], u), N(e5[1], r4), D(i3, e5[1]), F(s3, i3, c), M(i3, i3, e5[2]), U(s3, e5[2], s3), D(l3, s3), D(f3, l3), F(p3, f3, l3), F(n3, p3, i3), F(n3, n3, s3), q(n3, n3), F(n3, n3, i3), F(n3, n3, s3), F(n3, n3, s3), F(e5[0], n3, s3), D(o3, e5[0]), F(o3, o3, s3), B(o3, i3) && F(e5[0], e5[0], d), D(o3, e5[0]), F(o3, o3, s3), B(o3, i3) ? -1 : (L(e5[0]) === r4[31] >> 7 && M(e5[0], a, e5[0]), F(e5[3], e5[0], e5[1]), 0);
            }(p2, o2)) return -1;
            for (i2 = 0; i2 < n2; i2++) e4[i2] = r3[i2];
            for (i2 = 0; i2 < 32; i2++) e4[i2 + 32] = o2[i2];
            if (Y(l2, e4, n2), ae(l2), te(f2, p2, l2), re(p2, r3.subarray(32)), J(f2, p2), ee(s2, f2), n2 -= 64, v(r3, 0, s2, 0)) {
              for (i2 = 0; i2 < n2; i2++) e4[i2] = 0;
              return -1;
            }
            for (i2 = 0; i2 < n2; i2++) e4[i2] = r3[i2 + 64];
            return n2;
          }
          var ce = 16, le = 64, fe = 32, pe = 64;
          function de(e4, t4) {
            if (32 !== e4.length) throw new Error("bad key size");
            if (24 !== t4.length) throw new Error("bad nonce size");
          }
          function he() {
            for (var e4 = 0; e4 < arguments.length; e4++) if (!(arguments[e4] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
          }
          function ye(e4) {
            for (var t4 = 0; t4 < e4.length; t4++) e4[t4] = 0;
          }
          e3.lowlevel = { crypto_core_hsalsa20: b, crypto_stream_xor: _, crypto_stream: E, crypto_stream_salsa20_xor: S, crypto_stream_salsa20: k, crypto_onetimeauth: O, crypto_onetimeauth_verify: x, crypto_verify_16: m, crypto_verify_32: v, crypto_secretbox: A, crypto_secretbox_open: P, crypto_scalarmult: K, crypto_scalarmult_base: H, crypto_box_beforenm: X, crypto_box_afternm: G, crypto_box: function(e4, t4, r3, n2, o2, i2) {
            var a2 = new Uint8Array(32);
            return X(a2, o2, i2), G(e4, t4, r3, n2, a2);
          }, crypto_box_open: function(e4, t4, r3, n2, o2, i2) {
            var a2 = new Uint8Array(32);
            return X(a2, o2, i2), $(e4, t4, r3, n2, a2);
          }, crypto_box_keypair: z, crypto_hash: Y, crypto_sign: ue, crypto_sign_keypair: ne, crypto_sign_open: se, crypto_secretbox_KEYBYTES: 32, crypto_secretbox_NONCEBYTES: 24, crypto_secretbox_ZEROBYTES: 32, crypto_secretbox_BOXZEROBYTES: ce, crypto_scalarmult_BYTES: 32, crypto_scalarmult_SCALARBYTES: 32, crypto_box_PUBLICKEYBYTES: 32, crypto_box_SECRETKEYBYTES: 32, crypto_box_BEFORENMBYTES: 32, crypto_box_NONCEBYTES: 24, crypto_box_ZEROBYTES: 32, crypto_box_BOXZEROBYTES: 16, crypto_sign_BYTES: le, crypto_sign_PUBLICKEYBYTES: fe, crypto_sign_SECRETKEYBYTES: pe, crypto_sign_SEEDBYTES: 32, crypto_hash_BYTES: 64, gf: t3, D: c, L: oe, pack25519: j, unpack25519: N, M: F, A: U, S: D, Z: M, pow2523: q, add: J, set25519: I, modL: ie, scalarmult: te, scalarbase: re }, e3.randomBytes = function(e4) {
            var t4 = new Uint8Array(e4);
            return n(t4, e4), t4;
          }, e3.secretbox = function(e4, t4, r3) {
            he(e4, t4, r3), de(r3, t4);
            for (var n2 = new Uint8Array(32 + e4.length), o2 = new Uint8Array(n2.length), i2 = 0; i2 < e4.length; i2++) n2[i2 + 32] = e4[i2];
            return A(o2, n2, n2.length, t4, r3), o2.subarray(ce);
          }, e3.secretbox.open = function(e4, t4, r3) {
            he(e4, t4, r3), de(r3, t4);
            for (var n2 = new Uint8Array(ce + e4.length), o2 = new Uint8Array(n2.length), i2 = 0; i2 < e4.length; i2++) n2[i2 + ce] = e4[i2];
            return n2.length < 32 || 0 !== P(o2, n2, n2.length, t4, r3) ? null : o2.subarray(32);
          }, e3.secretbox.keyLength = 32, e3.secretbox.nonceLength = 24, e3.secretbox.overheadLength = ce, e3.scalarMult = function(e4, t4) {
            if (he(e4, t4), 32 !== e4.length) throw new Error("bad n size");
            if (32 !== t4.length) throw new Error("bad p size");
            var r3 = new Uint8Array(32);
            return K(r3, e4, t4), r3;
          }, e3.scalarMult.base = function(e4) {
            if (he(e4), 32 !== e4.length) throw new Error("bad n size");
            var t4 = new Uint8Array(32);
            return H(t4, e4), t4;
          }, e3.scalarMult.scalarLength = 32, e3.scalarMult.groupElementLength = 32, e3.box = function(t4, r3, n2, o2) {
            var i2 = e3.box.before(n2, o2);
            return e3.secretbox(t4, r3, i2);
          }, e3.box.before = function(e4, t4) {
            he(e4, t4), function(e5, t5) {
              if (32 !== e5.length) throw new Error("bad public key size");
              if (32 !== t5.length) throw new Error("bad secret key size");
            }(e4, t4);
            var r3 = new Uint8Array(32);
            return X(r3, e4, t4), r3;
          }, e3.box.after = e3.secretbox, e3.box.open = function(t4, r3, n2, o2) {
            var i2 = e3.box.before(n2, o2);
            return e3.secretbox.open(t4, r3, i2);
          }, e3.box.open.after = e3.secretbox.open, e3.box.keyPair = function() {
            var e4 = new Uint8Array(32), t4 = new Uint8Array(32);
            return z(e4, t4), { publicKey: e4, secretKey: t4 };
          }, e3.box.keyPair.fromSecretKey = function(e4) {
            if (he(e4), 32 !== e4.length) throw new Error("bad secret key size");
            var t4 = new Uint8Array(32);
            return H(t4, e4), { publicKey: t4, secretKey: new Uint8Array(e4) };
          }, e3.box.publicKeyLength = 32, e3.box.secretKeyLength = 32, e3.box.sharedKeyLength = 32, e3.box.nonceLength = 24, e3.box.overheadLength = e3.secretbox.overheadLength, e3.sign = function(e4, t4) {
            if (he(e4, t4), t4.length !== pe) throw new Error("bad secret key size");
            var r3 = new Uint8Array(le + e4.length);
            return ue(r3, e4, e4.length, t4), r3;
          }, e3.sign.open = function(e4, t4) {
            if (he(e4, t4), t4.length !== fe) throw new Error("bad public key size");
            var r3 = new Uint8Array(e4.length), n2 = se(r3, e4, e4.length, t4);
            if (n2 < 0) return null;
            for (var o2 = new Uint8Array(n2), i2 = 0; i2 < o2.length; i2++) o2[i2] = r3[i2];
            return o2;
          }, e3.sign.detached = function(t4, r3) {
            for (var n2 = e3.sign(t4, r3), o2 = new Uint8Array(le), i2 = 0; i2 < o2.length; i2++) o2[i2] = n2[i2];
            return o2;
          }, e3.sign.detached.verify = function(e4, t4, r3) {
            if (he(e4, t4, r3), t4.length !== le) throw new Error("bad signature size");
            if (r3.length !== fe) throw new Error("bad public key size");
            var n2, o2 = new Uint8Array(le + e4.length), i2 = new Uint8Array(le + e4.length);
            for (n2 = 0; n2 < le; n2++) o2[n2] = t4[n2];
            for (n2 = 0; n2 < e4.length; n2++) o2[n2 + le] = e4[n2];
            return se(i2, o2, o2.length, r3) >= 0;
          }, e3.sign.keyPair = function() {
            var e4 = new Uint8Array(fe), t4 = new Uint8Array(pe);
            return ne(e4, t4), { publicKey: e4, secretKey: t4 };
          }, e3.sign.keyPair.fromSecretKey = function(e4) {
            if (he(e4), e4.length !== pe) throw new Error("bad secret key size");
            for (var t4 = new Uint8Array(fe), r3 = 0; r3 < t4.length; r3++) t4[r3] = e4[32 + r3];
            return { publicKey: t4, secretKey: new Uint8Array(e4) };
          }, e3.sign.keyPair.fromSeed = function(e4) {
            if (he(e4), 32 !== e4.length) throw new Error("bad seed size");
            for (var t4 = new Uint8Array(fe), r3 = new Uint8Array(pe), n2 = 0; n2 < 32; n2++) r3[n2] = e4[n2];
            return ne(t4, r3, true), { publicKey: t4, secretKey: r3 };
          }, e3.sign.publicKeyLength = fe, e3.sign.secretKeyLength = pe, e3.sign.seedLength = 32, e3.sign.signatureLength = le, e3.hash = function(e4) {
            he(e4);
            var t4 = new Uint8Array(64);
            return Y(t4, e4, e4.length), t4;
          }, e3.hash.hashLength = 64, e3.verify = function(e4, t4) {
            return he(e4, t4), 0 !== e4.length && 0 !== t4.length && (e4.length === t4.length && 0 === y(e4, 0, t4, 0, e4.length));
          }, e3.setPRNG = function(e4) {
            n = e4;
          }, function() {
            var t4 = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
            if (t4 && t4.getRandomValues) {
              e3.setPRNG(function(e4, r3) {
                var n2, o2 = new Uint8Array(r3);
                for (n2 = 0; n2 < r3; n2 += 65536) t4.getRandomValues(o2.subarray(n2, n2 + Math.min(r3 - n2, 65536)));
                for (n2 = 0; n2 < r3; n2++) e4[n2] = o2[n2];
                ye(o2);
              });
            } else (t4 = r2(2894)) && t4.randomBytes && e3.setPRNG(function(e4, r3) {
              var n2, o2 = t4.randomBytes(r3);
              for (n2 = 0; n2 < r3; n2++) e4[n2] = o2[n2];
              ye(o2);
            });
          }();
        }(e2.exports ? e2.exports : self.nacl = self.nacl || {});
      }, 5328: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.authorizeEntry = y, t2.authorizeInvocation = function(e3, t3, r3) {
          var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "", o2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : s.Networks.FUTURENET, u2 = a.Keypair.random().rawPublicKey(), c2 = new i.default.Int64((p2 = u2, p2.subarray(0, 8).reduce(function(e4, t4) {
            return e4 << 8 | t4;
          }, 0))), f2 = n2 || e3.publicKey();
          var p2;
          if (!f2) throw new Error("authorizeInvocation requires publicKey parameter");
          return y(new i.default.SorobanAuthorizationEntry({ rootInvocation: r3, credentials: i.default.SorobanCredentials.sorobanCredentialsAddress(new i.default.SorobanAddressCredentials({ address: new l.Address(f2).toScAddress(), nonce: c2, signatureExpirationLedger: 0, signature: i.default.ScVal.scvVec([]) })) }), e3, t3, o2);
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(6691), u = r2(7120), s = r2(6202), c = r2(9152), l = r2(1180), f = r2(7177);
        function p(e3) {
          return p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, p(e3);
        }
        function d() {
          d = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof b ? t4 : b, a3 = Object.create(i3.prototype), u3 = new C(n3 || []);
            return o2(a3, "_invoke", { value: A(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var h2 = "suspendedStart", y2 = "suspendedYield", m2 = "executing", v = "completed", g = {};
          function b() {
          }
          function w() {
          }
          function S() {
          }
          var k = {};
          c2(k, a2, function() {
            return this;
          });
          var E = Object.getPrototypeOf, _ = E && E(E(j([])));
          _ && _ !== r3 && n2.call(_, a2) && (k = _);
          var T = S.prototype = b.prototype = Object.create(k);
          function O(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function x(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == p(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A(t4, r4, n3) {
            var o3 = h2;
            return function(i3, a3) {
              if (o3 === m2) throw Error("Generator is already running");
              if (o3 === v) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = P(u3, n3);
                  if (s3) {
                    if (s3 === g) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === h2) throw o3 = v, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = m2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? v : y2, c3.arg === g) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = v, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function P(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, P(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, g;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, g) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, g);
          }
          function I(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function R(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function C(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(I, this), this.reset(true);
          }
          function j(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(p(t4) + " is not iterable");
          }
          return w.prototype = S, o2(T, "constructor", { value: S, configurable: true }), o2(S, "constructor", { value: w, configurable: true }), w.displayName = c2(S, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === w || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, S) : (e4.__proto__ = S, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(T), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, O(x.prototype), c2(x.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = x, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new x(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, O(T), c2(T, s2, "Generator"), c2(T, a2, function() {
            return this;
          }), c2(T, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = j, C.prototype = { constructor: C, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(R), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, g) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), g;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), R(r4), g;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  R(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: j(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), g;
          } }, t3;
        }
        function h(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function y(e3, t3, r3) {
          return m.apply(this, arguments);
        }
        function m() {
          var e3;
          return e3 = d().mark(function e4(t3, r3, o2) {
            var p2, h2, y2, m2, v, g, b, w, S, k, E = arguments;
            return d().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  if (p2 = E.length > 3 && void 0 !== E[3] ? E[3] : s.Networks.FUTURENET, t3.credentials().switch().value === i.default.SorobanCredentialsType.sorobanCredentialsAddress().value) {
                    e5.next = 3;
                    break;
                  }
                  return e5.abrupt("return", t3);
                case 3:
                  if (h2 = i.default.SorobanAuthorizationEntry.fromXDR(t3.toXDR()), (y2 = h2.credentials().address()).signatureExpirationLedger(o2), m2 = (0, c.hash)(n.from(p2)), v = i.default.HashIdPreimage.envelopeTypeSorobanAuthorization(new i.default.HashIdPreimageSorobanAuthorization({ networkId: m2, nonce: y2.nonce(), invocation: h2.rootInvocation(), signatureExpirationLedger: y2.signatureExpirationLedger() })), g = (0, c.hash)(v.toXDR()), "function" != typeof r3) {
                    e5.next = 16;
                    break;
                  }
                  return e5.next = 12, r3(v);
                case 12:
                  null != (S = e5.sent) && S.signature ? (b = n.from(S.signature), w = S.publicKey) : (b = n.from(S), w = l.Address.fromScAddress(y2.address()).toString()), e5.next = 18;
                  break;
                case 16:
                  b = n.from(r3.sign(g)), w = r3.publicKey();
                case 18:
                  if (a.Keypair.fromPublicKey(w).verify(g, b)) {
                    e5.next = 20;
                    break;
                  }
                  throw new Error("signature doesn't match payload");
                case 20:
                  return k = (0, f.nativeToScVal)({ public_key: u.StrKey.decodeEd25519PublicKey(w), signature: b }, { type: { public_key: ["symbol", null], signature: ["symbol", null] } }), y2.signature(i.default.ScVal.scvVec([k])), e5.abrupt("return", h2);
                case 23:
                case "end":
                  return e5.stop();
              }
            }, e4);
          }), m = function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                h(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                h(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          }, m.apply(this, arguments);
        }
      }, 5360: (e2, t2) => {
        "use strict";
        var r2 = function(e3, t3) {
          return t3 || (t3 = {}), e3.split("").forEach(function(e4, r3) {
            e4 in t3 || (t3[e4] = r3);
          }), t3;
        }, n = { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", charmap: { 0: 14, 1: 8 } };
        n.charmap = r2(n.alphabet, n.charmap);
        var o = { alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ", charmap: { O: 0, I: 1, L: 1 } };
        o.charmap = r2(o.alphabet, o.charmap);
        var i = { alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", charmap: {} };
        function a(e3) {
          if (this.buf = [], this.shift = 8, this.carry = 0, e3) {
            switch (e3.type) {
              case "rfc4648":
                this.charmap = t2.rfc4648.charmap;
                break;
              case "crockford":
                this.charmap = t2.crockford.charmap;
                break;
              case "base32hex":
                this.charmap = t2.base32hex.charmap;
                break;
              default:
                throw new Error("invalid type");
            }
            e3.charmap && (this.charmap = e3.charmap);
          }
        }
        function u(e3) {
          if (this.buf = "", this.shift = 3, this.carry = 0, e3) {
            switch (e3.type) {
              case "rfc4648":
                this.alphabet = t2.rfc4648.alphabet;
                break;
              case "crockford":
                this.alphabet = t2.crockford.alphabet;
                break;
              case "base32hex":
                this.alphabet = t2.base32hex.alphabet;
                break;
              default:
                throw new Error("invalid type");
            }
            e3.alphabet ? this.alphabet = e3.alphabet : e3.lc && (this.alphabet = this.alphabet.toLowerCase());
          }
        }
        i.charmap = r2(i.alphabet, i.charmap), a.prototype.charmap = n.charmap, a.prototype.write = function(e3) {
          var t3 = this.charmap, r3 = this.buf, n2 = this.shift, o2 = this.carry;
          return e3.toUpperCase().split("").forEach(function(e4) {
            if ("=" != e4) {
              var i2 = 255 & t3[e4];
              (n2 -= 5) > 0 ? o2 |= i2 << n2 : n2 < 0 ? (r3.push(o2 | i2 >> -n2), o2 = i2 << (n2 += 8) & 255) : (r3.push(o2 | i2), n2 = 8, o2 = 0);
            }
          }), this.shift = n2, this.carry = o2, this;
        }, a.prototype.finalize = function(e3) {
          return e3 && this.write(e3), 8 !== this.shift && 0 !== this.carry && (this.buf.push(this.carry), this.shift = 8, this.carry = 0), this.buf;
        }, u.prototype.alphabet = n.alphabet, u.prototype.write = function(e3) {
          var t3, r3, n2, o2 = this.shift, i2 = this.carry;
          for (n2 = 0; n2 < e3.length; n2++) t3 = i2 | (r3 = e3[n2]) >> o2, this.buf += this.alphabet[31 & t3], o2 > 5 && (t3 = r3 >> (o2 -= 5), this.buf += this.alphabet[31 & t3]), i2 = r3 << (o2 = 5 - o2), o2 = 8 - o2;
          return this.shift = o2, this.carry = i2, this;
        }, u.prototype.finalize = function(e3) {
          return e3 && this.write(e3), 3 !== this.shift && (this.buf += this.alphabet[31 & this.carry], this.shift = 3, this.carry = 0), this.buf;
        }, t2.encode = function(e3, t3) {
          return new u(t3).finalize(e3);
        }, t2.decode = function(e3, t3) {
          return new a(t3).finalize(e3);
        }, t2.Decoder = a, t2.Encoder = u, t2.charmap = r2, t2.crockford = o, t2.rfc4648 = n, t2.base32hex = i;
      }, 5479: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { InvalidChallengeError: () => y, buildChallengeTx: () => _, gatherTxSigners: () => P, readChallengeTx: () => T, verifyChallengeTxSigners: () => x, verifyChallengeTxThreshold: () => O, verifyTxSignedBy: () => A });
        var n = r2(3209), o = r2.n(n), i = r2(356), a = r2(3121);
        function u(e3) {
          return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, u(e3);
        }
        function s(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, c(n2.key), n2);
          }
        }
        function c(e3) {
          var t3 = function(e4, t4) {
            if ("object" != u(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != u(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == u(t3) ? t3 : t3 + "";
        }
        function l(e3, t3, r3) {
          return t3 = h(t3), function(e4, t4) {
            if (t4 && ("object" == u(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, p() ? Reflect.construct(t3, r3 || [], h(e3).constructor) : t3.apply(e3, r3));
        }
        function f(e3) {
          var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return f = function(e4) {
            if (null === e4 || !function(e5) {
              try {
                return -1 !== Function.toString.call(e5).indexOf("[native code]");
              } catch (t4) {
                return "function" == typeof e5;
              }
            }(e4)) return e4;
            if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t3) {
              if (t3.has(e4)) return t3.get(e4);
              t3.set(e4, r3);
            }
            function r3() {
              return function(e5, t4, r4) {
                if (p()) return Reflect.construct.apply(null, arguments);
                var n2 = [null];
                n2.push.apply(n2, t4);
                var o2 = new (e5.bind.apply(e5, n2))();
                return r4 && d(o2, r4.prototype), o2;
              }(e4, arguments, h(this).constructor);
            }
            return r3.prototype = Object.create(e4.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), d(r3, e4);
          }, f(e3);
        }
        function p() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (p = function() {
            return !!e3;
          })();
        }
        function d(e3, t3) {
          return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, d(e3, t3);
        }
        function h(e3) {
          return h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, h(e3);
        }
        var y = function(e3) {
          function t3(e4) {
            var r4;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var n3 = (this instanceof t3 ? this.constructor : void 0).prototype;
            return (r4 = l(this, t3, [e4])).__proto__ = n3, r4.constructor = t3, r4.name = "InvalidChallengeError", r4;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && d(e4, t4);
          }(t3, e3), r3 = t3, n2 && s(r3.prototype, n2), o2 && s(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(f(Error)), m = r2(8287).Buffer;
        function v(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return k(e4);
          }(e3) || E(e3) || S(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function g(e3, t3) {
          var r3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (!r3) {
            if (Array.isArray(e3) || (r3 = S(e3)) || t3 && e3 && "number" == typeof e3.length) {
              r3 && (e3 = r3);
              var n2 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
              }, e: function(e4) {
                throw e4;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var i2, a2 = true, u2 = false;
          return { s: function() {
            r3 = r3.call(e3);
          }, n: function() {
            var e4 = r3.next();
            return a2 = e4.done, e4;
          }, e: function(e4) {
            u2 = true, i2 = e4;
          }, f: function() {
            try {
              a2 || null == r3.return || r3.return();
            } finally {
              if (u2) throw i2;
            }
          } };
        }
        function b(e3) {
          return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, b(e3);
        }
        function w(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || E(e3) || S(e3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function S(e3, t3) {
          if (e3) {
            if ("string" == typeof e3) return k(e3, t3);
            var r3 = {}.toString.call(e3).slice(8, -1);
            return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? k(e3, t3) : void 0;
          }
        }
        function k(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function E(e3) {
          if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"]) return Array.from(e3);
        }
        function _(e3, t3, r3) {
          var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 300, a2 = arguments.length > 4 ? arguments[4] : void 0, u2 = arguments.length > 5 ? arguments[5] : void 0, s2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, c2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null;
          if (t3.startsWith("M") && s2) throw Error("memo cannot be used if clientAccountID is a muxed account");
          var f2 = new i.Account(e3.publicKey(), "-1"), p2 = Math.floor(Date.now() / 1e3), d2 = o()(48).toString("base64"), h2 = new i.TransactionBuilder(f2, { fee: i.BASE_FEE, networkPassphrase: a2, timebounds: { minTime: p2, maxTime: p2 + n2 } }).addOperation(i.Operation.manageData({ name: "".concat(r3, " auth"), value: d2, source: t3 })).addOperation(i.Operation.manageData({ name: "web_auth_domain", value: u2, source: f2.accountId() }));
          if (c2) {
            if (!l2) throw Error("clientSigningKey is required if clientDomain is provided");
            h2.addOperation(i.Operation.manageData({ name: "client_domain", value: c2, source: l2 }));
          }
          s2 && h2.addMemo(i.Memo.id(s2));
          var y2 = h2.build();
          return y2.sign(e3), y2.toEnvelope().toXDR("base64").toString();
        }
        function T(e3, t3, r3, n2, o2) {
          var u2, s2;
          if (t3.startsWith("M")) throw Error("Invalid serverAccountID: multiplexed accounts are not supported.");
          try {
            s2 = new i.Transaction(e3, r3);
          } catch (t4) {
            try {
              s2 = new i.FeeBumpTransaction(e3, r3);
            } catch (e4) {
              throw new y("Invalid challenge: unable to deserialize challengeTx transaction string");
            }
            throw new y("Invalid challenge: expected a Transaction but received a FeeBumpTransaction");
          }
          if (0 !== Number.parseInt(s2.sequence, 10)) throw new y("The transaction sequence number should be zero");
          if (s2.source !== t3) throw new y("The transaction source account is not equal to the server's account");
          if (s2.operations.length < 1) throw new y("The transaction should contain at least one operation");
          var c2 = w(s2.operations), l2 = c2[0], f2 = c2.slice(1);
          if (!l2.source) throw new y("The transaction's operation should contain a source account");
          var p2, d2 = l2.source, h2 = null;
          if (s2.memo.type !== i.MemoNone) {
            if (d2.startsWith("M")) throw new y("The transaction has a memo but the client account ID is a muxed account");
            if (s2.memo.type !== i.MemoID) throw new y("The transaction's memo must be of type `id`");
            h2 = s2.memo.value;
          }
          if ("manageData" !== l2.type) throw new y("The transaction's operation type should be 'manageData'");
          if (s2.timeBounds && Number.parseInt(null === (u2 = s2.timeBounds) || void 0 === u2 ? void 0 : u2.maxTime, 10) === i.TimeoutInfinite) throw new y("The transaction requires non-infinite timebounds");
          if (!a.A.validateTimebounds(s2, 300)) throw new y("The transaction has expired");
          if (void 0 === l2.value) throw new y("The transaction's operation values should not be null");
          if (!l2.value) throw new y("The transaction's operation value should not be null");
          if (48 !== m.from(l2.value.toString(), "base64").length) throw new y("The transaction's operation value should be a 64 bytes base64 random string");
          if (!n2) throw new y("Invalid homeDomains: a home domain must be provided for verification");
          if ("string" == typeof n2) "".concat(n2, " auth") === l2.name && (p2 = n2);
          else {
            if (!Array.isArray(n2)) throw new y("Invalid homeDomains: homeDomains type is ".concat(b(n2), " but should be a string or an array"));
            p2 = n2.find(function(e4) {
              return "".concat(e4, " auth") === l2.name;
            });
          }
          if (!p2) throw new y("Invalid homeDomains: the transaction's operation key name does not match the expected home domain");
          var v2, S2 = g(f2);
          try {
            for (S2.s(); !(v2 = S2.n()).done; ) {
              var k2 = v2.value;
              if ("manageData" !== k2.type) throw new y("The transaction has operations that are not of type 'manageData'");
              if (k2.source !== t3 && "client_domain" !== k2.name) throw new y("The transaction has operations that are unrecognized");
              if ("web_auth_domain" === k2.name) {
                if (void 0 === k2.value) throw new y("'web_auth_domain' operation value should not be null");
                if (k2.value.compare(m.from(o2))) throw new y("'web_auth_domain' operation value does not match ".concat(o2));
              }
            }
          } catch (e4) {
            S2.e(e4);
          } finally {
            S2.f();
          }
          if (!A(s2, t3)) throw new y("Transaction not signed by server: '".concat(t3, "'"));
          return { tx: s2, clientAccountID: d2, matchedHomeDomain: p2, memo: h2 };
        }
        function O(e3, t3, r3, n2, o2, i2, a2) {
          for (var u2 = x(e3, t3, r3, o2.map(function(e4) {
            return e4.key;
          }), i2, a2), s2 = 0, c2 = function() {
            var e4, t4 = f2[l2], r4 = (null === (e4 = o2.find(function(e5) {
              return e5.key === t4;
            })) || void 0 === e4 ? void 0 : e4.weight) || 0;
            s2 += r4;
          }, l2 = 0, f2 = u2; l2 < f2.length; l2++) c2();
          if (s2 < n2) throw new y("signers with weight ".concat(s2, " do not meet threshold ").concat(n2, '"'));
          return u2;
        }
        function x(e3, t3, r3, n2, o2, a2) {
          var u2, s2 = T(e3, t3, r3, o2, a2).tx;
          try {
            u2 = i.Keypair.fromPublicKey(t3);
          } catch (e4) {
            throw new Error("Couldn't infer keypair from the provided 'serverAccountID': ".concat(e4.message));
          }
          var c2, l2, f2 = /* @__PURE__ */ new Set(), p2 = g(n2);
          try {
            for (p2.s(); !(c2 = p2.n()).done; ) {
              var d2 = c2.value;
              d2 !== u2.publicKey() && ("G" === d2.charAt(0) && f2.add(d2));
            }
          } catch (e4) {
            p2.e(e4);
          } finally {
            p2.f();
          }
          if (0 === f2.size) throw new y("No verifiable client signers provided, at least one G... address must be provided");
          var h2, m2 = g(s2.operations);
          try {
            for (m2.s(); !(h2 = m2.n()).done; ) {
              var b2 = h2.value;
              if ("manageData" === b2.type && "client_domain" === b2.name) {
                if (l2) throw new y("Found more than one client_domain operation");
                l2 = b2.source;
              }
            }
          } catch (e4) {
            m2.e(e4);
          } finally {
            m2.f();
          }
          var w2 = [u2.publicKey()].concat(v(Array.from(f2)));
          l2 && w2.push(l2);
          for (var S2 = P(s2, w2), k2 = false, E2 = false, _2 = 0, O2 = S2; _2 < O2.length; _2++) {
            var x2 = O2[_2];
            x2 === u2.publicKey() && (k2 = true), x2 === l2 && (E2 = true);
          }
          if (!k2) throw new y("Transaction not signed by server: '".concat(u2.publicKey(), "'"));
          if (l2 && !E2) throw new y("Transaction not signed by the source account of the 'client_domain' ManageData operation");
          if (1 === S2.length) throw new y("None of the given signers match the transaction signatures");
          if (S2.length !== s2.signatures.length) throw new y("Transaction has unrecognized signatures");
          return S2.splice(S2.indexOf(u2.publicKey()), 1), l2 && S2.splice(S2.indexOf(l2), 1), S2;
        }
        function A(e3, t3) {
          return 0 !== P(e3, [t3]).length;
        }
        function P(e3, t3) {
          var r3, n2 = e3.hash(), o2 = v(e3.signatures), a2 = /* @__PURE__ */ new Set(), u2 = g(t3);
          try {
            for (u2.s(); !(r3 = u2.n()).done; ) {
              var s2 = r3.value;
              if (0 === o2.length) break;
              var c2 = void 0;
              try {
                c2 = i.Keypair.fromPublicKey(s2);
              } catch (e4) {
                throw new y("Signer is not a valid address: ".concat(e4.message));
              }
              for (var l2 = 0; l2 < o2.length; l2++) {
                var f2 = o2[l2];
                if (f2.hint().equals(c2.signatureHint()) && c2.verify(n2, f2.signature())) {
                  a2.add(s2), o2.splice(l2, 1);
                  break;
                }
              }
            }
          } catch (e4) {
            u2.e(e4);
          } finally {
            u2.f();
          }
          return Array.from(a2);
        }
      }, 5487: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Int128 = void 0;
        var o = r2(3740);
        function i(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, a(n2.key), n2);
          }
        }
        function a(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        function u(e3, t3, r3) {
          return t3 = c(t3), function(e4, t4) {
            if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, s() ? Reflect.construct(t3, r3 || [], c(e3).constructor) : t3.apply(e3, r3));
        }
        function s() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (s = function() {
            return !!e3;
          })();
        }
        function c(e3) {
          return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, c(e3);
        }
        function l(e3, t3) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, l(e3, t3);
        }
        (t2.Int128 = function(e3) {
          function t3() {
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            for (var e4 = arguments.length, r4 = new Array(e4), n3 = 0; n3 < e4; n3++) r4[n3] = arguments[n3];
            return u(this, t3, [r4]);
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && l(e4, t4);
          }(t3, e3), r3 = t3, (n2 = [{ key: "unsigned", get: function() {
            return false;
          } }, { key: "size", get: function() {
            return 128;
          } }]) && i(r3.prototype, n2), o2 && i(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(o.LargeInt)).defineIntBoundaries();
      }, 5546: (e2) => {
        e2.exports = function() {
          function e3(e4, t2, r2, n, o, i) {
            this.message = e4, this.expected = t2, this.found = r2, this.offset = n, this.line = o, this.column = i, this.name = "SyntaxError";
          }
          return function(e4, t2) {
            function r2() {
              this.constructor = e4;
            }
            r2.prototype = t2.prototype, e4.prototype = new r2();
          }(e3, Error), { SyntaxError: e3, parse: function(t2) {
            var r2, n = arguments.length > 1 ? arguments[1] : {}, o = {}, i = { start: Bt }, a = Bt, u = function() {
              return pr;
            }, s = o, c = "#", l = { type: "literal", value: "#", description: '"#"' }, f = void 0, p = { type: "any", description: "any character" }, d = "[", h = { type: "literal", value: "[", description: '"["' }, y = "]", m = { type: "literal", value: "]", description: '"]"' }, v = function(e4) {
              dr(hr("ObjectPath", e4, Pt, It));
            }, g = function(e4) {
              dr(hr("ArrayPath", e4, Pt, It));
            }, b = function(e4, t3) {
              return e4.concat(t3);
            }, w = function(e4) {
              return [e4];
            }, S = function(e4) {
              return e4;
            }, k = ".", E = { type: "literal", value: ".", description: '"."' }, _ = "=", T = { type: "literal", value: "=", description: '"="' }, O = function(e4, t3) {
              dr(hr("Assign", t3, Pt, It, e4));
            }, x = function(e4) {
              return e4.join("");
            }, A = function(e4) {
              return e4.value;
            }, P = '"""', I = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, R = null, C = function(e4) {
              return hr("String", e4.join(""), Pt, It);
            }, j = '"', B = { type: "literal", value: '"', description: '"\\""' }, L = "'''", N = { type: "literal", value: "'''", description: `"'''"` }, U = "'", M = { type: "literal", value: "'", description: `"'"` }, F = function(e4) {
              return e4;
            }, D = function(e4) {
              return e4;
            }, V = "\\", q = { type: "literal", value: "\\", description: '"\\\\"' }, K = function() {
              return "";
            }, H = "e", z = { type: "literal", value: "e", description: '"e"' }, X = "E", G = { type: "literal", value: "E", description: '"E"' }, $ = function(e4, t3) {
              return hr("Float", parseFloat(e4 + "e" + t3), Pt, It);
            }, Q = function(e4) {
              return hr("Float", parseFloat(e4), Pt, It);
            }, W = "+", Y = { type: "literal", value: "+", description: '"+"' }, J = function(e4) {
              return e4.join("");
            }, Z = "-", ee = { type: "literal", value: "-", description: '"-"' }, te = function(e4) {
              return "-" + e4.join("");
            }, re = function(e4) {
              return hr("Integer", parseInt(e4, 10), Pt, It);
            }, ne = "true", oe = { type: "literal", value: "true", description: '"true"' }, ie = function() {
              return hr("Boolean", true, Pt, It);
            }, ae = "false", ue = { type: "literal", value: "false", description: '"false"' }, se = function() {
              return hr("Boolean", false, Pt, It);
            }, ce = function() {
              return hr("Array", [], Pt, It);
            }, le = function(e4) {
              return hr("Array", e4 ? [e4] : [], Pt, It);
            }, fe = function(e4) {
              return hr("Array", e4, Pt, It);
            }, pe = function(e4, t3) {
              return hr("Array", e4.concat(t3), Pt, It);
            }, de = function(e4) {
              return e4;
            }, he = ",", ye = { type: "literal", value: ",", description: '","' }, me = "{", ve = { type: "literal", value: "{", description: '"{"' }, ge = "}", be = { type: "literal", value: "}", description: '"}"' }, we = function(e4) {
              return hr("InlineTable", e4, Pt, It);
            }, Se = function(e4, t3) {
              return hr("InlineTableValue", t3, Pt, It, e4);
            }, ke = function(e4) {
              return "." + e4;
            }, Ee = function(e4) {
              return e4.join("");
            }, _e = ":", Te = { type: "literal", value: ":", description: '":"' }, Oe = function(e4) {
              return e4.join("");
            }, xe = "T", Ae = { type: "literal", value: "T", description: '"T"' }, Pe = "Z", Ie = { type: "literal", value: "Z", description: '"Z"' }, Re = function(e4, t3) {
              return hr("Date", /* @__PURE__ */ new Date(e4 + "T" + t3 + "Z"), Pt, It);
            }, Ce = function(e4, t3) {
              return hr("Date", /* @__PURE__ */ new Date(e4 + "T" + t3), Pt, It);
            }, je = /^[ \t]/, Be = { type: "class", value: "[ \\t]", description: "[ \\t]" }, Le = "\n", Ne = { type: "literal", value: "\n", description: '"\\n"' }, Ue = "\r", Me = { type: "literal", value: "\r", description: '"\\r"' }, Fe = /^[0-9a-f]/i, De = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, Ve = /^[0-9]/, qe = { type: "class", value: "[0-9]", description: "[0-9]" }, Ke = "_", He = { type: "literal", value: "_", description: '"_"' }, ze = function() {
              return "";
            }, Xe = /^[A-Za-z0-9_\-]/, Ge = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, $e = function(e4) {
              return e4.join("");
            }, Qe = '\\"', We = { type: "literal", value: '\\"', description: '"\\\\\\""' }, Ye = function() {
              return '"';
            }, Je = "\\\\", Ze = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, et = function() {
              return "\\";
            }, tt = "\\b", rt = { type: "literal", value: "\\b", description: '"\\\\b"' }, nt = function() {
              return "\b";
            }, ot = "\\t", it = { type: "literal", value: "\\t", description: '"\\\\t"' }, at = function() {
              return "	";
            }, ut = "\\n", st = { type: "literal", value: "\\n", description: '"\\\\n"' }, ct = function() {
              return "\n";
            }, lt = "\\f", ft = { type: "literal", value: "\\f", description: '"\\\\f"' }, pt = function() {
              return "\f";
            }, dt = "\\r", ht = { type: "literal", value: "\\r", description: '"\\\\r"' }, yt = function() {
              return "\r";
            }, mt = "\\U", vt = { type: "literal", value: "\\U", description: '"\\\\U"' }, gt = function(e4) {
              return function(e5, t3, r3) {
                var n2 = parseInt("0x" + e5);
                if (!(!isFinite(n2) || Math.floor(n2) != n2 || n2 < 0 || n2 > 1114111 || n2 > 55295 && n2 < 57344)) return function() {
                  var e6, t4, r4 = 16384, n3 = [], o2 = -1, i2 = arguments.length;
                  if (!i2) return "";
                  var a2 = "";
                  for (; ++o2 < i2; ) {
                    var u2 = Number(arguments[o2]);
                    u2 <= 65535 ? n3.push(u2) : (e6 = 55296 + ((u2 -= 65536) >> 10), t4 = u2 % 1024 + 56320, n3.push(e6, t4)), (o2 + 1 == i2 || n3.length > r4) && (a2 += String.fromCharCode.apply(null, n3), n3.length = 0);
                  }
                  return a2;
                }(n2);
                !function(e6, t4, r4) {
                  var n3 = new Error(e6);
                  throw n3.line = t4, n3.column = r4, n3;
                }("Invalid Unicode escape code: " + e5, t3, r3);
              }(e4.join(""));
            }, bt = "\\u", wt = { type: "literal", value: "\\u", description: '"\\\\u"' }, St = 0, kt = 0, Et = 0, _t = { line: 1, column: 1, seenCR: false }, Tt = 0, Ot = [], xt = 0, At = {};
            if ("startRule" in n) {
              if (!(n.startRule in i)) throw new Error(`Can't start parsing from rule "` + n.startRule + '".');
              a = i[n.startRule];
            }
            function Pt() {
              return Rt(kt).line;
            }
            function It() {
              return Rt(kt).column;
            }
            function Rt(e4) {
              return Et !== e4 && (Et > e4 && (Et = 0, _t = { line: 1, column: 1, seenCR: false }), function(e5, r3, n2) {
                var o2, i2;
                for (o2 = r3; o2 < n2; o2++) "\n" === (i2 = t2.charAt(o2)) ? (e5.seenCR || e5.line++, e5.column = 1, e5.seenCR = false) : "\r" === i2 || "\u2028" === i2 || "\u2029" === i2 ? (e5.line++, e5.column = 1, e5.seenCR = true) : (e5.column++, e5.seenCR = false);
              }(_t, Et, e4), Et = e4), _t;
            }
            function Ct(e4) {
              St < Tt || (St > Tt && (Tt = St, Ot = []), Ot.push(e4));
            }
            function jt(r3, n2, o2) {
              var i2 = Rt(o2), a2 = o2 < t2.length ? t2.charAt(o2) : null;
              return null !== n2 && function(e4) {
                var t3 = 1;
                for (e4.sort(function(e5, t4) {
                  return e5.description < t4.description ? -1 : e5.description > t4.description ? 1 : 0;
                }); t3 < e4.length; ) e4[t3 - 1] === e4[t3] ? e4.splice(t3, 1) : t3++;
              }(n2), new e3(null !== r3 ? r3 : function(e4, t3) {
                var r4, n3 = new Array(e4.length);
                for (r4 = 0; r4 < e4.length; r4++) n3[r4] = e4[r4].description;
                return "Expected " + (e4.length > 1 ? n3.slice(0, -1).join(", ") + " or " + n3[e4.length - 1] : n3[0]) + " but " + (t3 ? '"' + function(e5) {
                  function t4(e6) {
                    return e6.charCodeAt(0).toString(16).toUpperCase();
                  }
                  return e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(e6) {
                    return "\\x0" + t4(e6);
                  }).replace(/[\x10-\x1F\x80-\xFF]/g, function(e6) {
                    return "\\x" + t4(e6);
                  }).replace(/[\u0180-\u0FFF]/g, function(e6) {
                    return "\\u0" + t4(e6);
                  }).replace(/[\u1080-\uFFFF]/g, function(e6) {
                    return "\\u" + t4(e6);
                  });
                }(t3) + '"' : "end of input") + " found.";
              }(n2, a2), n2, a2, o2, i2.line, i2.column);
            }
            function Bt() {
              var e4, t3, r3, n2 = 49 * St + 0, i2 = At[n2];
              if (i2) return St = i2.nextPos, i2.result;
              for (e4 = St, t3 = [], r3 = Lt(); r3 !== o; ) t3.push(r3), r3 = Lt();
              return t3 !== o && (kt = e4, t3 = u()), e4 = t3, At[n2] = { nextPos: St, result: e4 }, e4;
            }
            function Lt() {
              var e4, r3, n2, i2, a2, u2, c2, l2 = 49 * St + 1, f2 = At[l2];
              if (f2) return St = f2.nextPos, f2.result;
              for (e4 = St, r3 = [], n2 = nr(); n2 !== o; ) r3.push(n2), n2 = nr();
              if (r3 !== o) if (n2 = function() {
                var e5, r4 = 49 * St + 2, n3 = At[r4];
                if (n3) return St = n3.nextPos, n3.result;
                e5 = Nt(), e5 === o && (e5 = function() {
                  var e6, r5, n4, i3, a3, u3, c3 = 49 * St + 4, l3 = At[c3];
                  if (l3) return St = l3.nextPos, l3.result;
                  e6 = St, 91 === t2.charCodeAt(St) ? (r5 = d, St++) : (r5 = o, 0 === xt && Ct(h));
                  if (r5 !== o) {
                    for (n4 = [], i3 = nr(); i3 !== o; ) n4.push(i3), i3 = nr();
                    if (n4 !== o) if ((i3 = Ut()) !== o) {
                      for (a3 = [], u3 = nr(); u3 !== o; ) a3.push(u3), u3 = nr();
                      a3 !== o ? (93 === t2.charCodeAt(St) ? (u3 = y, St++) : (u3 = o, 0 === xt && Ct(m)), u3 !== o ? (kt = e6, e6 = r5 = v(i3)) : (St = e6, e6 = s)) : (St = e6, e6 = s);
                    } else St = e6, e6 = s;
                    else St = e6, e6 = s;
                  } else St = e6, e6 = s;
                  return At[c3] = { nextPos: St, result: e6 }, e6;
                }(), e5 === o && (e5 = function() {
                  var e6, r5, n4, i3, a3, u3, c3, l3, f3 = 49 * St + 5, p2 = At[f3];
                  if (p2) return St = p2.nextPos, p2.result;
                  e6 = St, 91 === t2.charCodeAt(St) ? (r5 = d, St++) : (r5 = o, 0 === xt && Ct(h));
                  if (r5 !== o) if (91 === t2.charCodeAt(St) ? (n4 = d, St++) : (n4 = o, 0 === xt && Ct(h)), n4 !== o) {
                    for (i3 = [], a3 = nr(); a3 !== o; ) i3.push(a3), a3 = nr();
                    if (i3 !== o) if ((a3 = Ut()) !== o) {
                      for (u3 = [], c3 = nr(); c3 !== o; ) u3.push(c3), c3 = nr();
                      u3 !== o ? (93 === t2.charCodeAt(St) ? (c3 = y, St++) : (c3 = o, 0 === xt && Ct(m)), c3 !== o ? (93 === t2.charCodeAt(St) ? (l3 = y, St++) : (l3 = o, 0 === xt && Ct(m)), l3 !== o ? (kt = e6, e6 = r5 = g(a3)) : (St = e6, e6 = s)) : (St = e6, e6 = s)) : (St = e6, e6 = s);
                    } else St = e6, e6 = s;
                    else St = e6, e6 = s;
                  } else St = e6, e6 = s;
                  else St = e6, e6 = s;
                  return At[f3] = { nextPos: St, result: e6 }, e6;
                }(), e5 === o && (e5 = function() {
                  var e6, r5, n4, i3, a3, u3, c3 = 49 * St + 9, l3 = At[c3];
                  if (l3) return St = l3.nextPos, l3.result;
                  if (e6 = St, r5 = Dt(), r5 !== o) {
                    for (n4 = [], i3 = nr(); i3 !== o; ) n4.push(i3), i3 = nr();
                    if (n4 !== o) if (61 === t2.charCodeAt(St) ? (i3 = _, St++) : (i3 = o, 0 === xt && Ct(T)), i3 !== o) {
                      for (a3 = [], u3 = nr(); u3 !== o; ) a3.push(u3), u3 = nr();
                      a3 !== o && (u3 = qt()) !== o ? (kt = e6, e6 = r5 = O(r5, u3)) : (St = e6, e6 = s);
                    } else St = e6, e6 = s;
                    else St = e6, e6 = s;
                  } else St = e6, e6 = s;
                  if (e6 === o) if (e6 = St, (r5 = Vt()) !== o) {
                    for (n4 = [], i3 = nr(); i3 !== o; ) n4.push(i3), i3 = nr();
                    if (n4 !== o) if (61 === t2.charCodeAt(St) ? (i3 = _, St++) : (i3 = o, 0 === xt && Ct(T)), i3 !== o) {
                      for (a3 = [], u3 = nr(); u3 !== o; ) a3.push(u3), u3 = nr();
                      a3 !== o && (u3 = qt()) !== o ? (kt = e6, e6 = r5 = O(r5, u3)) : (St = e6, e6 = s);
                    } else St = e6, e6 = s;
                    else St = e6, e6 = s;
                  } else St = e6, e6 = s;
                  return At[c3] = { nextPos: St, result: e6 }, e6;
                }())));
                return At[r4] = { nextPos: St, result: e5 }, e5;
              }(), n2 !== o) {
                for (i2 = [], a2 = nr(); a2 !== o; ) i2.push(a2), a2 = nr();
                if (i2 !== o) {
                  for (a2 = [], u2 = Nt(); u2 !== o; ) a2.push(u2), u2 = Nt();
                  if (a2 !== o) {
                    if (u2 = [], (c2 = or()) !== o) for (; c2 !== o; ) u2.push(c2), c2 = or();
                    else u2 = s;
                    u2 === o && (u2 = ar()), u2 !== o ? e4 = r3 = [r3, n2, i2, a2, u2] : (St = e4, e4 = s);
                  } else St = e4, e4 = s;
                } else St = e4, e4 = s;
              } else St = e4, e4 = s;
              else St = e4, e4 = s;
              if (e4 === o) {
                if (e4 = St, r3 = [], (n2 = nr()) !== o) for (; n2 !== o; ) r3.push(n2), n2 = nr();
                else r3 = s;
                if (r3 !== o) {
                  if (n2 = [], (i2 = or()) !== o) for (; i2 !== o; ) n2.push(i2), i2 = or();
                  else n2 = s;
                  n2 === o && (n2 = ar()), n2 !== o ? e4 = r3 = [r3, n2] : (St = e4, e4 = s);
                } else St = e4, e4 = s;
                e4 === o && (e4 = or());
              }
              return At[l2] = { nextPos: St, result: e4 }, e4;
            }
            function Nt() {
              var e4, r3, n2, i2, a2, u2, d2 = 49 * St + 3, h2 = At[d2];
              if (h2) return St = h2.nextPos, h2.result;
              if (e4 = St, 35 === t2.charCodeAt(St) ? (r3 = c, St++) : (r3 = o, 0 === xt && Ct(l)), r3 !== o) {
                for (n2 = [], i2 = St, a2 = St, xt++, (u2 = or()) === o && (u2 = ar()), xt--, u2 === o ? a2 = f : (St = a2, a2 = s), a2 !== o ? (t2.length > St ? (u2 = t2.charAt(St), St++) : (u2 = o, 0 === xt && Ct(p)), u2 !== o ? i2 = a2 = [a2, u2] : (St = i2, i2 = s)) : (St = i2, i2 = s); i2 !== o; ) n2.push(i2), i2 = St, a2 = St, xt++, (u2 = or()) === o && (u2 = ar()), xt--, u2 === o ? a2 = f : (St = a2, a2 = s), a2 !== o ? (t2.length > St ? (u2 = t2.charAt(St), St++) : (u2 = o, 0 === xt && Ct(p)), u2 !== o ? i2 = a2 = [a2, u2] : (St = i2, i2 = s)) : (St = i2, i2 = s);
                n2 !== o ? e4 = r3 = [r3, n2] : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              return At[d2] = { nextPos: St, result: e4 }, e4;
            }
            function Ut() {
              var e4, t3, r3, n2 = 49 * St + 6, i2 = At[n2];
              if (i2) return St = i2.nextPos, i2.result;
              if (e4 = St, t3 = [], (r3 = Ft()) !== o) for (; r3 !== o; ) t3.push(r3), r3 = Ft();
              else t3 = s;
              return t3 !== o && (r3 = Mt()) !== o ? (kt = e4, e4 = t3 = b(t3, r3)) : (St = e4, e4 = s), e4 === o && (e4 = St, (t3 = Mt()) !== o && (kt = e4, t3 = w(t3)), e4 = t3), At[n2] = { nextPos: St, result: e4 }, e4;
            }
            function Mt() {
              var e4, t3, r3, n2, i2, a2 = 49 * St + 7, u2 = At[a2];
              if (u2) return St = u2.nextPos, u2.result;
              for (e4 = St, t3 = [], r3 = nr(); r3 !== o; ) t3.push(r3), r3 = nr();
              if (t3 !== o) if ((r3 = Dt()) !== o) {
                for (n2 = [], i2 = nr(); i2 !== o; ) n2.push(i2), i2 = nr();
                n2 !== o ? (kt = e4, e4 = t3 = S(r3)) : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              else St = e4, e4 = s;
              if (e4 === o) {
                for (e4 = St, t3 = [], r3 = nr(); r3 !== o; ) t3.push(r3), r3 = nr();
                if (t3 !== o) if ((r3 = Vt()) !== o) {
                  for (n2 = [], i2 = nr(); i2 !== o; ) n2.push(i2), i2 = nr();
                  n2 !== o ? (kt = e4, e4 = t3 = S(r3)) : (St = e4, e4 = s);
                } else St = e4, e4 = s;
                else St = e4, e4 = s;
              }
              return At[a2] = { nextPos: St, result: e4 }, e4;
            }
            function Ft() {
              var e4, r3, n2, i2, a2, u2, c2, l2 = 49 * St + 8, f2 = At[l2];
              if (f2) return St = f2.nextPos, f2.result;
              for (e4 = St, r3 = [], n2 = nr(); n2 !== o; ) r3.push(n2), n2 = nr();
              if (r3 !== o) if ((n2 = Dt()) !== o) {
                for (i2 = [], a2 = nr(); a2 !== o; ) i2.push(a2), a2 = nr();
                if (i2 !== o) if (46 === t2.charCodeAt(St) ? (a2 = k, St++) : (a2 = o, 0 === xt && Ct(E)), a2 !== o) {
                  for (u2 = [], c2 = nr(); c2 !== o; ) u2.push(c2), c2 = nr();
                  u2 !== o ? (kt = e4, e4 = r3 = S(n2)) : (St = e4, e4 = s);
                } else St = e4, e4 = s;
                else St = e4, e4 = s;
              } else St = e4, e4 = s;
              else St = e4, e4 = s;
              if (e4 === o) {
                for (e4 = St, r3 = [], n2 = nr(); n2 !== o; ) r3.push(n2), n2 = nr();
                if (r3 !== o) if ((n2 = Vt()) !== o) {
                  for (i2 = [], a2 = nr(); a2 !== o; ) i2.push(a2), a2 = nr();
                  if (i2 !== o) if (46 === t2.charCodeAt(St) ? (a2 = k, St++) : (a2 = o, 0 === xt && Ct(E)), a2 !== o) {
                    for (u2 = [], c2 = nr(); c2 !== o; ) u2.push(c2), c2 = nr();
                    u2 !== o ? (kt = e4, e4 = r3 = S(n2)) : (St = e4, e4 = s);
                  } else St = e4, e4 = s;
                  else St = e4, e4 = s;
                } else St = e4, e4 = s;
                else St = e4, e4 = s;
              }
              return At[l2] = { nextPos: St, result: e4 }, e4;
            }
            function Dt() {
              var e4, t3, r3, n2 = 49 * St + 10, i2 = At[n2];
              if (i2) return St = i2.nextPos, i2.result;
              if (e4 = St, t3 = [], (r3 = cr()) !== o) for (; r3 !== o; ) t3.push(r3), r3 = cr();
              else t3 = s;
              return t3 !== o && (kt = e4, t3 = x(t3)), e4 = t3, At[n2] = { nextPos: St, result: e4 }, e4;
            }
            function Vt() {
              var e4, t3, r3 = 49 * St + 11, n2 = At[r3];
              return n2 ? (St = n2.nextPos, n2.result) : (e4 = St, (t3 = Kt()) !== o && (kt = e4, t3 = A(t3)), (e4 = t3) === o && (e4 = St, (t3 = Ht()) !== o && (kt = e4, t3 = A(t3)), e4 = t3), At[r3] = { nextPos: St, result: e4 }, e4);
            }
            function qt() {
              var e4, r3 = 49 * St + 12, n2 = At[r3];
              return n2 ? (St = n2.nextPos, n2.result) : (e4 = function() {
                var e5, r4 = 49 * St + 13, n3 = At[r4];
                if (n3) return St = n3.nextPos, n3.result;
                e5 = function() {
                  var e6, r5, n4, i2, a2, u2 = 49 * St + 14, c2 = At[u2];
                  if (c2) return St = c2.nextPos, c2.result;
                  e6 = St, t2.substr(St, 3) === P ? (r5 = P, St += 3) : (r5 = o, 0 === xt && Ct(I));
                  if (r5 !== o) if ((n4 = or()) === o && (n4 = R), n4 !== o) {
                    for (i2 = [], a2 = Gt(); a2 !== o; ) i2.push(a2), a2 = Gt();
                    i2 !== o ? (t2.substr(St, 3) === P ? (a2 = P, St += 3) : (a2 = o, 0 === xt && Ct(I)), a2 !== o ? (kt = e6, e6 = r5 = C(i2)) : (St = e6, e6 = s)) : (St = e6, e6 = s);
                  } else St = e6, e6 = s;
                  else St = e6, e6 = s;
                  return At[u2] = { nextPos: St, result: e6 }, e6;
                }(), e5 === o && (e5 = Kt()) === o && (e5 = function() {
                  var e6, r5, n4, i2, a2, u2 = 49 * St + 16, c2 = At[u2];
                  if (c2) return St = c2.nextPos, c2.result;
                  e6 = St, t2.substr(St, 3) === L ? (r5 = L, St += 3) : (r5 = o, 0 === xt && Ct(N));
                  if (r5 !== o) if ((n4 = or()) === o && (n4 = R), n4 !== o) {
                    for (i2 = [], a2 = $t(); a2 !== o; ) i2.push(a2), a2 = $t();
                    i2 !== o ? (t2.substr(St, 3) === L ? (a2 = L, St += 3) : (a2 = o, 0 === xt && Ct(N)), a2 !== o ? (kt = e6, e6 = r5 = C(i2)) : (St = e6, e6 = s)) : (St = e6, e6 = s);
                  } else St = e6, e6 = s;
                  else St = e6, e6 = s;
                  return At[u2] = { nextPos: St, result: e6 }, e6;
                }(), e5 === o && (e5 = Ht()));
                return At[r4] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = function() {
                var e5, r4, n3, i2, a2, u2 = 49 * St + 38, c2 = At[u2];
                if (c2) return St = c2.nextPos, c2.result;
                e5 = St, (r4 = rr()) !== o ? (84 === t2.charCodeAt(St) ? (n3 = xe, St++) : (n3 = o, 0 === xt && Ct(Ae)), n3 !== o ? (i2 = function() {
                  var e6, r5, n4, i3, a3, u3, c3, l2, f2, p2, d2, h2 = 49 * St + 36, y2 = At[h2];
                  if (y2) return St = y2.nextPos, y2.result;
                  e6 = St, r5 = St, n4 = sr(), n4 !== o && (i3 = sr()) !== o ? (58 === t2.charCodeAt(St) ? (a3 = _e, St++) : (a3 = o, 0 === xt && Ct(Te)), a3 !== o && (u3 = sr()) !== o && (c3 = sr()) !== o ? (58 === t2.charCodeAt(St) ? (l2 = _e, St++) : (l2 = o, 0 === xt && Ct(Te)), l2 !== o && (f2 = sr()) !== o && (p2 = sr()) !== o ? ((d2 = tr()) === o && (d2 = R), d2 !== o ? r5 = n4 = [n4, i3, a3, u3, c3, l2, f2, p2, d2] : (St = r5, r5 = s)) : (St = r5, r5 = s)) : (St = r5, r5 = s)) : (St = r5, r5 = s);
                  r5 !== o && (kt = e6, r5 = Oe(r5));
                  return e6 = r5, At[h2] = { nextPos: St, result: e6 }, e6;
                }(), i2 !== o ? (90 === t2.charCodeAt(St) ? (a2 = Pe, St++) : (a2 = o, 0 === xt && Ct(Ie)), a2 !== o ? (kt = e5, e5 = r4 = Re(r4, i2)) : (St = e5, e5 = s)) : (St = e5, e5 = s)) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                e5 === o && (e5 = St, (r4 = rr()) !== o ? (84 === t2.charCodeAt(St) ? (n3 = xe, St++) : (n3 = o, 0 === xt && Ct(Ae)), n3 !== o ? (i2 = function() {
                  var e6, r5, n4, i3, a3, u3, c3, l2, f2, p2, d2, h2, y2, m2, v2, g2, b2, w2 = 49 * St + 37, S2 = At[w2];
                  if (S2) return St = S2.nextPos, S2.result;
                  e6 = St, r5 = St, n4 = sr(), n4 !== o && (i3 = sr()) !== o ? (58 === t2.charCodeAt(St) ? (a3 = _e, St++) : (a3 = o, 0 === xt && Ct(Te)), a3 !== o && (u3 = sr()) !== o && (c3 = sr()) !== o ? (58 === t2.charCodeAt(St) ? (l2 = _e, St++) : (l2 = o, 0 === xt && Ct(Te)), l2 !== o && (f2 = sr()) !== o && (p2 = sr()) !== o ? ((d2 = tr()) === o && (d2 = R), d2 !== o ? (45 === t2.charCodeAt(St) ? (h2 = Z, St++) : (h2 = o, 0 === xt && Ct(ee)), h2 === o && (43 === t2.charCodeAt(St) ? (h2 = W, St++) : (h2 = o, 0 === xt && Ct(Y))), h2 !== o && (y2 = sr()) !== o && (m2 = sr()) !== o ? (58 === t2.charCodeAt(St) ? (v2 = _e, St++) : (v2 = o, 0 === xt && Ct(Te)), v2 !== o && (g2 = sr()) !== o && (b2 = sr()) !== o ? r5 = n4 = [n4, i3, a3, u3, c3, l2, f2, p2, d2, h2, y2, m2, v2, g2, b2] : (St = r5, r5 = s)) : (St = r5, r5 = s)) : (St = r5, r5 = s)) : (St = r5, r5 = s)) : (St = r5, r5 = s)) : (St = r5, r5 = s);
                  r5 !== o && (kt = e6, r5 = Oe(r5));
                  return e6 = r5, At[w2] = { nextPos: St, result: e6 }, e6;
                }(), i2 !== o ? (kt = e5, e5 = r4 = Ce(r4, i2)) : (St = e5, e5 = s)) : (St = e5, e5 = s)) : (St = e5, e5 = s));
                return At[u2] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = function() {
                var e5, r4, n3, i2, a2 = 49 * St + 23, u2 = At[a2];
                if (u2) return St = u2.nextPos, u2.result;
                e5 = St, (r4 = Qt()) === o && (r4 = Wt());
                r4 !== o ? (101 === t2.charCodeAt(St) ? (n3 = H, St++) : (n3 = o, 0 === xt && Ct(z)), n3 === o && (69 === t2.charCodeAt(St) ? (n3 = X, St++) : (n3 = o, 0 === xt && Ct(G))), n3 !== o && (i2 = Wt()) !== o ? (kt = e5, e5 = r4 = $(r4, i2)) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                e5 === o && (e5 = St, (r4 = Qt()) !== o && (kt = e5, r4 = Q(r4)), e5 = r4);
                return At[a2] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = function() {
                var e5, t3, r4 = 49 * St + 25, n3 = At[r4];
                if (n3) return St = n3.nextPos, n3.result;
                e5 = St, (t3 = Wt()) !== o && (kt = e5, t3 = re(t3));
                return e5 = t3, At[r4] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = function() {
                var e5, r4, n3 = 49 * St + 27, i2 = At[n3];
                if (i2) return St = i2.nextPos, i2.result;
                e5 = St, t2.substr(St, 4) === ne ? (r4 = ne, St += 4) : (r4 = o, 0 === xt && Ct(oe));
                r4 !== o && (kt = e5, r4 = ie());
                e5 = r4, e5 === o && (e5 = St, t2.substr(St, 5) === ae ? (r4 = ae, St += 5) : (r4 = o, 0 === xt && Ct(ue)), r4 !== o && (kt = e5, r4 = se()), e5 = r4);
                return At[n3] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = function() {
                var e5, r4, n3, i2, a2, u2 = 49 * St + 28, c2 = At[u2];
                if (c2) return St = c2.nextPos, c2.result;
                e5 = St, 91 === t2.charCodeAt(St) ? (r4 = d, St++) : (r4 = o, 0 === xt && Ct(h));
                if (r4 !== o) {
                  for (n3 = [], i2 = Zt(); i2 !== o; ) n3.push(i2), i2 = Zt();
                  n3 !== o ? (93 === t2.charCodeAt(St) ? (i2 = y, St++) : (i2 = o, 0 === xt && Ct(m)), i2 !== o ? (kt = e5, e5 = r4 = ce()) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                } else St = e5, e5 = s;
                if (e5 === o && (e5 = St, 91 === t2.charCodeAt(St) ? (r4 = d, St++) : (r4 = o, 0 === xt && Ct(h)), r4 !== o ? ((n3 = Yt()) === o && (n3 = R), n3 !== o ? (93 === t2.charCodeAt(St) ? (i2 = y, St++) : (i2 = o, 0 === xt && Ct(m)), i2 !== o ? (kt = e5, e5 = r4 = le(n3)) : (St = e5, e5 = s)) : (St = e5, e5 = s)) : (St = e5, e5 = s), e5 === o)) {
                  if (e5 = St, 91 === t2.charCodeAt(St) ? (r4 = d, St++) : (r4 = o, 0 === xt && Ct(h)), r4 !== o) {
                    if (n3 = [], (i2 = Jt()) !== o) for (; i2 !== o; ) n3.push(i2), i2 = Jt();
                    else n3 = s;
                    n3 !== o ? (93 === t2.charCodeAt(St) ? (i2 = y, St++) : (i2 = o, 0 === xt && Ct(m)), i2 !== o ? (kt = e5, e5 = r4 = fe(n3)) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                  } else St = e5, e5 = s;
                  if (e5 === o) if (e5 = St, 91 === t2.charCodeAt(St) ? (r4 = d, St++) : (r4 = o, 0 === xt && Ct(h)), r4 !== o) {
                    if (n3 = [], (i2 = Jt()) !== o) for (; i2 !== o; ) n3.push(i2), i2 = Jt();
                    else n3 = s;
                    n3 !== o && (i2 = Yt()) !== o ? (93 === t2.charCodeAt(St) ? (a2 = y, St++) : (a2 = o, 0 === xt && Ct(m)), a2 !== o ? (kt = e5, e5 = r4 = pe(n3, i2)) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                  } else St = e5, e5 = s;
                }
                return At[u2] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = function() {
                var e5, r4, n3, i2, a2, u2, c2 = 49 * St + 32, l2 = At[c2];
                if (l2) return St = l2.nextPos, l2.result;
                e5 = St, 123 === t2.charCodeAt(St) ? (r4 = me, St++) : (r4 = o, 0 === xt && Ct(ve));
                if (r4 !== o) {
                  for (n3 = [], i2 = nr(); i2 !== o; ) n3.push(i2), i2 = nr();
                  if (n3 !== o) {
                    for (i2 = [], a2 = er(); a2 !== o; ) i2.push(a2), a2 = er();
                    if (i2 !== o) {
                      for (a2 = [], u2 = nr(); u2 !== o; ) a2.push(u2), u2 = nr();
                      a2 !== o ? (125 === t2.charCodeAt(St) ? (u2 = ge, St++) : (u2 = o, 0 === xt && Ct(be)), u2 !== o ? (kt = e5, e5 = r4 = we(i2)) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                    } else St = e5, e5 = s;
                  } else St = e5, e5 = s;
                } else St = e5, e5 = s;
                return At[c2] = { nextPos: St, result: e5 }, e5;
              }())))))), At[r3] = { nextPos: St, result: e4 }, e4);
            }
            function Kt() {
              var e4, r3, n2, i2, a2 = 49 * St + 15, u2 = At[a2];
              if (u2) return St = u2.nextPos, u2.result;
              if (e4 = St, 34 === t2.charCodeAt(St) ? (r3 = j, St++) : (r3 = o, 0 === xt && Ct(B)), r3 !== o) {
                for (n2 = [], i2 = zt(); i2 !== o; ) n2.push(i2), i2 = zt();
                n2 !== o ? (34 === t2.charCodeAt(St) ? (i2 = j, St++) : (i2 = o, 0 === xt && Ct(B)), i2 !== o ? (kt = e4, e4 = r3 = C(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              return At[a2] = { nextPos: St, result: e4 }, e4;
            }
            function Ht() {
              var e4, r3, n2, i2, a2 = 49 * St + 17, u2 = At[a2];
              if (u2) return St = u2.nextPos, u2.result;
              if (e4 = St, 39 === t2.charCodeAt(St) ? (r3 = U, St++) : (r3 = o, 0 === xt && Ct(M)), r3 !== o) {
                for (n2 = [], i2 = Xt(); i2 !== o; ) n2.push(i2), i2 = Xt();
                n2 !== o ? (39 === t2.charCodeAt(St) ? (i2 = U, St++) : (i2 = o, 0 === xt && Ct(M)), i2 !== o ? (kt = e4, e4 = r3 = C(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              return At[a2] = { nextPos: St, result: e4 }, e4;
            }
            function zt() {
              var e4, r3, n2, i2 = 49 * St + 18, a2 = At[i2];
              return a2 ? (St = a2.nextPos, a2.result) : ((e4 = fr()) === o && (e4 = St, r3 = St, xt++, 34 === t2.charCodeAt(St) ? (n2 = j, St++) : (n2 = o, 0 === xt && Ct(B)), xt--, n2 === o ? r3 = f : (St = r3, r3 = s), r3 !== o ? (t2.length > St ? (n2 = t2.charAt(St), St++) : (n2 = o, 0 === xt && Ct(p)), n2 !== o ? (kt = e4, e4 = r3 = F(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s)), At[i2] = { nextPos: St, result: e4 }, e4);
            }
            function Xt() {
              var e4, r3, n2, i2 = 49 * St + 19, a2 = At[i2];
              return a2 ? (St = a2.nextPos, a2.result) : (e4 = St, r3 = St, xt++, 39 === t2.charCodeAt(St) ? (n2 = U, St++) : (n2 = o, 0 === xt && Ct(M)), xt--, n2 === o ? r3 = f : (St = r3, r3 = s), r3 !== o ? (t2.length > St ? (n2 = t2.charAt(St), St++) : (n2 = o, 0 === xt && Ct(p)), n2 !== o ? (kt = e4, e4 = r3 = F(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s), At[i2] = { nextPos: St, result: e4 }, e4);
            }
            function Gt() {
              var e4, r3, n2, i2 = 49 * St + 20, a2 = At[i2];
              return a2 ? (St = a2.nextPos, a2.result) : ((e4 = fr()) === o && (e4 = function() {
                var e5, r4, n3, i3, a3 = 49 * St + 21, u2 = At[a3];
                if (u2) return St = u2.nextPos, u2.result;
                e5 = St, 92 === t2.charCodeAt(St) ? (r4 = V, St++) : (r4 = o, 0 === xt && Ct(q));
                if (r4 !== o) if (or() !== o) {
                  for (n3 = [], i3 = ir(); i3 !== o; ) n3.push(i3), i3 = ir();
                  n3 !== o ? (kt = e5, e5 = r4 = K()) : (St = e5, e5 = s);
                } else St = e5, e5 = s;
                else St = e5, e5 = s;
                return At[a3] = { nextPos: St, result: e5 }, e5;
              }(), e4 === o && (e4 = St, r3 = St, xt++, t2.substr(St, 3) === P ? (n2 = P, St += 3) : (n2 = o, 0 === xt && Ct(I)), xt--, n2 === o ? r3 = f : (St = r3, r3 = s), r3 !== o ? (t2.length > St ? (n2 = t2.charAt(St), St++) : (n2 = o, 0 === xt && Ct(p)), n2 !== o ? (kt = e4, e4 = r3 = D(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s))), At[i2] = { nextPos: St, result: e4 }, e4);
            }
            function $t() {
              var e4, r3, n2, i2 = 49 * St + 22, a2 = At[i2];
              return a2 ? (St = a2.nextPos, a2.result) : (e4 = St, r3 = St, xt++, t2.substr(St, 3) === L ? (n2 = L, St += 3) : (n2 = o, 0 === xt && Ct(N)), xt--, n2 === o ? r3 = f : (St = r3, r3 = s), r3 !== o ? (t2.length > St ? (n2 = t2.charAt(St), St++) : (n2 = o, 0 === xt && Ct(p)), n2 !== o ? (kt = e4, e4 = r3 = F(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s), At[i2] = { nextPos: St, result: e4 }, e4);
            }
            function Qt() {
              var e4, r3, n2, i2, a2, u2, c2 = 49 * St + 24, l2 = At[c2];
              return l2 ? (St = l2.nextPos, l2.result) : (e4 = St, 43 === t2.charCodeAt(St) ? (r3 = W, St++) : (r3 = o, 0 === xt && Ct(Y)), r3 === o && (r3 = R), r3 !== o ? (n2 = St, (i2 = lr()) !== o ? (46 === t2.charCodeAt(St) ? (a2 = k, St++) : (a2 = o, 0 === xt && Ct(E)), a2 !== o && (u2 = lr()) !== o ? n2 = i2 = [i2, a2, u2] : (St = n2, n2 = s)) : (St = n2, n2 = s), n2 !== o ? (kt = e4, e4 = r3 = J(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s), e4 === o && (e4 = St, 45 === t2.charCodeAt(St) ? (r3 = Z, St++) : (r3 = o, 0 === xt && Ct(ee)), r3 !== o ? (n2 = St, (i2 = lr()) !== o ? (46 === t2.charCodeAt(St) ? (a2 = k, St++) : (a2 = o, 0 === xt && Ct(E)), a2 !== o && (u2 = lr()) !== o ? n2 = i2 = [i2, a2, u2] : (St = n2, n2 = s)) : (St = n2, n2 = s), n2 !== o ? (kt = e4, e4 = r3 = te(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s)), At[c2] = { nextPos: St, result: e4 }, e4);
            }
            function Wt() {
              var e4, r3, n2, i2, a2, u2 = 49 * St + 26, c2 = At[u2];
              if (c2) return St = c2.nextPos, c2.result;
              if (e4 = St, 43 === t2.charCodeAt(St) ? (r3 = W, St++) : (r3 = o, 0 === xt && Ct(Y)), r3 === o && (r3 = R), r3 !== o) {
                if (n2 = [], (i2 = sr()) !== o) for (; i2 !== o; ) n2.push(i2), i2 = sr();
                else n2 = s;
                n2 !== o ? (i2 = St, xt++, 46 === t2.charCodeAt(St) ? (a2 = k, St++) : (a2 = o, 0 === xt && Ct(E)), xt--, a2 === o ? i2 = f : (St = i2, i2 = s), i2 !== o ? (kt = e4, e4 = r3 = J(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              if (e4 === o) if (e4 = St, 45 === t2.charCodeAt(St) ? (r3 = Z, St++) : (r3 = o, 0 === xt && Ct(ee)), r3 !== o) {
                if (n2 = [], (i2 = sr()) !== o) for (; i2 !== o; ) n2.push(i2), i2 = sr();
                else n2 = s;
                n2 !== o ? (i2 = St, xt++, 46 === t2.charCodeAt(St) ? (a2 = k, St++) : (a2 = o, 0 === xt && Ct(E)), xt--, a2 === o ? i2 = f : (St = i2, i2 = s), i2 !== o ? (kt = e4, e4 = r3 = te(n2)) : (St = e4, e4 = s)) : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              return At[u2] = { nextPos: St, result: e4 }, e4;
            }
            function Yt() {
              var e4, t3, r3, n2, i2, a2 = 49 * St + 29, u2 = At[a2];
              if (u2) return St = u2.nextPos, u2.result;
              for (e4 = St, t3 = [], r3 = Zt(); r3 !== o; ) t3.push(r3), r3 = Zt();
              if (t3 !== o) if ((r3 = qt()) !== o) {
                for (n2 = [], i2 = Zt(); i2 !== o; ) n2.push(i2), i2 = Zt();
                n2 !== o ? (kt = e4, e4 = t3 = de(r3)) : (St = e4, e4 = s);
              } else St = e4, e4 = s;
              else St = e4, e4 = s;
              return At[a2] = { nextPos: St, result: e4 }, e4;
            }
            function Jt() {
              var e4, r3, n2, i2, a2, u2, c2, l2 = 49 * St + 30, f2 = At[l2];
              if (f2) return St = f2.nextPos, f2.result;
              for (e4 = St, r3 = [], n2 = Zt(); n2 !== o; ) r3.push(n2), n2 = Zt();
              if (r3 !== o) if ((n2 = qt()) !== o) {
                for (i2 = [], a2 = Zt(); a2 !== o; ) i2.push(a2), a2 = Zt();
                if (i2 !== o) if (44 === t2.charCodeAt(St) ? (a2 = he, St++) : (a2 = o, 0 === xt && Ct(ye)), a2 !== o) {
                  for (u2 = [], c2 = Zt(); c2 !== o; ) u2.push(c2), c2 = Zt();
                  u2 !== o ? (kt = e4, e4 = r3 = de(n2)) : (St = e4, e4 = s);
                } else St = e4, e4 = s;
                else St = e4, e4 = s;
              } else St = e4, e4 = s;
              else St = e4, e4 = s;
              return At[l2] = { nextPos: St, result: e4 }, e4;
            }
            function Zt() {
              var e4, t3 = 49 * St + 31, r3 = At[t3];
              return r3 ? (St = r3.nextPos, r3.result) : ((e4 = nr()) === o && (e4 = or()) === o && (e4 = Nt()), At[t3] = { nextPos: St, result: e4 }, e4);
            }
            function er() {
              var e4, r3, n2, i2, a2, u2, c2, l2, f2, p2, d2, h2 = 49 * St + 33, y2 = At[h2];
              if (y2) return St = y2.nextPos, y2.result;
              for (e4 = St, r3 = [], n2 = nr(); n2 !== o; ) r3.push(n2), n2 = nr();
              if (r3 !== o) if ((n2 = Dt()) !== o) {
                for (i2 = [], a2 = nr(); a2 !== o; ) i2.push(a2), a2 = nr();
                if (i2 !== o) if (61 === t2.charCodeAt(St) ? (a2 = _, St++) : (a2 = o, 0 === xt && Ct(T)), a2 !== o) {
                  for (u2 = [], c2 = nr(); c2 !== o; ) u2.push(c2), c2 = nr();
                  if (u2 !== o) if ((c2 = qt()) !== o) {
                    for (l2 = [], f2 = nr(); f2 !== o; ) l2.push(f2), f2 = nr();
                    if (l2 !== o) if (44 === t2.charCodeAt(St) ? (f2 = he, St++) : (f2 = o, 0 === xt && Ct(ye)), f2 !== o) {
                      for (p2 = [], d2 = nr(); d2 !== o; ) p2.push(d2), d2 = nr();
                      p2 !== o ? (kt = e4, e4 = r3 = Se(n2, c2)) : (St = e4, e4 = s);
                    } else St = e4, e4 = s;
                    else St = e4, e4 = s;
                  } else St = e4, e4 = s;
                  else St = e4, e4 = s;
                } else St = e4, e4 = s;
                else St = e4, e4 = s;
              } else St = e4, e4 = s;
              else St = e4, e4 = s;
              if (e4 === o) {
                for (e4 = St, r3 = [], n2 = nr(); n2 !== o; ) r3.push(n2), n2 = nr();
                if (r3 !== o) if ((n2 = Dt()) !== o) {
                  for (i2 = [], a2 = nr(); a2 !== o; ) i2.push(a2), a2 = nr();
                  if (i2 !== o) if (61 === t2.charCodeAt(St) ? (a2 = _, St++) : (a2 = o, 0 === xt && Ct(T)), a2 !== o) {
                    for (u2 = [], c2 = nr(); c2 !== o; ) u2.push(c2), c2 = nr();
                    u2 !== o && (c2 = qt()) !== o ? (kt = e4, e4 = r3 = Se(n2, c2)) : (St = e4, e4 = s);
                  } else St = e4, e4 = s;
                  else St = e4, e4 = s;
                } else St = e4, e4 = s;
                else St = e4, e4 = s;
              }
              return At[h2] = { nextPos: St, result: e4 }, e4;
            }
            function tr() {
              var e4, r3, n2, i2 = 49 * St + 34, a2 = At[i2];
              return a2 ? (St = a2.nextPos, a2.result) : (e4 = St, 46 === t2.charCodeAt(St) ? (r3 = k, St++) : (r3 = o, 0 === xt && Ct(E)), r3 !== o && (n2 = lr()) !== o ? (kt = e4, e4 = r3 = ke(n2)) : (St = e4, e4 = s), At[i2] = { nextPos: St, result: e4 }, e4);
            }
            function rr() {
              var e4, r3, n2, i2, a2, u2, c2, l2, f2, p2, d2, h2, y2 = 49 * St + 35, m2 = At[y2];
              return m2 ? (St = m2.nextPos, m2.result) : (e4 = St, r3 = St, (n2 = sr()) !== o && (i2 = sr()) !== o && (a2 = sr()) !== o && (u2 = sr()) !== o ? (45 === t2.charCodeAt(St) ? (c2 = Z, St++) : (c2 = o, 0 === xt && Ct(ee)), c2 !== o && (l2 = sr()) !== o && (f2 = sr()) !== o ? (45 === t2.charCodeAt(St) ? (p2 = Z, St++) : (p2 = o, 0 === xt && Ct(ee)), p2 !== o && (d2 = sr()) !== o && (h2 = sr()) !== o ? r3 = n2 = [n2, i2, a2, u2, c2, l2, f2, p2, d2, h2] : (St = r3, r3 = s)) : (St = r3, r3 = s)) : (St = r3, r3 = s), r3 !== o && (kt = e4, r3 = Ee(r3)), e4 = r3, At[y2] = { nextPos: St, result: e4 }, e4);
            }
            function nr() {
              var e4, r3 = 49 * St + 39, n2 = At[r3];
              return n2 ? (St = n2.nextPos, n2.result) : (je.test(t2.charAt(St)) ? (e4 = t2.charAt(St), St++) : (e4 = o, 0 === xt && Ct(Be)), At[r3] = { nextPos: St, result: e4 }, e4);
            }
            function or() {
              var e4, r3, n2, i2 = 49 * St + 40, a2 = At[i2];
              return a2 ? (St = a2.nextPos, a2.result) : (10 === t2.charCodeAt(St) ? (e4 = Le, St++) : (e4 = o, 0 === xt && Ct(Ne)), e4 === o && (e4 = St, 13 === t2.charCodeAt(St) ? (r3 = Ue, St++) : (r3 = o, 0 === xt && Ct(Me)), r3 !== o ? (10 === t2.charCodeAt(St) ? (n2 = Le, St++) : (n2 = o, 0 === xt && Ct(Ne)), n2 !== o ? e4 = r3 = [r3, n2] : (St = e4, e4 = s)) : (St = e4, e4 = s)), At[i2] = { nextPos: St, result: e4 }, e4);
            }
            function ir() {
              var e4, t3 = 49 * St + 41, r3 = At[t3];
              return r3 ? (St = r3.nextPos, r3.result) : ((e4 = or()) === o && (e4 = nr()), At[t3] = { nextPos: St, result: e4 }, e4);
            }
            function ar() {
              var e4, r3, n2 = 49 * St + 42, i2 = At[n2];
              return i2 ? (St = i2.nextPos, i2.result) : (e4 = St, xt++, t2.length > St ? (r3 = t2.charAt(St), St++) : (r3 = o, 0 === xt && Ct(p)), xt--, r3 === o ? e4 = f : (St = e4, e4 = s), At[n2] = { nextPos: St, result: e4 }, e4);
            }
            function ur() {
              var e4, r3 = 49 * St + 43, n2 = At[r3];
              return n2 ? (St = n2.nextPos, n2.result) : (Fe.test(t2.charAt(St)) ? (e4 = t2.charAt(St), St++) : (e4 = o, 0 === xt && Ct(De)), At[r3] = { nextPos: St, result: e4 }, e4);
            }
            function sr() {
              var e4, r3, n2 = 49 * St + 44, i2 = At[n2];
              return i2 ? (St = i2.nextPos, i2.result) : (Ve.test(t2.charAt(St)) ? (e4 = t2.charAt(St), St++) : (e4 = o, 0 === xt && Ct(qe)), e4 === o && (e4 = St, 95 === t2.charCodeAt(St) ? (r3 = Ke, St++) : (r3 = o, 0 === xt && Ct(He)), r3 !== o && (kt = e4, r3 = ze()), e4 = r3), At[n2] = { nextPos: St, result: e4 }, e4);
            }
            function cr() {
              var e4, r3 = 49 * St + 45, n2 = At[r3];
              return n2 ? (St = n2.nextPos, n2.result) : (Xe.test(t2.charAt(St)) ? (e4 = t2.charAt(St), St++) : (e4 = o, 0 === xt && Ct(Ge)), At[r3] = { nextPos: St, result: e4 }, e4);
            }
            function lr() {
              var e4, t3, r3, n2 = 49 * St + 46, i2 = At[n2];
              if (i2) return St = i2.nextPos, i2.result;
              if (e4 = St, t3 = [], (r3 = sr()) !== o) for (; r3 !== o; ) t3.push(r3), r3 = sr();
              else t3 = s;
              return t3 !== o && (kt = e4, t3 = $e(t3)), e4 = t3, At[n2] = { nextPos: St, result: e4 }, e4;
            }
            function fr() {
              var e4, r3, n2 = 49 * St + 47, i2 = At[n2];
              return i2 ? (St = i2.nextPos, i2.result) : (e4 = St, t2.substr(St, 2) === Qe ? (r3 = Qe, St += 2) : (r3 = o, 0 === xt && Ct(We)), r3 !== o && (kt = e4, r3 = Ye()), (e4 = r3) === o && (e4 = St, t2.substr(St, 2) === Je ? (r3 = Je, St += 2) : (r3 = o, 0 === xt && Ct(Ze)), r3 !== o && (kt = e4, r3 = et()), (e4 = r3) === o && (e4 = St, t2.substr(St, 2) === tt ? (r3 = tt, St += 2) : (r3 = o, 0 === xt && Ct(rt)), r3 !== o && (kt = e4, r3 = nt()), (e4 = r3) === o && (e4 = St, t2.substr(St, 2) === ot ? (r3 = ot, St += 2) : (r3 = o, 0 === xt && Ct(it)), r3 !== o && (kt = e4, r3 = at()), (e4 = r3) === o && (e4 = St, t2.substr(St, 2) === ut ? (r3 = ut, St += 2) : (r3 = o, 0 === xt && Ct(st)), r3 !== o && (kt = e4, r3 = ct()), (e4 = r3) === o && (e4 = St, t2.substr(St, 2) === lt ? (r3 = lt, St += 2) : (r3 = o, 0 === xt && Ct(ft)), r3 !== o && (kt = e4, r3 = pt()), (e4 = r3) === o && (e4 = St, t2.substr(St, 2) === dt ? (r3 = dt, St += 2) : (r3 = o, 0 === xt && Ct(ht)), r3 !== o && (kt = e4, r3 = yt()), (e4 = r3) === o && (e4 = function() {
                var e5, r4, n3, i3, a2, u2, c2, l2, f2, p2, d2, h2 = 49 * St + 48, y2 = At[h2];
                if (y2) return St = y2.nextPos, y2.result;
                e5 = St, t2.substr(St, 2) === mt ? (r4 = mt, St += 2) : (r4 = o, 0 === xt && Ct(vt));
                r4 !== o ? (n3 = St, (i3 = ur()) !== o && (a2 = ur()) !== o && (u2 = ur()) !== o && (c2 = ur()) !== o && (l2 = ur()) !== o && (f2 = ur()) !== o && (p2 = ur()) !== o && (d2 = ur()) !== o ? n3 = i3 = [i3, a2, u2, c2, l2, f2, p2, d2] : (St = n3, n3 = s), n3 !== o ? (kt = e5, e5 = r4 = gt(n3)) : (St = e5, e5 = s)) : (St = e5, e5 = s);
                e5 === o && (e5 = St, t2.substr(St, 2) === bt ? (r4 = bt, St += 2) : (r4 = o, 0 === xt && Ct(wt)), r4 !== o ? (n3 = St, (i3 = ur()) !== o && (a2 = ur()) !== o && (u2 = ur()) !== o && (c2 = ur()) !== o ? n3 = i3 = [i3, a2, u2, c2] : (St = n3, n3 = s), n3 !== o ? (kt = e5, e5 = r4 = gt(n3)) : (St = e5, e5 = s)) : (St = e5, e5 = s));
                return At[h2] = { nextPos: St, result: e5 }, e5;
              }()))))))), At[n2] = { nextPos: St, result: e4 }, e4);
            }
            var pr = [];
            function dr(e4) {
              pr.push(e4);
            }
            function hr(e4, t3, r3, n2, o2) {
              var i2 = { type: e4, value: t3, line: r3(), column: n2() };
              return o2 && (i2.key = o2), i2;
            }
            if ((r2 = a()) !== o && St === t2.length) return r2;
            throw r2 !== o && St < t2.length && Ct({ type: "end", description: "end of input" }), jt(null, Ot, Tt);
          } };
        }();
      }, 5578: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LiquidityPoolFeeV18 = void 0, t2.getLiquidityPoolId = function(e3) {
          var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("constant_product" !== e3) throw new Error("liquidityPoolType is invalid");
          var r3 = t3.assetA, o2 = t3.assetB, c = t3.fee;
          if (!(r3 && r3 instanceof a.Asset)) throw new Error("assetA is invalid");
          if (!(o2 && o2 instanceof a.Asset)) throw new Error("assetB is invalid");
          if (!c || c !== s) throw new Error("fee is invalid");
          if (-1 !== a.Asset.compare(r3, o2)) throw new Error("Assets are not in lexicographic order");
          var l = i.default.LiquidityPoolType.liquidityPoolConstantProduct().toXDR(), f = new i.default.LiquidityPoolConstantProductParameters({ assetA: r3.toXDRObject(), assetB: o2.toXDRObject(), fee: c }).toXDR(), p = n.concat([l, f]);
          return (0, u.hash)(p);
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(1764), u = r2(9152);
        var s = t2.LiquidityPoolFeeV18 = 30;
      }, 5798: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        function o(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, i(n2.key), n2);
          }
        }
        function i(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        r2.d(t2, { q: () => c });
        var a, u, s, c = (a = function e3(t3) {
          var r3, n2 = this;
          !function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), this.promise = new Promise(function(e4) {
            r3 = e4;
          }), t3(function(e4) {
            n2.reason = e4, r3();
          });
        }, (u = [{ key: "throwIfRequested", value: function() {
          if (this.reason) throw new Error(this.reason);
        } }]) && o(a.prototype, u), s && o(a, s), Object.defineProperty(a, "prototype", { writable: false }), a);
      }, 5976: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        function o(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, i(n2.key), n2);
          }
        }
        function i(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        function a(e3, t3, r3) {
          return t3 = l(t3), function(e4, t4) {
            if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, s() ? Reflect.construct(t3, r3 || [], l(e3).constructor) : t3.apply(e3, r3));
        }
        function u(e3) {
          var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return u = function(e4) {
            if (null === e4 || !function(e5) {
              try {
                return -1 !== Function.toString.call(e5).indexOf("[native code]");
              } catch (t4) {
                return "function" == typeof e5;
              }
            }(e4)) return e4;
            if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t3) {
              if (t3.has(e4)) return t3.get(e4);
              t3.set(e4, r3);
            }
            function r3() {
              return function(e5, t4, r4) {
                if (s()) return Reflect.construct.apply(null, arguments);
                var n2 = [null];
                n2.push.apply(n2, t4);
                var o2 = new (e5.bind.apply(e5, n2))();
                return r4 && c(o2, r4.prototype), o2;
              }(e4, arguments, l(this).constructor);
            }
            return r3.prototype = Object.create(e4.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), c(r3, e4);
          }, u(e3);
        }
        function s() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (s = function() {
            return !!e3;
          })();
        }
        function c(e3, t3) {
          return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, c(e3, t3);
        }
        function l(e3) {
          return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, l(e3);
        }
        r2.d(t2, { Cu: () => H, v7: () => x, nS: () => L, Dr: () => f, m_: () => b });
        var f = function(e3) {
          function t3(e4, r4) {
            var n3;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var o2 = (this instanceof t3 ? this.constructor : void 0).prototype;
            return (n3 = a(this, t3, [e4])).__proto__ = o2, n3.constructor = t3, n3.response = r4, n3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && c(e4, t4);
          }(t3, e3), r3 = t3, (n2 = [{ key: "getResponse", value: function() {
            return this.response;
          } }]) && o(r3.prototype, n2), i2 && o(r3, i2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, i2;
        }(u(Error));
        function p(e3) {
          return p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, p(e3);
        }
        function d(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, h(n2.key), n2);
          }
        }
        function h(e3) {
          var t3 = function(e4, t4) {
            if ("object" != p(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != p(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == p(t3) ? t3 : t3 + "";
        }
        function y(e3, t3, r3) {
          return t3 = v(t3), function(e4, t4) {
            if (t4 && ("object" == p(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, m() ? Reflect.construct(t3, r3 || [], v(e3).constructor) : t3.apply(e3, r3));
        }
        function m() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (m = function() {
            return !!e3;
          })();
        }
        function v(e3) {
          return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, v(e3);
        }
        function g(e3, t3) {
          return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, g(e3, t3);
        }
        var b = function(e3) {
          function t3(e4, r4) {
            var n3;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var o3 = (this instanceof t3 ? this.constructor : void 0).prototype;
            return (n3 = y(this, t3, [e4, r4])).__proto__ = o3, n3.constructor = t3, n3.name = "NotFoundError", n3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && g(e4, t4);
          }(t3, e3), r3 = t3, n2 && d(r3.prototype, n2), o2 && d(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(f);
        function w(e3) {
          return w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, w(e3);
        }
        function S(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, k(n2.key), n2);
          }
        }
        function k(e3) {
          var t3 = function(e4, t4) {
            if ("object" != w(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != w(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == w(t3) ? t3 : t3 + "";
        }
        function E(e3, t3, r3) {
          return t3 = T(t3), function(e4, t4) {
            if (t4 && ("object" == w(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, _() ? Reflect.construct(t3, r3 || [], T(e3).constructor) : t3.apply(e3, r3));
        }
        function _() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (_ = function() {
            return !!e3;
          })();
        }
        function T(e3) {
          return T = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, T(e3);
        }
        function O(e3, t3) {
          return O = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, O(e3, t3);
        }
        var x = function(e3) {
          function t3(e4, r4) {
            var n3;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var o3 = (this instanceof t3 ? this.constructor : void 0).prototype;
            return (n3 = E(this, t3, [e4, r4])).__proto__ = o3, n3.constructor = t3, n3.name = "BadRequestError", n3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && O(e4, t4);
          }(t3, e3), r3 = t3, n2 && S(r3.prototype, n2), o2 && S(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(f);
        function A(e3) {
          return A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, A(e3);
        }
        function P(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, I(n2.key), n2);
          }
        }
        function I(e3) {
          var t3 = function(e4, t4) {
            if ("object" != A(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != A(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == A(t3) ? t3 : t3 + "";
        }
        function R(e3, t3, r3) {
          return t3 = j(t3), function(e4, t4) {
            if (t4 && ("object" == A(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, C() ? Reflect.construct(t3, r3 || [], j(e3).constructor) : t3.apply(e3, r3));
        }
        function C() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (C = function() {
            return !!e3;
          })();
        }
        function j(e3) {
          return j = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, j(e3);
        }
        function B(e3, t3) {
          return B = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, B(e3, t3);
        }
        var L = function(e3) {
          function t3(e4, r4) {
            var n3;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var o3 = (this instanceof t3 ? this.constructor : void 0).prototype;
            return (n3 = R(this, t3, [e4, r4])).__proto__ = o3, n3.constructor = t3, n3.name = "BadResponseError", n3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && B(e4, t4);
          }(t3, e3), r3 = t3, n2 && P(r3.prototype, n2), o2 && P(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(f);
        function N(e3) {
          return N = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, N(e3);
        }
        function U(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, M(n2.key), n2);
          }
        }
        function M(e3) {
          var t3 = function(e4, t4) {
            if ("object" != N(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != N(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == N(t3) ? t3 : t3 + "";
        }
        function F(e3, t3, r3) {
          return t3 = K(t3), function(e4, t4) {
            if (t4 && ("object" == N(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, V() ? Reflect.construct(t3, r3 || [], K(e3).constructor) : t3.apply(e3, r3));
        }
        function D(e3) {
          var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return D = function(e4) {
            if (null === e4 || !function(e5) {
              try {
                return -1 !== Function.toString.call(e5).indexOf("[native code]");
              } catch (t4) {
                return "function" == typeof e5;
              }
            }(e4)) return e4;
            if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t3) {
              if (t3.has(e4)) return t3.get(e4);
              t3.set(e4, r3);
            }
            function r3() {
              return function(e5, t4, r4) {
                if (V()) return Reflect.construct.apply(null, arguments);
                var n2 = [null];
                n2.push.apply(n2, t4);
                var o2 = new (e5.bind.apply(e5, n2))();
                return r4 && q(o2, r4.prototype), o2;
              }(e4, arguments, K(this).constructor);
            }
            return r3.prototype = Object.create(e4.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), q(r3, e4);
          }, D(e3);
        }
        function V() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (V = function() {
            return !!e3;
          })();
        }
        function q(e3, t3) {
          return q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, q(e3, t3);
        }
        function K(e3) {
          return K = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, K(e3);
        }
        var H = function(e3) {
          function t3(e4, r4, n3) {
            var o3;
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            var i2 = (this instanceof t3 ? this.constructor : void 0).prototype;
            return (o3 = F(this, t3, [e4])).__proto__ = i2, o3.constructor = t3, o3.name = "AccountRequiresMemoError", o3.accountId = r4, o3.operationIndex = n3, o3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && q(e4, t4);
          }(t3, e3), r3 = t3, n2 && U(r3.prototype, n2), o2 && U(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(D(Error));
      }, 6160: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.decodeAddressToMuxedAccount = u, t2.encodeMuxedAccount = function(e3, t3) {
          if (!a.StrKey.isValidEd25519PublicKey(e3)) throw new Error("address should be a Stellar account ID (G...)");
          if ("string" != typeof t3) throw new Error("id should be a string representing a number (uint64)");
          return i.default.MuxedAccount.keyTypeMuxedEd25519(new i.default.MuxedAccountMed25519({ id: i.default.Uint64.fromString(t3), ed25519: a.StrKey.decodeEd25519PublicKey(e3) }));
        }, t2.encodeMuxedAccountToAddress = s, t2.extractBaseAddress = function(e3) {
          if (a.StrKey.isValidEd25519PublicKey(e3)) return e3;
          if (!a.StrKey.isValidMed25519PublicKey(e3)) throw new TypeError("expected muxed account (M...), got ".concat(e3));
          var t3 = u(e3);
          return a.StrKey.encodeEd25519PublicKey(t3.med25519().ed25519());
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(7120);
        function u(e3) {
          return a.StrKey.isValidMed25519PublicKey(e3) ? function(e4) {
            var t3 = a.StrKey.decodeMed25519PublicKey(e4);
            return i.default.MuxedAccount.keyTypeMuxedEd25519(new i.default.MuxedAccountMed25519({ id: i.default.Uint64.fromXDR(t3.subarray(-8)), ed25519: t3.subarray(0, -8) }));
          }(e3) : i.default.MuxedAccount.keyTypeEd25519(a.StrKey.decodeEd25519PublicKey(e3));
        }
        function s(e3) {
          return e3.switch().value === i.default.CryptoKeyType.keyTypeMuxedEd25519().value ? function(e4) {
            if (e4.switch() === i.default.CryptoKeyType.keyTypeEd25519()) return s(e4);
            var t3 = e4.med25519();
            return a.StrKey.encodeMed25519PublicKey(n.concat([t3.ed25519(), t3.id().toXDR("raw")]));
          }(e3) : a.StrKey.encodeEd25519PublicKey(e3.ed25519());
        }
      }, 6183: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.bumpSequence = function(e3) {
          var t3 = {};
          if ("string" != typeof e3.bumpTo) throw new Error("bumpTo must be a string");
          try {
            new o.default(e3.bumpTo);
          } catch (e4) {
            throw new Error("bumpTo must be a stringified number");
          }
          t3.bumpTo = n.Hyper.fromString(e3.bumpTo);
          var r3 = new i.default.BumpSequenceOp(t3), a2 = {};
          return a2.body = i.default.OperationBody.bumpSequence(r3), this.setSourceAccount(a2, e3), new i.default.Operation(a2);
        };
        var n = r2(3740), o = a(r2(1242)), i = a(r2(1918));
        function a(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
      }, 6202: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Networks = void 0;
        t2.Networks = { PUBLIC: "Public Global Stellar Network ; September 2015", TESTNET: "Test SDF Network ; September 2015", FUTURENET: "Test SDF Future Network ; October 2022", SANDBOX: "Local Sandbox Stellar Network ; September 2022", STANDALONE: "Standalone Network ; February 2017" };
      }, 6272: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Uint128 = void 0;
        var o = r2(3740);
        function i(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, a(n2.key), n2);
          }
        }
        function a(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        function u(e3, t3, r3) {
          return t3 = c(t3), function(e4, t4) {
            if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, s() ? Reflect.construct(t3, r3 || [], c(e3).constructor) : t3.apply(e3, r3));
        }
        function s() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (s = function() {
            return !!e3;
          })();
        }
        function c(e3) {
          return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, c(e3);
        }
        function l(e3, t3) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, l(e3, t3);
        }
        (t2.Uint128 = function(e3) {
          function t3() {
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            for (var e4 = arguments.length, r4 = new Array(e4), n3 = 0; n3 < e4; n3++) r4[n3] = arguments[n3];
            return u(this, t3, [r4]);
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && l(e4, t4);
          }(t3, e3), r3 = t3, (n2 = [{ key: "unsigned", get: function() {
            return true;
          } }, { key: "size", get: function() {
            return 128;
          } }]) && i(r3.prototype, n2), o2 && i(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(o.LargeInt)).defineIntBoundaries();
      }, 6299: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { AssembledTransaction: () => de, Client: () => ot, DEFAULT_TIMEOUT: () => h, Err: () => d, NULL_ACCOUNT: () => y, Ok: () => p, SentTransaction: () => K, Spec: () => Ne, basicNodeSigner: () => be });
        var n = r2(356), o = r2(3496), i = r2(4076), a = r2(8680);
        function u(e3) {
          return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, u(e3);
        }
        function s(e3, t3) {
          if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
        }
        function c(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, f(n2.key), n2);
          }
        }
        function l(e3, t3, r3) {
          return t3 && c(e3.prototype, t3), r3 && c(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        }
        function f(e3) {
          var t3 = function(e4, t4) {
            if ("object" != u(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != u(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == u(t3) ? t3 : t3 + "";
        }
        var p = l(function e3(t3) {
          s(this, e3), this.value = t3;
        }, [{ key: "unwrapErr", value: function() {
          throw new Error("No error");
        } }, { key: "unwrap", value: function() {
          return this.value;
        } }, { key: "isOk", value: function() {
          return true;
        } }, { key: "isErr", value: function() {
          return false;
        } }]), d = l(function e3(t3) {
          s(this, e3), this.error = t3;
        }, [{ key: "unwrapErr", value: function() {
          return this.error;
        } }, { key: "unwrap", value: function() {
          throw new Error(this.error.message);
        } }, { key: "isOk", value: function() {
          return false;
        } }, { key: "isErr", value: function() {
          return true;
        } }]), h = 300, y = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
        function m() {
          m = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof b2 ? t4 : b2, a3 = Object.create(i3.prototype), u3 = new C2(n3 || []);
            return o2(a3, "_invoke", { value: A2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", g2 = {};
          function b2() {
          }
          function w2() {
          }
          function S2() {
          }
          var k2 = {};
          c2(k2, a2, function() {
            return this;
          });
          var E2 = Object.getPrototypeOf, _2 = E2 && E2(E2(j2([])));
          _2 && _2 !== r3 && n2.call(_2, a2) && (k2 = _2);
          var T2 = S2.prototype = b2.prototype = Object.create(k2);
          function O2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function x2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == v(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = P2(u3, n3);
                  if (s3) {
                    if (s3 === g2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === g2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function P2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, P2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, g2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, g2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, g2);
          }
          function I2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function R2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function C2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(I2, this), this.reset(true);
          }
          function j2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(v(t4) + " is not iterable");
          }
          return w2.prototype = S2, o2(T2, "constructor", { value: S2, configurable: true }), o2(S2, "constructor", { value: w2, configurable: true }), w2.displayName = c2(S2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === w2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, S2) : (e4.__proto__ = S2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(T2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, O2(x2.prototype), c2(x2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = x2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new x2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, O2(T2), c2(T2, s2, "Generator"), c2(T2, a2, function() {
            return this;
          }), c2(T2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = j2, C2.prototype = { constructor: C2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(R2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, g2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), g2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), R2(r4), g2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  R2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: j2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), g2;
          } }, t3;
        }
        function v(e3) {
          return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, v(e3);
        }
        function g(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function b(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                g(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                g(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function w(e3, t3, r3) {
          return S.apply(this, arguments);
        }
        function S() {
          return S = b(m().mark(function e3(t3, r3, n2) {
            var o2, i2, a2, u2, s2, c2, l2, f2 = arguments;
            return m().wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return o2 = f2.length > 3 && void 0 !== f2[3] ? f2[3] : 1.5, i2 = f2.length > 4 && void 0 !== f2[4] && f2[4], a2 = [], u2 = 0, e4.t0 = a2, e4.next = 7, t3();
                case 7:
                  if (e4.t1 = e4.sent, e4.t0.push.call(e4.t0, e4.t1), r3(a2[a2.length - 1])) {
                    e4.next = 11;
                    break;
                  }
                  return e4.abrupt("return", a2);
                case 11:
                  s2 = new Date(Date.now() + 1e3 * n2).valueOf(), l2 = c2 = 1e3;
                case 14:
                  if (!(Date.now() < s2 && r3(a2[a2.length - 1]))) {
                    e4.next = 30;
                    break;
                  }
                  return u2 += 1, i2 && console.info("Waiting ".concat(c2, "ms before trying again (bringing the total wait time to ").concat(l2, "ms so far, of total ").concat(1e3 * n2, "ms)")), e4.next = 19, new Promise(function(e5) {
                    return setTimeout(e5, c2);
                  });
                case 19:
                  return c2 *= o2, new Date(Date.now() + c2).valueOf() > s2 && (c2 = s2 - Date.now(), i2 && console.info("was gonna wait too long; new waitTime: ".concat(c2, "ms"))), l2 = c2 + l2, e4.t2 = a2, e4.next = 25, t3(a2[a2.length - 1]);
                case 25:
                  e4.t3 = e4.sent, e4.t2.push.call(e4.t2, e4.t3), i2 && r3(a2[a2.length - 1]) && console.info("".concat(u2, ". Called ").concat(t3, "; ").concat(a2.length, " prev attempts. Most recent: ").concat(JSON.stringify(a2[a2.length - 1], null, 2))), e4.next = 14;
                  break;
                case 30:
                  return e4.abrupt("return", a2);
                case 31:
                case "end":
                  return e4.stop();
              }
            }, e3);
          })), S.apply(this, arguments);
        }
        var k, E = /Error\(Contract, #(\d+)\)/;
        function _(e3) {
          for (var t3 = new n.cereal.XdrReader(e3), r3 = []; !t3.eof; ) r3.push(n.xdr.ScSpecEntry.read(t3));
          return r3;
        }
        function T(e3, t3) {
          return O.apply(this, arguments);
        }
        function O() {
          return (O = b(m().mark(function e3(t3, r3) {
            return m().wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return e4.abrupt("return", t3.publicKey ? r3.getAccount(t3.publicKey) : new n.Account(y, "0"));
                case 1:
                case "end":
                  return e4.stop();
              }
            }, e3);
          }))).apply(this, arguments);
        }
        function x(e3, t3, r3) {
          return t3 = C(t3), function(e4, t4) {
            if (t4 && ("object" == j(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, I() ? Reflect.construct(t3, r3 || [], C(e3).constructor) : t3.apply(e3, r3));
        }
        function A(e3, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && R(e3, t3);
        }
        function P(e3) {
          var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return P = function(e4) {
            if (null === e4 || !function(e5) {
              try {
                return -1 !== Function.toString.call(e5).indexOf("[native code]");
              } catch (t4) {
                return "function" == typeof e5;
              }
            }(e4)) return e4;
            if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t3) {
              if (t3.has(e4)) return t3.get(e4);
              t3.set(e4, r3);
            }
            function r3() {
              return function(e5, t4, r4) {
                if (I()) return Reflect.construct.apply(null, arguments);
                var n2 = [null];
                n2.push.apply(n2, t4);
                var o2 = new (e5.bind.apply(e5, n2))();
                return r4 && R(o2, r4.prototype), o2;
              }(e4, arguments, C(this).constructor);
            }
            return r3.prototype = Object.create(e4.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), R(r3, e4);
          }, P(e3);
        }
        function I() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (I = function() {
            return !!e3;
          })();
        }
        function R(e3, t3) {
          return R = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, R(e3, t3);
        }
        function C(e3) {
          return C = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, C(e3);
        }
        function j(e3) {
          return j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, j(e3);
        }
        function B() {
          B = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof v2 ? t4 : v2, a3 = Object.create(i3.prototype), u3 = new I2(n3 || []);
            return o2(a3, "_invoke", { value: O2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function v2() {
          }
          function g2() {
          }
          function b2() {
          }
          var w2 = {};
          c2(w2, a2, function() {
            return this;
          });
          var S2 = Object.getPrototypeOf, k2 = S2 && S2(S2(R2([])));
          k2 && k2 !== r3 && n2.call(k2, a2) && (w2 = k2);
          var E2 = b2.prototype = v2.prototype = Object.create(w2);
          function _2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == j(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function O2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = x2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function x2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, x2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function A2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function P2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function I2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
          }
          function R2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(j(t4) + " is not iterable");
          }
          return g2.prototype = b2, o2(E2, "constructor", { value: b2, configurable: true }), o2(b2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(b2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === g2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, b2) : (e4.__proto__ = b2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(E2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, _2(T2.prototype), c2(T2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new T2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, _2(E2), c2(E2, s2, "Generator"), c2(E2, a2, function() {
            return this;
          }), c2(E2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = R2, I2.prototype = { constructor: I2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), P2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  P2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: R2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function L(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function N(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                L(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                L(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function U(e3, t3) {
          if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
        }
        function M(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, V(n2.key), n2);
          }
        }
        function F(e3, t3, r3) {
          return t3 && M(e3.prototype, t3), r3 && M(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        }
        function D(e3, t3, r3) {
          return (t3 = V(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function V(e3) {
          var t3 = function(e4, t4) {
            if ("object" != j(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != j(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == j(t3) ? t3 : t3 + "";
        }
        var q, K = function() {
          function e3(t3) {
            var r3, n2 = this;
            U(this, e3), D(this, "send", N(B().mark(function t4() {
              var r4, o2, a2;
              return B().wrap(function(t5) {
                for (; ; ) switch (t5.prev = t5.next) {
                  case 0:
                    return t5.next = 2, n2.server.sendTransaction(n2.assembled.signed);
                  case 2:
                    if (n2.sendTransactionResponse = t5.sent, "PENDING" === n2.sendTransactionResponse.status) {
                      t5.next = 5;
                      break;
                    }
                    throw new e3.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(n2.sendTransactionResponse, null, 2)));
                  case 5:
                    return o2 = n2.sendTransactionResponse.hash, a2 = null !== (r4 = n2.assembled.options.timeoutInSeconds) && void 0 !== r4 ? r4 : h, t5.next = 9, w(function() {
                      return n2.server.getTransaction(o2);
                    }, function(e4) {
                      return e4.status === i.j.GetTransactionStatus.NOT_FOUND;
                    }, a2);
                  case 9:
                    if (n2.getTransactionResponseAll = t5.sent, n2.getTransactionResponse = n2.getTransactionResponseAll[n2.getTransactionResponseAll.length - 1], n2.getTransactionResponse.status !== i.j.GetTransactionStatus.NOT_FOUND) {
                      t5.next = 13;
                      break;
                    }
                    throw new e3.Errors.TransactionStillPending("Waited ".concat(a2, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(n2.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(n2.getTransactionResponseAll, null, 2)));
                  case 13:
                    return t5.abrupt("return", n2);
                  case 14:
                  case "end":
                    return t5.stop();
                }
              }, t4);
            }))), this.assembled = t3, this.server = new o.Server(this.assembled.options.rpcUrl, { allowHttp: null !== (r3 = this.assembled.options.allowHttp) && void 0 !== r3 && r3 });
          }
          return F(e3, [{ key: "result", get: function() {
            if ("getTransactionResponse" in this && this.getTransactionResponse) {
              if ("returnValue" in this.getTransactionResponse) return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
              throw new Error("Transaction failed! Cannot parse result.");
            }
            if (this.sendTransactionResponse) {
              var t3, r3 = null === (t3 = this.sendTransactionResponse.errorResult) || void 0 === t3 ? void 0 : t3.result();
              if (r3) throw new e3.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(r3));
              throw new e3.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
            }
            throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
          } }]);
        }();
        k = K, D(K, "Errors", { SendFailed: function(e3) {
          function t3() {
            return U(this, t3), x(this, t3, arguments);
          }
          return A(t3, e3), F(t3);
        }(P(Error)), SendResultOnly: function(e3) {
          function t3() {
            return U(this, t3), x(this, t3, arguments);
          }
          return A(t3, e3), F(t3);
        }(P(Error)), TransactionStillPending: function(e3) {
          function t3() {
            return U(this, t3), x(this, t3, arguments);
          }
          return A(t3, e3), F(t3);
        }(P(Error)) }), D(K, "init", (q = N(B().mark(function e3(t3) {
          var r3, n2;
          return B().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return r3 = new k(t3), e4.next = 3, r3.send();
              case 3:
                return n2 = e4.sent, e4.abrupt("return", n2);
              case 5:
              case "end":
                return e4.stop();
            }
          }, e3);
        })), function(e3) {
          return q.apply(this, arguments);
        }));
        var H = r2(8287).Buffer;
        function z(e3, t3, r3) {
          return t3 = W(t3), function(e4, t4) {
            if (t4 && ("object" == Y(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, $() ? Reflect.construct(t3, r3 || [], W(e3).constructor) : t3.apply(e3, r3));
        }
        function X(e3, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && Q(e3, t3);
        }
        function G(e3) {
          var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return G = function(e4) {
            if (null === e4 || !function(e5) {
              try {
                return -1 !== Function.toString.call(e5).indexOf("[native code]");
              } catch (t4) {
                return "function" == typeof e5;
              }
            }(e4)) return e4;
            if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t3) {
              if (t3.has(e4)) return t3.get(e4);
              t3.set(e4, r3);
            }
            function r3() {
              return function(e5, t4, r4) {
                if ($()) return Reflect.construct.apply(null, arguments);
                var n2 = [null];
                n2.push.apply(n2, t4);
                var o2 = new (e5.bind.apply(e5, n2))();
                return r4 && Q(o2, r4.prototype), o2;
              }(e4, arguments, W(this).constructor);
            }
            return r3.prototype = Object.create(e4.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), Q(r3, e4);
          }, G(e3);
        }
        function $() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return ($ = function() {
            return !!e3;
          })();
        }
        function Q(e3, t3) {
          return Q = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Q(e3, t3);
        }
        function W(e3) {
          return W = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, W(e3);
        }
        function Y(e3) {
          return Y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Y(e3);
        }
        function J(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function Z(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? J(Object(r3), true).forEach(function(t4) {
              fe(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : J(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function ee(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t4) {
            var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != r3) {
              var n2, o2, i2, a2, u2 = [], s2 = true, c2 = false;
              try {
                if (i2 = (r3 = r3.call(e4)).next, 0 === t4) {
                  if (Object(r3) !== r3) return;
                  s2 = false;
                } else for (; !(s2 = (n2 = i2.call(r3)).done) && (u2.push(n2.value), u2.length !== t4); s2 = true) ;
              } catch (e5) {
                c2 = true, o2 = e5;
              } finally {
                try {
                  if (!s2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2)) return;
                } finally {
                  if (c2) throw o2;
                }
              }
              return u2;
            }
          }(e3, t3) || oe(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function te(e3, t3) {
          var r3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (!r3) {
            if (Array.isArray(e3) || (r3 = oe(e3)) || t3 && e3 && "number" == typeof e3.length) {
              r3 && (e3 = r3);
              var n2 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return n2 >= e3.length ? { done: true } : { done: false, value: e3[n2++] };
              }, e: function(e4) {
                throw e4;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var i2, a2 = true, u2 = false;
          return { s: function() {
            r3 = r3.call(e3);
          }, n: function() {
            var e4 = r3.next();
            return a2 = e4.done, e4;
          }, e: function(e4) {
            u2 = true, i2 = e4;
          }, f: function() {
            try {
              a2 || null == r3.return || r3.return();
            } finally {
              if (u2) throw i2;
            }
          } };
        }
        function re() {
          re = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof v2 ? t4 : v2, a3 = Object.create(i3.prototype), u3 = new I2(n3 || []);
            return o2(a3, "_invoke", { value: O2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function v2() {
          }
          function g2() {
          }
          function b2() {
          }
          var w2 = {};
          c2(w2, a2, function() {
            return this;
          });
          var S2 = Object.getPrototypeOf, k2 = S2 && S2(S2(R2([])));
          k2 && k2 !== r3 && n2.call(k2, a2) && (w2 = k2);
          var E2 = b2.prototype = v2.prototype = Object.create(w2);
          function _2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == Y(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function O2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = x2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function x2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, x2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function A2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function P2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function I2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
          }
          function R2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(Y(t4) + " is not iterable");
          }
          return g2.prototype = b2, o2(E2, "constructor", { value: b2, configurable: true }), o2(b2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(b2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === g2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, b2) : (e4.__proto__ = b2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(E2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, _2(T2.prototype), c2(T2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new T2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, _2(E2), c2(E2, s2, "Generator"), c2(E2, a2, function() {
            return this;
          }), c2(E2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = R2, I2.prototype = { constructor: I2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), P2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  P2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: R2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function ne(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return ie(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || oe(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function oe(e3, t3) {
          if (e3) {
            if ("string" == typeof e3) return ie(e3, t3);
            var r3 = {}.toString.call(e3).slice(8, -1);
            return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? ie(e3, t3) : void 0;
          }
        }
        function ie(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function ae(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function ue(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                ae(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                ae(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function se(e3, t3) {
          if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
        }
        function ce(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, pe(n2.key), n2);
          }
        }
        function le(e3, t3, r3) {
          return t3 && ce(e3.prototype, t3), r3 && ce(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        }
        function fe(e3, t3, r3) {
          return (t3 = pe(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function pe(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Y(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Y(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Y(t3) ? t3 : t3 + "";
        }
        var de = function() {
          function e3(t4) {
            var r4, u3, s3 = this;
            se(this, e3), fe(this, "simulate", ue(re().mark(function t5() {
              var r5, o2, u4, c2, l2, f2, p2, d2 = arguments;
              return re().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    if (r5 = (d2.length > 0 && void 0 !== d2[0] ? d2[0] : {}).restore, s3.built) {
                      t6.next = 5;
                      break;
                    }
                    if (s3.raw) {
                      t6.next = 4;
                      break;
                    }
                    throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
                  case 4:
                    s3.built = s3.raw.build();
                  case 5:
                    return r5 = null != r5 ? r5 : s3.options.restore, delete s3.simulationResult, delete s3.simulationTransactionData, t6.next = 10, s3.server.simulateTransaction(s3.built);
                  case 10:
                    if (s3.simulation = t6.sent, !r5 || !i.j.isSimulationRestore(s3.simulation)) {
                      t6.next = 25;
                      break;
                    }
                    return t6.next = 14, T(s3.options, s3.server);
                  case 14:
                    return o2 = t6.sent, t6.next = 17, s3.restoreFootprint(s3.simulation.restorePreamble, o2);
                  case 17:
                    if ((u4 = t6.sent).status !== i.j.GetTransactionStatus.SUCCESS) {
                      t6.next = 24;
                      break;
                    }
                    return p2 = new n.Contract(s3.options.contractId), s3.raw = new n.TransactionBuilder(o2, { fee: null !== (c2 = s3.options.fee) && void 0 !== c2 ? c2 : n.BASE_FEE, networkPassphrase: s3.options.networkPassphrase }).addOperation(p2.call.apply(p2, [s3.options.method].concat(ne(null !== (l2 = s3.options.args) && void 0 !== l2 ? l2 : [])))).setTimeout(null !== (f2 = s3.options.timeoutInSeconds) && void 0 !== f2 ? f2 : h), t6.next = 23, s3.simulate();
                  case 23:
                    return t6.abrupt("return", s3);
                  case 24:
                    throw new e3.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(u4)));
                  case 25:
                    return i.j.isSimulationSuccess(s3.simulation) && (s3.built = (0, a.X)(s3.built, s3.simulation).build()), t6.abrupt("return", s3);
                  case 27:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }))), fe(this, "sign", ue(re().mark(function t5() {
              var r5, o2, i2, a2, u4, c2, l2, f2, p2, d2, y2, m2, v2 = arguments;
              return re().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    if (i2 = (o2 = v2.length > 0 && void 0 !== v2[0] ? v2[0] : {}).force, a2 = void 0 !== i2 && i2, u4 = o2.signTransaction, c2 = void 0 === u4 ? s3.options.signTransaction : u4, s3.built) {
                      t6.next = 3;
                      break;
                    }
                    throw new Error("Transaction has not yet been simulated");
                  case 3:
                    if (a2 || !s3.isReadCall) {
                      t6.next = 5;
                      break;
                    }
                    throw new e3.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
                  case 5:
                    if (c2) {
                      t6.next = 7;
                      break;
                    }
                    throw new e3.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
                  case 7:
                    if (!(l2 = s3.needsNonInvokerSigningBy().filter(function(e4) {
                      return !e4.startsWith("C");
                    })).length) {
                      t6.next = 10;
                      break;
                    }
                    throw new e3.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(l2, ". ") + "See `needsNonInvokerSigningBy` for details.");
                  case 10:
                    return f2 = null !== (r5 = s3.options.timeoutInSeconds) && void 0 !== r5 ? r5 : h, s3.built = n.TransactionBuilder.cloneFrom(s3.built, { fee: s3.built.fee, timebounds: void 0, sorobanData: s3.simulationData.transactionData }).setTimeout(f2).build(), p2 = { networkPassphrase: s3.options.networkPassphrase }, s3.options.address && (p2.address = s3.options.address), void 0 !== s3.options.submit && (p2.submit = s3.options.submit), s3.options.submitUrl && (p2.submitUrl = s3.options.submitUrl), t6.next = 18, c2(s3.built.toXDR(), p2);
                  case 18:
                    d2 = t6.sent, y2 = d2.signedTxXdr, m2 = d2.error, s3.handleWalletError(m2), s3.signed = n.TransactionBuilder.fromXDR(y2, s3.options.networkPassphrase);
                  case 23:
                  case "end":
                    return t6.stop();
                }
              }, t5);
            }))), fe(this, "signAndSend", ue(re().mark(function e4() {
              var t5, r5, n2, o2, i2, a2, u4 = arguments;
              return re().wrap(function(e5) {
                for (; ; ) switch (e5.prev = e5.next) {
                  case 0:
                    if (r5 = (t5 = u4.length > 0 && void 0 !== u4[0] ? u4[0] : {}).force, n2 = void 0 !== r5 && r5, o2 = t5.signTransaction, i2 = void 0 === o2 ? s3.options.signTransaction : o2, s3.signed) {
                      e5.next = 10;
                      break;
                    }
                    return a2 = s3.options.submit, s3.options.submit && (s3.options.submit = false), e5.prev = 4, e5.next = 7, s3.sign({ force: n2, signTransaction: i2 });
                  case 7:
                    return e5.prev = 7, s3.options.submit = a2, e5.finish(7);
                  case 10:
                    return e5.abrupt("return", s3.send());
                  case 11:
                  case "end":
                    return e5.stop();
                }
              }, e4, null, [[4, , 7, 10]]);
            }))), fe(this, "needsNonInvokerSigningBy", function() {
              var e4, t5 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeAlreadySigned, r5 = void 0 !== t5 && t5;
              if (!s3.built) throw new Error("Transaction has not yet been simulated");
              if (!("operations" in s3.built)) throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(s3.built)));
              var o2 = s3.built.operations[0];
              return ne(new Set((null !== (e4 = o2.auth) && void 0 !== e4 ? e4 : []).filter(function(e5) {
                return e5.credentials().switch() === n.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (r5 || "scvVoid" === e5.credentials().address().signature().switch().name);
              }).map(function(e5) {
                return n.Address.fromScAddress(e5.credentials().address().address()).toString();
              })));
            }), fe(this, "signAuthEntries", ue(re().mark(function t5() {
              var r5, o2, i2, a2, u4, c2, l2, f2, p2, d2, h2, y2, m2, v2, g2, b2, w2 = arguments;
              return re().wrap(function(t6) {
                for (; ; ) switch (t6.prev = t6.next) {
                  case 0:
                    if (i2 = (o2 = w2.length > 0 && void 0 !== w2[0] ? w2[0] : {}).expiration, a2 = void 0 === i2 ? ue(re().mark(function e4() {
                      return re().wrap(function(e5) {
                        for (; ; ) switch (e5.prev = e5.next) {
                          case 0:
                            return e5.next = 2, s3.server.getLatestLedger();
                          case 2:
                            return e5.t0 = e5.sent.sequence, e5.abrupt("return", e5.t0 + 100);
                          case 4:
                          case "end":
                            return e5.stop();
                        }
                      }, e4);
                    }))() : i2, u4 = o2.signAuthEntry, c2 = void 0 === u4 ? s3.options.signAuthEntry : u4, l2 = o2.address, f2 = void 0 === l2 ? s3.options.publicKey : l2, p2 = o2.authorizeEntry, d2 = void 0 === p2 ? n.authorizeEntry : p2, s3.built) {
                      t6.next = 3;
                      break;
                    }
                    throw new Error("Transaction has not yet been assembled or simulated");
                  case 3:
                    if (d2 !== n.authorizeEntry) {
                      t6.next = 11;
                      break;
                    }
                    if (0 !== (h2 = s3.needsNonInvokerSigningBy()).length) {
                      t6.next = 7;
                      break;
                    }
                    throw new e3.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
                  case 7:
                    if (-1 !== h2.indexOf(null != f2 ? f2 : "")) {
                      t6.next = 9;
                      break;
                    }
                    throw new e3.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(f2, '"'));
                  case 9:
                    if (c2) {
                      t6.next = 11;
                      break;
                    }
                    throw new e3.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
                  case 11:
                    y2 = s3.built.operations[0], m2 = null !== (r5 = y2.auth) && void 0 !== r5 ? r5 : [], v2 = te(m2.entries()), t6.prev = 14, b2 = re().mark(function e4() {
                      var t7, r6, o3, i3, u5;
                      return re().wrap(function(e5) {
                        for (; ; ) switch (e5.prev = e5.next) {
                          case 0:
                            if (t7 = ee(g2.value, 2), r6 = t7[0], o3 = t7[1], (i3 = n.xdr.SorobanCredentials.fromXDR(o3.credentials().toXDR())).switch() === n.xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {
                              e5.next = 4;
                              break;
                            }
                            return e5.abrupt("return", 0);
                          case 4:
                            if (n.Address.fromScAddress(i3.address().address()).toString() === f2) {
                              e5.next = 7;
                              break;
                            }
                            return e5.abrupt("return", 0);
                          case 7:
                            return u5 = null != c2 ? c2 : Promise.resolve, e5.t0 = d2, e5.t1 = o3, e5.t2 = function() {
                              var e6 = ue(re().mark(function e7(t8) {
                                var r7, n2, o4;
                                return re().wrap(function(e8) {
                                  for (; ; ) switch (e8.prev = e8.next) {
                                    case 0:
                                      return e8.next = 2, u5(t8.toXDR("base64"), { address: f2 });
                                    case 2:
                                      return r7 = e8.sent, n2 = r7.signedAuthEntry, o4 = r7.error, s3.handleWalletError(o4), e8.abrupt("return", H.from(n2, "base64"));
                                    case 7:
                                    case "end":
                                      return e8.stop();
                                  }
                                }, e7);
                              }));
                              return function(t8) {
                                return e6.apply(this, arguments);
                              };
                            }(), e5.next = 13, a2;
                          case 13:
                            return e5.t3 = e5.sent, e5.t4 = s3.options.networkPassphrase, e5.next = 17, (0, e5.t0)(e5.t1, e5.t2, e5.t3, e5.t4);
                          case 17:
                            m2[r6] = e5.sent;
                          case 18:
                          case "end":
                            return e5.stop();
                        }
                      }, e4);
                    }), v2.s();
                  case 17:
                    if ((g2 = v2.n()).done) {
                      t6.next = 24;
                      break;
                    }
                    return t6.delegateYield(b2(), "t0", 19);
                  case 19:
                    if (0 !== t6.t0) {
                      t6.next = 22;
                      break;
                    }
                    return t6.abrupt("continue", 22);
                  case 22:
                    t6.next = 17;
                    break;
                  case 24:
                    t6.next = 29;
                    break;
                  case 26:
                    t6.prev = 26, t6.t1 = t6.catch(14), v2.e(t6.t1);
                  case 29:
                    return t6.prev = 29, v2.f(), t6.finish(29);
                  case 32:
                  case "end":
                    return t6.stop();
                }
              }, t5, null, [[14, 26, 29, 32]]);
            }))), this.options = t4, this.options.simulate = null === (r4 = this.options.simulate) || void 0 === r4 || r4, this.server = new o.Server(this.options.rpcUrl, { allowHttp: null !== (u3 = this.options.allowHttp) && void 0 !== u3 && u3 });
          }
          return le(e3, [{ key: "toJSON", value: function() {
            var e4;
            return JSON.stringify({ method: this.options.method, tx: null === (e4 = this.built) || void 0 === e4 ? void 0 : e4.toXDR(), simulationResult: { auth: this.simulationData.result.auth.map(function(e5) {
              return e5.toXDR("base64");
            }), retval: this.simulationData.result.retval.toXDR("base64") }, simulationTransactionData: this.simulationData.transactionData.toXDR("base64") });
          } }, { key: "toXDR", value: function() {
            var e4;
            if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
            return null === (e4 = this.built) || void 0 === e4 ? void 0 : e4.toEnvelope().toXDR("base64");
          } }, { key: "handleWalletError", value: function(t4) {
            if (t4) {
              var r4 = t4.message, n2 = t4.code, o2 = "".concat(r4).concat(t4.ext ? " (".concat(t4.ext.join(", "), ")") : "");
              switch (n2) {
                case -1:
                  throw new e3.Errors.InternalWalletError(o2);
                case -2:
                  throw new e3.Errors.ExternalServiceError(o2);
                case -3:
                  throw new e3.Errors.InvalidClientRequest(o2);
                case -4:
                  throw new e3.Errors.UserRejected(o2);
                default:
                  throw new Error("Unhandled error: ".concat(o2));
              }
            }
          } }, { key: "simulationData", get: function() {
            var t4;
            if (this.simulationResult && this.simulationTransactionData) return { result: this.simulationResult, transactionData: this.simulationTransactionData };
            var r4 = this.simulation;
            if (!r4) throw new e3.Errors.NotYetSimulated("Transaction has not yet been simulated");
            if (i.j.isSimulationError(r4)) throw new e3.Errors.SimulationFailed('Transaction simulation failed: "'.concat(r4.error, '"'));
            if (i.j.isSimulationRestore(r4)) throw new e3.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
            return this.simulationResult = null !== (t4 = r4.result) && void 0 !== t4 ? t4 : { auth: [], retval: n.xdr.ScVal.scvVoid() }, this.simulationTransactionData = r4.transactionData.build(), { result: this.simulationResult, transactionData: this.simulationTransactionData };
          } }, { key: "result", get: function() {
            try {
              if (!this.simulationData.result) throw new Error("No simulation result!");
              return this.options.parseResultXdr(this.simulationData.result.retval);
            } catch (r4) {
              if ("object" !== v(t4 = r4) || null === t4 || !("toString" in t4)) throw r4;
              var e4 = this.parseError(r4.toString());
              if (e4) return e4;
              throw r4;
            }
            var t4;
          } }, { key: "parseError", value: function(e4) {
            if (this.options.errorTypes) {
              var t4 = e4.match(E);
              if (t4) {
                var r4 = parseInt(t4[1], 10), n2 = this.options.errorTypes[r4];
                if (n2) return new d(n2);
              }
            }
          } }, { key: "send", value: (s2 = ue(re().mark(function e4() {
            var t4;
            return re().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  if (this.signed) {
                    e5.next = 2;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 2:
                  return e5.next = 4, K.init(this);
                case 4:
                  return t4 = e5.sent, e5.abrupt("return", t4);
                case 6:
                case "end":
                  return e5.stop();
              }
            }, e4, this);
          })), function() {
            return s2.apply(this, arguments);
          }) }, { key: "isReadCall", get: function() {
            var e4 = this.simulationData.result.auth.length, t4 = this.simulationData.transactionData.resources().footprint().readWrite().length;
            return 0 === e4 && 0 === t4;
          } }, { key: "restoreFootprint", value: (u2 = ue(re().mark(function t4(r4, n2) {
            var o2, i2;
            return re().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  if (this.options.signTransaction) {
                    t5.next = 2;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 2:
                  if (null == n2) {
                    t5.next = 6;
                    break;
                  }
                  t5.t0 = n2, t5.next = 9;
                  break;
                case 6:
                  return t5.next = 8, T(this.options, this.server);
                case 8:
                  t5.t0 = t5.sent;
                case 9:
                  return n2 = t5.t0, t5.next = 12, e3.buildFootprintRestoreTransaction(Z({}, this.options), r4.transactionData, n2, r4.minResourceFee);
                case 12:
                  return o2 = t5.sent, t5.next = 15, o2.signAndSend();
                case 15:
                  if ((i2 = t5.sent).getTransactionResponse) {
                    t5.next = 18;
                    break;
                  }
                  throw new e3.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(i2)));
                case 18:
                  return t5.abrupt("return", i2.getTransactionResponse);
                case 19:
                case "end":
                  return t5.stop();
              }
            }, t4, this);
          })), function(e4, t4) {
            return u2.apply(this, arguments);
          }) }], [{ key: "fromJSON", value: function(t4, r4) {
            var o2 = r4.tx, i2 = r4.simulationResult, a2 = r4.simulationTransactionData, u3 = new e3(t4);
            return u3.built = n.TransactionBuilder.fromXDR(o2, t4.networkPassphrase), u3.simulationResult = { auth: i2.auth.map(function(e4) {
              return n.xdr.SorobanAuthorizationEntry.fromXDR(e4, "base64");
            }), retval: n.xdr.ScVal.fromXDR(i2.retval, "base64") }, u3.simulationTransactionData = n.xdr.SorobanTransactionData.fromXDR(a2, "base64"), u3;
          } }, { key: "fromXDR", value: function(t4, r4, o2) {
            var i2, a2 = n.xdr.TransactionEnvelope.fromXDR(r4, "base64"), u3 = n.TransactionBuilder.fromXDR(a2, t4.networkPassphrase), s3 = u3.operations[0];
            if (null == s3 || null === (i2 = s3.func) || void 0 === i2 || !i2.value || "function" != typeof s3.func.value) throw new Error("Could not extract the method from the transaction envelope.");
            var c2 = s3.func.value();
            if (null == c2 || !c2.functionName) throw new Error("Could not extract the method name from the transaction envelope.");
            var l2 = c2.functionName().toString("utf-8"), f2 = new e3(Z(Z({}, t4), {}, { method: l2, parseResultXdr: function(e4) {
              return o2.funcResToNative(l2, e4);
            } }));
            return f2.built = u3, f2;
          } }, { key: "build", value: function(t4) {
            var r4, o2 = new n.Contract(t4.contractId);
            return e3.buildWithOp(o2.call.apply(o2, [t4.method].concat(ne(null !== (r4 = t4.args) && void 0 !== r4 ? r4 : []))), t4);
          } }, { key: "buildWithOp", value: (r3 = ue(re().mark(function t4(r4, o2) {
            var i2, a2, u3, s3;
            return re().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return u3 = new e3(o2), t5.next = 3, T(o2, u3.server);
                case 3:
                  if (s3 = t5.sent, u3.raw = new n.TransactionBuilder(s3, { fee: null !== (i2 = o2.fee) && void 0 !== i2 ? i2 : n.BASE_FEE, networkPassphrase: o2.networkPassphrase }).setTimeout(null !== (a2 = o2.timeoutInSeconds) && void 0 !== a2 ? a2 : h).addOperation(r4), !o2.simulate) {
                    t5.next = 8;
                    break;
                  }
                  return t5.next = 8, u3.simulate();
                case 8:
                  return t5.abrupt("return", u3);
                case 9:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4, t4) {
            return r3.apply(this, arguments);
          }) }, { key: "buildFootprintRestoreTransaction", value: (t3 = ue(re().mark(function t4(r4, o2, i2, a2) {
            var u3, s3;
            return re().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return (s3 = new e3(r4)).raw = new n.TransactionBuilder(i2, { fee: a2, networkPassphrase: r4.networkPassphrase }).setSorobanData(o2 instanceof n.SorobanDataBuilder ? o2.build() : o2).addOperation(n.Operation.restoreFootprint({})).setTimeout(null !== (u3 = r4.timeoutInSeconds) && void 0 !== u3 ? u3 : h), t5.next = 4, s3.simulate({ restore: false });
                case 4:
                  return t5.abrupt("return", s3);
                case 5:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4, r4, n2, o2) {
            return t3.apply(this, arguments);
          }) }]);
          var t3, r3, u2, s2;
        }();
        fe(de, "Errors", { ExpiredState: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), RestorationFailure: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), NeedsMoreSignatures: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), NoSignatureNeeded: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), NoUnsignedNonInvokerAuthEntries: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), NoSigner: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), NotYetSimulated: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), FakeAccount: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), SimulationFailed: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), InternalWalletError: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), ExternalServiceError: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), InvalidClientRequest: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)), UserRejected: function(e3) {
          function t3() {
            return se(this, t3), z(this, t3, arguments);
          }
          return X(t3, e3), le(t3);
        }(G(Error)) });
        var he = r2(8287).Buffer;
        function ye(e3) {
          return ye = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, ye(e3);
        }
        function me() {
          me = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof v2 ? t4 : v2, a3 = Object.create(i3.prototype), u3 = new I2(n3 || []);
            return o2(a3, "_invoke", { value: O2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function v2() {
          }
          function g2() {
          }
          function b2() {
          }
          var w2 = {};
          c2(w2, a2, function() {
            return this;
          });
          var S2 = Object.getPrototypeOf, k2 = S2 && S2(S2(R2([])));
          k2 && k2 !== r3 && n2.call(k2, a2) && (w2 = k2);
          var E2 = b2.prototype = v2.prototype = Object.create(w2);
          function _2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == ye(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function O2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = x2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function x2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, x2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function A2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function P2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function I2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
          }
          function R2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(ye(t4) + " is not iterable");
          }
          return g2.prototype = b2, o2(E2, "constructor", { value: b2, configurable: true }), o2(b2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(b2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === g2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, b2) : (e4.__proto__ = b2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(E2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, _2(T2.prototype), c2(T2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new T2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, _2(E2), c2(E2, s2, "Generator"), c2(E2, a2, function() {
            return this;
          }), c2(E2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = R2, I2.prototype = { constructor: I2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), P2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  P2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: R2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function ve(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function ge(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                ve(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                ve(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        var be = function(e3, t3) {
          return { signTransaction: (o2 = ge(me().mark(function r4(o3, i2) {
            var a2;
            return me().wrap(function(r5) {
              for (; ; ) switch (r5.prev = r5.next) {
                case 0:
                  return (a2 = n.TransactionBuilder.fromXDR(o3, (null == i2 ? void 0 : i2.networkPassphrase) || t3)).sign(e3), r5.abrupt("return", { signedTxXdr: a2.toXDR(), signerAddress: e3.publicKey() });
                case 3:
                case "end":
                  return r5.stop();
              }
            }, r4);
          })), function(e4, t4) {
            return o2.apply(this, arguments);
          }), signAuthEntry: (r3 = ge(me().mark(function t4(r4) {
            var o3;
            return me().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return o3 = e3.sign((0, n.hash)(he.from(r4, "base64"))).toString("base64"), t5.abrupt("return", { signedAuthEntry: o3, signerAddress: e3.publicKey() });
                case 2:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4) {
            return r3.apply(this, arguments);
          }) };
          var r3, o2;
        }, we = r2(8287).Buffer;
        function Se(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function ke(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Se(Object(r3), true).forEach(function(t4) {
              Te(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : Se(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function Ee(e3) {
          return Ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Ee(e3);
        }
        function _e(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Oe(n2.key), n2);
          }
        }
        function Te(e3, t3, r3) {
          return (t3 = Oe(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function Oe(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Ee(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Ee(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Ee(t3) ? t3 : t3 + "";
        }
        function xe(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t4) {
            var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != r3) {
              var n2, o2, i2, a2, u2 = [], s2 = true, c2 = false;
              try {
                if (i2 = (r3 = r3.call(e4)).next, 0 === t4) {
                  if (Object(r3) !== r3) return;
                  s2 = false;
                } else for (; !(s2 = (n2 = i2.call(r3)).done) && (u2.push(n2.value), u2.length !== t4); s2 = true) ;
              } catch (e5) {
                c2 = true, o2 = e5;
              } finally {
                try {
                  if (!s2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2)) return;
                } finally {
                  if (c2) throw o2;
                }
              }
              return u2;
            }
          }(e3, t3) || function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return Ae(e4, t4);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? Ae(e4, t4) : void 0;
            }
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function Ae(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function Pe(e3) {
          return /^\d+$/.test(e3.name().toString());
        }
        var Ie = { U32: { type: "integer", minimum: 0, maximum: 4294967295 }, I32: { type: "integer", minimum: -2147483648, maximum: 2147483647 }, U64: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 20 }, I64: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 21 }, U128: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 39 }, I128: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 40 }, U256: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 78 }, I256: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 79 }, Address: { type: "string", format: "address", description: "Address can be a public key or contract id" }, ScString: { type: "string", description: "ScString is a string" }, ScSymbol: { type: "string", description: "ScSymbol is a string" }, DataUrl: { type: "string", pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$" } };
        function Re(e3) {
          var t3;
          switch (e3.switch().value) {
            case n.xdr.ScSpecType.scSpecTypeVal().value:
              t3 = "Val";
              break;
            case n.xdr.ScSpecType.scSpecTypeBool().value:
              return { type: "boolean" };
            case n.xdr.ScSpecType.scSpecTypeVoid().value:
              return { type: "null" };
            case n.xdr.ScSpecType.scSpecTypeError().value:
              t3 = "Error";
              break;
            case n.xdr.ScSpecType.scSpecTypeU32().value:
              t3 = "U32";
              break;
            case n.xdr.ScSpecType.scSpecTypeI32().value:
              t3 = "I32";
              break;
            case n.xdr.ScSpecType.scSpecTypeU64().value:
              t3 = "U64";
              break;
            case n.xdr.ScSpecType.scSpecTypeI64().value:
              t3 = "I64";
              break;
            case n.xdr.ScSpecType.scSpecTypeTimepoint().value:
              throw new Error("Timepoint type not supported");
            case n.xdr.ScSpecType.scSpecTypeDuration().value:
              throw new Error("Duration not supported");
            case n.xdr.ScSpecType.scSpecTypeU128().value:
              t3 = "U128";
              break;
            case n.xdr.ScSpecType.scSpecTypeI128().value:
              t3 = "I128";
              break;
            case n.xdr.ScSpecType.scSpecTypeU256().value:
              t3 = "U256";
              break;
            case n.xdr.ScSpecType.scSpecTypeI256().value:
              t3 = "I256";
              break;
            case n.xdr.ScSpecType.scSpecTypeBytes().value:
              t3 = "DataUrl";
              break;
            case n.xdr.ScSpecType.scSpecTypeString().value:
              t3 = "ScString";
              break;
            case n.xdr.ScSpecType.scSpecTypeSymbol().value:
              t3 = "ScSymbol";
              break;
            case n.xdr.ScSpecType.scSpecTypeAddress().value:
              t3 = "Address";
              break;
            case n.xdr.ScSpecType.scSpecTypeOption().value:
              return Re(e3.option().valueType());
            case n.xdr.ScSpecType.scSpecTypeResult().value:
              break;
            case n.xdr.ScSpecType.scSpecTypeVec().value:
              return { type: "array", items: Re(e3.vec().elementType()) };
            case n.xdr.ScSpecType.scSpecTypeMap().value:
              var r3 = e3.map();
              return { type: "array", items: { type: "array", items: [Re(r3.keyType()), Re(r3.valueType())], minItems: 2, maxItems: 2 } };
            case n.xdr.ScSpecType.scSpecTypeTuple().value:
              var o2 = e3.tuple(), i2 = o2.valueTypes().length, a2 = i2;
              return { type: "array", items: o2.valueTypes().map(Re), minItems: i2, maxItems: a2 };
            case n.xdr.ScSpecType.scSpecTypeBytesN().value:
              return { $ref: "#/definitions/DataUrl", maxLength: e3.bytesN().n() };
            case n.xdr.ScSpecType.scSpecTypeUdt().value:
              t3 = e3.udt().name().toString();
          }
          return { $ref: "#/definitions/".concat(t3) };
        }
        function Ce(e3) {
          var t3 = {}, r3 = [];
          e3.forEach(function(e4) {
            var o3 = e4.type(), i2 = e4.name().toString();
            t3[i2] = Re(o3), o3.switch().value !== n.xdr.ScSpecType.scSpecTypeOption().value && r3.push(i2);
          });
          var o2 = { properties: t3 };
          return r3.length > 0 && (o2.required = r3), o2;
        }
        var je, Be, Le, Ne = (je = function e3(t3) {
          if (function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), Te(this, "entries", []), 0 === t3.length) throw new Error("Contract spec must have at least one entry");
          var r3 = t3[0];
          this.entries = "string" == typeof r3 ? t3.map(function(e4) {
            return n.xdr.ScSpecEntry.fromXDR(e4, "base64");
          }) : t3;
        }, Be = [{ key: "funcs", value: function() {
          return this.entries.filter(function(e3) {
            return e3.switch().value === n.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(e3) {
            return e3.functionV0();
          });
        } }, { key: "getFunc", value: function(e3) {
          var t3 = this.findEntry(e3);
          if (t3.switch().value !== n.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) throw new Error("".concat(e3, " is not a function"));
          return t3.functionV0();
        } }, { key: "funcArgsToScVals", value: function(e3, t3) {
          var r3 = this;
          return this.getFunc(e3).inputs().map(function(e4) {
            return r3.nativeToScVal(function(e5, t4) {
              var r4 = t4.name().toString(), n2 = Object.entries(e5).find(function(e6) {
                return xe(e6, 1)[0] === r4;
              });
              if (!n2) throw new Error("Missing field ".concat(r4));
              return n2[1];
            }(t3, e4), e4.type());
          });
        } }, { key: "funcResToNative", value: function(e3, t3) {
          var r3 = "string" == typeof t3 ? n.xdr.ScVal.fromXDR(t3, "base64") : t3, o2 = this.getFunc(e3).outputs();
          if (0 === o2.length) {
            var i2 = r3.switch();
            if (i2.value !== n.xdr.ScValType.scvVoid().value) throw new Error("Expected void, got ".concat(i2.name));
            return null;
          }
          if (o2.length > 1) throw new Error("Multiple outputs not supported");
          var a2 = o2[0];
          return a2.switch().value === n.xdr.ScSpecType.scSpecTypeResult().value ? new p(this.scValToNative(r3, a2.result().okType())) : this.scValToNative(r3, a2);
        } }, { key: "findEntry", value: function(e3) {
          var t3 = this.entries.find(function(t4) {
            return t4.value().name().toString() === e3;
          });
          if (!t3) throw new Error("no such entry: ".concat(e3));
          return t3;
        } }, { key: "nativeToScVal", value: function(e3, t3) {
          var r3 = this, o2 = t3.switch(), i2 = o2.value;
          if (o2.value === n.xdr.ScSpecType.scSpecTypeUdt().value) {
            var a2 = t3.udt();
            return this.nativeToUdt(e3, a2.name().toString());
          }
          if (i2 === n.xdr.ScSpecType.scSpecTypeOption().value) {
            var u2 = t3.option();
            return void 0 === e3 ? n.xdr.ScVal.scvVoid() : this.nativeToScVal(e3, u2.valueType());
          }
          switch (Ee(e3)) {
            case "object":
              var s2, c2, l2;
              if (null === e3) {
                if (i2 === n.xdr.ScSpecType.scSpecTypeVoid().value) return n.xdr.ScVal.scvVoid();
                throw new TypeError("Type ".concat(t3, " was not void, but value was null"));
              }
              if (e3 instanceof n.xdr.ScVal) return e3;
              if (e3 instanceof n.Address) {
                if (t3.switch().value !== n.xdr.ScSpecType.scSpecTypeAddress().value) throw new TypeError("Type ".concat(t3, " was not address, but value was Address"));
                return e3.toScVal();
              }
              if (e3 instanceof n.Contract) {
                if (t3.switch().value !== n.xdr.ScSpecType.scSpecTypeAddress().value) throw new TypeError("Type ".concat(t3, " was not address, but value was Address"));
                return e3.address().toScVal();
              }
              if (e3 instanceof Uint8Array || we.isBuffer(e3)) {
                var f2 = Uint8Array.from(e3);
                switch (i2) {
                  case n.xdr.ScSpecType.scSpecTypeBytesN().value:
                    var p2 = t3.bytesN();
                    if (f2.length !== p2.n()) throw new TypeError("expected ".concat(p2.n(), " bytes, but got ").concat(f2.length));
                    return n.xdr.ScVal.scvBytes(f2);
                  case n.xdr.ScSpecType.scSpecTypeBytes().value:
                    return n.xdr.ScVal.scvBytes(f2);
                  default:
                    throw new TypeError("invalid type (".concat(t3, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(e3)) switch (i2) {
                case n.xdr.ScSpecType.scSpecTypeVec().value:
                  var d2 = t3.vec().elementType();
                  return n.xdr.ScVal.scvVec(e3.map(function(e4) {
                    return r3.nativeToScVal(e4, d2);
                  }));
                case n.xdr.ScSpecType.scSpecTypeTuple().value:
                  var h2 = t3.tuple().valueTypes();
                  if (e3.length !== h2.length) throw new TypeError("Tuple expects ".concat(h2.length, " values, but ").concat(e3.length, " were provided"));
                  return n.xdr.ScVal.scvVec(e3.map(function(e4, t4) {
                    return r3.nativeToScVal(e4, h2[t4]);
                  }));
                case n.xdr.ScSpecType.scSpecTypeMap().value:
                  var y2 = t3.map(), m2 = y2.keyType(), v2 = y2.valueType();
                  return n.xdr.ScVal.scvMap(e3.map(function(e4) {
                    var t4 = r3.nativeToScVal(e4[0], m2), o3 = r3.nativeToScVal(e4[1], v2);
                    return new n.xdr.ScMapEntry({ key: t4, val: o3 });
                  }));
                default:
                  throw new TypeError("Type ".concat(t3, " was not vec, but value was Array"));
              }
              if (e3.constructor === Map) {
                if (i2 !== n.xdr.ScSpecType.scSpecTypeMap().value) throw new TypeError("Type ".concat(t3, " was not map, but value was Map"));
                for (var g2 = t3.map(), b2 = [], w2 = e3.entries(), S2 = w2.next(); !S2.done; ) {
                  var k2 = xe(S2.value, 2), E2 = k2[0], _2 = k2[1], T2 = this.nativeToScVal(E2, g2.keyType()), O2 = this.nativeToScVal(_2, g2.valueType());
                  b2.push(new n.xdr.ScMapEntry({ key: T2, val: O2 })), S2 = w2.next();
                }
                return n.xdr.ScVal.scvMap(b2);
              }
              if ("Object" !== (null !== (s2 = null === (c2 = e3.constructor) || void 0 === c2 ? void 0 : c2.name) && void 0 !== s2 ? s2 : "")) throw new TypeError("cannot interpret ".concat(null === (l2 = e3.constructor) || void 0 === l2 ? void 0 : l2.name, " value as ScVal (").concat(JSON.stringify(e3), ")"));
              throw new TypeError("Received object ".concat(e3, "  did not match the provided type ").concat(t3));
            case "number":
            case "bigint":
              switch (i2) {
                case n.xdr.ScSpecType.scSpecTypeU32().value:
                  return n.xdr.ScVal.scvU32(e3);
                case n.xdr.ScSpecType.scSpecTypeI32().value:
                  return n.xdr.ScVal.scvI32(e3);
                case n.xdr.ScSpecType.scSpecTypeU64().value:
                case n.xdr.ScSpecType.scSpecTypeI64().value:
                case n.xdr.ScSpecType.scSpecTypeU128().value:
                case n.xdr.ScSpecType.scSpecTypeI128().value:
                case n.xdr.ScSpecType.scSpecTypeU256().value:
                case n.xdr.ScSpecType.scSpecTypeI256().value:
                  var x2 = o2.name.substring(10).toLowerCase();
                  return new n.XdrLargeInt(x2, e3).toScVal();
                default:
                  throw new TypeError("invalid type (".concat(t3, ") specified for integer"));
              }
            case "string":
              return function(e4, t4) {
                switch (t4.value) {
                  case n.xdr.ScSpecType.scSpecTypeString().value:
                    return n.xdr.ScVal.scvString(e4);
                  case n.xdr.ScSpecType.scSpecTypeSymbol().value:
                    return n.xdr.ScVal.scvSymbol(e4);
                  case n.xdr.ScSpecType.scSpecTypeAddress().value:
                    return n.Address.fromString(e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeU64().value:
                    return new n.XdrLargeInt("u64", e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeI64().value:
                    return new n.XdrLargeInt("i64", e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeU128().value:
                    return new n.XdrLargeInt("u128", e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeI128().value:
                    return new n.XdrLargeInt("i128", e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeU256().value:
                    return new n.XdrLargeInt("u256", e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeI256().value:
                    return new n.XdrLargeInt("i256", e4).toScVal();
                  case n.xdr.ScSpecType.scSpecTypeBytes().value:
                  case n.xdr.ScSpecType.scSpecTypeBytesN().value:
                    return n.xdr.ScVal.scvBytes(we.from(e4, "base64"));
                  default:
                    throw new TypeError("invalid type ".concat(t4.name, " specified for string value"));
                }
              }(e3, o2);
            case "boolean":
              if (i2 !== n.xdr.ScSpecType.scSpecTypeBool().value) throw TypeError("Type ".concat(t3, " was not bool, but value was bool"));
              return n.xdr.ScVal.scvBool(e3);
            case "undefined":
              if (!t3) return n.xdr.ScVal.scvVoid();
              switch (i2) {
                case n.xdr.ScSpecType.scSpecTypeVoid().value:
                case n.xdr.ScSpecType.scSpecTypeOption().value:
                  return n.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(t3, " was not void, but value was undefined"));
              }
            case "function":
              return this.nativeToScVal(e3(), t3);
            default:
              throw new TypeError("failed to convert typeof ".concat(Ee(e3), " (").concat(e3, ")"));
          }
        } }, { key: "nativeToUdt", value: function(e3, t3) {
          var r3 = this.findEntry(t3);
          switch (r3.switch()) {
            case n.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if ("number" != typeof e3) throw new TypeError("expected number for enum ".concat(t3, ", but got ").concat(Ee(e3)));
              return this.nativeToEnum(e3, r3.udtEnumV0());
            case n.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(e3, r3.udtStructV0());
            case n.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(e3, r3.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(t3));
          }
        } }, { key: "nativeToUnion", value: function(e3, t3) {
          var r3 = this, o2 = e3.tag, i2 = t3.cases().find(function(e4) {
            return e4.value().name().toString() === o2;
          });
          if (!i2) throw new TypeError("no such enum entry: ".concat(o2, " in ").concat(t3));
          var a2 = n.xdr.ScVal.scvSymbol(o2);
          switch (i2.switch()) {
            case n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0():
              return n.xdr.ScVal.scvVec([a2]);
            case n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0():
              var u2 = i2.tupleCase().type();
              if (Array.isArray(e3.values)) {
                if (e3.values.length !== u2.length) throw new TypeError("union ".concat(t3, " expects ").concat(u2.length, " values, but got ").concat(e3.values.length));
                var s2 = e3.values.map(function(e4, t4) {
                  return r3.nativeToScVal(e4, u2[t4]);
                });
                return s2.unshift(a2), n.xdr.ScVal.scvVec(s2);
              }
              throw new Error("failed to parse union case ".concat(i2, " with ").concat(e3));
            default:
              throw new Error("failed to parse union ".concat(t3, " with ").concat(e3));
          }
        } }, { key: "nativeToStruct", value: function(e3, t3) {
          var r3 = this, o2 = t3.fields();
          if (o2.some(Pe)) {
            if (!o2.every(Pe)) throw new Error("mixed numeric and non-numeric field names are not allowed");
            return n.xdr.ScVal.scvVec(o2.map(function(t4, n2) {
              return r3.nativeToScVal(e3[n2], o2[n2].type());
            }));
          }
          return n.xdr.ScVal.scvMap(o2.map(function(t4) {
            var o3 = t4.name().toString();
            return new n.xdr.ScMapEntry({ key: r3.nativeToScVal(o3, n.xdr.ScSpecTypeDef.scSpecTypeSymbol()), val: r3.nativeToScVal(e3[o3], t4.type()) });
          }));
        } }, { key: "nativeToEnum", value: function(e3, t3) {
          if (t3.cases().some(function(t4) {
            return t4.value() === e3;
          })) return n.xdr.ScVal.scvU32(e3);
          throw new TypeError("no such enum entry: ".concat(e3, " in ").concat(t3));
        } }, { key: "scValStrToNative", value: function(e3, t3) {
          return this.scValToNative(n.xdr.ScVal.fromXDR(e3, "base64"), t3);
        } }, { key: "scValToNative", value: function(e3, t3) {
          var r3 = this, o2 = t3.switch(), i2 = o2.value;
          if (i2 === n.xdr.ScSpecType.scSpecTypeUdt().value) return this.scValUdtToNative(e3, t3.udt());
          switch (e3.switch().value) {
            case n.xdr.ScValType.scvVoid().value:
              return;
            case n.xdr.ScValType.scvU64().value:
            case n.xdr.ScValType.scvI64().value:
            case n.xdr.ScValType.scvU128().value:
            case n.xdr.ScValType.scvI128().value:
            case n.xdr.ScValType.scvU256().value:
            case n.xdr.ScValType.scvI256().value:
              return (0, n.scValToBigInt)(e3);
            case n.xdr.ScValType.scvVec().value:
              if (i2 === n.xdr.ScSpecType.scSpecTypeVec().value) {
                var a2, u2 = t3.vec();
                return (null !== (a2 = e3.vec()) && void 0 !== a2 ? a2 : []).map(function(e4) {
                  return r3.scValToNative(e4, u2.elementType());
                });
              }
              if (i2 === n.xdr.ScSpecType.scSpecTypeTuple().value) {
                var s2, c2 = t3.tuple().valueTypes();
                return (null !== (s2 = e3.vec()) && void 0 !== s2 ? s2 : []).map(function(e4, t4) {
                  return r3.scValToNative(e4, c2[t4]);
                });
              }
              throw new TypeError("Type ".concat(t3, " was not vec, but ").concat(e3, " is"));
            case n.xdr.ScValType.scvAddress().value:
              return n.Address.fromScVal(e3).toString();
            case n.xdr.ScValType.scvMap().value:
              var l2, f2 = null !== (l2 = e3.map()) && void 0 !== l2 ? l2 : [];
              if (i2 === n.xdr.ScSpecType.scSpecTypeMap().value) {
                var p2 = t3.map(), d2 = p2.keyType(), h2 = p2.valueType();
                return f2.map(function(e4) {
                  return [r3.scValToNative(e4.key(), d2), r3.scValToNative(e4.val(), h2)];
                });
              }
              throw new TypeError("ScSpecType ".concat(o2.name, " was not map, but ").concat(JSON.stringify(e3, null, 2), " is"));
            case n.xdr.ScValType.scvBool().value:
            case n.xdr.ScValType.scvU32().value:
            case n.xdr.ScValType.scvI32().value:
            case n.xdr.ScValType.scvBytes().value:
              return e3.value();
            case n.xdr.ScValType.scvString().value:
            case n.xdr.ScValType.scvSymbol().value:
              var y2;
              if (i2 !== n.xdr.ScSpecType.scSpecTypeString().value && i2 !== n.xdr.ScSpecType.scSpecTypeSymbol().value) throw new Error("ScSpecType ".concat(o2.name, " was not string or symbol, but ").concat(JSON.stringify(e3, null, 2), " is"));
              return null === (y2 = e3.value()) || void 0 === y2 ? void 0 : y2.toString();
            case n.xdr.ScValType.scvTimepoint().value:
            case n.xdr.ScValType.scvDuration().value:
              return (0, n.scValToBigInt)(n.xdr.ScVal.scvU64(e3.u64()));
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(e3, null, 2), " to native type from type ").concat(o2.name));
          }
        } }, { key: "scValUdtToNative", value: function(e3, t3) {
          var r3 = this.findEntry(t3.name().toString());
          switch (r3.switch()) {
            case n.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(e3);
            case n.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(e3, r3.udtStructV0());
            case n.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(e3, r3.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(t3.name().toString(), ": ").concat(r3));
          }
        } }, { key: "unionToNative", value: function(e3, t3) {
          var r3 = this, o2 = e3.vec();
          if (!o2) throw new Error("".concat(JSON.stringify(e3, null, 2), " is not a vec"));
          if (0 === o2.length && 0 !== t3.cases.length) throw new Error("".concat(e3, " has length 0, but the there are at least one case in the union"));
          var i2 = o2[0].sym().toString();
          if (o2[0].switch().value !== n.xdr.ScValType.scvSymbol().value) throw new Error("{vec[0]} is not a symbol");
          var a2 = t3.cases().find(/* @__PURE__ */ function(e4) {
            return function(t4) {
              switch (t4.switch().value) {
                case n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
                  return t4.tupleCase().name().toString() === e4;
                case n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
                  return t4.voidCase().name().toString() === e4;
                default:
                  return false;
              }
            };
          }(i2));
          if (!a2) throw new Error("failed to find entry ".concat(i2, " in union {udt.name().toString()}"));
          var u2 = { tag: i2 };
          if (a2.switch().value === n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var s2 = a2.tupleCase().type().map(function(e4, t4) {
              return r3.scValToNative(o2[t4 + 1], e4);
            });
            u2.values = s2;
          }
          return u2;
        } }, { key: "structToNative", value: function(e3, t3) {
          var r3, n2, o2 = this, i2 = {}, a2 = t3.fields();
          return a2.some(Pe) ? null === (n2 = e3.vec()) || void 0 === n2 ? void 0 : n2.map(function(e4, t4) {
            return o2.scValToNative(e4, a2[t4].type());
          }) : (null === (r3 = e3.map()) || void 0 === r3 || r3.forEach(function(e4, t4) {
            var r4 = a2[t4];
            i2[r4.name().toString()] = o2.scValToNative(e4.val(), r4.type());
          }), i2);
        } }, { key: "enumToNative", value: function(e3) {
          if (e3.switch().value !== n.xdr.ScValType.scvU32().value) throw new Error("Enum must have a u32 value");
          return e3.u32();
        } }, { key: "errorCases", value: function() {
          return this.entries.filter(function(e3) {
            return e3.switch().value === n.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(e3) {
            return e3.value().cases();
          });
        } }, { key: "jsonSchema", value: function(e3) {
          var t3 = {};
          this.entries.forEach(function(e4) {
            switch (e4.switch().value) {
              case n.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value:
                var r4 = e4.udtEnumV0();
                t3[r4.name().toString()] = function(e5) {
                  var t4 = e5.doc().toString(), r5 = e5.cases(), n2 = [];
                  r5.forEach(function(e6) {
                    var t5 = e6.name().toString(), r6 = e6.doc().toString();
                    n2.push({ description: r6, title: t5, enum: [e6.value()], type: "number" });
                  });
                  var o3 = { oneOf: n2 };
                  return t4.length > 0 && (o3.description = t4), o3;
                }(r4);
                break;
              case n.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value:
                var o2 = e4.udtStructV0();
                t3[o2.name().toString()] = function(e5) {
                  var t4 = e5.fields();
                  if (t4.some(Pe)) {
                    if (!t4.every(Pe)) throw new Error("mixed numeric and non-numeric field names are not allowed");
                    return { type: "array", items: t4.map(function(e6, r6) {
                      return Re(t4[r6].type());
                    }), minItems: t4.length, maxItems: t4.length };
                  }
                  var r5 = e5.doc().toString(), n2 = Ce(t4), o3 = n2.properties, i3 = n2.required;
                  return o3.additionalProperties = false, { description: r5, properties: o3, required: i3, type: "object" };
                }(o2);
                break;
              case n.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value:
                var i2 = e4.udtUnionV0();
                t3[i2.name().toString()] = function(e5) {
                  var t4 = e5.doc().toString(), r5 = e5.cases(), o3 = [];
                  r5.forEach(function(e6) {
                    switch (e6.switch().value) {
                      case n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
                        var t5 = e6.voidCase().name().toString();
                        o3.push({ type: "object", title: t5, properties: { tag: t5 }, additionalProperties: false, required: ["tag"] });
                        break;
                      case n.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
                        var r6 = e6.tupleCase(), i4 = r6.name().toString();
                        o3.push({ type: "object", title: i4, properties: { tag: i4, values: { type: "array", items: r6.type().map(Re) } }, required: ["tag", "values"], additionalProperties: false });
                    }
                  });
                  var i3 = { oneOf: o3 };
                  return t4.length > 0 && (i3.description = t4), i3;
                }(i2);
                break;
              case n.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value:
                var a2 = e4.functionV0(), u2 = a2.name().toString(), s2 = function(e5) {
                  var t4 = Ce(e5.inputs()), r5 = t4.properties, o3 = t4.required, i3 = { additionalProperties: false, properties: r5, type: "object" };
                  (null == o3 ? void 0 : o3.length) > 0 && (i3.required = o3);
                  var a3 = { properties: { args: i3 } }, u3 = e5.outputs(), s3 = u3.length > 0 ? Re(u3[0]) : Re(n.xdr.ScSpecTypeDef.scSpecTypeVoid()), c3 = e5.doc().toString();
                  return c3.length > 0 && (a3.description = c3), a3.additionalProperties = false, s3.additionalProperties = false, { input: a3, output: s3 };
                }(a2), c2 = s2.input;
                t3[u2] = c2;
              case n.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value:
            }
          });
          var r3 = { $schema: "http://json-schema.org/draft-07/schema#", definitions: ke(ke({}, Ie), t3) };
          return e3 && (r3.$ref = "#/definitions/".concat(e3)), r3;
        } }], Be && _e(je.prototype, Be), Le && _e(je, Le), Object.defineProperty(je, "prototype", { writable: false }), je), Ue = r2(8287).Buffer;
        function Me(e3) {
          return Me = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Me(e3);
        }
        var Fe = ["method"], De = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
        function Ve() {
          Ve = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof v2 ? t4 : v2, a3 = Object.create(i3.prototype), u3 = new I2(n3 || []);
            return o2(a3, "_invoke", { value: O2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function v2() {
          }
          function g2() {
          }
          function b2() {
          }
          var w2 = {};
          c2(w2, a2, function() {
            return this;
          });
          var S2 = Object.getPrototypeOf, k2 = S2 && S2(S2(R2([])));
          k2 && k2 !== r3 && n2.call(k2, a2) && (w2 = k2);
          var E2 = b2.prototype = v2.prototype = Object.create(w2);
          function _2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == Me(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function O2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = x2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function x2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, x2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function A2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function P2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function I2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
          }
          function R2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(Me(t4) + " is not iterable");
          }
          return g2.prototype = b2, o2(E2, "constructor", { value: b2, configurable: true }), o2(b2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(b2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === g2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, b2) : (e4.__proto__ = b2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(E2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, _2(T2.prototype), c2(T2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new T2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, _2(E2), c2(E2, s2, "Generator"), c2(E2, a2, function() {
            return this;
          }), c2(E2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = R2, I2.prototype = { constructor: I2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), P2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  P2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: R2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function qe(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function Ke(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? qe(Object(r3), true).forEach(function(t4) {
              Xe(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : qe(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function He(e3, t3) {
          if (null == e3) return {};
          var r3, n2, o2 = function(e4, t4) {
            if (null == e4) return {};
            var r4 = {};
            for (var n3 in e4) if ({}.hasOwnProperty.call(e4, n3)) {
              if (-1 !== t4.indexOf(n3)) continue;
              r4[n3] = e4[n3];
            }
            return r4;
          }(e3, t3);
          if (Object.getOwnPropertySymbols) {
            var i2 = Object.getOwnPropertySymbols(e3);
            for (n2 = 0; n2 < i2.length; n2++) r3 = i2[n2], -1 === t3.indexOf(r3) && {}.propertyIsEnumerable.call(e3, r3) && (o2[r3] = e3[r3]);
          }
          return o2;
        }
        function ze(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Ge(n2.key), n2);
          }
        }
        function Xe(e3, t3, r3) {
          return (t3 = Ge(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function Ge(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Me(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Me(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Me(t3) ? t3 : t3 + "";
        }
        function $e(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return Qe(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return Qe(e4, t3);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? Qe(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function Qe(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function We(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function Ye(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                We(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                We(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        var Je = "__constructor";
        function Ze(e3) {
          return et.apply(this, arguments);
        }
        function et() {
          return (et = Ye(Ve().mark(function e3(t3) {
            var r3, n2, o2, i2, a2, u2;
            return Ve().wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return e4.prev = 0, e4.next = 3, WebAssembly.compile(t3);
                case 3:
                  n2 = e4.sent, r3 = WebAssembly.Module.customSections(n2, "contractspecv0"), e4.next = 11;
                  break;
                case 7:
                  e4.prev = 7, e4.t0 = e4.catch(0), o2 = tt(t3), r3 = o2.get("contractspecv0");
                case 11:
                  if (r3 && 0 !== r3.length) {
                    e4.next = 13;
                    break;
                  }
                  throw new Error("Could not obtain contract spec from wasm");
                case 13:
                  return i2 = Ue.from(r3[0]), a2 = _(i2), u2 = new Ne(a2), e4.abrupt("return", u2);
                case 17:
                case "end":
                  return e4.stop();
              }
            }, e3, null, [[0, 7]]);
          }))).apply(this, arguments);
        }
        function tt(e3) {
          var t3 = /* @__PURE__ */ new Map(), r3 = e3.buffer.slice(e3.byteOffset, e3.byteOffset + e3.byteLength), n2 = 0, o2 = function(t4) {
            if (n2 + t4 > e3.byteLength) throw new Error("Buffer overflow");
            var o3 = new Uint8Array(r3, n2, t4);
            return n2 += t4, o3;
          };
          if ("0,97,115,109" !== $e(o2(4)).join()) throw new Error("Invalid WASM magic");
          if ("1,0,0,0" !== $e(o2(4)).join()) throw new Error("Invalid WASM version");
          for (; n2 < e3.byteLength; ) {
            var i2 = o2(1)[0], a2 = p2(), u2 = n2;
            if (0 === i2) {
              var s2 = p2();
              if (0 === s2 || n2 + s2 > u2 + a2) continue;
              var c2 = o2(s2), l2 = o2(a2 - (n2 - u2));
              try {
                var f2 = new TextDecoder("utf-8", { fatal: true }).decode(c2);
                l2.length > 0 && t3.set(f2, (t3.get(f2) || []).concat(l2));
              } catch (e4) {
              }
            } else n2 += a2;
          }
          function p2() {
            for (var e4 = 0, t4 = 0; ; ) {
              var r4 = o2(1)[0];
              if (e4 |= (127 & r4) << t4, !(128 & r4)) break;
              if ((t4 += 7) >= 32) throw new Error("Invalid WASM value");
            }
            return e4 >>> 0;
          }
          return t3;
        }
        function rt(e3, t3) {
          return nt.apply(this, arguments);
        }
        function nt() {
          return nt = Ye(Ve().mark(function e3(t3, r3) {
            var n2, i2, a2, u2, s2, c2, l2 = arguments;
            return Ve().wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = l2.length > 2 && void 0 !== l2[2] ? l2[2] : "hex", r3 && r3.rpcUrl) {
                    e4.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  return i2 = r3.rpcUrl, a2 = r3.allowHttp, u2 = { allowHttp: a2 }, s2 = new o.Server(i2, u2), e4.next = 8, s2.getContractWasmByHash(t3, n2);
                case 8:
                  return c2 = e4.sent, e4.abrupt("return", Ze(c2));
                case 10:
                case "end":
                  return e4.stop();
              }
            }, e3);
          })), nt.apply(this, arguments);
        }
        var ot = function() {
          function e3(t4, r4) {
            var n2 = this;
            !function(e4, t5) {
              if (!(e4 instanceof t5)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), Xe(this, "txFromJSON", function(e4) {
              var t5 = JSON.parse(e4), r5 = t5.method, o2 = He(t5, Fe);
              return de.fromJSON(Ke(Ke({}, n2.options), {}, { method: r5, parseResultXdr: function(e5) {
                return n2.spec.funcResToNative(r5, e5);
              } }), o2);
            }), Xe(this, "txFromXDR", function(e4) {
              return de.fromXDR(n2.options, e4, n2.spec);
            }), this.spec = t4, this.options = r4, this.spec.funcs().forEach(function(e4) {
              var o2 = e4.name().toString();
              if (o2 !== Je) {
                var i3 = function(e5, n3) {
                  return de.build(Ke(Ke(Ke({ method: o2, args: e5 && t4.funcArgsToScVals(o2, e5) }, r4), n3), {}, { errorTypes: t4.errorCases().reduce(function(e6, t5) {
                    return Ke(Ke({}, e6), {}, Xe({}, t5.value(), { message: t5.doc().toString() }));
                  }, {}), parseResultXdr: function(e6) {
                    return t4.funcResToNative(o2, e6);
                  } }));
                };
                n2[o2] = 0 === t4.getFunc(o2).inputs().length ? function(e5) {
                  return i3(void 0, e5);
                } : i3;
              }
            });
          }
          return function(e4, t4, r4) {
            return t4 && ze(e4.prototype, t4), r4 && ze(e4, r4), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(e3, null, [{ key: "deploy", value: (a2 = Ye(Ve().mark(function t4(r4, o2) {
            var i3, a3, u2, s2, c2, l2, f2, p2, d2;
            return Ve().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return i3 = o2.wasmHash, a3 = o2.salt, u2 = o2.format, s2 = o2.fee, c2 = o2.timeoutInSeconds, l2 = o2.simulate, f2 = He(o2, De), t5.next = 3, rt(i3, f2, u2);
                case 3:
                  return p2 = t5.sent, d2 = n.Operation.createCustomContract({ address: new n.Address(o2.address || o2.publicKey), wasmHash: "string" == typeof i3 ? Ue.from(i3, null != u2 ? u2 : "hex") : i3, salt: a3, constructorArgs: r4 ? p2.funcArgsToScVals(Je, r4) : [] }), t5.abrupt("return", de.buildWithOp(d2, Ke(Ke({ fee: s2, timeoutInSeconds: c2, simulate: l2 }, f2), {}, { contractId: "ignored", method: Je, parseResultXdr: function(t6) {
                    return new e3(p2, Ke(Ke({}, f2), {}, { contractId: n.Address.fromScVal(t6).toString() }));
                  } })));
                case 6:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4, t4) {
            return a2.apply(this, arguments);
          }) }, { key: "fromWasmHash", value: (i2 = Ye(Ve().mark(function t4(r4, n2) {
            var i3, a3, u2, s2, c2, l2, f2 = arguments;
            return Ve().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  if (i3 = f2.length > 2 && void 0 !== f2[2] ? f2[2] : "hex", n2 && n2.rpcUrl) {
                    t5.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  return a3 = n2.rpcUrl, u2 = n2.allowHttp, s2 = { allowHttp: u2 }, c2 = new o.Server(a3, s2), t5.next = 8, c2.getContractWasmByHash(r4, i3);
                case 8:
                  return l2 = t5.sent, t5.abrupt("return", e3.fromWasm(l2, n2));
                case 10:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4, t4) {
            return i2.apply(this, arguments);
          }) }, { key: "fromWasm", value: (r3 = Ye(Ve().mark(function t4(r4, n2) {
            var o2;
            return Ve().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return t5.next = 2, Ze(r4);
                case 2:
                  return o2 = t5.sent, t5.abrupt("return", new e3(o2, n2));
                case 4:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4, t4) {
            return r3.apply(this, arguments);
          }) }, { key: "from", value: (t3 = Ye(Ve().mark(function t4(r4) {
            var n2, i3, a3, u2, s2, c2;
            return Ve().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  if (r4 && r4.rpcUrl && r4.contractId) {
                    t5.next = 2;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 2:
                  return n2 = r4.rpcUrl, i3 = r4.contractId, a3 = r4.allowHttp, u2 = { allowHttp: a3 }, s2 = new o.Server(n2, u2), t5.next = 7, s2.getContractWasmByContractId(i3);
                case 7:
                  return c2 = t5.sent, t5.abrupt("return", e3.fromWasm(c2, r4));
                case 9:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4) {
            return t3.apply(this, arguments);
          }) }]);
          var t3, r3, i2, a2;
        }();
      }, 6371: (e2, t2, r2) => {
        "use strict";
        r2.d(t2, { ok: () => n, vt: () => o });
        r2(5798);
        var n, o, i = r2(8920);
        n = i.fetchClient, o = i.create;
      }, 6396: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TransactionBuilder = t2.TimeoutInfinite = t2.BASE_FEE = void 0, t2.isValidDate = T;
        var n = r2(3740), o = y(r2(1242)), i = y(r2(1918)), a = r2(2135), u = r2(2243), s = r2(6160), c = r2(380), l = r2(9260), f = r2(4842), p = r2(7120), d = r2(225), h = r2(4172);
        function y(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        function m(e3) {
          return m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, m(e3);
        }
        function v(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return g(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
          }(e3) || function(e4, t3) {
            if (e4) {
              if ("string" == typeof e4) return g(e4, t3);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? g(e4, t3) : void 0;
            }
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function g(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function b(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function w(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? b(Object(r3), true).forEach(function(t4) {
              S(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : b(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function S(e3, t3, r3) {
          return (t3 = E(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function k(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, E(n2.key), n2);
          }
        }
        function E(e3) {
          var t3 = function(e4, t4) {
            if ("object" != m(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != m(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == m(t3) ? t3 : t3 + "";
        }
        var _ = t2.BASE_FEE = "100";
        t2.TimeoutInfinite = 0, t2.TransactionBuilder = function() {
          function e3(t4) {
            var r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (function(e4, t5) {
              if (!(e4 instanceof t5)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), !t4) throw new Error("must specify source account for the transaction");
            if (void 0 === r4.fee) throw new Error("must specify fee for the transaction (in stroops)");
            this.source = t4, this.operations = [], this.baseFee = r4.fee, this.timebounds = r4.timebounds ? w({}, r4.timebounds) : null, this.ledgerbounds = r4.ledgerbounds ? w({}, r4.ledgerbounds) : null, this.minAccountSequence = r4.minAccountSequence || null, this.minAccountSequenceAge = r4.minAccountSequenceAge || null, this.minAccountSequenceLedgerGap = r4.minAccountSequenceLedgerGap || null, this.extraSigners = r4.extraSigners ? v(r4.extraSigners) : null, this.memo = r4.memo || h.Memo.none(), this.networkPassphrase = r4.networkPassphrase || null, this.sorobanData = r4.sorobanData ? new f.SorobanDataBuilder(r4.sorobanData).build() : null;
          }
          return t3 = e3, y2 = [{ key: "cloneFrom", value: function(t4) {
            var r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (!(t4 instanceof c.Transaction)) throw new TypeError("expected a 'Transaction', got: ".concat(t4));
            var n2, o2 = (BigInt(t4.sequence) - 1n).toString();
            if (p.StrKey.isValidMed25519PublicKey(t4.source)) n2 = u.MuxedAccount.fromAddress(t4.source, o2);
            else {
              if (!p.StrKey.isValidEd25519PublicKey(t4.source)) throw new TypeError("unsupported tx source account: ".concat(t4.source));
              n2 = new a.Account(t4.source, o2);
            }
            var i2 = new e3(n2, w({ fee: (parseInt(t4.fee, 10) / t4.operations.length || _).toString(), memo: t4.memo, networkPassphrase: t4.networkPassphrase, timebounds: t4.timeBounds, ledgerbounds: t4.ledgerBounds, minAccountSequence: t4.minAccountSequence, minAccountSequenceAge: t4.minAccountSequenceAge, minAccountSequenceLedgerGap: t4.minAccountSequenceLedgerGap, extraSigners: t4.extraSigners }, r4));
            return t4._tx.operations().forEach(function(e4) {
              return i2.addOperation(e4);
            }), i2;
          } }, { key: "buildFeeBumpTransaction", value: function(e4, t4, r4, n2) {
            var a2 = r4.operations.length, u2 = new o.default(r4.fee).div(a2), c2 = new o.default(t4);
            if (c2.lt(u2)) throw new Error("Invalid baseFee, it should be at least ".concat(u2, " stroops."));
            var f2 = new o.default(_);
            if (c2.lt(f2)) throw new Error("Invalid baseFee, it should be at least ".concat(f2, " stroops."));
            var p2, d2 = r4.toEnvelope();
            if (d2.switch() === i.default.EnvelopeType.envelopeTypeTxV0()) {
              var h2 = d2.v0().tx(), y3 = new i.default.Transaction({ sourceAccount: new i.default.MuxedAccount.keyTypeEd25519(h2.sourceAccountEd25519()), fee: h2.fee(), seqNum: h2.seqNum(), cond: i.default.Preconditions.precondTime(h2.timeBounds()), memo: h2.memo(), operations: h2.operations(), ext: new i.default.TransactionExt(0) });
              d2 = new i.default.TransactionEnvelope.envelopeTypeTx(new i.default.TransactionV1Envelope({ tx: y3, signatures: d2.v0().signatures() }));
            }
            p2 = "string" == typeof e4 ? (0, s.decodeAddressToMuxedAccount)(e4) : e4.xdrMuxedAccount();
            var m2 = new i.default.FeeBumpTransaction({ feeSource: p2, fee: i.default.Int64.fromString(c2.times(a2 + 1).toString()), innerTx: i.default.FeeBumpTransactionInnerTx.envelopeTypeTx(d2.v1()), ext: new i.default.FeeBumpTransactionExt(0) }), v2 = new i.default.FeeBumpTransactionEnvelope({ tx: m2, signatures: [] }), g2 = new i.default.TransactionEnvelope.envelopeTypeTxFeeBump(v2);
            return new l.FeeBumpTransaction(g2, n2);
          } }, { key: "fromXDR", value: function(e4, t4) {
            return "string" == typeof e4 && (e4 = i.default.TransactionEnvelope.fromXDR(e4, "base64")), e4.switch() === i.default.EnvelopeType.envelopeTypeTxFeeBump() ? new l.FeeBumpTransaction(e4, t4) : new c.Transaction(e4, t4);
          } }], (r3 = [{ key: "addOperation", value: function(e4) {
            return this.operations.push(e4), this;
          } }, { key: "addOperationAt", value: function(e4, t4) {
            return this.operations.splice(t4, 0, e4), this;
          } }, { key: "clearOperations", value: function() {
            return this.operations = [], this;
          } }, { key: "clearOperationAt", value: function(e4) {
            return this.operations.splice(e4, 1), this;
          } }, { key: "addMemo", value: function(e4) {
            return this.memo = e4, this;
          } }, { key: "setTimeout", value: function(e4) {
            if (null !== this.timebounds && this.timebounds.maxTime > 0) throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
            if (e4 < 0) throw new Error("timeout cannot be negative");
            if (e4 > 0) {
              var t4 = Math.floor(Date.now() / 1e3) + e4;
              null === this.timebounds ? this.timebounds = { minTime: 0, maxTime: t4 } : this.timebounds = { minTime: this.timebounds.minTime, maxTime: t4 };
            } else this.timebounds = { minTime: 0, maxTime: 0 };
            return this;
          } }, { key: "setTimebounds", value: function(e4, t4) {
            if ("number" == typeof e4 && (e4 = new Date(1e3 * e4)), "number" == typeof t4 && (t4 = new Date(1e3 * t4)), null !== this.timebounds) throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
            var r4 = Math.floor(e4.valueOf() / 1e3), n2 = Math.floor(t4.valueOf() / 1e3);
            if (r4 < 0) throw new Error("min_time cannot be negative");
            if (n2 < 0) throw new Error("max_time cannot be negative");
            if (n2 > 0 && r4 > n2) throw new Error("min_time cannot be greater than max_time");
            return this.timebounds = { minTime: r4, maxTime: n2 }, this;
          } }, { key: "setLedgerbounds", value: function(e4, t4) {
            if (null !== this.ledgerbounds) throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
            if (e4 < 0) throw new Error("min_ledger cannot be negative");
            if (t4 < 0) throw new Error("max_ledger cannot be negative");
            if (t4 > 0 && e4 > t4) throw new Error("min_ledger cannot be greater than max_ledger");
            return this.ledgerbounds = { minLedger: e4, maxLedger: t4 }, this;
          } }, { key: "setMinAccountSequence", value: function(e4) {
            if (null !== this.minAccountSequence) throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
            return this.minAccountSequence = e4, this;
          } }, { key: "setMinAccountSequenceAge", value: function(e4) {
            if ("number" != typeof e4) throw new Error("min_account_sequence_age must be a number");
            if (null !== this.minAccountSequenceAge) throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
            if (e4 < 0) throw new Error("min_account_sequence_age cannot be negative");
            return this.minAccountSequenceAge = e4, this;
          } }, { key: "setMinAccountSequenceLedgerGap", value: function(e4) {
            if (null !== this.minAccountSequenceLedgerGap) throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
            if (e4 < 0) throw new Error("min_account_sequence_ledger_gap cannot be negative");
            return this.minAccountSequenceLedgerGap = e4, this;
          } }, { key: "setExtraSigners", value: function(e4) {
            if (!Array.isArray(e4)) throw new Error("extra_signers must be an array of strings.");
            if (null !== this.extraSigners) throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
            if (e4.length > 2) throw new Error("extra_signers cannot be longer than 2 elements.");
            return this.extraSigners = v(e4), this;
          } }, { key: "setNetworkPassphrase", value: function(e4) {
            return this.networkPassphrase = e4, this;
          } }, { key: "setSorobanData", value: function(e4) {
            return this.sorobanData = new f.SorobanDataBuilder(e4).build(), this;
          } }, { key: "build", value: function() {
            var e4 = new o.default(this.source.sequenceNumber()).plus(1), t4 = { fee: new o.default(this.baseFee).times(this.operations.length).toNumber(), seqNum: i.default.SequenceNumber.fromString(e4.toString()), memo: this.memo ? this.memo.toXDRObject() : null };
            if (null === this.timebounds || void 0 === this.timebounds.minTime || void 0 === this.timebounds.maxTime) throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
            T(this.timebounds.minTime) && (this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3), T(this.timebounds.maxTime) && (this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3), this.timebounds.minTime = n.UnsignedHyper.fromString(this.timebounds.minTime.toString()), this.timebounds.maxTime = n.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
            var r4 = new i.default.TimeBounds(this.timebounds);
            if (this.hasV2Preconditions()) {
              var a2 = null;
              null !== this.ledgerbounds && (a2 = new i.default.LedgerBounds(this.ledgerbounds));
              var u2 = this.minAccountSequence || "0";
              u2 = i.default.SequenceNumber.fromString(u2);
              var l2 = n.UnsignedHyper.fromString(null !== this.minAccountSequenceAge ? this.minAccountSequenceAge.toString() : "0"), f2 = this.minAccountSequenceLedgerGap || 0, p2 = null !== this.extraSigners ? this.extraSigners.map(d.SignerKey.decodeAddress) : [];
              t4.cond = i.default.Preconditions.precondV2(new i.default.PreconditionsV2({ timeBounds: r4, ledgerBounds: a2, minSeqNum: u2, minSeqAge: l2, minSeqLedgerGap: f2, extraSigners: p2 }));
            } else t4.cond = i.default.Preconditions.precondTime(r4);
            t4.sourceAccount = (0, s.decodeAddressToMuxedAccount)(this.source.accountId()), this.sorobanData ? t4.ext = new i.default.TransactionExt(1, this.sorobanData) : t4.ext = new i.default.TransactionExt(0, i.default.Void);
            var h2 = new i.default.Transaction(t4);
            h2.operations(this.operations);
            var y3 = new i.default.TransactionEnvelope.envelopeTypeTx(new i.default.TransactionV1Envelope({ tx: h2 })), m2 = new c.Transaction(y3, this.networkPassphrase);
            return this.source.incrementSequenceNumber(), m2;
          } }, { key: "hasV2Preconditions", value: function() {
            return null !== this.ledgerbounds || null !== this.minAccountSequence || null !== this.minAccountSequenceAge || null !== this.minAccountSequenceLedgerGap || null !== this.extraSigners && this.extraSigners.length > 0;
          } }]) && k(t3.prototype, r3), y2 && k(t3, y2), Object.defineProperty(t3, "prototype", { writable: false }), t3;
          var t3, r3, y2;
        }();
        function T(e3) {
          return e3 instanceof Date && !isNaN(e3);
        }
      }, 6691: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Keypair = void 0;
        var o = c(r2(4940)), i = r2(15), a = r2(7120), u = r2(9152), s = c(r2(1918));
        function c(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        function l(e3) {
          return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, l(e3);
        }
        function f(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, p(n2.key), n2);
          }
        }
        function p(e3) {
          var t3 = function(e4, t4) {
            if ("object" != l(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != l(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == l(t3) ? t3 : t3 + "";
        }
        t2.Keypair = function() {
          return e3 = function e4(t4) {
            if (function(e5, t5) {
              if (!(e5 instanceof t5)) throw new TypeError("Cannot call a class as a function");
            }(this, e4), "ed25519" !== t4.type) throw new Error("Invalid keys type");
            if (this.type = t4.type, t4.secretKey) {
              if (t4.secretKey = n.from(t4.secretKey), 32 !== t4.secretKey.length) throw new Error("secretKey length is invalid");
              if (this._secretSeed = t4.secretKey, this._publicKey = (0, i.generate)(t4.secretKey), this._secretKey = n.concat([t4.secretKey, this._publicKey]), t4.publicKey && !this._publicKey.equals(n.from(t4.publicKey))) throw new Error("secretKey does not match publicKey");
            } else if (this._publicKey = n.from(t4.publicKey), 32 !== this._publicKey.length) throw new Error("publicKey length is invalid");
          }, r3 = [{ key: "fromSecret", value: function(e4) {
            var t4 = a.StrKey.decodeEd25519SecretSeed(e4);
            return this.fromRawEd25519Seed(t4);
          } }, { key: "fromRawEd25519Seed", value: function(e4) {
            return new this({ type: "ed25519", secretKey: e4 });
          } }, { key: "master", value: function(e4) {
            if (!e4) throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
            return this.fromRawEd25519Seed((0, u.hash)(e4));
          } }, { key: "fromPublicKey", value: function(e4) {
            if (32 !== (e4 = a.StrKey.decodeEd25519PublicKey(e4)).length) throw new Error("Invalid Stellar public key");
            return new this({ type: "ed25519", publicKey: e4 });
          } }, { key: "random", value: function() {
            var e4 = o.default.randomBytes(32);
            return this.fromRawEd25519Seed(e4);
          } }], (t3 = [{ key: "xdrAccountId", value: function() {
            return new s.default.AccountId.publicKeyTypeEd25519(this._publicKey);
          } }, { key: "xdrPublicKey", value: function() {
            return new s.default.PublicKey.publicKeyTypeEd25519(this._publicKey);
          } }, { key: "xdrMuxedAccount", value: function(e4) {
            if (void 0 !== e4) {
              if ("string" != typeof e4) throw new TypeError("expected string for ID, got ".concat(l(e4)));
              return s.default.MuxedAccount.keyTypeMuxedEd25519(new s.default.MuxedAccountMed25519({ id: s.default.Uint64.fromString(e4), ed25519: this._publicKey }));
            }
            return new s.default.MuxedAccount.keyTypeEd25519(this._publicKey);
          } }, { key: "rawPublicKey", value: function() {
            return this._publicKey;
          } }, { key: "signatureHint", value: function() {
            var e4 = this.xdrAccountId().toXDR();
            return e4.slice(e4.length - 4);
          } }, { key: "publicKey", value: function() {
            return a.StrKey.encodeEd25519PublicKey(this._publicKey);
          } }, { key: "secret", value: function() {
            if (!this._secretSeed) throw new Error("no secret key available");
            if ("ed25519" === this.type) return a.StrKey.encodeEd25519SecretSeed(this._secretSeed);
            throw new Error("Invalid Keypair type");
          } }, { key: "rawSecretKey", value: function() {
            return this._secretSeed;
          } }, { key: "canSign", value: function() {
            return !!this._secretKey;
          } }, { key: "sign", value: function(e4) {
            if (!this.canSign()) throw new Error("cannot sign: no secret key available");
            return (0, i.sign)(e4, this._secretKey);
          } }, { key: "verify", value: function(e4, t4) {
            return (0, i.verify)(e4, t4, this._publicKey);
          } }, { key: "signDecorated", value: function(e4) {
            var t4 = this.sign(e4), r4 = this.signatureHint();
            return new s.default.DecoratedSignature({ hint: r4, signature: t4 });
          } }, { key: "signPayloadDecorated", value: function(e4) {
            var t4 = this.sign(e4), r4 = this.signatureHint(), o2 = n.from(e4.slice(-4));
            return o2.length < 4 && (o2 = n.concat([o2, n.alloc(4 - e4.length, 0)])), new s.default.DecoratedSignature({ hint: o2.map(function(e5, t5) {
              return e5 ^ r4[t5];
            }), signature: t4 });
          } }]) && f(e3.prototype, t3), r3 && f(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          var e3, t3, r3;
        }();
      }, 6698: (e2) => {
        "function" == typeof Object.create ? e2.exports = function(e3, t2) {
          t2 && (e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }));
        } : e2.exports = function(e3, t2) {
          if (t2) {
            e3.super_ = t2;
            var r2 = function() {
            };
            r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
          }
        };
      }, 6710: (e2, t2, r2) => {
        var n = r2(6698), o = r2(4107), i = r2(392), a = r2(2861).Buffer, u = new Array(64);
        function s() {
          this.init(), this._w = u, i.call(this, 64, 56);
        }
        n(s, o), s.prototype.init = function() {
          return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
        }, s.prototype._hash = function() {
          var e3 = a.allocUnsafe(28);
          return e3.writeInt32BE(this._a, 0), e3.writeInt32BE(this._b, 4), e3.writeInt32BE(this._c, 8), e3.writeInt32BE(this._d, 12), e3.writeInt32BE(this._e, 16), e3.writeInt32BE(this._f, 20), e3.writeInt32BE(this._g, 24), e3;
        }, e2.exports = s;
      }, 7120: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.StrKey = void 0, t2.decodeCheck = d, t2.encodeCheck = h;
        var o, i = (o = r2(5360)) && o.__esModule ? o : { default: o }, a = r2(1346);
        function u(e3) {
          return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, u(e3);
        }
        function s(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, c(n2.key), n2);
          }
        }
        function c(e3) {
          var t3 = function(e4, t4) {
            if ("object" != u(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != u(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == u(t3) ? t3 : t3 + "";
        }
        var l = { ed25519PublicKey: 48, ed25519SecretSeed: 144, med25519PublicKey: 96, preAuthTx: 152, sha256Hash: 184, signedPayload: 120, contract: 16 }, f = { G: "ed25519PublicKey", S: "ed25519SecretSeed", M: "med25519PublicKey", T: "preAuthTx", X: "sha256Hash", P: "signedPayload", C: "contract" };
        t2.StrKey = function() {
          return function(e3, t3, r3) {
            return t3 && s(e3.prototype, t3), r3 && s(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3() {
            !function(e4, t3) {
              if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
            }(this, e3);
          }, null, [{ key: "encodeEd25519PublicKey", value: function(e3) {
            return h("ed25519PublicKey", e3);
          } }, { key: "decodeEd25519PublicKey", value: function(e3) {
            return d("ed25519PublicKey", e3);
          } }, { key: "isValidEd25519PublicKey", value: function(e3) {
            return p("ed25519PublicKey", e3);
          } }, { key: "encodeEd25519SecretSeed", value: function(e3) {
            return h("ed25519SecretSeed", e3);
          } }, { key: "decodeEd25519SecretSeed", value: function(e3) {
            return d("ed25519SecretSeed", e3);
          } }, { key: "isValidEd25519SecretSeed", value: function(e3) {
            return p("ed25519SecretSeed", e3);
          } }, { key: "encodeMed25519PublicKey", value: function(e3) {
            return h("med25519PublicKey", e3);
          } }, { key: "decodeMed25519PublicKey", value: function(e3) {
            return d("med25519PublicKey", e3);
          } }, { key: "isValidMed25519PublicKey", value: function(e3) {
            return p("med25519PublicKey", e3);
          } }, { key: "encodePreAuthTx", value: function(e3) {
            return h("preAuthTx", e3);
          } }, { key: "decodePreAuthTx", value: function(e3) {
            return d("preAuthTx", e3);
          } }, { key: "encodeSha256Hash", value: function(e3) {
            return h("sha256Hash", e3);
          } }, { key: "decodeSha256Hash", value: function(e3) {
            return d("sha256Hash", e3);
          } }, { key: "encodeSignedPayload", value: function(e3) {
            return h("signedPayload", e3);
          } }, { key: "decodeSignedPayload", value: function(e3) {
            return d("signedPayload", e3);
          } }, { key: "isValidSignedPayload", value: function(e3) {
            return p("signedPayload", e3);
          } }, { key: "encodeContract", value: function(e3) {
            return h("contract", e3);
          } }, { key: "decodeContract", value: function(e3) {
            return d("contract", e3);
          } }, { key: "isValidContract", value: function(e3) {
            return p("contract", e3);
          } }, { key: "getVersionByteForPrefix", value: function(e3) {
            return f[e3[0]];
          } }]);
        }();
        function p(e3, t3) {
          if ("string" != typeof t3) return false;
          switch (e3) {
            case "ed25519PublicKey":
            case "ed25519SecretSeed":
            case "preAuthTx":
            case "sha256Hash":
            case "contract":
              if (56 !== t3.length) return false;
              break;
            case "med25519PublicKey":
              if (69 !== t3.length) return false;
              break;
            case "signedPayload":
              if (t3.length < 56 || t3.length > 165) return false;
              break;
            default:
              return false;
          }
          var r3 = "";
          try {
            r3 = d(e3, t3);
          } catch (e4) {
            return false;
          }
          switch (e3) {
            case "ed25519PublicKey":
            case "ed25519SecretSeed":
            case "preAuthTx":
            case "sha256Hash":
            case "contract":
              return 32 === r3.length;
            case "med25519PublicKey":
              return 40 === r3.length;
            case "signedPayload":
              return r3.length >= 40 && r3.length <= 100;
            default:
              return false;
          }
        }
        function d(e3, t3) {
          if ("string" != typeof t3) throw new TypeError("encoded argument must be of type String");
          var r3 = i.default.decode(t3), o2 = r3[0], u2 = r3.slice(0, -2), s2 = u2.slice(1), c2 = r3.slice(-2);
          if (t3 !== i.default.encode(r3)) throw new Error("invalid encoded string");
          var f2 = l[e3];
          if (void 0 === f2) throw new Error("".concat(e3, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(l).join(", ")));
          if (o2 !== f2) throw new Error("invalid version byte. expected ".concat(f2, ", got ").concat(o2));
          var p2 = y(u2);
          if (!(0, a.verifyChecksum)(p2, c2)) throw new Error("invalid checksum");
          return n.from(s2);
        }
        function h(e3, t3) {
          if (null == t3) throw new Error("cannot encode null data");
          var r3 = l[e3];
          if (void 0 === r3) throw new Error("".concat(e3, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(l).join(", ")));
          t3 = n.from(t3);
          var o2 = n.from([r3]), a2 = n.concat([o2, t3]), u2 = n.from(y(a2)), s2 = n.concat([a2, u2]);
          return i.default.encode(s2);
        }
        function y(e3) {
          for (var t3 = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920], r3 = 0, n2 = 0; n2 < e3.length; n2 += 1) {
            r3 = r3 << 8 ^ t3[r3 >> 8 ^ e3[n2]], r3 &= 65535;
          }
          var o2 = new Uint8Array(2);
          return o2[0] = 255 & r3, o2[1] = r3 >> 8 & 255, o2;
        }
      }, 7177: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.nativeToScVal = function e3(t3) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          switch (p(t3)) {
            case "object":
              var o2, f2, d2;
              if (null === t3) return i.default.ScVal.scvVoid();
              if (t3 instanceof i.default.ScVal) return t3;
              if (t3 instanceof u.Address) return t3.toScVal();
              if (t3 instanceof a.Keypair) return e3(t3.publicKey(), { type: "address" });
              if (t3 instanceof s.Contract) return t3.address().toScVal();
              if (t3 instanceof Uint8Array || n.isBuffer(t3)) {
                var h, y = Uint8Array.from(t3);
                switch (null !== (h = null == r3 ? void 0 : r3.type) && void 0 !== h ? h : "bytes") {
                  case "bytes":
                    return i.default.ScVal.scvBytes(y);
                  case "symbol":
                    return i.default.ScVal.scvSymbol(y);
                  case "string":
                    return i.default.ScVal.scvString(y);
                  default:
                    throw new TypeError("invalid type (".concat(r3.type, ") specified for bytes-like value"));
                }
              }
              if (Array.isArray(t3)) return i.default.ScVal.scvVec(t3.map(function(t4) {
                return e3(t4, r3);
              }));
              if ("Object" !== (null !== (o2 = null === (f2 = t3.constructor) || void 0 === f2 ? void 0 : f2.name) && void 0 !== o2 ? o2 : "")) throw new TypeError("cannot interpret ".concat(null === (d2 = t3.constructor) || void 0 === d2 ? void 0 : d2.name, " value as ScVal (").concat(JSON.stringify(t3), ")"));
              return i.default.ScVal.scvMap(Object.entries(t3).sort(function(e4, t4) {
                var r4 = l(e4, 1)[0], n2 = l(t4, 1)[0];
                return r4.localeCompare(n2);
              }).map(function(t4) {
                var n2, o3, a2 = l(t4, 2), u2 = a2[0], s2 = a2[1], c2 = l(null !== (n2 = (null !== (o3 = null == r3 ? void 0 : r3.type) && void 0 !== o3 ? o3 : {})[u2]) && void 0 !== n2 ? n2 : [null, null], 2), f3 = c2[0], p2 = c2[1], d3 = f3 ? { type: f3 } : {}, h2 = p2 ? { type: p2 } : {};
                return new i.default.ScMapEntry({ key: e3(u2, d3), val: e3(s2, h2) });
              }));
            case "number":
            case "bigint":
              switch (null == r3 ? void 0 : r3.type) {
                case "u32":
                  return i.default.ScVal.scvU32(t3);
                case "i32":
                  return i.default.ScVal.scvI32(t3);
              }
              return new c.ScInt(t3, { type: null == r3 ? void 0 : r3.type }).toScVal();
            case "string":
              var m, v = null !== (m = null == r3 ? void 0 : r3.type) && void 0 !== m ? m : "string";
              switch (v) {
                case "string":
                  return i.default.ScVal.scvString(t3);
                case "symbol":
                  return i.default.ScVal.scvSymbol(t3);
                case "address":
                  return new u.Address(t3).toScVal();
                case "u32":
                  return i.default.ScVal.scvU32(parseInt(t3, 10));
                case "i32":
                  return i.default.ScVal.scvI32(parseInt(t3, 10));
                default:
                  if (c.XdrLargeInt.isType(v)) return new c.XdrLargeInt(v, t3).toScVal();
                  throw new TypeError("invalid type (".concat(r3.type, ") specified for string value"));
              }
            case "boolean":
              return i.default.ScVal.scvBool(t3);
            case "undefined":
              return i.default.ScVal.scvVoid();
            case "function":
              return e3(t3());
            default:
              throw new TypeError("failed to convert typeof ".concat(p(t3), " (").concat(t3, ")"));
          }
        }, t2.scValToNative = d;
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(6691), u = r2(1180), s = r2(7452), c = r2(8549);
        function l(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t4) {
            var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != r3) {
              var n2, o2, i2, a2, u2 = [], s2 = true, c2 = false;
              try {
                if (i2 = (r3 = r3.call(e4)).next, 0 === t4) {
                  if (Object(r3) !== r3) return;
                  s2 = false;
                } else for (; !(s2 = (n2 = i2.call(r3)).done) && (u2.push(n2.value), u2.length !== t4); s2 = true) ;
              } catch (e5) {
                c2 = true, o2 = e5;
              } finally {
                try {
                  if (!s2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2)) return;
                } finally {
                  if (c2) throw o2;
                }
              }
              return u2;
            }
          }(e3, t3) || function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return f(e4, t4);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? f(e4, t4) : void 0;
            }
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function f(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function p(e3) {
          return p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, p(e3);
        }
        function d(e3) {
          var t3, r3;
          switch (e3.switch().value) {
            case i.default.ScValType.scvVoid().value:
              return null;
            case i.default.ScValType.scvU64().value:
            case i.default.ScValType.scvI64().value:
              return e3.value().toBigInt();
            case i.default.ScValType.scvU128().value:
            case i.default.ScValType.scvI128().value:
            case i.default.ScValType.scvU256().value:
            case i.default.ScValType.scvI256().value:
              return (0, c.scValToBigInt)(e3);
            case i.default.ScValType.scvVec().value:
              return (null !== (t3 = e3.vec()) && void 0 !== t3 ? t3 : []).map(d);
            case i.default.ScValType.scvAddress().value:
              return u.Address.fromScVal(e3).toString();
            case i.default.ScValType.scvMap().value:
              return Object.fromEntries((null !== (r3 = e3.map()) && void 0 !== r3 ? r3 : []).map(function(e4) {
                return [d(e4.key()), d(e4.val())];
              }));
            case i.default.ScValType.scvBool().value:
            case i.default.ScValType.scvU32().value:
            case i.default.ScValType.scvI32().value:
            case i.default.ScValType.scvBytes().value:
              return e3.value();
            case i.default.ScValType.scvSymbol().value:
            case i.default.ScValType.scvString().value:
              var o2 = e3.value();
              if (n.isBuffer(o2) || ArrayBuffer.isView(o2)) try {
                return new TextDecoder().decode(o2);
              } catch (e4) {
                return new Uint8Array(o2.buffer);
              }
              return o2;
            case i.default.ScValType.scvTimepoint().value:
            case i.default.ScValType.scvDuration().value:
              return new i.default.Uint64(e3.value()).toBigInt();
            case i.default.ScValType.scvError().value:
              if (e3.error().switch().value === i.default.ScErrorType.sceContract().value) return { type: "contract", code: e3.error().contractCode() };
              var a2 = e3.error();
              return { type: "system", code: a2.code().value, value: a2.code().name };
            default:
              return e3.value();
          }
        }
        i.default.scvSortedMap = function(e3) {
          var t3 = Array.from(e3).sort(function(e4, t4) {
            var r3 = d(e4.key()), n2 = d(t4.key());
            switch (p(r3)) {
              case "number":
              case "bigint":
                return r3 < n2 ? -1 : 1;
              default:
                return r3.toString().localeCompare(n2.toString());
            }
          });
          return i.default.ScVal.scvMap(t3);
        };
      }, 7237: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Operation = t2.AuthRevocableFlag = t2.AuthRequiredFlag = t2.AuthImmutableFlag = t2.AuthClawbackEnabledFlag = void 0;
        var n = r2(3740), o = m(r2(1242)), i = r2(645), a = r2(4151), u = r2(1764), s = r2(2262), c = r2(1387), l = r2(7120), f = r2(9353), p = m(r2(1918)), d = function(e3, t3) {
          if (!t3 && e3 && e3.__esModule) return e3;
          if (null === e3 || "object" != v(e3) && "function" != typeof e3) return { default: e3 };
          var r3 = y(t3);
          if (r3 && r3.has(e3)) return r3.get(e3);
          var n2 = { __proto__: null }, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var i2 in e3) if ("default" !== i2 && {}.hasOwnProperty.call(e3, i2)) {
            var a2 = o2 ? Object.getOwnPropertyDescriptor(e3, i2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, i2, a2) : n2[i2] = e3[i2];
          }
          return n2.default = e3, r3 && r3.set(e3, n2), n2;
        }(r2(7511)), h = r2(6160);
        function y(e3) {
          if ("function" != typeof WeakMap) return null;
          var t3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
          return (y = function(e4) {
            return e4 ? r3 : t3;
          })(e3);
        }
        function m(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        function v(e3) {
          return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, v(e3);
        }
        function g(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, b(n2.key), n2);
          }
        }
        function b(e3) {
          var t3 = function(e4, t4) {
            if ("object" != v(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != v(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == v(t3) ? t3 : t3 + "";
        }
        var w = 1e7, S = (t2.AuthRequiredFlag = 1, t2.AuthRevocableFlag = 2, t2.AuthImmutableFlag = 4, t2.AuthClawbackEnabledFlag = 8, t2.Operation = function() {
          return e3 = function e4() {
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e4);
          }, r3 = [{ key: "setSourceAccount", value: function(e4, t4) {
            if (t4.source) try {
              e4.sourceAccount = (0, h.decodeAddressToMuxedAccount)(t4.source);
            } catch (e5) {
              throw new Error("Source address is invalid");
            }
          } }, { key: "fromXDRObject", value: function(e4) {
            var t4 = {};
            e4.sourceAccount() && (t4.source = (0, h.encodeMuxedAccountToAddress)(e4.sourceAccount()));
            var r4 = e4.body().value(), n2 = e4.body().switch().name;
            switch (n2) {
              case "createAccount":
                t4.type = "createAccount", t4.destination = k(r4.destination()), t4.startingBalance = this._fromXDRAmount(r4.startingBalance());
                break;
              case "payment":
                t4.type = "payment", t4.destination = (0, h.encodeMuxedAccountToAddress)(r4.destination()), t4.asset = u.Asset.fromOperation(r4.asset()), t4.amount = this._fromXDRAmount(r4.amount());
                break;
              case "pathPaymentStrictReceive":
                t4.type = "pathPaymentStrictReceive", t4.sendAsset = u.Asset.fromOperation(r4.sendAsset()), t4.sendMax = this._fromXDRAmount(r4.sendMax()), t4.destination = (0, h.encodeMuxedAccountToAddress)(r4.destination()), t4.destAsset = u.Asset.fromOperation(r4.destAsset()), t4.destAmount = this._fromXDRAmount(r4.destAmount()), t4.path = [];
                var o2 = r4.path();
                Object.keys(o2).forEach(function(e5) {
                  t4.path.push(u.Asset.fromOperation(o2[e5]));
                });
                break;
              case "pathPaymentStrictSend":
                t4.type = "pathPaymentStrictSend", t4.sendAsset = u.Asset.fromOperation(r4.sendAsset()), t4.sendAmount = this._fromXDRAmount(r4.sendAmount()), t4.destination = (0, h.encodeMuxedAccountToAddress)(r4.destination()), t4.destAsset = u.Asset.fromOperation(r4.destAsset()), t4.destMin = this._fromXDRAmount(r4.destMin()), t4.path = [];
                var a2 = r4.path();
                Object.keys(a2).forEach(function(e5) {
                  t4.path.push(u.Asset.fromOperation(a2[e5]));
                });
                break;
              case "changeTrust":
                t4.type = "changeTrust", r4.line().switch() === p.default.AssetType.assetTypePoolShare() ? t4.line = s.LiquidityPoolAsset.fromOperation(r4.line()) : t4.line = u.Asset.fromOperation(r4.line()), t4.limit = this._fromXDRAmount(r4.limit());
                break;
              case "allowTrust":
                t4.type = "allowTrust", t4.trustor = k(r4.trustor()), t4.assetCode = r4.asset().value().toString(), t4.assetCode = (0, i.trimEnd)(t4.assetCode, "\0"), t4.authorize = r4.authorize();
                break;
              case "setOptions":
                if (t4.type = "setOptions", r4.inflationDest() && (t4.inflationDest = k(r4.inflationDest())), t4.clearFlags = r4.clearFlags(), t4.setFlags = r4.setFlags(), t4.masterWeight = r4.masterWeight(), t4.lowThreshold = r4.lowThreshold(), t4.medThreshold = r4.medThreshold(), t4.highThreshold = r4.highThreshold(), t4.homeDomain = void 0 !== r4.homeDomain() ? r4.homeDomain().toString("ascii") : void 0, r4.signer()) {
                  var d2 = {}, y2 = r4.signer().key().arm();
                  if ("ed25519" === y2) d2.ed25519PublicKey = k(r4.signer().key());
                  else if ("preAuthTx" === y2) d2.preAuthTx = r4.signer().key().preAuthTx();
                  else if ("hashX" === y2) d2.sha256Hash = r4.signer().key().hashX();
                  else if ("ed25519SignedPayload" === y2) {
                    var m2 = r4.signer().key().ed25519SignedPayload();
                    d2.ed25519SignedPayload = l.StrKey.encodeSignedPayload(m2.toXDR());
                  }
                  d2.weight = r4.signer().weight(), t4.signer = d2;
                }
                break;
              case "manageOffer":
              case "manageSellOffer":
                t4.type = "manageSellOffer", t4.selling = u.Asset.fromOperation(r4.selling()), t4.buying = u.Asset.fromOperation(r4.buying()), t4.amount = this._fromXDRAmount(r4.amount()), t4.price = this._fromXDRPrice(r4.price()), t4.offerId = r4.offerId().toString();
                break;
              case "manageBuyOffer":
                t4.type = "manageBuyOffer", t4.selling = u.Asset.fromOperation(r4.selling()), t4.buying = u.Asset.fromOperation(r4.buying()), t4.buyAmount = this._fromXDRAmount(r4.buyAmount()), t4.price = this._fromXDRPrice(r4.price()), t4.offerId = r4.offerId().toString();
                break;
              case "createPassiveOffer":
              case "createPassiveSellOffer":
                t4.type = "createPassiveSellOffer", t4.selling = u.Asset.fromOperation(r4.selling()), t4.buying = u.Asset.fromOperation(r4.buying()), t4.amount = this._fromXDRAmount(r4.amount()), t4.price = this._fromXDRPrice(r4.price());
                break;
              case "accountMerge":
                t4.type = "accountMerge", t4.destination = (0, h.encodeMuxedAccountToAddress)(r4);
                break;
              case "manageData":
                t4.type = "manageData", t4.name = r4.dataName().toString("ascii"), t4.value = r4.dataValue();
                break;
              case "inflation":
                t4.type = "inflation";
                break;
              case "bumpSequence":
                t4.type = "bumpSequence", t4.bumpTo = r4.bumpTo().toString();
                break;
              case "createClaimableBalance":
                t4.type = "createClaimableBalance", t4.asset = u.Asset.fromOperation(r4.asset()), t4.amount = this._fromXDRAmount(r4.amount()), t4.claimants = [], r4.claimants().forEach(function(e5) {
                  t4.claimants.push(c.Claimant.fromXDR(e5));
                });
                break;
              case "claimClaimableBalance":
                t4.type = "claimClaimableBalance", t4.balanceId = r4.toXDR("hex");
                break;
              case "beginSponsoringFutureReserves":
                t4.type = "beginSponsoringFutureReserves", t4.sponsoredId = k(r4.sponsoredId());
                break;
              case "endSponsoringFutureReserves":
                t4.type = "endSponsoringFutureReserves";
                break;
              case "revokeSponsorship":
                !function(e5, t5) {
                  switch (e5.switch().name) {
                    case "revokeSponsorshipLedgerEntry":
                      var r5 = e5.ledgerKey();
                      switch (r5.switch().name) {
                        case p.default.LedgerEntryType.account().name:
                          t5.type = "revokeAccountSponsorship", t5.account = k(r5.account().accountId());
                          break;
                        case p.default.LedgerEntryType.trustline().name:
                          t5.type = "revokeTrustlineSponsorship", t5.account = k(r5.trustLine().accountId());
                          var n3 = r5.trustLine().asset();
                          n3.switch() === p.default.AssetType.assetTypePoolShare() ? t5.asset = f.LiquidityPoolId.fromOperation(n3) : t5.asset = u.Asset.fromOperation(n3);
                          break;
                        case p.default.LedgerEntryType.offer().name:
                          t5.type = "revokeOfferSponsorship", t5.seller = k(r5.offer().sellerId()), t5.offerId = r5.offer().offerId().toString();
                          break;
                        case p.default.LedgerEntryType.data().name:
                          t5.type = "revokeDataSponsorship", t5.account = k(r5.data().accountId()), t5.name = r5.data().dataName().toString("ascii");
                          break;
                        case p.default.LedgerEntryType.claimableBalance().name:
                          t5.type = "revokeClaimableBalanceSponsorship", t5.balanceId = r5.claimableBalance().balanceId().toXDR("hex");
                          break;
                        case p.default.LedgerEntryType.liquidityPool().name:
                          t5.type = "revokeLiquidityPoolSponsorship", t5.liquidityPoolId = r5.liquidityPool().liquidityPoolId().toString("hex");
                          break;
                        default:
                          throw new Error("Unknown ledgerKey: ".concat(e5.switch().name));
                      }
                      break;
                    case "revokeSponsorshipSigner":
                      t5.type = "revokeSignerSponsorship", t5.account = k(e5.signer().accountId()), t5.signer = function(e6) {
                        var t6 = {};
                        switch (e6.switch().name) {
                          case p.default.SignerKeyType.signerKeyTypeEd25519().name:
                            t6.ed25519PublicKey = l.StrKey.encodeEd25519PublicKey(e6.ed25519());
                            break;
                          case p.default.SignerKeyType.signerKeyTypePreAuthTx().name:
                            t6.preAuthTx = e6.preAuthTx().toString("hex");
                            break;
                          case p.default.SignerKeyType.signerKeyTypeHashX().name:
                            t6.sha256Hash = e6.hashX().toString("hex");
                            break;
                          default:
                            throw new Error("Unknown signerKey: ".concat(e6.switch().name));
                        }
                        return t6;
                      }(e5.signer().signerKey());
                      break;
                    default:
                      throw new Error("Unknown revokeSponsorship: ".concat(e5.switch().name));
                  }
                }(r4, t4);
                break;
              case "clawback":
                t4.type = "clawback", t4.amount = this._fromXDRAmount(r4.amount()), t4.from = (0, h.encodeMuxedAccountToAddress)(r4.from()), t4.asset = u.Asset.fromOperation(r4.asset());
                break;
              case "clawbackClaimableBalance":
                t4.type = "clawbackClaimableBalance", t4.balanceId = r4.toXDR("hex");
                break;
              case "setTrustLineFlags":
                t4.type = "setTrustLineFlags", t4.asset = u.Asset.fromOperation(r4.asset()), t4.trustor = k(r4.trustor());
                var v2 = r4.clearFlags(), g2 = r4.setFlags(), b2 = { authorized: p.default.TrustLineFlags.authorizedFlag(), authorizedToMaintainLiabilities: p.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(), clawbackEnabled: p.default.TrustLineFlags.trustlineClawbackEnabledFlag() };
                t4.flags = {}, Object.keys(b2).forEach(function(e5) {
                  var r5;
                  t4.flags[e5] = (r5 = b2[e5].value, !!(g2 & r5) || !(v2 & r5) && void 0);
                });
                break;
              case "liquidityPoolDeposit":
                t4.type = "liquidityPoolDeposit", t4.liquidityPoolId = r4.liquidityPoolId().toString("hex"), t4.maxAmountA = this._fromXDRAmount(r4.maxAmountA()), t4.maxAmountB = this._fromXDRAmount(r4.maxAmountB()), t4.minPrice = this._fromXDRPrice(r4.minPrice()), t4.maxPrice = this._fromXDRPrice(r4.maxPrice());
                break;
              case "liquidityPoolWithdraw":
                t4.type = "liquidityPoolWithdraw", t4.liquidityPoolId = r4.liquidityPoolId().toString("hex"), t4.amount = this._fromXDRAmount(r4.amount()), t4.minAmountA = this._fromXDRAmount(r4.minAmountA()), t4.minAmountB = this._fromXDRAmount(r4.minAmountB());
                break;
              case "invokeHostFunction":
                var w2;
                t4.type = "invokeHostFunction", t4.func = r4.hostFunction(), t4.auth = null !== (w2 = r4.auth()) && void 0 !== w2 ? w2 : [];
                break;
              case "extendFootprintTtl":
                t4.type = "extendFootprintTtl", t4.extendTo = r4.extendTo();
                break;
              case "restoreFootprint":
                t4.type = "restoreFootprint";
                break;
              default:
                throw new Error("Unknown operation: ".concat(n2));
            }
            return t4;
          } }, { key: "isValidAmount", value: function(e4) {
            var t4, r4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if ("string" != typeof e4) return false;
            try {
              t4 = new o.default(e4);
            } catch (e5) {
              return false;
            }
            return !(!r4 && t4.isZero() || t4.isNegative() || t4.times(w).gt(new o.default("9223372036854775807").toString()) || t4.decimalPlaces() > 7 || t4.isNaN() || !t4.isFinite());
          } }, { key: "constructAmountRequirementsError", value: function(e4) {
            return "".concat(e4, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
          } }, { key: "_checkUnsignedIntValue", value: function(e4, t4) {
            var r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            if (void 0 !== t4) switch ("string" == typeof t4 && (t4 = parseFloat(t4)), true) {
              case ("number" != typeof t4 || !Number.isFinite(t4) || t4 % 1 != 0):
                throw new Error("".concat(e4, " value is invalid"));
              case t4 < 0:
                throw new Error("".concat(e4, " value must be unsigned"));
              case (!r4 || r4 && r4(t4, e4)):
                return t4;
              default:
                throw new Error("".concat(e4, " value is invalid"));
            }
          } }, { key: "_toXDRAmount", value: function(e4) {
            var t4 = new o.default(e4).times(w);
            return n.Hyper.fromString(t4.toString());
          } }, { key: "_fromXDRAmount", value: function(e4) {
            return new o.default(e4).div(w).toFixed(7);
          } }, { key: "_fromXDRPrice", value: function(e4) {
            return new o.default(e4.n()).div(new o.default(e4.d())).toString();
          } }, { key: "_toXDRPrice", value: function(e4) {
            var t4;
            if (e4.n && e4.d) t4 = new p.default.Price(e4);
            else {
              var r4 = (0, a.best_r)(e4);
              t4 = new p.default.Price({ n: parseInt(r4[0], 10), d: parseInt(r4[1], 10) });
            }
            if (t4.n() < 0 || t4.d() < 0) throw new Error("price must be positive");
            return t4;
          } }], (t3 = null) && g(e3.prototype, t3), r3 && g(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          var e3, t3, r3;
        }());
        function k(e3) {
          return l.StrKey.encodeEd25519PublicKey(e3.ed25519());
        }
        S.accountMerge = d.accountMerge, S.allowTrust = d.allowTrust, S.bumpSequence = d.bumpSequence, S.changeTrust = d.changeTrust, S.createAccount = d.createAccount, S.createClaimableBalance = d.createClaimableBalance, S.claimClaimableBalance = d.claimClaimableBalance, S.clawbackClaimableBalance = d.clawbackClaimableBalance, S.createPassiveSellOffer = d.createPassiveSellOffer, S.inflation = d.inflation, S.manageData = d.manageData, S.manageSellOffer = d.manageSellOffer, S.manageBuyOffer = d.manageBuyOffer, S.pathPaymentStrictReceive = d.pathPaymentStrictReceive, S.pathPaymentStrictSend = d.pathPaymentStrictSend, S.payment = d.payment, S.setOptions = d.setOptions, S.beginSponsoringFutureReserves = d.beginSponsoringFutureReserves, S.endSponsoringFutureReserves = d.endSponsoringFutureReserves, S.revokeAccountSponsorship = d.revokeAccountSponsorship, S.revokeTrustlineSponsorship = d.revokeTrustlineSponsorship, S.revokeOfferSponsorship = d.revokeOfferSponsorship, S.revokeDataSponsorship = d.revokeDataSponsorship, S.revokeClaimableBalanceSponsorship = d.revokeClaimableBalanceSponsorship, S.revokeLiquidityPoolSponsorship = d.revokeLiquidityPoolSponsorship, S.revokeSignerSponsorship = d.revokeSignerSponsorship, S.clawback = d.clawback, S.setTrustLineFlags = d.setTrustLineFlags, S.liquidityPoolDeposit = d.liquidityPoolDeposit, S.liquidityPoolWithdraw = d.liquidityPoolWithdraw, S.invokeHostFunction = d.invokeHostFunction, S.extendFootprintTtl = d.extendFootprintTtl, S.restoreFootprint = d.restoreFootprint, S.createStellarAssetContract = d.createStellarAssetContract, S.invokeContractFunction = d.invokeContractFunction, S.createCustomContract = d.createCustomContract, S.uploadContractWasm = d.uploadContractWasm;
      }, 7239: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.claimClaimableBalance = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          i(e3.balanceId);
          var t3 = {};
          t3.balanceId = o.default.ClaimableBalanceId.fromXDR(e3.balanceId, "hex");
          var r3 = new o.default.ClaimClaimableBalanceOp(t3), n2 = {};
          return n2.body = o.default.OperationBody.claimClaimableBalance(r3), this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        }, t2.validateClaimableBalanceId = i;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
        function i(e3) {
          if ("string" != typeof e3 || 72 !== e3.length) throw new Error("must provide a valid claimable balance id");
        }
      }, 7421: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.inflation = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = {};
          return t3.body = o.default.OperationBody.inflation(), this.setSourceAccount(t3, e3), new o.default.Operation(t3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 7429: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.XdrLargeInt = void 0;
        var n, o = r2(3740), i = r2(6272), a = r2(8672), u = r2(5487), s = r2(4063), c = (n = r2(1918)) && n.__esModule ? n : { default: n };
        function l(e3) {
          return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, l(e3);
        }
        function f(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, d(n2.key), n2);
          }
        }
        function p(e3, t3, r3) {
          return (t3 = d(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function d(e3) {
          var t3 = function(e4, t4) {
            if ("object" != l(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != l(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == l(t3) ? t3 : t3 + "";
        }
        t2.XdrLargeInt = function() {
          return function(e3, t3, r3) {
            return t3 && f(e3.prototype, t3), r3 && f(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3, r3) {
            switch (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), p(this, "int", void 0), p(this, "type", void 0), r3 instanceof Array || (r3 = [r3]), r3 = r3.map(function(t4) {
              return "bigint" == typeof t4 ? t4 : t4 instanceof e3 ? t4.toBigInt() : BigInt(t4);
            }), t3) {
              case "i64":
                this.int = new o.Hyper(r3);
                break;
              case "i128":
                this.int = new u.Int128(r3);
                break;
              case "i256":
                this.int = new s.Int256(r3);
                break;
              case "u64":
                this.int = new o.UnsignedHyper(r3);
                break;
              case "u128":
                this.int = new i.Uint128(r3);
                break;
              case "u256":
                this.int = new a.Uint256(r3);
                break;
              default:
                throw TypeError("invalid type: ".concat(t3));
            }
            this.type = t3;
          }, [{ key: "toNumber", value: function() {
            var e3 = this.int.toBigInt();
            if (e3 > Number.MAX_SAFE_INTEGER || e3 < Number.MIN_SAFE_INTEGER) throw RangeError("value ".concat(e3, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
            return Number(e3);
          } }, { key: "toBigInt", value: function() {
            return this.int.toBigInt();
          } }, { key: "toI64", value: function() {
            this._sizeCheck(64);
            var e3 = this.toBigInt();
            if (BigInt.asIntN(64, e3) !== e3) throw RangeError("value too large for i64: ".concat(e3));
            return c.default.ScVal.scvI64(new c.default.Int64(e3));
          } }, { key: "toU64", value: function() {
            return this._sizeCheck(64), c.default.ScVal.scvU64(new c.default.Uint64(BigInt.asUintN(64, this.toBigInt())));
          } }, { key: "toI128", value: function() {
            this._sizeCheck(128);
            var e3 = this.int.toBigInt(), t3 = BigInt.asIntN(64, e3 >> 64n), r3 = BigInt.asUintN(64, e3);
            return c.default.ScVal.scvI128(new c.default.Int128Parts({ hi: new c.default.Int64(t3), lo: new c.default.Uint64(r3) }));
          } }, { key: "toU128", value: function() {
            this._sizeCheck(128);
            var e3 = this.int.toBigInt();
            return c.default.ScVal.scvU128(new c.default.UInt128Parts({ hi: new c.default.Uint64(BigInt.asUintN(64, e3 >> 64n)), lo: new c.default.Uint64(BigInt.asUintN(64, e3)) }));
          } }, { key: "toI256", value: function() {
            var e3 = this.int.toBigInt(), t3 = BigInt.asIntN(64, e3 >> 192n), r3 = BigInt.asUintN(64, e3 >> 128n), n2 = BigInt.asUintN(64, e3 >> 64n), o2 = BigInt.asUintN(64, e3);
            return c.default.ScVal.scvI256(new c.default.Int256Parts({ hiHi: new c.default.Int64(t3), hiLo: new c.default.Uint64(r3), loHi: new c.default.Uint64(n2), loLo: new c.default.Uint64(o2) }));
          } }, { key: "toU256", value: function() {
            var e3 = this.int.toBigInt(), t3 = BigInt.asUintN(64, e3 >> 192n), r3 = BigInt.asUintN(64, e3 >> 128n), n2 = BigInt.asUintN(64, e3 >> 64n), o2 = BigInt.asUintN(64, e3);
            return c.default.ScVal.scvU256(new c.default.UInt256Parts({ hiHi: new c.default.Uint64(t3), hiLo: new c.default.Uint64(r3), loHi: new c.default.Uint64(n2), loLo: new c.default.Uint64(o2) }));
          } }, { key: "toScVal", value: function() {
            switch (this.type) {
              case "i64":
                return this.toI64();
              case "i128":
                return this.toI128();
              case "i256":
                return this.toI256();
              case "u64":
                return this.toU64();
              case "u128":
                return this.toU128();
              case "u256":
                return this.toU256();
              default:
                throw TypeError("invalid type: ".concat(this.type));
            }
          } }, { key: "valueOf", value: function() {
            return this.int.valueOf();
          } }, { key: "toString", value: function() {
            return this.int.toString();
          } }, { key: "toJSON", value: function() {
            return { value: this.toBigInt().toString(), type: this.type };
          } }, { key: "_sizeCheck", value: function(e3) {
            if (this.int.size > e3) throw RangeError("value too large for ".concat(e3, " bits (").concat(this.type, ")"));
          } }], [{ key: "isType", value: function(e3) {
            switch (e3) {
              case "i64":
              case "i128":
              case "i256":
              case "u64":
              case "u128":
              case "u256":
                return true;
              default:
                return false;
            }
          } }, { key: "getType", value: function(e3) {
            return e3.slice(3).toLowerCase();
          } }]);
        }();
      }, 7452: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Contract = void 0;
        var n, o = r2(1180), i = r2(7237), a = (n = r2(1918)) && n.__esModule ? n : { default: n }, u = r2(7120);
        function s(e3) {
          return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, s(e3);
        }
        function c(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, l(n2.key), n2);
          }
        }
        function l(e3) {
          var t3 = function(e4, t4) {
            if ("object" != s(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != s(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == s(t3) ? t3 : t3 + "";
        }
        t2.Contract = function() {
          return function(e3, t3, r3) {
            return t3 && c(e3.prototype, t3), r3 && c(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3) {
            !function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3);
            try {
              this._id = u.StrKey.decodeContract(t3);
            } catch (e4) {
              throw new Error("Invalid contract ID: ".concat(t3));
            }
          }, [{ key: "contractId", value: function() {
            return u.StrKey.encodeContract(this._id);
          } }, { key: "toString", value: function() {
            return this.contractId();
          } }, { key: "address", value: function() {
            return o.Address.contract(this._id);
          } }, { key: "call", value: function(e3) {
            for (var t3 = arguments.length, r3 = new Array(t3 > 1 ? t3 - 1 : 0), n2 = 1; n2 < t3; n2++) r3[n2 - 1] = arguments[n2];
            return i.Operation.invokeContractFunction({ contract: this.address().toString(), function: e3, args: r3 });
          } }, { key: "getFootprint", value: function() {
            return a.default.LedgerKey.contractData(new a.default.LedgerKeyContractData({ contract: this.address().toScAddress(), key: a.default.ScVal.scvLedgerKeyContractInstance(), durability: a.default.ContractDataDurability.persistent() }));
          } }]);
        }();
      }, 7505: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.beginSponsoringFutureReserves = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!i.StrKey.isValidEd25519PublicKey(e3.sponsoredId)) throw new Error("sponsoredId is invalid");
          var t3 = new o.default.BeginSponsoringFutureReservesOp({ sponsoredId: a.Keypair.fromPublicKey(e3.sponsoredId).xdrAccountId() }), r3 = {};
          return r3.body = o.default.OperationBody.beginSponsoringFutureReserves(t3), this.setSourceAccount(r3, e3), new o.default.Operation(r3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(7120), a = r2(6691);
      }, 7511: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "accountMerge", { enumerable: true, get: function() {
          return i.accountMerge;
        } }), Object.defineProperty(t2, "allowTrust", { enumerable: true, get: function() {
          return a.allowTrust;
        } }), Object.defineProperty(t2, "beginSponsoringFutureReserves", { enumerable: true, get: function() {
          return w.beginSponsoringFutureReserves;
        } }), Object.defineProperty(t2, "bumpSequence", { enumerable: true, get: function() {
          return u.bumpSequence;
        } }), Object.defineProperty(t2, "changeTrust", { enumerable: true, get: function() {
          return s.changeTrust;
        } }), Object.defineProperty(t2, "claimClaimableBalance", { enumerable: true, get: function() {
          return f.claimClaimableBalance;
        } }), Object.defineProperty(t2, "clawback", { enumerable: true, get: function() {
          return E.clawback;
        } }), Object.defineProperty(t2, "clawbackClaimableBalance", { enumerable: true, get: function() {
          return p.clawbackClaimableBalance;
        } }), Object.defineProperty(t2, "createAccount", { enumerable: true, get: function() {
          return c.createAccount;
        } }), Object.defineProperty(t2, "createClaimableBalance", { enumerable: true, get: function() {
          return l.createClaimableBalance;
        } }), Object.defineProperty(t2, "createCustomContract", { enumerable: true, get: function() {
          return x.createCustomContract;
        } }), Object.defineProperty(t2, "createPassiveSellOffer", { enumerable: true, get: function() {
          return o.createPassiveSellOffer;
        } }), Object.defineProperty(t2, "createStellarAssetContract", { enumerable: true, get: function() {
          return x.createStellarAssetContract;
        } }), Object.defineProperty(t2, "endSponsoringFutureReserves", { enumerable: true, get: function() {
          return S.endSponsoringFutureReserves;
        } }), Object.defineProperty(t2, "extendFootprintTtl", { enumerable: true, get: function() {
          return A.extendFootprintTtl;
        } }), Object.defineProperty(t2, "inflation", { enumerable: true, get: function() {
          return d.inflation;
        } }), Object.defineProperty(t2, "invokeContractFunction", { enumerable: true, get: function() {
          return x.invokeContractFunction;
        } }), Object.defineProperty(t2, "invokeHostFunction", { enumerable: true, get: function() {
          return x.invokeHostFunction;
        } }), Object.defineProperty(t2, "liquidityPoolDeposit", { enumerable: true, get: function() {
          return T.liquidityPoolDeposit;
        } }), Object.defineProperty(t2, "liquidityPoolWithdraw", { enumerable: true, get: function() {
          return O.liquidityPoolWithdraw;
        } }), Object.defineProperty(t2, "manageBuyOffer", { enumerable: true, get: function() {
          return y.manageBuyOffer;
        } }), Object.defineProperty(t2, "manageData", { enumerable: true, get: function() {
          return h.manageData;
        } }), Object.defineProperty(t2, "manageSellOffer", { enumerable: true, get: function() {
          return n.manageSellOffer;
        } }), Object.defineProperty(t2, "pathPaymentStrictReceive", { enumerable: true, get: function() {
          return m.pathPaymentStrictReceive;
        } }), Object.defineProperty(t2, "pathPaymentStrictSend", { enumerable: true, get: function() {
          return v.pathPaymentStrictSend;
        } }), Object.defineProperty(t2, "payment", { enumerable: true, get: function() {
          return g.payment;
        } }), Object.defineProperty(t2, "restoreFootprint", { enumerable: true, get: function() {
          return P.restoreFootprint;
        } }), Object.defineProperty(t2, "revokeAccountSponsorship", { enumerable: true, get: function() {
          return k.revokeAccountSponsorship;
        } }), Object.defineProperty(t2, "revokeClaimableBalanceSponsorship", { enumerable: true, get: function() {
          return k.revokeClaimableBalanceSponsorship;
        } }), Object.defineProperty(t2, "revokeDataSponsorship", { enumerable: true, get: function() {
          return k.revokeDataSponsorship;
        } }), Object.defineProperty(t2, "revokeLiquidityPoolSponsorship", { enumerable: true, get: function() {
          return k.revokeLiquidityPoolSponsorship;
        } }), Object.defineProperty(t2, "revokeOfferSponsorship", { enumerable: true, get: function() {
          return k.revokeOfferSponsorship;
        } }), Object.defineProperty(t2, "revokeSignerSponsorship", { enumerable: true, get: function() {
          return k.revokeSignerSponsorship;
        } }), Object.defineProperty(t2, "revokeTrustlineSponsorship", { enumerable: true, get: function() {
          return k.revokeTrustlineSponsorship;
        } }), Object.defineProperty(t2, "setOptions", { enumerable: true, get: function() {
          return b.setOptions;
        } }), Object.defineProperty(t2, "setTrustLineFlags", { enumerable: true, get: function() {
          return _.setTrustLineFlags;
        } }), Object.defineProperty(t2, "uploadContractWasm", { enumerable: true, get: function() {
          return x.uploadContractWasm;
        } });
        var n = r2(862), o = r2(9073), i = r2(4295), a = r2(3683), u = r2(6183), s = r2(2810), c = r2(2115), l = r2(4831), f = r2(7239), p = r2(2203), d = r2(7421), h = r2(1411), y = r2(1922), m = r2(2075), v = r2(3874), g = r2(3533), b = r2(2018), w = r2(7505), S = r2(721), k = r2(7790), E = r2(7651), _ = r2(1804), T = r2(9845), O = r2(4737), x = r2(4403), A = r2(8752), P = r2(149);
      }, 7526: (e2, t2) => {
        "use strict";
        t2.byteLength = function(e3) {
          var t3 = u(e3), r3 = t3[0], n2 = t3[1];
          return 3 * (r3 + n2) / 4 - n2;
        }, t2.toByteArray = function(e3) {
          var t3, r3, i2 = u(e3), a2 = i2[0], s2 = i2[1], c = new o(function(e4, t4, r4) {
            return 3 * (t4 + r4) / 4 - r4;
          }(0, a2, s2)), l = 0, f = s2 > 0 ? a2 - 4 : a2;
          for (r3 = 0; r3 < f; r3 += 4) t3 = n[e3.charCodeAt(r3)] << 18 | n[e3.charCodeAt(r3 + 1)] << 12 | n[e3.charCodeAt(r3 + 2)] << 6 | n[e3.charCodeAt(r3 + 3)], c[l++] = t3 >> 16 & 255, c[l++] = t3 >> 8 & 255, c[l++] = 255 & t3;
          2 === s2 && (t3 = n[e3.charCodeAt(r3)] << 2 | n[e3.charCodeAt(r3 + 1)] >> 4, c[l++] = 255 & t3);
          1 === s2 && (t3 = n[e3.charCodeAt(r3)] << 10 | n[e3.charCodeAt(r3 + 1)] << 4 | n[e3.charCodeAt(r3 + 2)] >> 2, c[l++] = t3 >> 8 & 255, c[l++] = 255 & t3);
          return c;
        }, t2.fromByteArray = function(e3) {
          for (var t3, n2 = e3.length, o2 = n2 % 3, i2 = [], a2 = 16383, u2 = 0, c = n2 - o2; u2 < c; u2 += a2) i2.push(s(e3, u2, u2 + a2 > c ? c : u2 + a2));
          1 === o2 ? (t3 = e3[n2 - 1], i2.push(r2[t3 >> 2] + r2[t3 << 4 & 63] + "==")) : 2 === o2 && (t3 = (e3[n2 - 2] << 8) + e3[n2 - 1], i2.push(r2[t3 >> 10] + r2[t3 >> 4 & 63] + r2[t3 << 2 & 63] + "="));
          return i2.join("");
        };
        for (var r2 = [], n = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0; a < 64; ++a) r2[a] = i[a], n[i.charCodeAt(a)] = a;
        function u(e3) {
          var t3 = e3.length;
          if (t3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var r3 = e3.indexOf("=");
          return -1 === r3 && (r3 = t3), [r3, r3 === t3 ? 0 : 4 - r3 % 4];
        }
        function s(e3, t3, n2) {
          for (var o2, i2, a2 = [], u2 = t3; u2 < n2; u2 += 3) o2 = (e3[u2] << 16 & 16711680) + (e3[u2 + 1] << 8 & 65280) + (255 & e3[u2 + 2]), a2.push(r2[(i2 = o2) >> 18 & 63] + r2[i2 >> 12 & 63] + r2[i2 >> 6 & 63] + r2[63 & i2]);
          return a2.join("");
        }
        n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
      }, 7600: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { Api: () => {
        }, FEDERATION_RESPONSE_MAX_SIZE: () => g, Server: () => b });
        var n = r2(356), o = r2(4193), i = r2.n(o), a = r2(8732), u = r2(5976), s = r2(3898), c = r2(6371);
        function l(e3) {
          return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, l(e3);
        }
        function f(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t4) {
            var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != r3) {
              var n2, o2, i2, a2, u2 = [], s2 = true, c2 = false;
              try {
                if (i2 = (r3 = r3.call(e4)).next, 0 === t4) {
                  if (Object(r3) !== r3) return;
                  s2 = false;
                } else for (; !(s2 = (n2 = i2.call(r3)).done) && (u2.push(n2.value), u2.length !== t4); s2 = true) ;
              } catch (e5) {
                c2 = true, o2 = e5;
              } finally {
                try {
                  if (!s2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2)) return;
                } finally {
                  if (c2) throw o2;
                }
              }
              return u2;
            }
          }(e3, t3) || function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return p(e4, t4);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? p(e4, t4) : void 0;
            }
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function p(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function d() {
          d = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function f2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof b2 ? t4 : b2, a3 = Object.create(i3.prototype), u3 = new C(n3 || []);
            return o2(a3, "_invoke", { value: A(e4, r4, u3) }), a3;
          }
          function p2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = f2;
          var h2 = "suspendedStart", y2 = "suspendedYield", m2 = "executing", v2 = "completed", g2 = {};
          function b2() {
          }
          function w() {
          }
          function S() {
          }
          var k = {};
          c2(k, a2, function() {
            return this;
          });
          var E = Object.getPrototypeOf, _ = E && E(E(j([])));
          _ && _ !== r3 && n2.call(_, a2) && (k = _);
          var T = S.prototype = b2.prototype = Object.create(k);
          function O(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function x(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = p2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, f3 = c3.value;
                return f3 && "object" == l(f3) && n2.call(f3, "__await") ? t4.resolve(f3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(f3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function A(t4, r4, n3) {
            var o3 = h2;
            return function(i3, a3) {
              if (o3 === m2) throw Error("Generator is already running");
              if (o3 === v2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = P(u3, n3);
                  if (s3) {
                    if (s3 === g2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === h2) throw o3 = v2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = m2;
                var c3 = p2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? v2 : y2, c3.arg === g2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = v2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function P(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, P(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), g2;
            var i3 = p2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, g2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, g2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, g2);
          }
          function I(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function R(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function C(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(I, this), this.reset(true);
          }
          function j(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(l(t4) + " is not iterable");
          }
          return w.prototype = S, o2(T, "constructor", { value: S, configurable: true }), o2(S, "constructor", { value: w, configurable: true }), w.displayName = c2(S, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === w || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, S) : (e4.__proto__ = S, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(T), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, O(x.prototype), c2(x.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = x, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new x(f2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, O(T), c2(T, s2, "Generator"), c2(T, a2, function() {
            return this;
          }), c2(T, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = j, C.prototype = { constructor: C, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(R), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, g2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), g2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), R(r4), g2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  R(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: j(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), g2;
          } }, t3;
        }
        function h(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function y(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                h(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                h(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function m(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, v(n2.key), n2);
          }
        }
        function v(e3) {
          var t3 = function(e4, t4) {
            if ("object" != l(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != l(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == l(t3) ? t3 : t3 + "";
        }
        var g = 102400, b = function() {
          function e3(t4, r4) {
            var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            !function(e4, t5) {
              if (!(e4 instanceof t5)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), this.serverURL = i()(t4), this.domain = r4;
            var o3 = void 0 === n2.allowHttp ? a.T.isAllowHttp() : n2.allowHttp;
            if (this.timeout = void 0 === n2.timeout ? a.T.getTimeout() : n2.timeout, "https" !== this.serverURL.protocol() && !o3) throw new Error("Cannot connect to insecure federation server");
          }
          return t3 = e3, r3 = [{ key: "resolveAddress", value: (w = y(d().mark(function e4(t4) {
            var r4, n2;
            return d().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  if (r4 = t4, !(t4.indexOf("*") < 0)) {
                    e5.next = 5;
                    break;
                  }
                  if (this.domain) {
                    e5.next = 4;
                    break;
                  }
                  return e5.abrupt("return", Promise.reject(new Error("Unknown domain. Make sure `address` contains a domain (ex. `bob*stellar.org`) or pass `domain` parameter when instantiating the server object.")));
                case 4:
                  r4 = "".concat(t4, "*").concat(this.domain);
                case 5:
                  return n2 = this.serverURL.query({ type: "name", q: r4 }), e5.abrupt("return", this._sendRequest(n2));
                case 7:
                case "end":
                  return e5.stop();
              }
            }, e4, this);
          })), function(e4) {
            return w.apply(this, arguments);
          }) }, { key: "resolveAccountId", value: (b2 = y(d().mark(function e4(t4) {
            var r4;
            return d().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  return r4 = this.serverURL.query({ type: "id", q: t4 }), e5.abrupt("return", this._sendRequest(r4));
                case 2:
                case "end":
                  return e5.stop();
              }
            }, e4, this);
          })), function(e4) {
            return b2.apply(this, arguments);
          }) }, { key: "resolveTransactionId", value: (v2 = y(d().mark(function e4(t4) {
            var r4;
            return d().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  return r4 = this.serverURL.query({ type: "txid", q: t4 }), e5.abrupt("return", this._sendRequest(r4));
                case 2:
                case "end":
                  return e5.stop();
              }
            }, e4, this);
          })), function(e4) {
            return v2.apply(this, arguments);
          }) }, { key: "_sendRequest", value: (h2 = y(d().mark(function e4(t4) {
            var r4;
            return d().wrap(function(e5) {
              for (; ; ) switch (e5.prev = e5.next) {
                case 0:
                  return r4 = this.timeout, e5.abrupt("return", c.ok.get(t4.toString(), { maxContentLength: g, timeout: r4 }).then(function(e6) {
                    if (void 0 !== e6.data.memo && "string" != typeof e6.data.memo) throw new Error("memo value should be of type string");
                    return e6.data;
                  }).catch(function(e6) {
                    if (e6 instanceof Error) {
                      if (e6.message.match(/^maxContentLength size/)) throw new Error("federation response exceeds allowed size of ".concat(g));
                      return Promise.reject(e6);
                    }
                    return Promise.reject(new u.nS("Server query failed. Server responded: ".concat(e6.status, " ").concat(e6.statusText), e6.data));
                  }));
                case 2:
                case "end":
                  return e5.stop();
              }
            }, e4, this);
          })), function(e4) {
            return h2.apply(this, arguments);
          }) }], o2 = [{ key: "resolve", value: (p2 = y(d().mark(function t4(r4) {
            var o3, i2, a2, u2, s2, c2 = arguments;
            return d().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  if (o3 = c2.length > 1 && void 0 !== c2[1] ? c2[1] : {}, !(r4.indexOf("*") < 0)) {
                    t5.next = 5;
                    break;
                  }
                  if (n.StrKey.isValidEd25519PublicKey(r4)) {
                    t5.next = 4;
                    break;
                  }
                  return t5.abrupt("return", Promise.reject(new Error("Invalid Account ID")));
                case 4:
                  return t5.abrupt("return", Promise.resolve({ account_id: r4 }));
                case 5:
                  if (i2 = r4.split("*"), a2 = f(i2, 2), u2 = a2[1], 2 === i2.length && u2) {
                    t5.next = 9;
                    break;
                  }
                  return t5.abrupt("return", Promise.reject(new Error("Invalid Stellar address")));
                case 9:
                  return t5.next = 11, e3.createForDomain(u2, o3);
                case 11:
                  return s2 = t5.sent, t5.abrupt("return", s2.resolveAddress(r4));
                case 13:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4) {
            return p2.apply(this, arguments);
          }) }, { key: "createForDomain", value: (l2 = y(d().mark(function t4(r4) {
            var n2, o3, i2 = arguments;
            return d().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return n2 = i2.length > 1 && void 0 !== i2[1] ? i2[1] : {}, t5.next = 3, s.Resolver.resolve(r4, n2);
                case 3:
                  if ((o3 = t5.sent).FEDERATION_SERVER) {
                    t5.next = 6;
                    break;
                  }
                  return t5.abrupt("return", Promise.reject(new Error("stellar.toml does not contain FEDERATION_SERVER field")));
                case 6:
                  return t5.abrupt("return", new e3(o3.FEDERATION_SERVER, r4, n2));
                case 7:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function(e4) {
            return l2.apply(this, arguments);
          }) }], r3 && m(t3.prototype, r3), o2 && m(t3, o2), Object.defineProperty(t3, "prototype", { writable: false }), t3;
          var t3, r3, o2, l2, p2, h2, v2, b2, w;
        }();
      }, 7651: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.clawback = function(e3) {
          var t3 = {};
          if (!this.isValidAmount(e3.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          t3.amount = this._toXDRAmount(e3.amount), t3.asset = e3.asset.toXDRObject();
          try {
            t3.from = (0, i.decodeAddressToMuxedAccount)(e3.from);
          } catch (e4) {
            throw new Error("from address is invalid");
          }
          var r3 = { body: o.default.OperationBody.clawback(new o.default.ClawbackOp(t3)) };
          return this.setSourceAccount(r3, e3), new o.default.Operation(r3);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n }, i = r2(6160);
      }, 7790: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.revokeAccountSponsorship = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!a.StrKey.isValidEd25519PublicKey(e3.account)) throw new Error("account is invalid");
          var t3 = i.default.LedgerKey.account(new i.default.LedgerKeyAccount({ accountId: u.Keypair.fromPublicKey(e3.account).xdrAccountId() })), r3 = i.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t3), n2 = {};
          return n2.body = i.default.OperationBody.revokeSponsorship(r3), this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        }, t2.revokeClaimableBalanceSponsorship = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if ("string" != typeof e3.balanceId) throw new Error("balanceId is invalid");
          var t3 = i.default.LedgerKey.claimableBalance(new i.default.LedgerKeyClaimableBalance({ balanceId: i.default.ClaimableBalanceId.fromXDR(e3.balanceId, "hex") })), r3 = i.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t3), n2 = {};
          return n2.body = i.default.OperationBody.revokeSponsorship(r3), this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        }, t2.revokeDataSponsorship = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!a.StrKey.isValidEd25519PublicKey(e3.account)) throw new Error("account is invalid");
          if ("string" != typeof e3.name || e3.name.length > 64) throw new Error("name must be a string, up to 64 characters");
          var t3 = i.default.LedgerKey.data(new i.default.LedgerKeyData({ accountId: u.Keypair.fromPublicKey(e3.account).xdrAccountId(), dataName: e3.name })), r3 = i.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t3), n2 = {};
          return n2.body = i.default.OperationBody.revokeSponsorship(r3), this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        }, t2.revokeLiquidityPoolSponsorship = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if ("string" != typeof e3.liquidityPoolId) throw new Error("liquidityPoolId is invalid");
          var t3 = i.default.LedgerKey.liquidityPool(new i.default.LedgerKeyLiquidityPool({ liquidityPoolId: i.default.PoolId.fromXDR(e3.liquidityPoolId, "hex") })), r3 = i.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t3), n2 = { body: i.default.OperationBody.revokeSponsorship(r3) };
          return this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        }, t2.revokeOfferSponsorship = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!a.StrKey.isValidEd25519PublicKey(e3.seller)) throw new Error("seller is invalid");
          if ("string" != typeof e3.offerId) throw new Error("offerId is invalid");
          var t3 = i.default.LedgerKey.offer(new i.default.LedgerKeyOffer({ sellerId: u.Keypair.fromPublicKey(e3.seller).xdrAccountId(), offerId: i.default.Int64.fromString(e3.offerId) })), r3 = i.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(t3), n2 = {};
          return n2.body = i.default.OperationBody.revokeSponsorship(r3), this.setSourceAccount(n2, e3), new i.default.Operation(n2);
        }, t2.revokeSignerSponsorship = function() {
          var e3, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!a.StrKey.isValidEd25519PublicKey(t3.account)) throw new Error("account is invalid");
          if (t3.signer.ed25519PublicKey) {
            if (!a.StrKey.isValidEd25519PublicKey(t3.signer.ed25519PublicKey)) throw new Error("signer.ed25519PublicKey is invalid.");
            var r3 = a.StrKey.decodeEd25519PublicKey(t3.signer.ed25519PublicKey);
            e3 = new i.default.SignerKey.signerKeyTypeEd25519(r3);
          } else if (t3.signer.preAuthTx) {
            var o2;
            if (o2 = "string" == typeof t3.signer.preAuthTx ? n.from(t3.signer.preAuthTx, "hex") : t3.signer.preAuthTx, !n.isBuffer(o2) || 32 !== o2.length) throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
            e3 = new i.default.SignerKey.signerKeyTypePreAuthTx(o2);
          } else {
            if (!t3.signer.sha256Hash) throw new Error("signer is invalid");
            var s2;
            if (s2 = "string" == typeof t3.signer.sha256Hash ? n.from(t3.signer.sha256Hash, "hex") : t3.signer.sha256Hash, !n.isBuffer(s2) || 32 !== s2.length) throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
            e3 = new i.default.SignerKey.signerKeyTypeHashX(s2);
          }
          var c2 = new i.default.RevokeSponsorshipOpSigner({ accountId: u.Keypair.fromPublicKey(t3.account).xdrAccountId(), signerKey: e3 }), l = i.default.RevokeSponsorshipOp.revokeSponsorshipSigner(c2), f = {};
          return f.body = i.default.OperationBody.revokeSponsorship(l), this.setSourceAccount(f, t3), new i.default.Operation(f);
        }, t2.revokeTrustlineSponsorship = function() {
          var e3, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!a.StrKey.isValidEd25519PublicKey(t3.account)) throw new Error("account is invalid");
          if (t3.asset instanceof s.Asset) e3 = t3.asset.toTrustLineXDRObject();
          else {
            if (!(t3.asset instanceof c.LiquidityPoolId)) throw new TypeError("asset must be an Asset or LiquidityPoolId");
            e3 = t3.asset.toXDRObject();
          }
          var r3 = i.default.LedgerKey.trustline(new i.default.LedgerKeyTrustLine({ accountId: u.Keypair.fromPublicKey(t3.account).xdrAccountId(), asset: e3 })), n2 = i.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(r3), o2 = {};
          return o2.body = i.default.OperationBody.revokeSponsorship(n2), this.setSourceAccount(o2, t3), new i.default.Operation(o2);
        };
        var o, i = (o = r2(1918)) && o.__esModule ? o : { default: o }, a = r2(7120), u = r2(6691), s = r2(1764), c = r2(9353);
      }, 7816: (e2, t2, r2) => {
        var n = r2(6698), o = r2(392), i = r2(2861).Buffer, a = [1518500249, 1859775393, -1894007588, -899497514], u = new Array(80);
        function s() {
          this.init(), this._w = u, o.call(this, 64, 56);
        }
        function c(e3) {
          return e3 << 30 | e3 >>> 2;
        }
        function l(e3, t3, r3, n2) {
          return 0 === e3 ? t3 & r3 | ~t3 & n2 : 2 === e3 ? t3 & r3 | t3 & n2 | r3 & n2 : t3 ^ r3 ^ n2;
        }
        n(s, o), s.prototype.init = function() {
          return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, s.prototype._update = function(e3) {
          for (var t3, r3 = this._w, n2 = 0 | this._a, o2 = 0 | this._b, i2 = 0 | this._c, u2 = 0 | this._d, s2 = 0 | this._e, f = 0; f < 16; ++f) r3[f] = e3.readInt32BE(4 * f);
          for (; f < 80; ++f) r3[f] = r3[f - 3] ^ r3[f - 8] ^ r3[f - 14] ^ r3[f - 16];
          for (var p = 0; p < 80; ++p) {
            var d = ~~(p / 20), h = 0 | ((t3 = n2) << 5 | t3 >>> 27) + l(d, o2, i2, u2) + s2 + r3[p] + a[d];
            s2 = u2, u2 = i2, i2 = c(o2), o2 = n2, n2 = h;
          }
          this._a = n2 + this._a | 0, this._b = o2 + this._b | 0, this._c = i2 + this._c | 0, this._d = u2 + this._d | 0, this._e = s2 + this._e | 0;
        }, s.prototype._hash = function() {
          var e3 = i.allocUnsafe(20);
          return e3.writeInt32BE(0 | this._a, 0), e3.writeInt32BE(0 | this._b, 4), e3.writeInt32BE(0 | this._c, 8), e3.writeInt32BE(0 | this._d, 12), e3.writeInt32BE(0 | this._e, 16), e3;
        }, e2.exports = s;
      }, 7938: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        function o(e3) {
          if ("function" != typeof WeakMap) return null;
          var t3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
          return (o = function(e4) {
            return e4 ? r3 : t3;
          })(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var i = function(e3, t3) {
          if (!t3 && e3 && e3.__esModule) return e3;
          if (null === e3 || "object" != n(e3) && "function" != typeof e3) return { default: e3 };
          var r3 = o(t3);
          if (r3 && r3.has(e3)) return r3.get(e3);
          var i2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var u in e3) if ("default" !== u && {}.hasOwnProperty.call(e3, u)) {
            var s = a ? Object.getOwnPropertyDescriptor(e3, u) : null;
            s && (s.get || s.set) ? Object.defineProperty(i2, u, s) : i2[u] = e3[u];
          }
          return i2.default = e3, r3 && r3.set(e3, i2), i2;
        }(r2(3740)).config(function(e3) {
          var t3 = 1024;
          e3.typedef("Value", e3.varOpaque()), e3.struct("ScpBallot", [["counter", e3.lookup("Uint32")], ["value", e3.lookup("Value")]]), e3.enum("ScpStatementType", { scpStPrepare: 0, scpStConfirm: 1, scpStExternalize: 2, scpStNominate: 3 }), e3.struct("ScpNomination", [["quorumSetHash", e3.lookup("Hash")], ["votes", e3.varArray(e3.lookup("Value"), 2147483647)], ["accepted", e3.varArray(e3.lookup("Value"), 2147483647)]]), e3.struct("ScpStatementPrepare", [["quorumSetHash", e3.lookup("Hash")], ["ballot", e3.lookup("ScpBallot")], ["prepared", e3.option(e3.lookup("ScpBallot"))], ["preparedPrime", e3.option(e3.lookup("ScpBallot"))], ["nC", e3.lookup("Uint32")], ["nH", e3.lookup("Uint32")]]), e3.struct("ScpStatementConfirm", [["ballot", e3.lookup("ScpBallot")], ["nPrepared", e3.lookup("Uint32")], ["nCommit", e3.lookup("Uint32")], ["nH", e3.lookup("Uint32")], ["quorumSetHash", e3.lookup("Hash")]]), e3.struct("ScpStatementExternalize", [["commit", e3.lookup("ScpBallot")], ["nH", e3.lookup("Uint32")], ["commitQuorumSetHash", e3.lookup("Hash")]]), e3.union("ScpStatementPledges", { switchOn: e3.lookup("ScpStatementType"), switchName: "type", switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]], arms: { prepare: e3.lookup("ScpStatementPrepare"), confirm: e3.lookup("ScpStatementConfirm"), externalize: e3.lookup("ScpStatementExternalize"), nominate: e3.lookup("ScpNomination") } }), e3.struct("ScpStatement", [["nodeId", e3.lookup("NodeId")], ["slotIndex", e3.lookup("Uint64")], ["pledges", e3.lookup("ScpStatementPledges")]]), e3.struct("ScpEnvelope", [["statement", e3.lookup("ScpStatement")], ["signature", e3.lookup("Signature")]]), e3.struct("ScpQuorumSet", [["threshold", e3.lookup("Uint32")], ["validators", e3.varArray(e3.lookup("NodeId"), 2147483647)], ["innerSets", e3.varArray(e3.lookup("ScpQuorumSet"), 2147483647)]]), e3.typedef("Thresholds", e3.opaque(4)), e3.typedef("String32", e3.string(32)), e3.typedef("String64", e3.string(64)), e3.typedef("SequenceNumber", e3.lookup("Int64")), e3.typedef("DataValue", e3.varOpaque(64)), e3.typedef("PoolId", e3.lookup("Hash")), e3.typedef("AssetCode4", e3.opaque(4)), e3.typedef("AssetCode12", e3.opaque(12)), e3.enum("AssetType", { assetTypeNative: 0, assetTypeCreditAlphanum4: 1, assetTypeCreditAlphanum12: 2, assetTypePoolShare: 3 }), e3.union("AssetCode", { switchOn: e3.lookup("AssetType"), switchName: "type", switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]], arms: { assetCode4: e3.lookup("AssetCode4"), assetCode12: e3.lookup("AssetCode12") } }), e3.struct("AlphaNum4", [["assetCode", e3.lookup("AssetCode4")], ["issuer", e3.lookup("AccountId")]]), e3.struct("AlphaNum12", [["assetCode", e3.lookup("AssetCode12")], ["issuer", e3.lookup("AccountId")]]), e3.union("Asset", { switchOn: e3.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", e3.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]], arms: { alphaNum4: e3.lookup("AlphaNum4"), alphaNum12: e3.lookup("AlphaNum12") } }), e3.struct("Price", [["n", e3.lookup("Int32")], ["d", e3.lookup("Int32")]]), e3.struct("Liabilities", [["buying", e3.lookup("Int64")], ["selling", e3.lookup("Int64")]]), e3.enum("ThresholdIndices", { thresholdMasterWeight: 0, thresholdLow: 1, thresholdMed: 2, thresholdHigh: 3 }), e3.enum("LedgerEntryType", { account: 0, trustline: 1, offer: 2, data: 3, claimableBalance: 4, liquidityPool: 5, contractData: 6, contractCode: 7, configSetting: 8, ttl: 9 }), e3.struct("Signer", [["key", e3.lookup("SignerKey")], ["weight", e3.lookup("Uint32")]]), e3.enum("AccountFlags", { authRequiredFlag: 1, authRevocableFlag: 2, authImmutableFlag: 4, authClawbackEnabledFlag: 8 }), e3.const("MASK_ACCOUNT_FLAGS", 7), e3.const("MASK_ACCOUNT_FLAGS_V17", 15), e3.const("MAX_SIGNERS", 20), e3.typedef("SponsorshipDescriptor", e3.option(e3.lookup("AccountId"))), e3.struct("AccountEntryExtensionV3", [["ext", e3.lookup("ExtensionPoint")], ["seqLedger", e3.lookup("Uint32")], ["seqTime", e3.lookup("TimePoint")]]), e3.union("AccountEntryExtensionV2Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [3, "v3"]], arms: { v3: e3.lookup("AccountEntryExtensionV3") } }), e3.struct("AccountEntryExtensionV2", [["numSponsored", e3.lookup("Uint32")], ["numSponsoring", e3.lookup("Uint32")], ["signerSponsoringIDs", e3.varArray(e3.lookup("SponsorshipDescriptor"), e3.lookup("MAX_SIGNERS"))], ["ext", e3.lookup("AccountEntryExtensionV2Ext")]]), e3.union("AccountEntryExtensionV1Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [2, "v2"]], arms: { v2: e3.lookup("AccountEntryExtensionV2") } }), e3.struct("AccountEntryExtensionV1", [["liabilities", e3.lookup("Liabilities")], ["ext", e3.lookup("AccountEntryExtensionV1Ext")]]), e3.union("AccountEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("AccountEntryExtensionV1") } }), e3.struct("AccountEntry", [["accountId", e3.lookup("AccountId")], ["balance", e3.lookup("Int64")], ["seqNum", e3.lookup("SequenceNumber")], ["numSubEntries", e3.lookup("Uint32")], ["inflationDest", e3.option(e3.lookup("AccountId"))], ["flags", e3.lookup("Uint32")], ["homeDomain", e3.lookup("String32")], ["thresholds", e3.lookup("Thresholds")], ["signers", e3.varArray(e3.lookup("Signer"), e3.lookup("MAX_SIGNERS"))], ["ext", e3.lookup("AccountEntryExt")]]), e3.enum("TrustLineFlags", { authorizedFlag: 1, authorizedToMaintainLiabilitiesFlag: 2, trustlineClawbackEnabledFlag: 4 }), e3.const("MASK_TRUSTLINE_FLAGS", 1), e3.const("MASK_TRUSTLINE_FLAGS_V13", 3), e3.const("MASK_TRUSTLINE_FLAGS_V17", 7), e3.enum("LiquidityPoolType", { liquidityPoolConstantProduct: 0 }), e3.union("TrustLineAsset", { switchOn: e3.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", e3.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]], arms: { alphaNum4: e3.lookup("AlphaNum4"), alphaNum12: e3.lookup("AlphaNum12"), liquidityPoolId: e3.lookup("PoolId") } }), e3.union("TrustLineEntryExtensionV2Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", e3.lookup("Int32")], ["ext", e3.lookup("TrustLineEntryExtensionV2Ext")]]), e3.union("TrustLineEntryV1Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [2, "v2"]], arms: { v2: e3.lookup("TrustLineEntryExtensionV2") } }), e3.struct("TrustLineEntryV1", [["liabilities", e3.lookup("Liabilities")], ["ext", e3.lookup("TrustLineEntryV1Ext")]]), e3.union("TrustLineEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("TrustLineEntryV1") } }), e3.struct("TrustLineEntry", [["accountId", e3.lookup("AccountId")], ["asset", e3.lookup("TrustLineAsset")], ["balance", e3.lookup("Int64")], ["limit", e3.lookup("Int64")], ["flags", e3.lookup("Uint32")], ["ext", e3.lookup("TrustLineEntryExt")]]), e3.enum("OfferEntryFlags", { passiveFlag: 1 }), e3.const("MASK_OFFERENTRY_FLAGS", 1), e3.union("OfferEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("OfferEntry", [["sellerId", e3.lookup("AccountId")], ["offerId", e3.lookup("Int64")], ["selling", e3.lookup("Asset")], ["buying", e3.lookup("Asset")], ["amount", e3.lookup("Int64")], ["price", e3.lookup("Price")], ["flags", e3.lookup("Uint32")], ["ext", e3.lookup("OfferEntryExt")]]), e3.union("DataEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("DataEntry", [["accountId", e3.lookup("AccountId")], ["dataName", e3.lookup("String64")], ["dataValue", e3.lookup("DataValue")], ["ext", e3.lookup("DataEntryExt")]]), e3.enum("ClaimPredicateType", { claimPredicateUnconditional: 0, claimPredicateAnd: 1, claimPredicateOr: 2, claimPredicateNot: 3, claimPredicateBeforeAbsoluteTime: 4, claimPredicateBeforeRelativeTime: 5 }), e3.union("ClaimPredicate", { switchOn: e3.lookup("ClaimPredicateType"), switchName: "type", switches: [["claimPredicateUnconditional", e3.void()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]], arms: { andPredicates: e3.varArray(e3.lookup("ClaimPredicate"), 2), orPredicates: e3.varArray(e3.lookup("ClaimPredicate"), 2), notPredicate: e3.option(e3.lookup("ClaimPredicate")), absBefore: e3.lookup("Int64"), relBefore: e3.lookup("Int64") } }), e3.enum("ClaimantType", { claimantTypeV0: 0 }), e3.struct("ClaimantV0", [["destination", e3.lookup("AccountId")], ["predicate", e3.lookup("ClaimPredicate")]]), e3.union("Claimant", { switchOn: e3.lookup("ClaimantType"), switchName: "type", switches: [["claimantTypeV0", "v0"]], arms: { v0: e3.lookup("ClaimantV0") } }), e3.enum("ClaimableBalanceIdType", { claimableBalanceIdTypeV0: 0 }), e3.union("ClaimableBalanceId", { switchOn: e3.lookup("ClaimableBalanceIdType"), switchName: "type", switches: [["claimableBalanceIdTypeV0", "v0"]], arms: { v0: e3.lookup("Hash") } }), e3.enum("ClaimableBalanceFlags", { claimableBalanceClawbackEnabledFlag: 1 }), e3.const("MASK_CLAIMABLE_BALANCE_FLAGS", 1), e3.union("ClaimableBalanceEntryExtensionV1Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("ClaimableBalanceEntryExtensionV1", [["ext", e3.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", e3.lookup("Uint32")]]), e3.union("ClaimableBalanceEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("ClaimableBalanceEntryExtensionV1") } }), e3.struct("ClaimableBalanceEntry", [["balanceId", e3.lookup("ClaimableBalanceId")], ["claimants", e3.varArray(e3.lookup("Claimant"), 10)], ["asset", e3.lookup("Asset")], ["amount", e3.lookup("Int64")], ["ext", e3.lookup("ClaimableBalanceEntryExt")]]), e3.struct("LiquidityPoolConstantProductParameters", [["assetA", e3.lookup("Asset")], ["assetB", e3.lookup("Asset")], ["fee", e3.lookup("Int32")]]), e3.struct("LiquidityPoolEntryConstantProduct", [["params", e3.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", e3.lookup("Int64")], ["reserveB", e3.lookup("Int64")], ["totalPoolShares", e3.lookup("Int64")], ["poolSharesTrustLineCount", e3.lookup("Int64")]]), e3.union("LiquidityPoolEntryBody", { switchOn: e3.lookup("LiquidityPoolType"), switchName: "type", switches: [["liquidityPoolConstantProduct", "constantProduct"]], arms: { constantProduct: e3.lookup("LiquidityPoolEntryConstantProduct") } }), e3.struct("LiquidityPoolEntry", [["liquidityPoolId", e3.lookup("PoolId")], ["body", e3.lookup("LiquidityPoolEntryBody")]]), e3.enum("ContractDataDurability", { temporary: 0, persistent: 1 }), e3.struct("ContractDataEntry", [["ext", e3.lookup("ExtensionPoint")], ["contract", e3.lookup("ScAddress")], ["key", e3.lookup("ScVal")], ["durability", e3.lookup("ContractDataDurability")], ["val", e3.lookup("ScVal")]]), e3.struct("ContractCodeCostInputs", [["ext", e3.lookup("ExtensionPoint")], ["nInstructions", e3.lookup("Uint32")], ["nFunctions", e3.lookup("Uint32")], ["nGlobals", e3.lookup("Uint32")], ["nTableEntries", e3.lookup("Uint32")], ["nTypes", e3.lookup("Uint32")], ["nDataSegments", e3.lookup("Uint32")], ["nElemSegments", e3.lookup("Uint32")], ["nImports", e3.lookup("Uint32")], ["nExports", e3.lookup("Uint32")], ["nDataSegmentBytes", e3.lookup("Uint32")]]), e3.struct("ContractCodeEntryV1", [["ext", e3.lookup("ExtensionPoint")], ["costInputs", e3.lookup("ContractCodeCostInputs")]]), e3.union("ContractCodeEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("ContractCodeEntryV1") } }), e3.struct("ContractCodeEntry", [["ext", e3.lookup("ContractCodeEntryExt")], ["hash", e3.lookup("Hash")], ["code", e3.varOpaque()]]), e3.struct("TtlEntry", [["keyHash", e3.lookup("Hash")], ["liveUntilLedgerSeq", e3.lookup("Uint32")]]), e3.union("LedgerEntryExtensionV1Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("LedgerEntryExtensionV1", [["sponsoringId", e3.lookup("SponsorshipDescriptor")], ["ext", e3.lookup("LedgerEntryExtensionV1Ext")]]), e3.union("LedgerEntryData", { switchOn: e3.lookup("LedgerEntryType"), switchName: "type", switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]], arms: { account: e3.lookup("AccountEntry"), trustLine: e3.lookup("TrustLineEntry"), offer: e3.lookup("OfferEntry"), data: e3.lookup("DataEntry"), claimableBalance: e3.lookup("ClaimableBalanceEntry"), liquidityPool: e3.lookup("LiquidityPoolEntry"), contractData: e3.lookup("ContractDataEntry"), contractCode: e3.lookup("ContractCodeEntry"), configSetting: e3.lookup("ConfigSettingEntry"), ttl: e3.lookup("TtlEntry") } }), e3.union("LedgerEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("LedgerEntryExtensionV1") } }), e3.struct("LedgerEntry", [["lastModifiedLedgerSeq", e3.lookup("Uint32")], ["data", e3.lookup("LedgerEntryData")], ["ext", e3.lookup("LedgerEntryExt")]]), e3.struct("LedgerKeyAccount", [["accountId", e3.lookup("AccountId")]]), e3.struct("LedgerKeyTrustLine", [["accountId", e3.lookup("AccountId")], ["asset", e3.lookup("TrustLineAsset")]]), e3.struct("LedgerKeyOffer", [["sellerId", e3.lookup("AccountId")], ["offerId", e3.lookup("Int64")]]), e3.struct("LedgerKeyData", [["accountId", e3.lookup("AccountId")], ["dataName", e3.lookup("String64")]]), e3.struct("LedgerKeyClaimableBalance", [["balanceId", e3.lookup("ClaimableBalanceId")]]), e3.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", e3.lookup("PoolId")]]), e3.struct("LedgerKeyContractData", [["contract", e3.lookup("ScAddress")], ["key", e3.lookup("ScVal")], ["durability", e3.lookup("ContractDataDurability")]]), e3.struct("LedgerKeyContractCode", [["hash", e3.lookup("Hash")]]), e3.struct("LedgerKeyConfigSetting", [["configSettingId", e3.lookup("ConfigSettingId")]]), e3.struct("LedgerKeyTtl", [["keyHash", e3.lookup("Hash")]]), e3.union("LedgerKey", { switchOn: e3.lookup("LedgerEntryType"), switchName: "type", switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]], arms: { account: e3.lookup("LedgerKeyAccount"), trustLine: e3.lookup("LedgerKeyTrustLine"), offer: e3.lookup("LedgerKeyOffer"), data: e3.lookup("LedgerKeyData"), claimableBalance: e3.lookup("LedgerKeyClaimableBalance"), liquidityPool: e3.lookup("LedgerKeyLiquidityPool"), contractData: e3.lookup("LedgerKeyContractData"), contractCode: e3.lookup("LedgerKeyContractCode"), configSetting: e3.lookup("LedgerKeyConfigSetting"), ttl: e3.lookup("LedgerKeyTtl") } }), e3.enum("EnvelopeType", { envelopeTypeTxV0: 0, envelopeTypeScp: 1, envelopeTypeTx: 2, envelopeTypeAuth: 3, envelopeTypeScpvalue: 4, envelopeTypeTxFeeBump: 5, envelopeTypeOpId: 6, envelopeTypePoolRevokeOpId: 7, envelopeTypeContractId: 8, envelopeTypeSorobanAuthorization: 9 }), e3.enum("BucketListType", { live: 0, hotArchive: 1, coldArchive: 2 }), e3.enum("BucketEntryType", { metaentry: -1, liveentry: 0, deadentry: 1, initentry: 2 }), e3.enum("HotArchiveBucketEntryType", { hotArchiveMetaentry: -1, hotArchiveArchived: 0, hotArchiveLive: 1, hotArchiveDeleted: 2 }), e3.enum("ColdArchiveBucketEntryType", { coldArchiveMetaentry: -1, coldArchiveArchivedLeaf: 0, coldArchiveDeletedLeaf: 1, coldArchiveBoundaryLeaf: 2, coldArchiveHash: 3 }), e3.union("BucketMetadataExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "bucketListType"]], arms: { bucketListType: e3.lookup("BucketListType") } }), e3.struct("BucketMetadata", [["ledgerVersion", e3.lookup("Uint32")], ["ext", e3.lookup("BucketMetadataExt")]]), e3.union("BucketEntry", { switchOn: e3.lookup("BucketEntryType"), switchName: "type", switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]], arms: { liveEntry: e3.lookup("LedgerEntry"), deadEntry: e3.lookup("LedgerKey"), metaEntry: e3.lookup("BucketMetadata") } }), e3.union("HotArchiveBucketEntry", { switchOn: e3.lookup("HotArchiveBucketEntryType"), switchName: "type", switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]], arms: { archivedEntry: e3.lookup("LedgerEntry"), key: e3.lookup("LedgerKey"), metaEntry: e3.lookup("BucketMetadata") } }), e3.struct("ColdArchiveArchivedLeaf", [["index", e3.lookup("Uint32")], ["archivedEntry", e3.lookup("LedgerEntry")]]), e3.struct("ColdArchiveDeletedLeaf", [["index", e3.lookup("Uint32")], ["deletedKey", e3.lookup("LedgerKey")]]), e3.struct("ColdArchiveBoundaryLeaf", [["index", e3.lookup("Uint32")], ["isLowerBound", e3.bool()]]), e3.struct("ColdArchiveHashEntry", [["index", e3.lookup("Uint32")], ["level", e3.lookup("Uint32")], ["hash", e3.lookup("Hash")]]), e3.union("ColdArchiveBucketEntry", { switchOn: e3.lookup("ColdArchiveBucketEntryType"), switchName: "type", switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]], arms: { metaEntry: e3.lookup("BucketMetadata"), archivedLeaf: e3.lookup("ColdArchiveArchivedLeaf"), deletedLeaf: e3.lookup("ColdArchiveDeletedLeaf"), boundaryLeaf: e3.lookup("ColdArchiveBoundaryLeaf"), hashEntry: e3.lookup("ColdArchiveHashEntry") } }), e3.typedef("UpgradeType", e3.varOpaque(128)), e3.enum("StellarValueType", { stellarValueBasic: 0, stellarValueSigned: 1 }), e3.struct("LedgerCloseValueSignature", [["nodeId", e3.lookup("NodeId")], ["signature", e3.lookup("Signature")]]), e3.union("StellarValueExt", { switchOn: e3.lookup("StellarValueType"), switchName: "v", switches: [["stellarValueBasic", e3.void()], ["stellarValueSigned", "lcValueSignature"]], arms: { lcValueSignature: e3.lookup("LedgerCloseValueSignature") } }), e3.struct("StellarValue", [["txSetHash", e3.lookup("Hash")], ["closeTime", e3.lookup("TimePoint")], ["upgrades", e3.varArray(e3.lookup("UpgradeType"), 6)], ["ext", e3.lookup("StellarValueExt")]]), e3.const("MASK_LEDGER_HEADER_FLAGS", 7), e3.enum("LedgerHeaderFlags", { disableLiquidityPoolTradingFlag: 1, disableLiquidityPoolDepositFlag: 2, disableLiquidityPoolWithdrawalFlag: 4 }), e3.union("LedgerHeaderExtensionV1Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("LedgerHeaderExtensionV1", [["flags", e3.lookup("Uint32")], ["ext", e3.lookup("LedgerHeaderExtensionV1Ext")]]), e3.union("LedgerHeaderExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("LedgerHeaderExtensionV1") } }), e3.struct("LedgerHeader", [["ledgerVersion", e3.lookup("Uint32")], ["previousLedgerHash", e3.lookup("Hash")], ["scpValue", e3.lookup("StellarValue")], ["txSetResultHash", e3.lookup("Hash")], ["bucketListHash", e3.lookup("Hash")], ["ledgerSeq", e3.lookup("Uint32")], ["totalCoins", e3.lookup("Int64")], ["feePool", e3.lookup("Int64")], ["inflationSeq", e3.lookup("Uint32")], ["idPool", e3.lookup("Uint64")], ["baseFee", e3.lookup("Uint32")], ["baseReserve", e3.lookup("Uint32")], ["maxTxSetSize", e3.lookup("Uint32")], ["skipList", e3.array(e3.lookup("Hash"), 4)], ["ext", e3.lookup("LedgerHeaderExt")]]), e3.enum("LedgerUpgradeType", { ledgerUpgradeVersion: 1, ledgerUpgradeBaseFee: 2, ledgerUpgradeMaxTxSetSize: 3, ledgerUpgradeBaseReserve: 4, ledgerUpgradeFlags: 5, ledgerUpgradeConfig: 6, ledgerUpgradeMaxSorobanTxSetSize: 7 }), e3.struct("ConfigUpgradeSetKey", [["contractId", e3.lookup("Hash")], ["contentHash", e3.lookup("Hash")]]), e3.union("LedgerUpgrade", { switchOn: e3.lookup("LedgerUpgradeType"), switchName: "type", switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]], arms: { newLedgerVersion: e3.lookup("Uint32"), newBaseFee: e3.lookup("Uint32"), newMaxTxSetSize: e3.lookup("Uint32"), newBaseReserve: e3.lookup("Uint32"), newFlags: e3.lookup("Uint32"), newConfig: e3.lookup("ConfigUpgradeSetKey"), newMaxSorobanTxSetSize: e3.lookup("Uint32") } }), e3.struct("ConfigUpgradeSet", [["updatedEntry", e3.varArray(e3.lookup("ConfigSettingEntry"), 2147483647)]]), e3.enum("TxSetComponentType", { txsetCompTxsMaybeDiscountedFee: 0 }), e3.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", e3.option(e3.lookup("Int64"))], ["txes", e3.varArray(e3.lookup("TransactionEnvelope"), 2147483647)]]), e3.union("TxSetComponent", { switchOn: e3.lookup("TxSetComponentType"), switchName: "type", switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]], arms: { txsMaybeDiscountedFee: e3.lookup("TxSetComponentTxsMaybeDiscountedFee") } }), e3.union("TransactionPhase", { switchOn: e3.int(), switchName: "v", switches: [[0, "v0Components"]], arms: { v0Components: e3.varArray(e3.lookup("TxSetComponent"), 2147483647) } }), e3.struct("TransactionSet", [["previousLedgerHash", e3.lookup("Hash")], ["txes", e3.varArray(e3.lookup("TransactionEnvelope"), 2147483647)]]), e3.struct("TransactionSetV1", [["previousLedgerHash", e3.lookup("Hash")], ["phases", e3.varArray(e3.lookup("TransactionPhase"), 2147483647)]]), e3.union("GeneralizedTransactionSet", { switchOn: e3.int(), switchName: "v", switches: [[1, "v1TxSet"]], arms: { v1TxSet: e3.lookup("TransactionSetV1") } }), e3.struct("TransactionResultPair", [["transactionHash", e3.lookup("Hash")], ["result", e3.lookup("TransactionResult")]]), e3.struct("TransactionResultSet", [["results", e3.varArray(e3.lookup("TransactionResultPair"), 2147483647)]]), e3.union("TransactionHistoryEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "generalizedTxSet"]], arms: { generalizedTxSet: e3.lookup("GeneralizedTransactionSet") } }), e3.struct("TransactionHistoryEntry", [["ledgerSeq", e3.lookup("Uint32")], ["txSet", e3.lookup("TransactionSet")], ["ext", e3.lookup("TransactionHistoryEntryExt")]]), e3.union("TransactionHistoryResultEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("TransactionHistoryResultEntry", [["ledgerSeq", e3.lookup("Uint32")], ["txResultSet", e3.lookup("TransactionResultSet")], ["ext", e3.lookup("TransactionHistoryResultEntryExt")]]), e3.union("LedgerHeaderHistoryEntryExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("LedgerHeaderHistoryEntry", [["hash", e3.lookup("Hash")], ["header", e3.lookup("LedgerHeader")], ["ext", e3.lookup("LedgerHeaderHistoryEntryExt")]]), e3.struct("LedgerScpMessages", [["ledgerSeq", e3.lookup("Uint32")], ["messages", e3.varArray(e3.lookup("ScpEnvelope"), 2147483647)]]), e3.struct("ScpHistoryEntryV0", [["quorumSets", e3.varArray(e3.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", e3.lookup("LedgerScpMessages")]]), e3.union("ScpHistoryEntry", { switchOn: e3.int(), switchName: "v", switches: [[0, "v0"]], arms: { v0: e3.lookup("ScpHistoryEntryV0") } }), e3.enum("LedgerEntryChangeType", { ledgerEntryCreated: 0, ledgerEntryUpdated: 1, ledgerEntryRemoved: 2, ledgerEntryState: 3 }), e3.union("LedgerEntryChange", { switchOn: e3.lookup("LedgerEntryChangeType"), switchName: "type", switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]], arms: { created: e3.lookup("LedgerEntry"), updated: e3.lookup("LedgerEntry"), removed: e3.lookup("LedgerKey"), state: e3.lookup("LedgerEntry") } }), e3.typedef("LedgerEntryChanges", e3.varArray(e3.lookup("LedgerEntryChange"), 2147483647)), e3.struct("OperationMeta", [["changes", e3.lookup("LedgerEntryChanges")]]), e3.struct("TransactionMetaV1", [["txChanges", e3.lookup("LedgerEntryChanges")], ["operations", e3.varArray(e3.lookup("OperationMeta"), 2147483647)]]), e3.struct("TransactionMetaV2", [["txChangesBefore", e3.lookup("LedgerEntryChanges")], ["operations", e3.varArray(e3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", e3.lookup("LedgerEntryChanges")]]), e3.enum("ContractEventType", { system: 0, contract: 1, diagnostic: 2 }), e3.struct("ContractEventV0", [["topics", e3.varArray(e3.lookup("ScVal"), 2147483647)], ["data", e3.lookup("ScVal")]]), e3.union("ContractEventBody", { switchOn: e3.int(), switchName: "v", switches: [[0, "v0"]], arms: { v0: e3.lookup("ContractEventV0") } }), e3.struct("ContractEvent", [["ext", e3.lookup("ExtensionPoint")], ["contractId", e3.option(e3.lookup("Hash"))], ["type", e3.lookup("ContractEventType")], ["body", e3.lookup("ContractEventBody")]]), e3.struct("DiagnosticEvent", [["inSuccessfulContractCall", e3.bool()], ["event", e3.lookup("ContractEvent")]]), e3.typedef("DiagnosticEvents", e3.varArray(e3.lookup("DiagnosticEvent"), 2147483647)), e3.struct("SorobanTransactionMetaExtV1", [["ext", e3.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", e3.lookup("Int64")], ["totalRefundableResourceFeeCharged", e3.lookup("Int64")], ["rentFeeCharged", e3.lookup("Int64")]]), e3.union("SorobanTransactionMetaExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("SorobanTransactionMetaExtV1") } }), e3.struct("SorobanTransactionMeta", [["ext", e3.lookup("SorobanTransactionMetaExt")], ["events", e3.varArray(e3.lookup("ContractEvent"), 2147483647)], ["returnValue", e3.lookup("ScVal")], ["diagnosticEvents", e3.varArray(e3.lookup("DiagnosticEvent"), 2147483647)]]), e3.struct("TransactionMetaV3", [["ext", e3.lookup("ExtensionPoint")], ["txChangesBefore", e3.lookup("LedgerEntryChanges")], ["operations", e3.varArray(e3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", e3.lookup("LedgerEntryChanges")], ["sorobanMeta", e3.option(e3.lookup("SorobanTransactionMeta"))]]), e3.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", e3.lookup("ScVal")], ["events", e3.varArray(e3.lookup("ContractEvent"), 2147483647)]]), e3.union("TransactionMeta", { switchOn: e3.int(), switchName: "v", switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]], arms: { operations: e3.varArray(e3.lookup("OperationMeta"), 2147483647), v1: e3.lookup("TransactionMetaV1"), v2: e3.lookup("TransactionMetaV2"), v3: e3.lookup("TransactionMetaV3") } }), e3.struct("TransactionResultMeta", [["result", e3.lookup("TransactionResultPair")], ["feeProcessing", e3.lookup("LedgerEntryChanges")], ["txApplyProcessing", e3.lookup("TransactionMeta")]]), e3.struct("UpgradeEntryMeta", [["upgrade", e3.lookup("LedgerUpgrade")], ["changes", e3.lookup("LedgerEntryChanges")]]), e3.struct("LedgerCloseMetaV0", [["ledgerHeader", e3.lookup("LedgerHeaderHistoryEntry")], ["txSet", e3.lookup("TransactionSet")], ["txProcessing", e3.varArray(e3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", e3.varArray(e3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", e3.varArray(e3.lookup("ScpHistoryEntry"), 2147483647)]]), e3.struct("LedgerCloseMetaExtV1", [["ext", e3.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", e3.lookup("Int64")]]), e3.union("LedgerCloseMetaExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "v1"]], arms: { v1: e3.lookup("LedgerCloseMetaExtV1") } }), e3.struct("LedgerCloseMetaV1", [["ext", e3.lookup("LedgerCloseMetaExt")], ["ledgerHeader", e3.lookup("LedgerHeaderHistoryEntry")], ["txSet", e3.lookup("GeneralizedTransactionSet")], ["txProcessing", e3.varArray(e3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", e3.varArray(e3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", e3.varArray(e3.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", e3.lookup("Uint64")], ["evictedTemporaryLedgerKeys", e3.varArray(e3.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", e3.varArray(e3.lookup("LedgerEntry"), 2147483647)]]), e3.union("LedgerCloseMeta", { switchOn: e3.int(), switchName: "v", switches: [[0, "v0"], [1, "v1"]], arms: { v0: e3.lookup("LedgerCloseMetaV0"), v1: e3.lookup("LedgerCloseMetaV1") } }), e3.enum("ErrorCode", { errMisc: 0, errData: 1, errConf: 2, errAuth: 3, errLoad: 4 }), e3.struct("Error", [["code", e3.lookup("ErrorCode")], ["msg", e3.string(100)]]), e3.struct("SendMore", [["numMessages", e3.lookup("Uint32")]]), e3.struct("SendMoreExtended", [["numMessages", e3.lookup("Uint32")], ["numBytes", e3.lookup("Uint32")]]), e3.struct("AuthCert", [["pubkey", e3.lookup("Curve25519Public")], ["expiration", e3.lookup("Uint64")], ["sig", e3.lookup("Signature")]]), e3.struct("Hello", [["ledgerVersion", e3.lookup("Uint32")], ["overlayVersion", e3.lookup("Uint32")], ["overlayMinVersion", e3.lookup("Uint32")], ["networkId", e3.lookup("Hash")], ["versionStr", e3.string(100)], ["listeningPort", e3.int()], ["peerId", e3.lookup("NodeId")], ["cert", e3.lookup("AuthCert")], ["nonce", e3.lookup("Uint256")]]), e3.const("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200), e3.struct("Auth", [["flags", e3.int()]]), e3.enum("IpAddrType", { iPv4: 0, iPv6: 1 }), e3.union("PeerAddressIp", { switchOn: e3.lookup("IpAddrType"), switchName: "type", switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]], arms: { ipv4: e3.opaque(4), ipv6: e3.opaque(16) } }), e3.struct("PeerAddress", [["ip", e3.lookup("PeerAddressIp")], ["port", e3.lookup("Uint32")], ["numFailures", e3.lookup("Uint32")]]), e3.enum("MessageType", { errorMsg: 0, auth: 2, dontHave: 3, getPeers: 4, peers: 5, getTxSet: 6, txSet: 7, generalizedTxSet: 17, transaction: 8, getScpQuorumset: 9, scpQuorumset: 10, scpMessage: 11, getScpState: 12, hello: 13, surveyRequest: 14, surveyResponse: 15, sendMore: 16, sendMoreExtended: 20, floodAdvert: 18, floodDemand: 19, timeSlicedSurveyRequest: 21, timeSlicedSurveyResponse: 22, timeSlicedSurveyStartCollecting: 23, timeSlicedSurveyStopCollecting: 24 }), e3.struct("DontHave", [["type", e3.lookup("MessageType")], ["reqHash", e3.lookup("Uint256")]]), e3.enum("SurveyMessageCommandType", { surveyTopology: 0, timeSlicedSurveyTopology: 1 }), e3.enum("SurveyMessageResponseType", { surveyTopologyResponseV0: 0, surveyTopologyResponseV1: 1, surveyTopologyResponseV2: 2 }), e3.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", e3.lookup("NodeId")], ["nonce", e3.lookup("Uint32")], ["ledgerNum", e3.lookup("Uint32")]]), e3.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", e3.lookup("Signature")], ["startCollecting", e3.lookup("TimeSlicedSurveyStartCollectingMessage")]]), e3.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", e3.lookup("NodeId")], ["nonce", e3.lookup("Uint32")], ["ledgerNum", e3.lookup("Uint32")]]), e3.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", e3.lookup("Signature")], ["stopCollecting", e3.lookup("TimeSlicedSurveyStopCollectingMessage")]]), e3.struct("SurveyRequestMessage", [["surveyorPeerId", e3.lookup("NodeId")], ["surveyedPeerId", e3.lookup("NodeId")], ["ledgerNum", e3.lookup("Uint32")], ["encryptionKey", e3.lookup("Curve25519Public")], ["commandType", e3.lookup("SurveyMessageCommandType")]]), e3.struct("TimeSlicedSurveyRequestMessage", [["request", e3.lookup("SurveyRequestMessage")], ["nonce", e3.lookup("Uint32")], ["inboundPeersIndex", e3.lookup("Uint32")], ["outboundPeersIndex", e3.lookup("Uint32")]]), e3.struct("SignedSurveyRequestMessage", [["requestSignature", e3.lookup("Signature")], ["request", e3.lookup("SurveyRequestMessage")]]), e3.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", e3.lookup("Signature")], ["request", e3.lookup("TimeSlicedSurveyRequestMessage")]]), e3.typedef("EncryptedBody", e3.varOpaque(64e3)), e3.struct("SurveyResponseMessage", [["surveyorPeerId", e3.lookup("NodeId")], ["surveyedPeerId", e3.lookup("NodeId")], ["ledgerNum", e3.lookup("Uint32")], ["commandType", e3.lookup("SurveyMessageCommandType")], ["encryptedBody", e3.lookup("EncryptedBody")]]), e3.struct("TimeSlicedSurveyResponseMessage", [["response", e3.lookup("SurveyResponseMessage")], ["nonce", e3.lookup("Uint32")]]), e3.struct("SignedSurveyResponseMessage", [["responseSignature", e3.lookup("Signature")], ["response", e3.lookup("SurveyResponseMessage")]]), e3.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", e3.lookup("Signature")], ["response", e3.lookup("TimeSlicedSurveyResponseMessage")]]), e3.struct("PeerStats", [["id", e3.lookup("NodeId")], ["versionStr", e3.string(100)], ["messagesRead", e3.lookup("Uint64")], ["messagesWritten", e3.lookup("Uint64")], ["bytesRead", e3.lookup("Uint64")], ["bytesWritten", e3.lookup("Uint64")], ["secondsConnected", e3.lookup("Uint64")], ["uniqueFloodBytesRecv", e3.lookup("Uint64")], ["duplicateFloodBytesRecv", e3.lookup("Uint64")], ["uniqueFetchBytesRecv", e3.lookup("Uint64")], ["duplicateFetchBytesRecv", e3.lookup("Uint64")], ["uniqueFloodMessageRecv", e3.lookup("Uint64")], ["duplicateFloodMessageRecv", e3.lookup("Uint64")], ["uniqueFetchMessageRecv", e3.lookup("Uint64")], ["duplicateFetchMessageRecv", e3.lookup("Uint64")]]), e3.typedef("PeerStatList", e3.varArray(e3.lookup("PeerStats"), 25)), e3.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", e3.lookup("Uint32")], ["droppedAuthenticatedPeers", e3.lookup("Uint32")], ["totalInboundPeerCount", e3.lookup("Uint32")], ["totalOutboundPeerCount", e3.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", e3.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", e3.lookup("Uint32")], ["lostSyncCount", e3.lookup("Uint32")], ["isValidator", e3.bool()], ["maxInboundPeerCount", e3.lookup("Uint32")], ["maxOutboundPeerCount", e3.lookup("Uint32")]]), e3.struct("TimeSlicedPeerData", [["peerStats", e3.lookup("PeerStats")], ["averageLatencyMs", e3.lookup("Uint32")]]), e3.typedef("TimeSlicedPeerDataList", e3.varArray(e3.lookup("TimeSlicedPeerData"), 25)), e3.struct("TopologyResponseBodyV0", [["inboundPeers", e3.lookup("PeerStatList")], ["outboundPeers", e3.lookup("PeerStatList")], ["totalInboundPeerCount", e3.lookup("Uint32")], ["totalOutboundPeerCount", e3.lookup("Uint32")]]), e3.struct("TopologyResponseBodyV1", [["inboundPeers", e3.lookup("PeerStatList")], ["outboundPeers", e3.lookup("PeerStatList")], ["totalInboundPeerCount", e3.lookup("Uint32")], ["totalOutboundPeerCount", e3.lookup("Uint32")], ["maxInboundPeerCount", e3.lookup("Uint32")], ["maxOutboundPeerCount", e3.lookup("Uint32")]]), e3.struct("TopologyResponseBodyV2", [["inboundPeers", e3.lookup("TimeSlicedPeerDataList")], ["outboundPeers", e3.lookup("TimeSlicedPeerDataList")], ["nodeData", e3.lookup("TimeSlicedNodeData")]]), e3.union("SurveyResponseBody", { switchOn: e3.lookup("SurveyMessageResponseType"), switchName: "type", switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]], arms: { topologyResponseBodyV0: e3.lookup("TopologyResponseBodyV0"), topologyResponseBodyV1: e3.lookup("TopologyResponseBodyV1"), topologyResponseBodyV2: e3.lookup("TopologyResponseBodyV2") } }), e3.const("TX_ADVERT_VECTOR_MAX_SIZE", 1e3), e3.typedef("TxAdvertVector", e3.varArray(e3.lookup("Hash"), e3.lookup("TX_ADVERT_VECTOR_MAX_SIZE"))), e3.struct("FloodAdvert", [["txHashes", e3.lookup("TxAdvertVector")]]), e3.const("TX_DEMAND_VECTOR_MAX_SIZE", 1e3), e3.typedef("TxDemandVector", e3.varArray(e3.lookup("Hash"), e3.lookup("TX_DEMAND_VECTOR_MAX_SIZE"))), e3.struct("FloodDemand", [["txHashes", e3.lookup("TxDemandVector")]]), e3.union("StellarMessage", { switchOn: e3.lookup("MessageType"), switchName: "type", switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", e3.void()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]], arms: { error: e3.lookup("Error"), hello: e3.lookup("Hello"), auth: e3.lookup("Auth"), dontHave: e3.lookup("DontHave"), peers: e3.varArray(e3.lookup("PeerAddress"), 100), txSetHash: e3.lookup("Uint256"), txSet: e3.lookup("TransactionSet"), generalizedTxSet: e3.lookup("GeneralizedTransactionSet"), transaction: e3.lookup("TransactionEnvelope"), signedSurveyRequestMessage: e3.lookup("SignedSurveyRequestMessage"), signedSurveyResponseMessage: e3.lookup("SignedSurveyResponseMessage"), signedTimeSlicedSurveyRequestMessage: e3.lookup("SignedTimeSlicedSurveyRequestMessage"), signedTimeSlicedSurveyResponseMessage: e3.lookup("SignedTimeSlicedSurveyResponseMessage"), signedTimeSlicedSurveyStartCollectingMessage: e3.lookup("SignedTimeSlicedSurveyStartCollectingMessage"), signedTimeSlicedSurveyStopCollectingMessage: e3.lookup("SignedTimeSlicedSurveyStopCollectingMessage"), qSetHash: e3.lookup("Uint256"), qSet: e3.lookup("ScpQuorumSet"), envelope: e3.lookup("ScpEnvelope"), getScpLedgerSeq: e3.lookup("Uint32"), sendMoreMessage: e3.lookup("SendMore"), sendMoreExtendedMessage: e3.lookup("SendMoreExtended"), floodAdvert: e3.lookup("FloodAdvert"), floodDemand: e3.lookup("FloodDemand") } }), e3.struct("AuthenticatedMessageV0", [["sequence", e3.lookup("Uint64")], ["message", e3.lookup("StellarMessage")], ["mac", e3.lookup("HmacSha256Mac")]]), e3.union("AuthenticatedMessage", { switchOn: e3.lookup("Uint32"), switchName: "v", switches: [[0, "v0"]], arms: { v0: e3.lookup("AuthenticatedMessageV0") } }), e3.const("MAX_OPS_PER_TX", 100), e3.union("LiquidityPoolParameters", { switchOn: e3.lookup("LiquidityPoolType"), switchName: "type", switches: [["liquidityPoolConstantProduct", "constantProduct"]], arms: { constantProduct: e3.lookup("LiquidityPoolConstantProductParameters") } }), e3.struct("MuxedAccountMed25519", [["id", e3.lookup("Uint64")], ["ed25519", e3.lookup("Uint256")]]), e3.union("MuxedAccount", { switchOn: e3.lookup("CryptoKeyType"), switchName: "type", switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]], arms: { ed25519: e3.lookup("Uint256"), med25519: e3.lookup("MuxedAccountMed25519") } }), e3.struct("DecoratedSignature", [["hint", e3.lookup("SignatureHint")], ["signature", e3.lookup("Signature")]]), e3.enum("OperationType", { createAccount: 0, payment: 1, pathPaymentStrictReceive: 2, manageSellOffer: 3, createPassiveSellOffer: 4, setOptions: 5, changeTrust: 6, allowTrust: 7, accountMerge: 8, inflation: 9, manageData: 10, bumpSequence: 11, manageBuyOffer: 12, pathPaymentStrictSend: 13, createClaimableBalance: 14, claimClaimableBalance: 15, beginSponsoringFutureReserves: 16, endSponsoringFutureReserves: 17, revokeSponsorship: 18, clawback: 19, clawbackClaimableBalance: 20, setTrustLineFlags: 21, liquidityPoolDeposit: 22, liquidityPoolWithdraw: 23, invokeHostFunction: 24, extendFootprintTtl: 25, restoreFootprint: 26 }), e3.struct("CreateAccountOp", [["destination", e3.lookup("AccountId")], ["startingBalance", e3.lookup("Int64")]]), e3.struct("PaymentOp", [["destination", e3.lookup("MuxedAccount")], ["asset", e3.lookup("Asset")], ["amount", e3.lookup("Int64")]]), e3.struct("PathPaymentStrictReceiveOp", [["sendAsset", e3.lookup("Asset")], ["sendMax", e3.lookup("Int64")], ["destination", e3.lookup("MuxedAccount")], ["destAsset", e3.lookup("Asset")], ["destAmount", e3.lookup("Int64")], ["path", e3.varArray(e3.lookup("Asset"), 5)]]), e3.struct("PathPaymentStrictSendOp", [["sendAsset", e3.lookup("Asset")], ["sendAmount", e3.lookup("Int64")], ["destination", e3.lookup("MuxedAccount")], ["destAsset", e3.lookup("Asset")], ["destMin", e3.lookup("Int64")], ["path", e3.varArray(e3.lookup("Asset"), 5)]]), e3.struct("ManageSellOfferOp", [["selling", e3.lookup("Asset")], ["buying", e3.lookup("Asset")], ["amount", e3.lookup("Int64")], ["price", e3.lookup("Price")], ["offerId", e3.lookup("Int64")]]), e3.struct("ManageBuyOfferOp", [["selling", e3.lookup("Asset")], ["buying", e3.lookup("Asset")], ["buyAmount", e3.lookup("Int64")], ["price", e3.lookup("Price")], ["offerId", e3.lookup("Int64")]]), e3.struct("CreatePassiveSellOfferOp", [["selling", e3.lookup("Asset")], ["buying", e3.lookup("Asset")], ["amount", e3.lookup("Int64")], ["price", e3.lookup("Price")]]), e3.struct("SetOptionsOp", [["inflationDest", e3.option(e3.lookup("AccountId"))], ["clearFlags", e3.option(e3.lookup("Uint32"))], ["setFlags", e3.option(e3.lookup("Uint32"))], ["masterWeight", e3.option(e3.lookup("Uint32"))], ["lowThreshold", e3.option(e3.lookup("Uint32"))], ["medThreshold", e3.option(e3.lookup("Uint32"))], ["highThreshold", e3.option(e3.lookup("Uint32"))], ["homeDomain", e3.option(e3.lookup("String32"))], ["signer", e3.option(e3.lookup("Signer"))]]), e3.union("ChangeTrustAsset", { switchOn: e3.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", e3.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]], arms: { alphaNum4: e3.lookup("AlphaNum4"), alphaNum12: e3.lookup("AlphaNum12"), liquidityPool: e3.lookup("LiquidityPoolParameters") } }), e3.struct("ChangeTrustOp", [["line", e3.lookup("ChangeTrustAsset")], ["limit", e3.lookup("Int64")]]), e3.struct("AllowTrustOp", [["trustor", e3.lookup("AccountId")], ["asset", e3.lookup("AssetCode")], ["authorize", e3.lookup("Uint32")]]), e3.struct("ManageDataOp", [["dataName", e3.lookup("String64")], ["dataValue", e3.option(e3.lookup("DataValue"))]]), e3.struct("BumpSequenceOp", [["bumpTo", e3.lookup("SequenceNumber")]]), e3.struct("CreateClaimableBalanceOp", [["asset", e3.lookup("Asset")], ["amount", e3.lookup("Int64")], ["claimants", e3.varArray(e3.lookup("Claimant"), 10)]]), e3.struct("ClaimClaimableBalanceOp", [["balanceId", e3.lookup("ClaimableBalanceId")]]), e3.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", e3.lookup("AccountId")]]), e3.enum("RevokeSponsorshipType", { revokeSponsorshipLedgerEntry: 0, revokeSponsorshipSigner: 1 }), e3.struct("RevokeSponsorshipOpSigner", [["accountId", e3.lookup("AccountId")], ["signerKey", e3.lookup("SignerKey")]]), e3.union("RevokeSponsorshipOp", { switchOn: e3.lookup("RevokeSponsorshipType"), switchName: "type", switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]], arms: { ledgerKey: e3.lookup("LedgerKey"), signer: e3.lookup("RevokeSponsorshipOpSigner") } }), e3.struct("ClawbackOp", [["asset", e3.lookup("Asset")], ["from", e3.lookup("MuxedAccount")], ["amount", e3.lookup("Int64")]]), e3.struct("ClawbackClaimableBalanceOp", [["balanceId", e3.lookup("ClaimableBalanceId")]]), e3.struct("SetTrustLineFlagsOp", [["trustor", e3.lookup("AccountId")], ["asset", e3.lookup("Asset")], ["clearFlags", e3.lookup("Uint32")], ["setFlags", e3.lookup("Uint32")]]), e3.const("LIQUIDITY_POOL_FEE_V18", 30), e3.struct("LiquidityPoolDepositOp", [["liquidityPoolId", e3.lookup("PoolId")], ["maxAmountA", e3.lookup("Int64")], ["maxAmountB", e3.lookup("Int64")], ["minPrice", e3.lookup("Price")], ["maxPrice", e3.lookup("Price")]]), e3.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", e3.lookup("PoolId")], ["amount", e3.lookup("Int64")], ["minAmountA", e3.lookup("Int64")], ["minAmountB", e3.lookup("Int64")]]), e3.enum("HostFunctionType", { hostFunctionTypeInvokeContract: 0, hostFunctionTypeCreateContract: 1, hostFunctionTypeUploadContractWasm: 2, hostFunctionTypeCreateContractV2: 3 }), e3.enum("ContractIdPreimageType", { contractIdPreimageFromAddress: 0, contractIdPreimageFromAsset: 1 }), e3.struct("ContractIdPreimageFromAddress", [["address", e3.lookup("ScAddress")], ["salt", e3.lookup("Uint256")]]), e3.union("ContractIdPreimage", { switchOn: e3.lookup("ContractIdPreimageType"), switchName: "type", switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]], arms: { fromAddress: e3.lookup("ContractIdPreimageFromAddress"), fromAsset: e3.lookup("Asset") } }), e3.struct("CreateContractArgs", [["contractIdPreimage", e3.lookup("ContractIdPreimage")], ["executable", e3.lookup("ContractExecutable")]]), e3.struct("CreateContractArgsV2", [["contractIdPreimage", e3.lookup("ContractIdPreimage")], ["executable", e3.lookup("ContractExecutable")], ["constructorArgs", e3.varArray(e3.lookup("ScVal"), 2147483647)]]), e3.struct("InvokeContractArgs", [["contractAddress", e3.lookup("ScAddress")], ["functionName", e3.lookup("ScSymbol")], ["args", e3.varArray(e3.lookup("ScVal"), 2147483647)]]), e3.union("HostFunction", { switchOn: e3.lookup("HostFunctionType"), switchName: "type", switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]], arms: { invokeContract: e3.lookup("InvokeContractArgs"), createContract: e3.lookup("CreateContractArgs"), wasm: e3.varOpaque(), createContractV2: e3.lookup("CreateContractArgsV2") } }), e3.enum("SorobanAuthorizedFunctionType", { sorobanAuthorizedFunctionTypeContractFn: 0, sorobanAuthorizedFunctionTypeCreateContractHostFn: 1, sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2 }), e3.union("SorobanAuthorizedFunction", { switchOn: e3.lookup("SorobanAuthorizedFunctionType"), switchName: "type", switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]], arms: { contractFn: e3.lookup("InvokeContractArgs"), createContractHostFn: e3.lookup("CreateContractArgs"), createContractV2HostFn: e3.lookup("CreateContractArgsV2") } }), e3.struct("SorobanAuthorizedInvocation", [["function", e3.lookup("SorobanAuthorizedFunction")], ["subInvocations", e3.varArray(e3.lookup("SorobanAuthorizedInvocation"), 2147483647)]]), e3.struct("SorobanAddressCredentials", [["address", e3.lookup("ScAddress")], ["nonce", e3.lookup("Int64")], ["signatureExpirationLedger", e3.lookup("Uint32")], ["signature", e3.lookup("ScVal")]]), e3.enum("SorobanCredentialsType", { sorobanCredentialsSourceAccount: 0, sorobanCredentialsAddress: 1 }), e3.union("SorobanCredentials", { switchOn: e3.lookup("SorobanCredentialsType"), switchName: "type", switches: [["sorobanCredentialsSourceAccount", e3.void()], ["sorobanCredentialsAddress", "address"]], arms: { address: e3.lookup("SorobanAddressCredentials") } }), e3.struct("SorobanAuthorizationEntry", [["credentials", e3.lookup("SorobanCredentials")], ["rootInvocation", e3.lookup("SorobanAuthorizedInvocation")]]), e3.struct("InvokeHostFunctionOp", [["hostFunction", e3.lookup("HostFunction")], ["auth", e3.varArray(e3.lookup("SorobanAuthorizationEntry"), 2147483647)]]), e3.struct("ExtendFootprintTtlOp", [["ext", e3.lookup("ExtensionPoint")], ["extendTo", e3.lookup("Uint32")]]), e3.struct("RestoreFootprintOp", [["ext", e3.lookup("ExtensionPoint")]]), e3.union("OperationBody", { switchOn: e3.lookup("OperationType"), switchName: "type", switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", e3.void()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", e3.void()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]], arms: { createAccountOp: e3.lookup("CreateAccountOp"), paymentOp: e3.lookup("PaymentOp"), pathPaymentStrictReceiveOp: e3.lookup("PathPaymentStrictReceiveOp"), manageSellOfferOp: e3.lookup("ManageSellOfferOp"), createPassiveSellOfferOp: e3.lookup("CreatePassiveSellOfferOp"), setOptionsOp: e3.lookup("SetOptionsOp"), changeTrustOp: e3.lookup("ChangeTrustOp"), allowTrustOp: e3.lookup("AllowTrustOp"), destination: e3.lookup("MuxedAccount"), manageDataOp: e3.lookup("ManageDataOp"), bumpSequenceOp: e3.lookup("BumpSequenceOp"), manageBuyOfferOp: e3.lookup("ManageBuyOfferOp"), pathPaymentStrictSendOp: e3.lookup("PathPaymentStrictSendOp"), createClaimableBalanceOp: e3.lookup("CreateClaimableBalanceOp"), claimClaimableBalanceOp: e3.lookup("ClaimClaimableBalanceOp"), beginSponsoringFutureReservesOp: e3.lookup("BeginSponsoringFutureReservesOp"), revokeSponsorshipOp: e3.lookup("RevokeSponsorshipOp"), clawbackOp: e3.lookup("ClawbackOp"), clawbackClaimableBalanceOp: e3.lookup("ClawbackClaimableBalanceOp"), setTrustLineFlagsOp: e3.lookup("SetTrustLineFlagsOp"), liquidityPoolDepositOp: e3.lookup("LiquidityPoolDepositOp"), liquidityPoolWithdrawOp: e3.lookup("LiquidityPoolWithdrawOp"), invokeHostFunctionOp: e3.lookup("InvokeHostFunctionOp"), extendFootprintTtlOp: e3.lookup("ExtendFootprintTtlOp"), restoreFootprintOp: e3.lookup("RestoreFootprintOp") } }), e3.struct("Operation", [["sourceAccount", e3.option(e3.lookup("MuxedAccount"))], ["body", e3.lookup("OperationBody")]]), e3.struct("HashIdPreimageOperationId", [["sourceAccount", e3.lookup("AccountId")], ["seqNum", e3.lookup("SequenceNumber")], ["opNum", e3.lookup("Uint32")]]), e3.struct("HashIdPreimageRevokeId", [["sourceAccount", e3.lookup("AccountId")], ["seqNum", e3.lookup("SequenceNumber")], ["opNum", e3.lookup("Uint32")], ["liquidityPoolId", e3.lookup("PoolId")], ["asset", e3.lookup("Asset")]]), e3.struct("HashIdPreimageContractId", [["networkId", e3.lookup("Hash")], ["contractIdPreimage", e3.lookup("ContractIdPreimage")]]), e3.struct("HashIdPreimageSorobanAuthorization", [["networkId", e3.lookup("Hash")], ["nonce", e3.lookup("Int64")], ["signatureExpirationLedger", e3.lookup("Uint32")], ["invocation", e3.lookup("SorobanAuthorizedInvocation")]]), e3.union("HashIdPreimage", { switchOn: e3.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]], arms: { operationId: e3.lookup("HashIdPreimageOperationId"), revokeId: e3.lookup("HashIdPreimageRevokeId"), contractId: e3.lookup("HashIdPreimageContractId"), sorobanAuthorization: e3.lookup("HashIdPreimageSorobanAuthorization") } }), e3.enum("MemoType", { memoNone: 0, memoText: 1, memoId: 2, memoHash: 3, memoReturn: 4 }), e3.union("Memo", { switchOn: e3.lookup("MemoType"), switchName: "type", switches: [["memoNone", e3.void()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]], arms: { text: e3.string(28), id: e3.lookup("Uint64"), hash: e3.lookup("Hash"), retHash: e3.lookup("Hash") } }), e3.struct("TimeBounds", [["minTime", e3.lookup("TimePoint")], ["maxTime", e3.lookup("TimePoint")]]), e3.struct("LedgerBounds", [["minLedger", e3.lookup("Uint32")], ["maxLedger", e3.lookup("Uint32")]]), e3.struct("PreconditionsV2", [["timeBounds", e3.option(e3.lookup("TimeBounds"))], ["ledgerBounds", e3.option(e3.lookup("LedgerBounds"))], ["minSeqNum", e3.option(e3.lookup("SequenceNumber"))], ["minSeqAge", e3.lookup("Duration")], ["minSeqLedgerGap", e3.lookup("Uint32")], ["extraSigners", e3.varArray(e3.lookup("SignerKey"), 2)]]), e3.enum("PreconditionType", { precondNone: 0, precondTime: 1, precondV2: 2 }), e3.union("Preconditions", { switchOn: e3.lookup("PreconditionType"), switchName: "type", switches: [["precondNone", e3.void()], ["precondTime", "timeBounds"], ["precondV2", "v2"]], arms: { timeBounds: e3.lookup("TimeBounds"), v2: e3.lookup("PreconditionsV2") } }), e3.struct("LedgerFootprint", [["readOnly", e3.varArray(e3.lookup("LedgerKey"), 2147483647)], ["readWrite", e3.varArray(e3.lookup("LedgerKey"), 2147483647)]]), e3.enum("ArchivalProofType", { existence: 0, nonexistence: 1 }), e3.struct("ArchivalProofNode", [["index", e3.lookup("Uint32")], ["hash", e3.lookup("Hash")]]), e3.typedef("ProofLevel", e3.varArray(e3.lookup("ArchivalProofNode"), 2147483647)), e3.struct("NonexistenceProofBody", [["entriesToProve", e3.varArray(e3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", e3.varArray(e3.lookup("ProofLevel"), 2147483647)]]), e3.struct("ExistenceProofBody", [["keysToProve", e3.varArray(e3.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", e3.varArray(e3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", e3.varArray(e3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", e3.varArray(e3.lookup("ProofLevel"), 2147483647)]]), e3.union("ArchivalProofBody", { switchOn: e3.lookup("ArchivalProofType"), switchName: "t", switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]], arms: { nonexistenceProof: e3.lookup("NonexistenceProofBody"), existenceProof: e3.lookup("ExistenceProofBody") } }), e3.struct("ArchivalProof", [["epoch", e3.lookup("Uint32")], ["body", e3.lookup("ArchivalProofBody")]]), e3.struct("SorobanResources", [["footprint", e3.lookup("LedgerFootprint")], ["instructions", e3.lookup("Uint32")], ["readBytes", e3.lookup("Uint32")], ["writeBytes", e3.lookup("Uint32")]]), e3.struct("SorobanTransactionData", [["ext", e3.lookup("ExtensionPoint")], ["resources", e3.lookup("SorobanResources")], ["resourceFee", e3.lookup("Int64")]]), e3.union("TransactionV0Ext", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("TransactionV0", [["sourceAccountEd25519", e3.lookup("Uint256")], ["fee", e3.lookup("Uint32")], ["seqNum", e3.lookup("SequenceNumber")], ["timeBounds", e3.option(e3.lookup("TimeBounds"))], ["memo", e3.lookup("Memo")], ["operations", e3.varArray(e3.lookup("Operation"), e3.lookup("MAX_OPS_PER_TX"))], ["ext", e3.lookup("TransactionV0Ext")]]), e3.struct("TransactionV0Envelope", [["tx", e3.lookup("TransactionV0")], ["signatures", e3.varArray(e3.lookup("DecoratedSignature"), 20)]]), e3.union("TransactionExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()], [1, "sorobanData"]], arms: { sorobanData: e3.lookup("SorobanTransactionData") } }), e3.struct("Transaction", [["sourceAccount", e3.lookup("MuxedAccount")], ["fee", e3.lookup("Uint32")], ["seqNum", e3.lookup("SequenceNumber")], ["cond", e3.lookup("Preconditions")], ["memo", e3.lookup("Memo")], ["operations", e3.varArray(e3.lookup("Operation"), e3.lookup("MAX_OPS_PER_TX"))], ["ext", e3.lookup("TransactionExt")]]), e3.struct("TransactionV1Envelope", [["tx", e3.lookup("Transaction")], ["signatures", e3.varArray(e3.lookup("DecoratedSignature"), 20)]]), e3.union("FeeBumpTransactionInnerTx", { switchOn: e3.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTx", "v1"]], arms: { v1: e3.lookup("TransactionV1Envelope") } }), e3.union("FeeBumpTransactionExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("FeeBumpTransaction", [["feeSource", e3.lookup("MuxedAccount")], ["fee", e3.lookup("Int64")], ["innerTx", e3.lookup("FeeBumpTransactionInnerTx")], ["ext", e3.lookup("FeeBumpTransactionExt")]]), e3.struct("FeeBumpTransactionEnvelope", [["tx", e3.lookup("FeeBumpTransaction")], ["signatures", e3.varArray(e3.lookup("DecoratedSignature"), 20)]]), e3.union("TransactionEnvelope", { switchOn: e3.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]], arms: { v0: e3.lookup("TransactionV0Envelope"), v1: e3.lookup("TransactionV1Envelope"), feeBump: e3.lookup("FeeBumpTransactionEnvelope") } }), e3.union("TransactionSignaturePayloadTaggedTransaction", { switchOn: e3.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]], arms: { tx: e3.lookup("Transaction"), feeBump: e3.lookup("FeeBumpTransaction") } }), e3.struct("TransactionSignaturePayload", [["networkId", e3.lookup("Hash")], ["taggedTransaction", e3.lookup("TransactionSignaturePayloadTaggedTransaction")]]), e3.enum("ClaimAtomType", { claimAtomTypeV0: 0, claimAtomTypeOrderBook: 1, claimAtomTypeLiquidityPool: 2 }), e3.struct("ClaimOfferAtomV0", [["sellerEd25519", e3.lookup("Uint256")], ["offerId", e3.lookup("Int64")], ["assetSold", e3.lookup("Asset")], ["amountSold", e3.lookup("Int64")], ["assetBought", e3.lookup("Asset")], ["amountBought", e3.lookup("Int64")]]), e3.struct("ClaimOfferAtom", [["sellerId", e3.lookup("AccountId")], ["offerId", e3.lookup("Int64")], ["assetSold", e3.lookup("Asset")], ["amountSold", e3.lookup("Int64")], ["assetBought", e3.lookup("Asset")], ["amountBought", e3.lookup("Int64")]]), e3.struct("ClaimLiquidityAtom", [["liquidityPoolId", e3.lookup("PoolId")], ["assetSold", e3.lookup("Asset")], ["amountSold", e3.lookup("Int64")], ["assetBought", e3.lookup("Asset")], ["amountBought", e3.lookup("Int64")]]), e3.union("ClaimAtom", { switchOn: e3.lookup("ClaimAtomType"), switchName: "type", switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]], arms: { v0: e3.lookup("ClaimOfferAtomV0"), orderBook: e3.lookup("ClaimOfferAtom"), liquidityPool: e3.lookup("ClaimLiquidityAtom") } }), e3.enum("CreateAccountResultCode", { createAccountSuccess: 0, createAccountMalformed: -1, createAccountUnderfunded: -2, createAccountLowReserve: -3, createAccountAlreadyExist: -4 }), e3.union("CreateAccountResult", { switchOn: e3.lookup("CreateAccountResultCode"), switchName: "code", switches: [["createAccountSuccess", e3.void()], ["createAccountMalformed", e3.void()], ["createAccountUnderfunded", e3.void()], ["createAccountLowReserve", e3.void()], ["createAccountAlreadyExist", e3.void()]], arms: {} }), e3.enum("PaymentResultCode", { paymentSuccess: 0, paymentMalformed: -1, paymentUnderfunded: -2, paymentSrcNoTrust: -3, paymentSrcNotAuthorized: -4, paymentNoDestination: -5, paymentNoTrust: -6, paymentNotAuthorized: -7, paymentLineFull: -8, paymentNoIssuer: -9 }), e3.union("PaymentResult", { switchOn: e3.lookup("PaymentResultCode"), switchName: "code", switches: [["paymentSuccess", e3.void()], ["paymentMalformed", e3.void()], ["paymentUnderfunded", e3.void()], ["paymentSrcNoTrust", e3.void()], ["paymentSrcNotAuthorized", e3.void()], ["paymentNoDestination", e3.void()], ["paymentNoTrust", e3.void()], ["paymentNotAuthorized", e3.void()], ["paymentLineFull", e3.void()], ["paymentNoIssuer", e3.void()]], arms: {} }), e3.enum("PathPaymentStrictReceiveResultCode", { pathPaymentStrictReceiveSuccess: 0, pathPaymentStrictReceiveMalformed: -1, pathPaymentStrictReceiveUnderfunded: -2, pathPaymentStrictReceiveSrcNoTrust: -3, pathPaymentStrictReceiveSrcNotAuthorized: -4, pathPaymentStrictReceiveNoDestination: -5, pathPaymentStrictReceiveNoTrust: -6, pathPaymentStrictReceiveNotAuthorized: -7, pathPaymentStrictReceiveLineFull: -8, pathPaymentStrictReceiveNoIssuer: -9, pathPaymentStrictReceiveTooFewOffers: -10, pathPaymentStrictReceiveOfferCrossSelf: -11, pathPaymentStrictReceiveOverSendmax: -12 }), e3.struct("SimplePaymentResult", [["destination", e3.lookup("AccountId")], ["asset", e3.lookup("Asset")], ["amount", e3.lookup("Int64")]]), e3.struct("PathPaymentStrictReceiveResultSuccess", [["offers", e3.varArray(e3.lookup("ClaimAtom"), 2147483647)], ["last", e3.lookup("SimplePaymentResult")]]), e3.union("PathPaymentStrictReceiveResult", { switchOn: e3.lookup("PathPaymentStrictReceiveResultCode"), switchName: "code", switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", e3.void()], ["pathPaymentStrictReceiveUnderfunded", e3.void()], ["pathPaymentStrictReceiveSrcNoTrust", e3.void()], ["pathPaymentStrictReceiveSrcNotAuthorized", e3.void()], ["pathPaymentStrictReceiveNoDestination", e3.void()], ["pathPaymentStrictReceiveNoTrust", e3.void()], ["pathPaymentStrictReceiveNotAuthorized", e3.void()], ["pathPaymentStrictReceiveLineFull", e3.void()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", e3.void()], ["pathPaymentStrictReceiveOfferCrossSelf", e3.void()], ["pathPaymentStrictReceiveOverSendmax", e3.void()]], arms: { success: e3.lookup("PathPaymentStrictReceiveResultSuccess"), noIssuer: e3.lookup("Asset") } }), e3.enum("PathPaymentStrictSendResultCode", { pathPaymentStrictSendSuccess: 0, pathPaymentStrictSendMalformed: -1, pathPaymentStrictSendUnderfunded: -2, pathPaymentStrictSendSrcNoTrust: -3, pathPaymentStrictSendSrcNotAuthorized: -4, pathPaymentStrictSendNoDestination: -5, pathPaymentStrictSendNoTrust: -6, pathPaymentStrictSendNotAuthorized: -7, pathPaymentStrictSendLineFull: -8, pathPaymentStrictSendNoIssuer: -9, pathPaymentStrictSendTooFewOffers: -10, pathPaymentStrictSendOfferCrossSelf: -11, pathPaymentStrictSendUnderDestmin: -12 }), e3.struct("PathPaymentStrictSendResultSuccess", [["offers", e3.varArray(e3.lookup("ClaimAtom"), 2147483647)], ["last", e3.lookup("SimplePaymentResult")]]), e3.union("PathPaymentStrictSendResult", { switchOn: e3.lookup("PathPaymentStrictSendResultCode"), switchName: "code", switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", e3.void()], ["pathPaymentStrictSendUnderfunded", e3.void()], ["pathPaymentStrictSendSrcNoTrust", e3.void()], ["pathPaymentStrictSendSrcNotAuthorized", e3.void()], ["pathPaymentStrictSendNoDestination", e3.void()], ["pathPaymentStrictSendNoTrust", e3.void()], ["pathPaymentStrictSendNotAuthorized", e3.void()], ["pathPaymentStrictSendLineFull", e3.void()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", e3.void()], ["pathPaymentStrictSendOfferCrossSelf", e3.void()], ["pathPaymentStrictSendUnderDestmin", e3.void()]], arms: { success: e3.lookup("PathPaymentStrictSendResultSuccess"), noIssuer: e3.lookup("Asset") } }), e3.enum("ManageSellOfferResultCode", { manageSellOfferSuccess: 0, manageSellOfferMalformed: -1, manageSellOfferSellNoTrust: -2, manageSellOfferBuyNoTrust: -3, manageSellOfferSellNotAuthorized: -4, manageSellOfferBuyNotAuthorized: -5, manageSellOfferLineFull: -6, manageSellOfferUnderfunded: -7, manageSellOfferCrossSelf: -8, manageSellOfferSellNoIssuer: -9, manageSellOfferBuyNoIssuer: -10, manageSellOfferNotFound: -11, manageSellOfferLowReserve: -12 }), e3.enum("ManageOfferEffect", { manageOfferCreated: 0, manageOfferUpdated: 1, manageOfferDeleted: 2 }), e3.union("ManageOfferSuccessResultOffer", { switchOn: e3.lookup("ManageOfferEffect"), switchName: "effect", switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", e3.void()]], arms: { offer: e3.lookup("OfferEntry") } }), e3.struct("ManageOfferSuccessResult", [["offersClaimed", e3.varArray(e3.lookup("ClaimAtom"), 2147483647)], ["offer", e3.lookup("ManageOfferSuccessResultOffer")]]), e3.union("ManageSellOfferResult", { switchOn: e3.lookup("ManageSellOfferResultCode"), switchName: "code", switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", e3.void()], ["manageSellOfferSellNoTrust", e3.void()], ["manageSellOfferBuyNoTrust", e3.void()], ["manageSellOfferSellNotAuthorized", e3.void()], ["manageSellOfferBuyNotAuthorized", e3.void()], ["manageSellOfferLineFull", e3.void()], ["manageSellOfferUnderfunded", e3.void()], ["manageSellOfferCrossSelf", e3.void()], ["manageSellOfferSellNoIssuer", e3.void()], ["manageSellOfferBuyNoIssuer", e3.void()], ["manageSellOfferNotFound", e3.void()], ["manageSellOfferLowReserve", e3.void()]], arms: { success: e3.lookup("ManageOfferSuccessResult") } }), e3.enum("ManageBuyOfferResultCode", { manageBuyOfferSuccess: 0, manageBuyOfferMalformed: -1, manageBuyOfferSellNoTrust: -2, manageBuyOfferBuyNoTrust: -3, manageBuyOfferSellNotAuthorized: -4, manageBuyOfferBuyNotAuthorized: -5, manageBuyOfferLineFull: -6, manageBuyOfferUnderfunded: -7, manageBuyOfferCrossSelf: -8, manageBuyOfferSellNoIssuer: -9, manageBuyOfferBuyNoIssuer: -10, manageBuyOfferNotFound: -11, manageBuyOfferLowReserve: -12 }), e3.union("ManageBuyOfferResult", { switchOn: e3.lookup("ManageBuyOfferResultCode"), switchName: "code", switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", e3.void()], ["manageBuyOfferSellNoTrust", e3.void()], ["manageBuyOfferBuyNoTrust", e3.void()], ["manageBuyOfferSellNotAuthorized", e3.void()], ["manageBuyOfferBuyNotAuthorized", e3.void()], ["manageBuyOfferLineFull", e3.void()], ["manageBuyOfferUnderfunded", e3.void()], ["manageBuyOfferCrossSelf", e3.void()], ["manageBuyOfferSellNoIssuer", e3.void()], ["manageBuyOfferBuyNoIssuer", e3.void()], ["manageBuyOfferNotFound", e3.void()], ["manageBuyOfferLowReserve", e3.void()]], arms: { success: e3.lookup("ManageOfferSuccessResult") } }), e3.enum("SetOptionsResultCode", { setOptionsSuccess: 0, setOptionsLowReserve: -1, setOptionsTooManySigners: -2, setOptionsBadFlags: -3, setOptionsInvalidInflation: -4, setOptionsCantChange: -5, setOptionsUnknownFlag: -6, setOptionsThresholdOutOfRange: -7, setOptionsBadSigner: -8, setOptionsInvalidHomeDomain: -9, setOptionsAuthRevocableRequired: -10 }), e3.union("SetOptionsResult", { switchOn: e3.lookup("SetOptionsResultCode"), switchName: "code", switches: [["setOptionsSuccess", e3.void()], ["setOptionsLowReserve", e3.void()], ["setOptionsTooManySigners", e3.void()], ["setOptionsBadFlags", e3.void()], ["setOptionsInvalidInflation", e3.void()], ["setOptionsCantChange", e3.void()], ["setOptionsUnknownFlag", e3.void()], ["setOptionsThresholdOutOfRange", e3.void()], ["setOptionsBadSigner", e3.void()], ["setOptionsInvalidHomeDomain", e3.void()], ["setOptionsAuthRevocableRequired", e3.void()]], arms: {} }), e3.enum("ChangeTrustResultCode", { changeTrustSuccess: 0, changeTrustMalformed: -1, changeTrustNoIssuer: -2, changeTrustInvalidLimit: -3, changeTrustLowReserve: -4, changeTrustSelfNotAllowed: -5, changeTrustTrustLineMissing: -6, changeTrustCannotDelete: -7, changeTrustNotAuthMaintainLiabilities: -8 }), e3.union("ChangeTrustResult", { switchOn: e3.lookup("ChangeTrustResultCode"), switchName: "code", switches: [["changeTrustSuccess", e3.void()], ["changeTrustMalformed", e3.void()], ["changeTrustNoIssuer", e3.void()], ["changeTrustInvalidLimit", e3.void()], ["changeTrustLowReserve", e3.void()], ["changeTrustSelfNotAllowed", e3.void()], ["changeTrustTrustLineMissing", e3.void()], ["changeTrustCannotDelete", e3.void()], ["changeTrustNotAuthMaintainLiabilities", e3.void()]], arms: {} }), e3.enum("AllowTrustResultCode", { allowTrustSuccess: 0, allowTrustMalformed: -1, allowTrustNoTrustLine: -2, allowTrustTrustNotRequired: -3, allowTrustCantRevoke: -4, allowTrustSelfNotAllowed: -5, allowTrustLowReserve: -6 }), e3.union("AllowTrustResult", { switchOn: e3.lookup("AllowTrustResultCode"), switchName: "code", switches: [["allowTrustSuccess", e3.void()], ["allowTrustMalformed", e3.void()], ["allowTrustNoTrustLine", e3.void()], ["allowTrustTrustNotRequired", e3.void()], ["allowTrustCantRevoke", e3.void()], ["allowTrustSelfNotAllowed", e3.void()], ["allowTrustLowReserve", e3.void()]], arms: {} }), e3.enum("AccountMergeResultCode", { accountMergeSuccess: 0, accountMergeMalformed: -1, accountMergeNoAccount: -2, accountMergeImmutableSet: -3, accountMergeHasSubEntries: -4, accountMergeSeqnumTooFar: -5, accountMergeDestFull: -6, accountMergeIsSponsor: -7 }), e3.union("AccountMergeResult", { switchOn: e3.lookup("AccountMergeResultCode"), switchName: "code", switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", e3.void()], ["accountMergeNoAccount", e3.void()], ["accountMergeImmutableSet", e3.void()], ["accountMergeHasSubEntries", e3.void()], ["accountMergeSeqnumTooFar", e3.void()], ["accountMergeDestFull", e3.void()], ["accountMergeIsSponsor", e3.void()]], arms: { sourceAccountBalance: e3.lookup("Int64") } }), e3.enum("InflationResultCode", { inflationSuccess: 0, inflationNotTime: -1 }), e3.struct("InflationPayout", [["destination", e3.lookup("AccountId")], ["amount", e3.lookup("Int64")]]), e3.union("InflationResult", { switchOn: e3.lookup("InflationResultCode"), switchName: "code", switches: [["inflationSuccess", "payouts"], ["inflationNotTime", e3.void()]], arms: { payouts: e3.varArray(e3.lookup("InflationPayout"), 2147483647) } }), e3.enum("ManageDataResultCode", { manageDataSuccess: 0, manageDataNotSupportedYet: -1, manageDataNameNotFound: -2, manageDataLowReserve: -3, manageDataInvalidName: -4 }), e3.union("ManageDataResult", { switchOn: e3.lookup("ManageDataResultCode"), switchName: "code", switches: [["manageDataSuccess", e3.void()], ["manageDataNotSupportedYet", e3.void()], ["manageDataNameNotFound", e3.void()], ["manageDataLowReserve", e3.void()], ["manageDataInvalidName", e3.void()]], arms: {} }), e3.enum("BumpSequenceResultCode", { bumpSequenceSuccess: 0, bumpSequenceBadSeq: -1 }), e3.union("BumpSequenceResult", { switchOn: e3.lookup("BumpSequenceResultCode"), switchName: "code", switches: [["bumpSequenceSuccess", e3.void()], ["bumpSequenceBadSeq", e3.void()]], arms: {} }), e3.enum("CreateClaimableBalanceResultCode", { createClaimableBalanceSuccess: 0, createClaimableBalanceMalformed: -1, createClaimableBalanceLowReserve: -2, createClaimableBalanceNoTrust: -3, createClaimableBalanceNotAuthorized: -4, createClaimableBalanceUnderfunded: -5 }), e3.union("CreateClaimableBalanceResult", { switchOn: e3.lookup("CreateClaimableBalanceResultCode"), switchName: "code", switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", e3.void()], ["createClaimableBalanceLowReserve", e3.void()], ["createClaimableBalanceNoTrust", e3.void()], ["createClaimableBalanceNotAuthorized", e3.void()], ["createClaimableBalanceUnderfunded", e3.void()]], arms: { balanceId: e3.lookup("ClaimableBalanceId") } }), e3.enum("ClaimClaimableBalanceResultCode", { claimClaimableBalanceSuccess: 0, claimClaimableBalanceDoesNotExist: -1, claimClaimableBalanceCannotClaim: -2, claimClaimableBalanceLineFull: -3, claimClaimableBalanceNoTrust: -4, claimClaimableBalanceNotAuthorized: -5 }), e3.union("ClaimClaimableBalanceResult", { switchOn: e3.lookup("ClaimClaimableBalanceResultCode"), switchName: "code", switches: [["claimClaimableBalanceSuccess", e3.void()], ["claimClaimableBalanceDoesNotExist", e3.void()], ["claimClaimableBalanceCannotClaim", e3.void()], ["claimClaimableBalanceLineFull", e3.void()], ["claimClaimableBalanceNoTrust", e3.void()], ["claimClaimableBalanceNotAuthorized", e3.void()]], arms: {} }), e3.enum("BeginSponsoringFutureReservesResultCode", { beginSponsoringFutureReservesSuccess: 0, beginSponsoringFutureReservesMalformed: -1, beginSponsoringFutureReservesAlreadySponsored: -2, beginSponsoringFutureReservesRecursive: -3 }), e3.union("BeginSponsoringFutureReservesResult", { switchOn: e3.lookup("BeginSponsoringFutureReservesResultCode"), switchName: "code", switches: [["beginSponsoringFutureReservesSuccess", e3.void()], ["beginSponsoringFutureReservesMalformed", e3.void()], ["beginSponsoringFutureReservesAlreadySponsored", e3.void()], ["beginSponsoringFutureReservesRecursive", e3.void()]], arms: {} }), e3.enum("EndSponsoringFutureReservesResultCode", { endSponsoringFutureReservesSuccess: 0, endSponsoringFutureReservesNotSponsored: -1 }), e3.union("EndSponsoringFutureReservesResult", { switchOn: e3.lookup("EndSponsoringFutureReservesResultCode"), switchName: "code", switches: [["endSponsoringFutureReservesSuccess", e3.void()], ["endSponsoringFutureReservesNotSponsored", e3.void()]], arms: {} }), e3.enum("RevokeSponsorshipResultCode", { revokeSponsorshipSuccess: 0, revokeSponsorshipDoesNotExist: -1, revokeSponsorshipNotSponsor: -2, revokeSponsorshipLowReserve: -3, revokeSponsorshipOnlyTransferable: -4, revokeSponsorshipMalformed: -5 }), e3.union("RevokeSponsorshipResult", { switchOn: e3.lookup("RevokeSponsorshipResultCode"), switchName: "code", switches: [["revokeSponsorshipSuccess", e3.void()], ["revokeSponsorshipDoesNotExist", e3.void()], ["revokeSponsorshipNotSponsor", e3.void()], ["revokeSponsorshipLowReserve", e3.void()], ["revokeSponsorshipOnlyTransferable", e3.void()], ["revokeSponsorshipMalformed", e3.void()]], arms: {} }), e3.enum("ClawbackResultCode", { clawbackSuccess: 0, clawbackMalformed: -1, clawbackNotClawbackEnabled: -2, clawbackNoTrust: -3, clawbackUnderfunded: -4 }), e3.union("ClawbackResult", { switchOn: e3.lookup("ClawbackResultCode"), switchName: "code", switches: [["clawbackSuccess", e3.void()], ["clawbackMalformed", e3.void()], ["clawbackNotClawbackEnabled", e3.void()], ["clawbackNoTrust", e3.void()], ["clawbackUnderfunded", e3.void()]], arms: {} }), e3.enum("ClawbackClaimableBalanceResultCode", { clawbackClaimableBalanceSuccess: 0, clawbackClaimableBalanceDoesNotExist: -1, clawbackClaimableBalanceNotIssuer: -2, clawbackClaimableBalanceNotClawbackEnabled: -3 }), e3.union("ClawbackClaimableBalanceResult", { switchOn: e3.lookup("ClawbackClaimableBalanceResultCode"), switchName: "code", switches: [["clawbackClaimableBalanceSuccess", e3.void()], ["clawbackClaimableBalanceDoesNotExist", e3.void()], ["clawbackClaimableBalanceNotIssuer", e3.void()], ["clawbackClaimableBalanceNotClawbackEnabled", e3.void()]], arms: {} }), e3.enum("SetTrustLineFlagsResultCode", { setTrustLineFlagsSuccess: 0, setTrustLineFlagsMalformed: -1, setTrustLineFlagsNoTrustLine: -2, setTrustLineFlagsCantRevoke: -3, setTrustLineFlagsInvalidState: -4, setTrustLineFlagsLowReserve: -5 }), e3.union("SetTrustLineFlagsResult", { switchOn: e3.lookup("SetTrustLineFlagsResultCode"), switchName: "code", switches: [["setTrustLineFlagsSuccess", e3.void()], ["setTrustLineFlagsMalformed", e3.void()], ["setTrustLineFlagsNoTrustLine", e3.void()], ["setTrustLineFlagsCantRevoke", e3.void()], ["setTrustLineFlagsInvalidState", e3.void()], ["setTrustLineFlagsLowReserve", e3.void()]], arms: {} }), e3.enum("LiquidityPoolDepositResultCode", { liquidityPoolDepositSuccess: 0, liquidityPoolDepositMalformed: -1, liquidityPoolDepositNoTrust: -2, liquidityPoolDepositNotAuthorized: -3, liquidityPoolDepositUnderfunded: -4, liquidityPoolDepositLineFull: -5, liquidityPoolDepositBadPrice: -6, liquidityPoolDepositPoolFull: -7 }), e3.union("LiquidityPoolDepositResult", { switchOn: e3.lookup("LiquidityPoolDepositResultCode"), switchName: "code", switches: [["liquidityPoolDepositSuccess", e3.void()], ["liquidityPoolDepositMalformed", e3.void()], ["liquidityPoolDepositNoTrust", e3.void()], ["liquidityPoolDepositNotAuthorized", e3.void()], ["liquidityPoolDepositUnderfunded", e3.void()], ["liquidityPoolDepositLineFull", e3.void()], ["liquidityPoolDepositBadPrice", e3.void()], ["liquidityPoolDepositPoolFull", e3.void()]], arms: {} }), e3.enum("LiquidityPoolWithdrawResultCode", { liquidityPoolWithdrawSuccess: 0, liquidityPoolWithdrawMalformed: -1, liquidityPoolWithdrawNoTrust: -2, liquidityPoolWithdrawUnderfunded: -3, liquidityPoolWithdrawLineFull: -4, liquidityPoolWithdrawUnderMinimum: -5 }), e3.union("LiquidityPoolWithdrawResult", { switchOn: e3.lookup("LiquidityPoolWithdrawResultCode"), switchName: "code", switches: [["liquidityPoolWithdrawSuccess", e3.void()], ["liquidityPoolWithdrawMalformed", e3.void()], ["liquidityPoolWithdrawNoTrust", e3.void()], ["liquidityPoolWithdrawUnderfunded", e3.void()], ["liquidityPoolWithdrawLineFull", e3.void()], ["liquidityPoolWithdrawUnderMinimum", e3.void()]], arms: {} }), e3.enum("InvokeHostFunctionResultCode", { invokeHostFunctionSuccess: 0, invokeHostFunctionMalformed: -1, invokeHostFunctionTrapped: -2, invokeHostFunctionResourceLimitExceeded: -3, invokeHostFunctionEntryArchived: -4, invokeHostFunctionInsufficientRefundableFee: -5 }), e3.union("InvokeHostFunctionResult", { switchOn: e3.lookup("InvokeHostFunctionResultCode"), switchName: "code", switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", e3.void()], ["invokeHostFunctionTrapped", e3.void()], ["invokeHostFunctionResourceLimitExceeded", e3.void()], ["invokeHostFunctionEntryArchived", e3.void()], ["invokeHostFunctionInsufficientRefundableFee", e3.void()]], arms: { success: e3.lookup("Hash") } }), e3.enum("ExtendFootprintTtlResultCode", { extendFootprintTtlSuccess: 0, extendFootprintTtlMalformed: -1, extendFootprintTtlResourceLimitExceeded: -2, extendFootprintTtlInsufficientRefundableFee: -3 }), e3.union("ExtendFootprintTtlResult", { switchOn: e3.lookup("ExtendFootprintTtlResultCode"), switchName: "code", switches: [["extendFootprintTtlSuccess", e3.void()], ["extendFootprintTtlMalformed", e3.void()], ["extendFootprintTtlResourceLimitExceeded", e3.void()], ["extendFootprintTtlInsufficientRefundableFee", e3.void()]], arms: {} }), e3.enum("RestoreFootprintResultCode", { restoreFootprintSuccess: 0, restoreFootprintMalformed: -1, restoreFootprintResourceLimitExceeded: -2, restoreFootprintInsufficientRefundableFee: -3 }), e3.union("RestoreFootprintResult", { switchOn: e3.lookup("RestoreFootprintResultCode"), switchName: "code", switches: [["restoreFootprintSuccess", e3.void()], ["restoreFootprintMalformed", e3.void()], ["restoreFootprintResourceLimitExceeded", e3.void()], ["restoreFootprintInsufficientRefundableFee", e3.void()]], arms: {} }), e3.enum("OperationResultCode", { opInner: 0, opBadAuth: -1, opNoAccount: -2, opNotSupported: -3, opTooManySubentries: -4, opExceededWorkLimit: -5, opTooManySponsoring: -6 }), e3.union("OperationResultTr", { switchOn: e3.lookup("OperationType"), switchName: "type", switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]], arms: { createAccountResult: e3.lookup("CreateAccountResult"), paymentResult: e3.lookup("PaymentResult"), pathPaymentStrictReceiveResult: e3.lookup("PathPaymentStrictReceiveResult"), manageSellOfferResult: e3.lookup("ManageSellOfferResult"), createPassiveSellOfferResult: e3.lookup("ManageSellOfferResult"), setOptionsResult: e3.lookup("SetOptionsResult"), changeTrustResult: e3.lookup("ChangeTrustResult"), allowTrustResult: e3.lookup("AllowTrustResult"), accountMergeResult: e3.lookup("AccountMergeResult"), inflationResult: e3.lookup("InflationResult"), manageDataResult: e3.lookup("ManageDataResult"), bumpSeqResult: e3.lookup("BumpSequenceResult"), manageBuyOfferResult: e3.lookup("ManageBuyOfferResult"), pathPaymentStrictSendResult: e3.lookup("PathPaymentStrictSendResult"), createClaimableBalanceResult: e3.lookup("CreateClaimableBalanceResult"), claimClaimableBalanceResult: e3.lookup("ClaimClaimableBalanceResult"), beginSponsoringFutureReservesResult: e3.lookup("BeginSponsoringFutureReservesResult"), endSponsoringFutureReservesResult: e3.lookup("EndSponsoringFutureReservesResult"), revokeSponsorshipResult: e3.lookup("RevokeSponsorshipResult"), clawbackResult: e3.lookup("ClawbackResult"), clawbackClaimableBalanceResult: e3.lookup("ClawbackClaimableBalanceResult"), setTrustLineFlagsResult: e3.lookup("SetTrustLineFlagsResult"), liquidityPoolDepositResult: e3.lookup("LiquidityPoolDepositResult"), liquidityPoolWithdrawResult: e3.lookup("LiquidityPoolWithdrawResult"), invokeHostFunctionResult: e3.lookup("InvokeHostFunctionResult"), extendFootprintTtlResult: e3.lookup("ExtendFootprintTtlResult"), restoreFootprintResult: e3.lookup("RestoreFootprintResult") } }), e3.union("OperationResult", { switchOn: e3.lookup("OperationResultCode"), switchName: "code", switches: [["opInner", "tr"], ["opBadAuth", e3.void()], ["opNoAccount", e3.void()], ["opNotSupported", e3.void()], ["opTooManySubentries", e3.void()], ["opExceededWorkLimit", e3.void()], ["opTooManySponsoring", e3.void()]], arms: { tr: e3.lookup("OperationResultTr") } }), e3.enum("TransactionResultCode", { txFeeBumpInnerSuccess: 1, txSuccess: 0, txFailed: -1, txTooEarly: -2, txTooLate: -3, txMissingOperation: -4, txBadSeq: -5, txBadAuth: -6, txInsufficientBalance: -7, txNoAccount: -8, txInsufficientFee: -9, txBadAuthExtra: -10, txInternalError: -11, txNotSupported: -12, txFeeBumpInnerFailed: -13, txBadSponsorship: -14, txBadMinSeqAgeOrGap: -15, txMalformed: -16, txSorobanInvalid: -17 }), e3.union("InnerTransactionResultResult", { switchOn: e3.lookup("TransactionResultCode"), switchName: "code", switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", e3.void()], ["txTooLate", e3.void()], ["txMissingOperation", e3.void()], ["txBadSeq", e3.void()], ["txBadAuth", e3.void()], ["txInsufficientBalance", e3.void()], ["txNoAccount", e3.void()], ["txInsufficientFee", e3.void()], ["txBadAuthExtra", e3.void()], ["txInternalError", e3.void()], ["txNotSupported", e3.void()], ["txBadSponsorship", e3.void()], ["txBadMinSeqAgeOrGap", e3.void()], ["txMalformed", e3.void()], ["txSorobanInvalid", e3.void()]], arms: { results: e3.varArray(e3.lookup("OperationResult"), 2147483647) } }), e3.union("InnerTransactionResultExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("InnerTransactionResult", [["feeCharged", e3.lookup("Int64")], ["result", e3.lookup("InnerTransactionResultResult")], ["ext", e3.lookup("InnerTransactionResultExt")]]), e3.struct("InnerTransactionResultPair", [["transactionHash", e3.lookup("Hash")], ["result", e3.lookup("InnerTransactionResult")]]), e3.union("TransactionResultResult", { switchOn: e3.lookup("TransactionResultCode"), switchName: "code", switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", e3.void()], ["txTooLate", e3.void()], ["txMissingOperation", e3.void()], ["txBadSeq", e3.void()], ["txBadAuth", e3.void()], ["txInsufficientBalance", e3.void()], ["txNoAccount", e3.void()], ["txInsufficientFee", e3.void()], ["txBadAuthExtra", e3.void()], ["txInternalError", e3.void()], ["txNotSupported", e3.void()], ["txBadSponsorship", e3.void()], ["txBadMinSeqAgeOrGap", e3.void()], ["txMalformed", e3.void()], ["txSorobanInvalid", e3.void()]], arms: { innerResultPair: e3.lookup("InnerTransactionResultPair"), results: e3.varArray(e3.lookup("OperationResult"), 2147483647) } }), e3.union("TransactionResultExt", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.struct("TransactionResult", [["feeCharged", e3.lookup("Int64")], ["result", e3.lookup("TransactionResultResult")], ["ext", e3.lookup("TransactionResultExt")]]), e3.typedef("Hash", e3.opaque(32)), e3.typedef("Uint256", e3.opaque(32)), e3.typedef("Uint32", e3.uint()), e3.typedef("Int32", e3.int()), e3.typedef("Uint64", e3.uhyper()), e3.typedef("Int64", e3.hyper()), e3.typedef("TimePoint", e3.lookup("Uint64")), e3.typedef("Duration", e3.lookup("Uint64")), e3.union("ExtensionPoint", { switchOn: e3.int(), switchName: "v", switches: [[0, e3.void()]], arms: {} }), e3.enum("CryptoKeyType", { keyTypeEd25519: 0, keyTypePreAuthTx: 1, keyTypeHashX: 2, keyTypeEd25519SignedPayload: 3, keyTypeMuxedEd25519: 256 }), e3.enum("PublicKeyType", { publicKeyTypeEd25519: 0 }), e3.enum("SignerKeyType", { signerKeyTypeEd25519: 0, signerKeyTypePreAuthTx: 1, signerKeyTypeHashX: 2, signerKeyTypeEd25519SignedPayload: 3 }), e3.union("PublicKey", { switchOn: e3.lookup("PublicKeyType"), switchName: "type", switches: [["publicKeyTypeEd25519", "ed25519"]], arms: { ed25519: e3.lookup("Uint256") } }), e3.struct("SignerKeyEd25519SignedPayload", [["ed25519", e3.lookup("Uint256")], ["payload", e3.varOpaque(64)]]), e3.union("SignerKey", { switchOn: e3.lookup("SignerKeyType"), switchName: "type", switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]], arms: { ed25519: e3.lookup("Uint256"), preAuthTx: e3.lookup("Uint256"), hashX: e3.lookup("Uint256"), ed25519SignedPayload: e3.lookup("SignerKeyEd25519SignedPayload") } }), e3.typedef("Signature", e3.varOpaque(64)), e3.typedef("SignatureHint", e3.opaque(4)), e3.typedef("NodeId", e3.lookup("PublicKey")), e3.typedef("AccountId", e3.lookup("PublicKey")), e3.struct("Curve25519Secret", [["key", e3.opaque(32)]]), e3.struct("Curve25519Public", [["key", e3.opaque(32)]]), e3.struct("HmacSha256Key", [["key", e3.opaque(32)]]), e3.struct("HmacSha256Mac", [["mac", e3.opaque(32)]]), e3.struct("ShortHashSeed", [["seed", e3.opaque(16)]]), e3.enum("BinaryFuseFilterType", { binaryFuseFilter8Bit: 0, binaryFuseFilter16Bit: 1, binaryFuseFilter32Bit: 2 }), e3.struct("SerializedBinaryFuseFilter", [["type", e3.lookup("BinaryFuseFilterType")], ["inputHashSeed", e3.lookup("ShortHashSeed")], ["filterSeed", e3.lookup("ShortHashSeed")], ["segmentLength", e3.lookup("Uint32")], ["segementLengthMask", e3.lookup("Uint32")], ["segmentCount", e3.lookup("Uint32")], ["segmentCountLength", e3.lookup("Uint32")], ["fingerprintLength", e3.lookup("Uint32")], ["fingerprints", e3.varOpaque()]]), e3.enum("ScValType", { scvBool: 0, scvVoid: 1, scvError: 2, scvU32: 3, scvI32: 4, scvU64: 5, scvI64: 6, scvTimepoint: 7, scvDuration: 8, scvU128: 9, scvI128: 10, scvU256: 11, scvI256: 12, scvBytes: 13, scvString: 14, scvSymbol: 15, scvVec: 16, scvMap: 17, scvAddress: 18, scvContractInstance: 19, scvLedgerKeyContractInstance: 20, scvLedgerKeyNonce: 21 }), e3.enum("ScErrorType", { sceContract: 0, sceWasmVm: 1, sceContext: 2, sceStorage: 3, sceObject: 4, sceCrypto: 5, sceEvents: 6, sceBudget: 7, sceValue: 8, sceAuth: 9 }), e3.enum("ScErrorCode", { scecArithDomain: 0, scecIndexBounds: 1, scecInvalidInput: 2, scecMissingValue: 3, scecExistingValue: 4, scecExceededLimit: 5, scecInvalidAction: 6, scecInternalError: 7, scecUnexpectedType: 8, scecUnexpectedSize: 9 }), e3.union("ScError", { switchOn: e3.lookup("ScErrorType"), switchName: "type", switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]], arms: { contractCode: e3.lookup("Uint32"), code: e3.lookup("ScErrorCode") } }), e3.struct("UInt128Parts", [["hi", e3.lookup("Uint64")], ["lo", e3.lookup("Uint64")]]), e3.struct("Int128Parts", [["hi", e3.lookup("Int64")], ["lo", e3.lookup("Uint64")]]), e3.struct("UInt256Parts", [["hiHi", e3.lookup("Uint64")], ["hiLo", e3.lookup("Uint64")], ["loHi", e3.lookup("Uint64")], ["loLo", e3.lookup("Uint64")]]), e3.struct("Int256Parts", [["hiHi", e3.lookup("Int64")], ["hiLo", e3.lookup("Uint64")], ["loHi", e3.lookup("Uint64")], ["loLo", e3.lookup("Uint64")]]), e3.enum("ContractExecutableType", { contractExecutableWasm: 0, contractExecutableStellarAsset: 1 }), e3.union("ContractExecutable", { switchOn: e3.lookup("ContractExecutableType"), switchName: "type", switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", e3.void()]], arms: { wasmHash: e3.lookup("Hash") } }), e3.enum("ScAddressType", { scAddressTypeAccount: 0, scAddressTypeContract: 1 }), e3.union("ScAddress", { switchOn: e3.lookup("ScAddressType"), switchName: "type", switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]], arms: { accountId: e3.lookup("AccountId"), contractId: e3.lookup("Hash") } }), e3.const("SCSYMBOL_LIMIT", 32), e3.typedef("ScVec", e3.varArray(e3.lookup("ScVal"), 2147483647)), e3.typedef("ScMap", e3.varArray(e3.lookup("ScMapEntry"), 2147483647)), e3.typedef("ScBytes", e3.varOpaque()), e3.typedef("ScString", e3.string()), e3.typedef("ScSymbol", e3.string(32)), e3.struct("ScNonceKey", [["nonce", e3.lookup("Int64")]]), e3.struct("ScContractInstance", [["executable", e3.lookup("ContractExecutable")], ["storage", e3.option(e3.lookup("ScMap"))]]), e3.union("ScVal", { switchOn: e3.lookup("ScValType"), switchName: "type", switches: [["scvBool", "b"], ["scvVoid", e3.void()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", e3.void()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]], arms: { b: e3.bool(), error: e3.lookup("ScError"), u32: e3.lookup("Uint32"), i32: e3.lookup("Int32"), u64: e3.lookup("Uint64"), i64: e3.lookup("Int64"), timepoint: e3.lookup("TimePoint"), duration: e3.lookup("Duration"), u128: e3.lookup("UInt128Parts"), i128: e3.lookup("Int128Parts"), u256: e3.lookup("UInt256Parts"), i256: e3.lookup("Int256Parts"), bytes: e3.lookup("ScBytes"), str: e3.lookup("ScString"), sym: e3.lookup("ScSymbol"), vec: e3.option(e3.lookup("ScVec")), map: e3.option(e3.lookup("ScMap")), address: e3.lookup("ScAddress"), nonceKey: e3.lookup("ScNonceKey"), instance: e3.lookup("ScContractInstance") } }), e3.struct("ScMapEntry", [["key", e3.lookup("ScVal")], ["val", e3.lookup("ScVal")]]), e3.enum("ScEnvMetaKind", { scEnvMetaKindInterfaceVersion: 0 }), e3.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", e3.lookup("Uint32")], ["preRelease", e3.lookup("Uint32")]]), e3.union("ScEnvMetaEntry", { switchOn: e3.lookup("ScEnvMetaKind"), switchName: "kind", switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]], arms: { interfaceVersion: e3.lookup("ScEnvMetaEntryInterfaceVersion") } }), e3.struct("ScMetaV0", [["key", e3.string()], ["val", e3.string()]]), e3.enum("ScMetaKind", { scMetaV0: 0 }), e3.union("ScMetaEntry", { switchOn: e3.lookup("ScMetaKind"), switchName: "kind", switches: [["scMetaV0", "v0"]], arms: { v0: e3.lookup("ScMetaV0") } }), e3.const("SC_SPEC_DOC_LIMIT", 1024), e3.enum("ScSpecType", { scSpecTypeVal: 0, scSpecTypeBool: 1, scSpecTypeVoid: 2, scSpecTypeError: 3, scSpecTypeU32: 4, scSpecTypeI32: 5, scSpecTypeU64: 6, scSpecTypeI64: 7, scSpecTypeTimepoint: 8, scSpecTypeDuration: 9, scSpecTypeU128: 10, scSpecTypeI128: 11, scSpecTypeU256: 12, scSpecTypeI256: 13, scSpecTypeBytes: 14, scSpecTypeString: 16, scSpecTypeSymbol: 17, scSpecTypeAddress: 19, scSpecTypeOption: 1e3, scSpecTypeResult: 1001, scSpecTypeVec: 1002, scSpecTypeMap: 1004, scSpecTypeTuple: 1005, scSpecTypeBytesN: 1006, scSpecTypeUdt: 2e3 }), e3.struct("ScSpecTypeOption", [["valueType", e3.lookup("ScSpecTypeDef")]]), e3.struct("ScSpecTypeResult", [["okType", e3.lookup("ScSpecTypeDef")], ["errorType", e3.lookup("ScSpecTypeDef")]]), e3.struct("ScSpecTypeVec", [["elementType", e3.lookup("ScSpecTypeDef")]]), e3.struct("ScSpecTypeMap", [["keyType", e3.lookup("ScSpecTypeDef")], ["valueType", e3.lookup("ScSpecTypeDef")]]), e3.struct("ScSpecTypeTuple", [["valueTypes", e3.varArray(e3.lookup("ScSpecTypeDef"), 12)]]), e3.struct("ScSpecTypeBytesN", [["n", e3.lookup("Uint32")]]), e3.struct("ScSpecTypeUdt", [["name", e3.string(60)]]), e3.union("ScSpecTypeDef", { switchOn: e3.lookup("ScSpecType"), switchName: "type", switches: [["scSpecTypeVal", e3.void()], ["scSpecTypeBool", e3.void()], ["scSpecTypeVoid", e3.void()], ["scSpecTypeError", e3.void()], ["scSpecTypeU32", e3.void()], ["scSpecTypeI32", e3.void()], ["scSpecTypeU64", e3.void()], ["scSpecTypeI64", e3.void()], ["scSpecTypeTimepoint", e3.void()], ["scSpecTypeDuration", e3.void()], ["scSpecTypeU128", e3.void()], ["scSpecTypeI128", e3.void()], ["scSpecTypeU256", e3.void()], ["scSpecTypeI256", e3.void()], ["scSpecTypeBytes", e3.void()], ["scSpecTypeString", e3.void()], ["scSpecTypeSymbol", e3.void()], ["scSpecTypeAddress", e3.void()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]], arms: { option: e3.lookup("ScSpecTypeOption"), result: e3.lookup("ScSpecTypeResult"), vec: e3.lookup("ScSpecTypeVec"), map: e3.lookup("ScSpecTypeMap"), tuple: e3.lookup("ScSpecTypeTuple"), bytesN: e3.lookup("ScSpecTypeBytesN"), udt: e3.lookup("ScSpecTypeUdt") } }), e3.struct("ScSpecUdtStructFieldV0", [["doc", e3.string(t3)], ["name", e3.string(30)], ["type", e3.lookup("ScSpecTypeDef")]]), e3.struct("ScSpecUdtStructV0", [["doc", e3.string(t3)], ["lib", e3.string(80)], ["name", e3.string(60)], ["fields", e3.varArray(e3.lookup("ScSpecUdtStructFieldV0"), 40)]]), e3.struct("ScSpecUdtUnionCaseVoidV0", [["doc", e3.string(t3)], ["name", e3.string(60)]]), e3.struct("ScSpecUdtUnionCaseTupleV0", [["doc", e3.string(t3)], ["name", e3.string(60)], ["type", e3.varArray(e3.lookup("ScSpecTypeDef"), 12)]]), e3.enum("ScSpecUdtUnionCaseV0Kind", { scSpecUdtUnionCaseVoidV0: 0, scSpecUdtUnionCaseTupleV0: 1 }), e3.union("ScSpecUdtUnionCaseV0", { switchOn: e3.lookup("ScSpecUdtUnionCaseV0Kind"), switchName: "kind", switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]], arms: { voidCase: e3.lookup("ScSpecUdtUnionCaseVoidV0"), tupleCase: e3.lookup("ScSpecUdtUnionCaseTupleV0") } }), e3.struct("ScSpecUdtUnionV0", [["doc", e3.string(t3)], ["lib", e3.string(80)], ["name", e3.string(60)], ["cases", e3.varArray(e3.lookup("ScSpecUdtUnionCaseV0"), 50)]]), e3.struct("ScSpecUdtEnumCaseV0", [["doc", e3.string(t3)], ["name", e3.string(60)], ["value", e3.lookup("Uint32")]]), e3.struct("ScSpecUdtEnumV0", [["doc", e3.string(t3)], ["lib", e3.string(80)], ["name", e3.string(60)], ["cases", e3.varArray(e3.lookup("ScSpecUdtEnumCaseV0"), 50)]]), e3.struct("ScSpecUdtErrorEnumCaseV0", [["doc", e3.string(t3)], ["name", e3.string(60)], ["value", e3.lookup("Uint32")]]), e3.struct("ScSpecUdtErrorEnumV0", [["doc", e3.string(t3)], ["lib", e3.string(80)], ["name", e3.string(60)], ["cases", e3.varArray(e3.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]), e3.struct("ScSpecFunctionInputV0", [["doc", e3.string(t3)], ["name", e3.string(30)], ["type", e3.lookup("ScSpecTypeDef")]]), e3.struct("ScSpecFunctionV0", [["doc", e3.string(t3)], ["name", e3.lookup("ScSymbol")], ["inputs", e3.varArray(e3.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", e3.varArray(e3.lookup("ScSpecTypeDef"), 1)]]), e3.enum("ScSpecEntryKind", { scSpecEntryFunctionV0: 0, scSpecEntryUdtStructV0: 1, scSpecEntryUdtUnionV0: 2, scSpecEntryUdtEnumV0: 3, scSpecEntryUdtErrorEnumV0: 4 }), e3.union("ScSpecEntry", { switchOn: e3.lookup("ScSpecEntryKind"), switchName: "kind", switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]], arms: { functionV0: e3.lookup("ScSpecFunctionV0"), udtStructV0: e3.lookup("ScSpecUdtStructV0"), udtUnionV0: e3.lookup("ScSpecUdtUnionV0"), udtEnumV0: e3.lookup("ScSpecUdtEnumV0"), udtErrorEnumV0: e3.lookup("ScSpecUdtErrorEnumV0") } }), e3.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", e3.lookup("Uint32")]]), e3.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", e3.lookup("Int64")], ["txMaxInstructions", e3.lookup("Int64")], ["feeRatePerInstructionsIncrement", e3.lookup("Int64")], ["txMemoryLimit", e3.lookup("Uint32")]]), e3.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", e3.lookup("Uint32")], ["ledgerMaxReadBytes", e3.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", e3.lookup("Uint32")], ["ledgerMaxWriteBytes", e3.lookup("Uint32")], ["txMaxReadLedgerEntries", e3.lookup("Uint32")], ["txMaxReadBytes", e3.lookup("Uint32")], ["txMaxWriteLedgerEntries", e3.lookup("Uint32")], ["txMaxWriteBytes", e3.lookup("Uint32")], ["feeReadLedgerEntry", e3.lookup("Int64")], ["feeWriteLedgerEntry", e3.lookup("Int64")], ["feeRead1Kb", e3.lookup("Int64")], ["bucketListTargetSizeBytes", e3.lookup("Int64")], ["writeFee1KbBucketListLow", e3.lookup("Int64")], ["writeFee1KbBucketListHigh", e3.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", e3.lookup("Uint32")]]), e3.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", e3.lookup("Int64")]]), e3.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", e3.lookup("Uint32")], ["feeContractEvents1Kb", e3.lookup("Int64")]]), e3.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", e3.lookup("Uint32")], ["txMaxSizeBytes", e3.lookup("Uint32")], ["feeTxSize1Kb", e3.lookup("Int64")]]), e3.enum("ContractCostType", { wasmInsnExec: 0, memAlloc: 1, memCpy: 2, memCmp: 3, dispatchHostFunction: 4, visitObject: 5, valSer: 6, valDeser: 7, computeSha256Hash: 8, computeEd25519PubKey: 9, verifyEd25519Sig: 10, vmInstantiation: 11, vmCachedInstantiation: 12, invokeVmFunction: 13, computeKeccak256Hash: 14, decodeEcdsaCurve256Sig: 15, recoverEcdsaSecp256k1Key: 16, int256AddSub: 17, int256Mul: 18, int256Div: 19, int256Pow: 20, int256Shift: 21, chaCha20DrawBytes: 22, parseWasmInstructions: 23, parseWasmFunctions: 24, parseWasmGlobals: 25, parseWasmTableEntries: 26, parseWasmTypes: 27, parseWasmDataSegments: 28, parseWasmElemSegments: 29, parseWasmImports: 30, parseWasmExports: 31, parseWasmDataSegmentBytes: 32, instantiateWasmInstructions: 33, instantiateWasmFunctions: 34, instantiateWasmGlobals: 35, instantiateWasmTableEntries: 36, instantiateWasmTypes: 37, instantiateWasmDataSegments: 38, instantiateWasmElemSegments: 39, instantiateWasmImports: 40, instantiateWasmExports: 41, instantiateWasmDataSegmentBytes: 42, sec1DecodePointUncompressed: 43, verifyEcdsaSecp256r1Sig: 44, bls12381EncodeFp: 45, bls12381DecodeFp: 46, bls12381G1CheckPointOnCurve: 47, bls12381G1CheckPointInSubgroup: 48, bls12381G2CheckPointOnCurve: 49, bls12381G2CheckPointInSubgroup: 50, bls12381G1ProjectiveToAffine: 51, bls12381G2ProjectiveToAffine: 52, bls12381G1Add: 53, bls12381G1Mul: 54, bls12381G1Msm: 55, bls12381MapFpToG1: 56, bls12381HashToG1: 57, bls12381G2Add: 58, bls12381G2Mul: 59, bls12381G2Msm: 60, bls12381MapFp2ToG2: 61, bls12381HashToG2: 62, bls12381Pairing: 63, bls12381FrFromU256: 64, bls12381FrToU256: 65, bls12381FrAddSub: 66, bls12381FrMul: 67, bls12381FrPow: 68, bls12381FrInv: 69 }), e3.struct("ContractCostParamEntry", [["ext", e3.lookup("ExtensionPoint")], ["constTerm", e3.lookup("Int64")], ["linearTerm", e3.lookup("Int64")]]), e3.struct("StateArchivalSettings", [["maxEntryTtl", e3.lookup("Uint32")], ["minTemporaryTtl", e3.lookup("Uint32")], ["minPersistentTtl", e3.lookup("Uint32")], ["persistentRentRateDenominator", e3.lookup("Int64")], ["tempRentRateDenominator", e3.lookup("Int64")], ["maxEntriesToArchive", e3.lookup("Uint32")], ["bucketListSizeWindowSampleSize", e3.lookup("Uint32")], ["bucketListWindowSamplePeriod", e3.lookup("Uint32")], ["evictionScanSize", e3.lookup("Uint32")], ["startingEvictionScanLevel", e3.lookup("Uint32")]]), e3.struct("EvictionIterator", [["bucketListLevel", e3.lookup("Uint32")], ["isCurrBucket", e3.bool()], ["bucketFileOffset", e3.lookup("Uint64")]]), e3.const("CONTRACT_COST_COUNT_LIMIT", 1024), e3.typedef("ContractCostParams", e3.varArray(e3.lookup("ContractCostParamEntry"), e3.lookup("CONTRACT_COST_COUNT_LIMIT"))), e3.enum("ConfigSettingId", { configSettingContractMaxSizeBytes: 0, configSettingContractComputeV0: 1, configSettingContractLedgerCostV0: 2, configSettingContractHistoricalDataV0: 3, configSettingContractEventsV0: 4, configSettingContractBandwidthV0: 5, configSettingContractCostParamsCpuInstructions: 6, configSettingContractCostParamsMemoryBytes: 7, configSettingContractDataKeySizeBytes: 8, configSettingContractDataEntrySizeBytes: 9, configSettingStateArchival: 10, configSettingContractExecutionLanes: 11, configSettingBucketlistSizeWindow: 12, configSettingEvictionIterator: 13 }), e3.union("ConfigSettingEntry", { switchOn: e3.lookup("ConfigSettingId"), switchName: "configSettingId", switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]], arms: { contractMaxSizeBytes: e3.lookup("Uint32"), contractCompute: e3.lookup("ConfigSettingContractComputeV0"), contractLedgerCost: e3.lookup("ConfigSettingContractLedgerCostV0"), contractHistoricalData: e3.lookup("ConfigSettingContractHistoricalDataV0"), contractEvents: e3.lookup("ConfigSettingContractEventsV0"), contractBandwidth: e3.lookup("ConfigSettingContractBandwidthV0"), contractCostParamsCpuInsns: e3.lookup("ContractCostParams"), contractCostParamsMemBytes: e3.lookup("ContractCostParams"), contractDataKeySizeBytes: e3.lookup("Uint32"), contractDataEntrySizeBytes: e3.lookup("Uint32"), stateArchivalSettings: e3.lookup("StateArchivalSettings"), contractExecutionLanes: e3.lookup("ConfigSettingContractExecutionLanesV0"), bucketListSizeWindow: e3.varArray(e3.lookup("Uint64"), 2147483647), evictionIterator: e3.lookup("EvictionIterator") } });
        });
        t2.default = i;
      }, 7963: function(e2, t2, r2) {
        var n;
        !function() {
          "use strict";
          var o, i = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, a = Math.ceil, u = Math.floor, s = "[BigNumber Error] ", c = s + "Number primitive has more than 15 significant digits: ", l = 1e14, f = 14, p = 9007199254740991, d = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], h = 1e7, y = 1e9;
          function m(e3) {
            var t3 = 0 | e3;
            return e3 > 0 || e3 === t3 ? t3 : t3 - 1;
          }
          function v(e3) {
            for (var t3, r3, n2 = 1, o2 = e3.length, i2 = e3[0] + ""; n2 < o2; ) {
              for (t3 = e3[n2++] + "", r3 = f - t3.length; r3--; t3 = "0" + t3) ;
              i2 += t3;
            }
            for (o2 = i2.length; 48 === i2.charCodeAt(--o2); ) ;
            return i2.slice(0, o2 + 1 || 1);
          }
          function g(e3, t3) {
            var r3, n2, o2 = e3.c, i2 = t3.c, a2 = e3.s, u2 = t3.s, s2 = e3.e, c2 = t3.e;
            if (!a2 || !u2) return null;
            if (r3 = o2 && !o2[0], n2 = i2 && !i2[0], r3 || n2) return r3 ? n2 ? 0 : -u2 : a2;
            if (a2 != u2) return a2;
            if (r3 = a2 < 0, n2 = s2 == c2, !o2 || !i2) return n2 ? 0 : !o2 ^ r3 ? 1 : -1;
            if (!n2) return s2 > c2 ^ r3 ? 1 : -1;
            for (u2 = (s2 = o2.length) < (c2 = i2.length) ? s2 : c2, a2 = 0; a2 < u2; a2++) if (o2[a2] != i2[a2]) return o2[a2] > i2[a2] ^ r3 ? 1 : -1;
            return s2 == c2 ? 0 : s2 > c2 ^ r3 ? 1 : -1;
          }
          function b(e3, t3, r3, n2) {
            if (e3 < t3 || e3 > r3 || e3 !== u(e3)) throw Error(s + (n2 || "Argument") + ("number" == typeof e3 ? e3 < t3 || e3 > r3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e3));
          }
          function w(e3) {
            var t3 = e3.c.length - 1;
            return m(e3.e / f) == t3 && e3.c[t3] % 2 != 0;
          }
          function S(e3, t3) {
            return (e3.length > 1 ? e3.charAt(0) + "." + e3.slice(1) : e3) + (t3 < 0 ? "e" : "e+") + t3;
          }
          function k(e3, t3, r3) {
            var n2, o2;
            if (t3 < 0) {
              for (o2 = r3 + "."; ++t3; o2 += r3) ;
              e3 = o2 + e3;
            } else if (++t3 > (n2 = e3.length)) {
              for (o2 = r3, t3 -= n2; --t3; o2 += r3) ;
              e3 += o2;
            } else t3 < n2 && (e3 = e3.slice(0, t3) + "." + e3.slice(t3));
            return e3;
          }
          o = function e3(t3) {
            var r3, n2, o2, E, _, T, O, x, A, P, I = H.prototype = { constructor: H, toString: null, valueOf: null }, R = new H(1), C = 20, j = 4, B = -7, L = 21, N = -1e7, U = 1e7, M = false, F = 1, D = 0, V = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, q = "0123456789abcdefghijklmnopqrstuvwxyz", K = true;
            function H(e4, t4) {
              var r4, a2, s2, l2, d2, h2, y2, m2, v2 = this;
              if (!(v2 instanceof H)) return new H(e4, t4);
              if (null == t4) {
                if (e4 && true === e4._isBigNumber) return v2.s = e4.s, void (!e4.c || e4.e > U ? v2.c = v2.e = null : e4.e < N ? v2.c = [v2.e = 0] : (v2.e = e4.e, v2.c = e4.c.slice()));
                if ((h2 = "number" == typeof e4) && 0 * e4 == 0) {
                  if (v2.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {
                    for (l2 = 0, d2 = e4; d2 >= 10; d2 /= 10, l2++) ;
                    return void (l2 > U ? v2.c = v2.e = null : (v2.e = l2, v2.c = [e4]));
                  }
                  m2 = String(e4);
                } else {
                  if (!i.test(m2 = String(e4))) return o2(v2, m2, h2);
                  v2.s = 45 == m2.charCodeAt(0) ? (m2 = m2.slice(1), -1) : 1;
                }
                (l2 = m2.indexOf(".")) > -1 && (m2 = m2.replace(".", "")), (d2 = m2.search(/e/i)) > 0 ? (l2 < 0 && (l2 = d2), l2 += +m2.slice(d2 + 1), m2 = m2.substring(0, d2)) : l2 < 0 && (l2 = m2.length);
              } else {
                if (b(t4, 2, q.length, "Base"), 10 == t4 && K) return $(v2 = new H(e4), C + v2.e + 1, j);
                if (m2 = String(e4), h2 = "number" == typeof e4) {
                  if (0 * e4 != 0) return o2(v2, m2, h2, t4);
                  if (v2.s = 1 / e4 < 0 ? (m2 = m2.slice(1), -1) : 1, H.DEBUG && m2.replace(/^0\.0*|\./, "").length > 15) throw Error(c + e4);
                } else v2.s = 45 === m2.charCodeAt(0) ? (m2 = m2.slice(1), -1) : 1;
                for (r4 = q.slice(0, t4), l2 = d2 = 0, y2 = m2.length; d2 < y2; d2++) if (r4.indexOf(a2 = m2.charAt(d2)) < 0) {
                  if ("." == a2) {
                    if (d2 > l2) {
                      l2 = y2;
                      continue;
                    }
                  } else if (!s2 && (m2 == m2.toUpperCase() && (m2 = m2.toLowerCase()) || m2 == m2.toLowerCase() && (m2 = m2.toUpperCase()))) {
                    s2 = true, d2 = -1, l2 = 0;
                    continue;
                  }
                  return o2(v2, String(e4), h2, t4);
                }
                h2 = false, (l2 = (m2 = n2(m2, t4, 10, v2.s)).indexOf(".")) > -1 ? m2 = m2.replace(".", "") : l2 = m2.length;
              }
              for (d2 = 0; 48 === m2.charCodeAt(d2); d2++) ;
              for (y2 = m2.length; 48 === m2.charCodeAt(--y2); ) ;
              if (m2 = m2.slice(d2, ++y2)) {
                if (y2 -= d2, h2 && H.DEBUG && y2 > 15 && (e4 > p || e4 !== u(e4))) throw Error(c + v2.s * e4);
                if ((l2 = l2 - d2 - 1) > U) v2.c = v2.e = null;
                else if (l2 < N) v2.c = [v2.e = 0];
                else {
                  if (v2.e = l2, v2.c = [], d2 = (l2 + 1) % f, l2 < 0 && (d2 += f), d2 < y2) {
                    for (d2 && v2.c.push(+m2.slice(0, d2)), y2 -= f; d2 < y2; ) v2.c.push(+m2.slice(d2, d2 += f));
                    d2 = f - (m2 = m2.slice(d2)).length;
                  } else d2 -= y2;
                  for (; d2--; m2 += "0") ;
                  v2.c.push(+m2);
                }
              } else v2.c = [v2.e = 0];
            }
            function z(e4, t4, r4, n3) {
              var o3, i2, a2, u2, s2;
              if (null == r4 ? r4 = j : b(r4, 0, 8), !e4.c) return e4.toString();
              if (o3 = e4.c[0], a2 = e4.e, null == t4) s2 = v(e4.c), s2 = 1 == n3 || 2 == n3 && (a2 <= B || a2 >= L) ? S(s2, a2) : k(s2, a2, "0");
              else if (i2 = (e4 = $(new H(e4), t4, r4)).e, u2 = (s2 = v(e4.c)).length, 1 == n3 || 2 == n3 && (t4 <= i2 || i2 <= B)) {
                for (; u2 < t4; s2 += "0", u2++) ;
                s2 = S(s2, i2);
              } else if (t4 -= a2, s2 = k(s2, i2, "0"), i2 + 1 > u2) {
                if (--t4 > 0) for (s2 += "."; t4--; s2 += "0") ;
              } else if ((t4 += i2 - u2) > 0) for (i2 + 1 == u2 && (s2 += "."); t4--; s2 += "0") ;
              return e4.s < 0 && o3 ? "-" + s2 : s2;
            }
            function X(e4, t4) {
              for (var r4, n3, o3 = 1, i2 = new H(e4[0]); o3 < e4.length; o3++) (!(n3 = new H(e4[o3])).s || (r4 = g(i2, n3)) === t4 || 0 === r4 && i2.s === t4) && (i2 = n3);
              return i2;
            }
            function G(e4, t4, r4) {
              for (var n3 = 1, o3 = t4.length; !t4[--o3]; t4.pop()) ;
              for (o3 = t4[0]; o3 >= 10; o3 /= 10, n3++) ;
              return (r4 = n3 + r4 * f - 1) > U ? e4.c = e4.e = null : r4 < N ? e4.c = [e4.e = 0] : (e4.e = r4, e4.c = t4), e4;
            }
            function $(e4, t4, r4, n3) {
              var o3, i2, s2, c2, p2, h2, y2, m2 = e4.c, v2 = d;
              if (m2) {
                e: {
                  for (o3 = 1, c2 = m2[0]; c2 >= 10; c2 /= 10, o3++) ;
                  if ((i2 = t4 - o3) < 0) i2 += f, s2 = t4, p2 = m2[h2 = 0], y2 = u(p2 / v2[o3 - s2 - 1] % 10);
                  else if ((h2 = a((i2 + 1) / f)) >= m2.length) {
                    if (!n3) break e;
                    for (; m2.length <= h2; m2.push(0)) ;
                    p2 = y2 = 0, o3 = 1, s2 = (i2 %= f) - f + 1;
                  } else {
                    for (p2 = c2 = m2[h2], o3 = 1; c2 >= 10; c2 /= 10, o3++) ;
                    y2 = (s2 = (i2 %= f) - f + o3) < 0 ? 0 : u(p2 / v2[o3 - s2 - 1] % 10);
                  }
                  if (n3 = n3 || t4 < 0 || null != m2[h2 + 1] || (s2 < 0 ? p2 : p2 % v2[o3 - s2 - 1]), n3 = r4 < 4 ? (y2 || n3) && (0 == r4 || r4 == (e4.s < 0 ? 3 : 2)) : y2 > 5 || 5 == y2 && (4 == r4 || n3 || 6 == r4 && (i2 > 0 ? s2 > 0 ? p2 / v2[o3 - s2] : 0 : m2[h2 - 1]) % 10 & 1 || r4 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !m2[0]) return m2.length = 0, n3 ? (t4 -= e4.e + 1, m2[0] = v2[(f - t4 % f) % f], e4.e = -t4 || 0) : m2[0] = e4.e = 0, e4;
                  if (0 == i2 ? (m2.length = h2, c2 = 1, h2--) : (m2.length = h2 + 1, c2 = v2[f - i2], m2[h2] = s2 > 0 ? u(p2 / v2[o3 - s2] % v2[s2]) * c2 : 0), n3) for (; ; ) {
                    if (0 == h2) {
                      for (i2 = 1, s2 = m2[0]; s2 >= 10; s2 /= 10, i2++) ;
                      for (s2 = m2[0] += c2, c2 = 1; s2 >= 10; s2 /= 10, c2++) ;
                      i2 != c2 && (e4.e++, m2[0] == l && (m2[0] = 1));
                      break;
                    }
                    if (m2[h2] += c2, m2[h2] != l) break;
                    m2[h2--] = 0, c2 = 1;
                  }
                  for (i2 = m2.length; 0 === m2[--i2]; m2.pop()) ;
                }
                e4.e > U ? e4.c = e4.e = null : e4.e < N && (e4.c = [e4.e = 0]);
              }
              return e4;
            }
            function Q(e4) {
              var t4, r4 = e4.e;
              return null === r4 ? e4.toString() : (t4 = v(e4.c), t4 = r4 <= B || r4 >= L ? S(t4, r4) : k(t4, r4, "0"), e4.s < 0 ? "-" + t4 : t4);
            }
            return H.clone = e3, H.ROUND_UP = 0, H.ROUND_DOWN = 1, H.ROUND_CEIL = 2, H.ROUND_FLOOR = 3, H.ROUND_HALF_UP = 4, H.ROUND_HALF_DOWN = 5, H.ROUND_HALF_EVEN = 6, H.ROUND_HALF_CEIL = 7, H.ROUND_HALF_FLOOR = 8, H.EUCLID = 9, H.config = H.set = function(e4) {
              var t4, r4;
              if (null != e4) {
                if ("object" != typeof e4) throw Error(s + "Object expected: " + e4);
                if (e4.hasOwnProperty(t4 = "DECIMAL_PLACES") && (b(r4 = e4[t4], 0, y, t4), C = r4), e4.hasOwnProperty(t4 = "ROUNDING_MODE") && (b(r4 = e4[t4], 0, 8, t4), j = r4), e4.hasOwnProperty(t4 = "EXPONENTIAL_AT") && ((r4 = e4[t4]) && r4.pop ? (b(r4[0], -y, 0, t4), b(r4[1], 0, y, t4), B = r4[0], L = r4[1]) : (b(r4, -y, y, t4), B = -(L = r4 < 0 ? -r4 : r4))), e4.hasOwnProperty(t4 = "RANGE")) if ((r4 = e4[t4]) && r4.pop) b(r4[0], -y, -1, t4), b(r4[1], 1, y, t4), N = r4[0], U = r4[1];
                else {
                  if (b(r4, -y, y, t4), !r4) throw Error(s + t4 + " cannot be zero: " + r4);
                  N = -(U = r4 < 0 ? -r4 : r4);
                }
                if (e4.hasOwnProperty(t4 = "CRYPTO")) {
                  if ((r4 = e4[t4]) !== !!r4) throw Error(s + t4 + " not true or false: " + r4);
                  if (r4) {
                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw M = !r4, Error(s + "crypto unavailable");
                    M = r4;
                  } else M = r4;
                }
                if (e4.hasOwnProperty(t4 = "MODULO_MODE") && (b(r4 = e4[t4], 0, 9, t4), F = r4), e4.hasOwnProperty(t4 = "POW_PRECISION") && (b(r4 = e4[t4], 0, y, t4), D = r4), e4.hasOwnProperty(t4 = "FORMAT")) {
                  if ("object" != typeof (r4 = e4[t4])) throw Error(s + t4 + " not an object: " + r4);
                  V = r4;
                }
                if (e4.hasOwnProperty(t4 = "ALPHABET")) {
                  if ("string" != typeof (r4 = e4[t4]) || /^.?$|[+\-.\s]|(.).*\1/.test(r4)) throw Error(s + t4 + " invalid: " + r4);
                  K = "0123456789" == r4.slice(0, 10), q = r4;
                }
              }
              return { DECIMAL_PLACES: C, ROUNDING_MODE: j, EXPONENTIAL_AT: [B, L], RANGE: [N, U], CRYPTO: M, MODULO_MODE: F, POW_PRECISION: D, FORMAT: V, ALPHABET: q };
            }, H.isBigNumber = function(e4) {
              if (!e4 || true !== e4._isBigNumber) return false;
              if (!H.DEBUG) return true;
              var t4, r4, n3 = e4.c, o3 = e4.e, i2 = e4.s;
              e: if ("[object Array]" == {}.toString.call(n3)) {
                if ((1 === i2 || -1 === i2) && o3 >= -y && o3 <= y && o3 === u(o3)) {
                  if (0 === n3[0]) {
                    if (0 === o3 && 1 === n3.length) return true;
                    break e;
                  }
                  if ((t4 = (o3 + 1) % f) < 1 && (t4 += f), String(n3[0]).length == t4) {
                    for (t4 = 0; t4 < n3.length; t4++) if ((r4 = n3[t4]) < 0 || r4 >= l || r4 !== u(r4)) break e;
                    if (0 !== r4) return true;
                  }
                }
              } else if (null === n3 && null === o3 && (null === i2 || 1 === i2 || -1 === i2)) return true;
              throw Error(s + "Invalid BigNumber: " + e4);
            }, H.maximum = H.max = function() {
              return X(arguments, -1);
            }, H.minimum = H.min = function() {
              return X(arguments, 1);
            }, H.random = (E = 9007199254740992, _ = Math.random() * E & 2097151 ? function() {
              return u(Math.random() * E);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(e4) {
              var t4, r4, n3, o3, i2, c2 = 0, l2 = [], p2 = new H(R);
              if (null == e4 ? e4 = C : b(e4, 0, y), o3 = a(e4 / f), M) if (crypto.getRandomValues) {
                for (t4 = crypto.getRandomValues(new Uint32Array(o3 *= 2)); c2 < o3; ) (i2 = 131072 * t4[c2] + (t4[c2 + 1] >>> 11)) >= 9e15 ? (r4 = crypto.getRandomValues(new Uint32Array(2)), t4[c2] = r4[0], t4[c2 + 1] = r4[1]) : (l2.push(i2 % 1e14), c2 += 2);
                c2 = o3 / 2;
              } else {
                if (!crypto.randomBytes) throw M = false, Error(s + "crypto unavailable");
                for (t4 = crypto.randomBytes(o3 *= 7); c2 < o3; ) (i2 = 281474976710656 * (31 & t4[c2]) + 1099511627776 * t4[c2 + 1] + 4294967296 * t4[c2 + 2] + 16777216 * t4[c2 + 3] + (t4[c2 + 4] << 16) + (t4[c2 + 5] << 8) + t4[c2 + 6]) >= 9e15 ? crypto.randomBytes(7).copy(t4, c2) : (l2.push(i2 % 1e14), c2 += 7);
                c2 = o3 / 7;
              }
              if (!M) for (; c2 < o3; ) (i2 = _()) < 9e15 && (l2[c2++] = i2 % 1e14);
              for (o3 = l2[--c2], e4 %= f, o3 && e4 && (i2 = d[f - e4], l2[c2] = u(o3 / i2) * i2); 0 === l2[c2]; l2.pop(), c2--) ;
              if (c2 < 0) l2 = [n3 = 0];
              else {
                for (n3 = -1; 0 === l2[0]; l2.splice(0, 1), n3 -= f) ;
                for (c2 = 1, i2 = l2[0]; i2 >= 10; i2 /= 10, c2++) ;
                c2 < f && (n3 -= f - c2);
              }
              return p2.e = n3, p2.c = l2, p2;
            }), H.sum = function() {
              for (var e4 = 1, t4 = arguments, r4 = new H(t4[0]); e4 < t4.length; ) r4 = r4.plus(t4[e4++]);
              return r4;
            }, n2 = /* @__PURE__ */ function() {
              var e4 = "0123456789";
              function t4(e5, t5, r4, n3) {
                for (var o3, i2, a2 = [0], u2 = 0, s2 = e5.length; u2 < s2; ) {
                  for (i2 = a2.length; i2--; a2[i2] *= t5) ;
                  for (a2[0] += n3.indexOf(e5.charAt(u2++)), o3 = 0; o3 < a2.length; o3++) a2[o3] > r4 - 1 && (null == a2[o3 + 1] && (a2[o3 + 1] = 0), a2[o3 + 1] += a2[o3] / r4 | 0, a2[o3] %= r4);
                }
                return a2.reverse();
              }
              return function(n3, o3, i2, a2, u2) {
                var s2, c2, l2, f2, p2, d2, h2, y2, m2 = n3.indexOf("."), g2 = C, b2 = j;
                for (m2 >= 0 && (f2 = D, D = 0, n3 = n3.replace(".", ""), d2 = (y2 = new H(o3)).pow(n3.length - m2), D = f2, y2.c = t4(k(v(d2.c), d2.e, "0"), 10, i2, e4), y2.e = y2.c.length), l2 = f2 = (h2 = t4(n3, o3, i2, u2 ? (s2 = q, e4) : (s2 = e4, q))).length; 0 == h2[--f2]; h2.pop()) ;
                if (!h2[0]) return s2.charAt(0);
                if (m2 < 0 ? --l2 : (d2.c = h2, d2.e = l2, d2.s = a2, h2 = (d2 = r3(d2, y2, g2, b2, i2)).c, p2 = d2.r, l2 = d2.e), m2 = h2[c2 = l2 + g2 + 1], f2 = i2 / 2, p2 = p2 || c2 < 0 || null != h2[c2 + 1], p2 = b2 < 4 ? (null != m2 || p2) && (0 == b2 || b2 == (d2.s < 0 ? 3 : 2)) : m2 > f2 || m2 == f2 && (4 == b2 || p2 || 6 == b2 && 1 & h2[c2 - 1] || b2 == (d2.s < 0 ? 8 : 7)), c2 < 1 || !h2[0]) n3 = p2 ? k(s2.charAt(1), -g2, s2.charAt(0)) : s2.charAt(0);
                else {
                  if (h2.length = c2, p2) for (--i2; ++h2[--c2] > i2; ) h2[c2] = 0, c2 || (++l2, h2 = [1].concat(h2));
                  for (f2 = h2.length; !h2[--f2]; ) ;
                  for (m2 = 0, n3 = ""; m2 <= f2; n3 += s2.charAt(h2[m2++])) ;
                  n3 = k(n3, l2, s2.charAt(0));
                }
                return n3;
              };
            }(), r3 = /* @__PURE__ */ function() {
              function e4(e5, t5, r5) {
                var n3, o3, i2, a2, u2 = 0, s2 = e5.length, c2 = t5 % h, l2 = t5 / h | 0;
                for (e5 = e5.slice(); s2--; ) u2 = ((o3 = c2 * (i2 = e5[s2] % h) + (n3 = l2 * i2 + (a2 = e5[s2] / h | 0) * c2) % h * h + u2) / r5 | 0) + (n3 / h | 0) + l2 * a2, e5[s2] = o3 % r5;
                return u2 && (e5 = [u2].concat(e5)), e5;
              }
              function t4(e5, t5, r5, n3) {
                var o3, i2;
                if (r5 != n3) i2 = r5 > n3 ? 1 : -1;
                else for (o3 = i2 = 0; o3 < r5; o3++) if (e5[o3] != t5[o3]) {
                  i2 = e5[o3] > t5[o3] ? 1 : -1;
                  break;
                }
                return i2;
              }
              function r4(e5, t5, r5, n3) {
                for (var o3 = 0; r5--; ) e5[r5] -= o3, o3 = e5[r5] < t5[r5] ? 1 : 0, e5[r5] = o3 * n3 + e5[r5] - t5[r5];
                for (; !e5[0] && e5.length > 1; e5.splice(0, 1)) ;
              }
              return function(n3, o3, i2, a2, s2) {
                var c2, p2, d2, h2, y2, v2, g2, b2, w2, S2, k2, E2, _2, T2, O2, x2, A2, P2 = n3.s == o3.s ? 1 : -1, I2 = n3.c, R2 = o3.c;
                if (!(I2 && I2[0] && R2 && R2[0])) return new H(n3.s && o3.s && (I2 ? !R2 || I2[0] != R2[0] : R2) ? I2 && 0 == I2[0] || !R2 ? 0 * P2 : P2 / 0 : NaN);
                for (w2 = (b2 = new H(P2)).c = [], P2 = i2 + (p2 = n3.e - o3.e) + 1, s2 || (s2 = l, p2 = m(n3.e / f) - m(o3.e / f), P2 = P2 / f | 0), d2 = 0; R2[d2] == (I2[d2] || 0); d2++) ;
                if (R2[d2] > (I2[d2] || 0) && p2--, P2 < 0) w2.push(1), h2 = true;
                else {
                  for (T2 = I2.length, x2 = R2.length, d2 = 0, P2 += 2, (y2 = u(s2 / (R2[0] + 1))) > 1 && (R2 = e4(R2, y2, s2), I2 = e4(I2, y2, s2), x2 = R2.length, T2 = I2.length), _2 = x2, k2 = (S2 = I2.slice(0, x2)).length; k2 < x2; S2[k2++] = 0) ;
                  A2 = R2.slice(), A2 = [0].concat(A2), O2 = R2[0], R2[1] >= s2 / 2 && O2++;
                  do {
                    if (y2 = 0, (c2 = t4(R2, S2, x2, k2)) < 0) {
                      if (E2 = S2[0], x2 != k2 && (E2 = E2 * s2 + (S2[1] || 0)), (y2 = u(E2 / O2)) > 1) for (y2 >= s2 && (y2 = s2 - 1), g2 = (v2 = e4(R2, y2, s2)).length, k2 = S2.length; 1 == t4(v2, S2, g2, k2); ) y2--, r4(v2, x2 < g2 ? A2 : R2, g2, s2), g2 = v2.length, c2 = 1;
                      else 0 == y2 && (c2 = y2 = 1), g2 = (v2 = R2.slice()).length;
                      if (g2 < k2 && (v2 = [0].concat(v2)), r4(S2, v2, k2, s2), k2 = S2.length, -1 == c2) for (; t4(R2, S2, x2, k2) < 1; ) y2++, r4(S2, x2 < k2 ? A2 : R2, k2, s2), k2 = S2.length;
                    } else 0 === c2 && (y2++, S2 = [0]);
                    w2[d2++] = y2, S2[0] ? S2[k2++] = I2[_2] || 0 : (S2 = [I2[_2]], k2 = 1);
                  } while ((_2++ < T2 || null != S2[0]) && P2--);
                  h2 = null != S2[0], w2[0] || w2.splice(0, 1);
                }
                if (s2 == l) {
                  for (d2 = 1, P2 = w2[0]; P2 >= 10; P2 /= 10, d2++) ;
                  $(b2, i2 + (b2.e = d2 + p2 * f - 1) + 1, a2, h2);
                } else b2.e = p2, b2.r = +h2;
                return b2;
              };
            }(), T = /^(-?)0([xbo])(?=\w[\w.]*$)/i, O = /^([^.]+)\.$/, x = /^\.([^.]+)$/, A = /^-?(Infinity|NaN)$/, P = /^\s*\+(?=[\w.])|^\s+|\s+$/g, o2 = function(e4, t4, r4, n3) {
              var o3, i2 = r4 ? t4 : t4.replace(P, "");
              if (A.test(i2)) e4.s = isNaN(i2) ? null : i2 < 0 ? -1 : 1;
              else {
                if (!r4 && (i2 = i2.replace(T, function(e5, t5, r5) {
                  return o3 = "x" == (r5 = r5.toLowerCase()) ? 16 : "b" == r5 ? 2 : 8, n3 && n3 != o3 ? e5 : t5;
                }), n3 && (o3 = n3, i2 = i2.replace(O, "$1").replace(x, "0.$1")), t4 != i2)) return new H(i2, o3);
                if (H.DEBUG) throw Error(s + "Not a" + (n3 ? " base " + n3 : "") + " number: " + t4);
                e4.s = null;
              }
              e4.c = e4.e = null;
            }, I.absoluteValue = I.abs = function() {
              var e4 = new H(this);
              return e4.s < 0 && (e4.s = 1), e4;
            }, I.comparedTo = function(e4, t4) {
              return g(this, new H(e4, t4));
            }, I.decimalPlaces = I.dp = function(e4, t4) {
              var r4, n3, o3, i2 = this;
              if (null != e4) return b(e4, 0, y), null == t4 ? t4 = j : b(t4, 0, 8), $(new H(i2), e4 + i2.e + 1, t4);
              if (!(r4 = i2.c)) return null;
              if (n3 = ((o3 = r4.length - 1) - m(this.e / f)) * f, o3 = r4[o3]) for (; o3 % 10 == 0; o3 /= 10, n3--) ;
              return n3 < 0 && (n3 = 0), n3;
            }, I.dividedBy = I.div = function(e4, t4) {
              return r3(this, new H(e4, t4), C, j);
            }, I.dividedToIntegerBy = I.idiv = function(e4, t4) {
              return r3(this, new H(e4, t4), 0, 1);
            }, I.exponentiatedBy = I.pow = function(e4, t4) {
              var r4, n3, o3, i2, c2, l2, p2, d2, h2 = this;
              if ((e4 = new H(e4)).c && !e4.isInteger()) throw Error(s + "Exponent not an integer: " + Q(e4));
              if (null != t4 && (t4 = new H(t4)), c2 = e4.e > 14, !h2.c || !h2.c[0] || 1 == h2.c[0] && !h2.e && 1 == h2.c.length || !e4.c || !e4.c[0]) return d2 = new H(Math.pow(+Q(h2), c2 ? e4.s * (2 - w(e4)) : +Q(e4))), t4 ? d2.mod(t4) : d2;
              if (l2 = e4.s < 0, t4) {
                if (t4.c ? !t4.c[0] : !t4.s) return new H(NaN);
                (n3 = !l2 && h2.isInteger() && t4.isInteger()) && (h2 = h2.mod(t4));
              } else {
                if (e4.e > 9 && (h2.e > 0 || h2.e < -1 || (0 == h2.e ? h2.c[0] > 1 || c2 && h2.c[1] >= 24e7 : h2.c[0] < 8e13 || c2 && h2.c[0] <= 9999975e7))) return i2 = h2.s < 0 && w(e4) ? -0 : 0, h2.e > -1 && (i2 = 1 / i2), new H(l2 ? 1 / i2 : i2);
                D && (i2 = a(D / f + 2));
              }
              for (c2 ? (r4 = new H(0.5), l2 && (e4.s = 1), p2 = w(e4)) : p2 = (o3 = Math.abs(+Q(e4))) % 2, d2 = new H(R); ; ) {
                if (p2) {
                  if (!(d2 = d2.times(h2)).c) break;
                  i2 ? d2.c.length > i2 && (d2.c.length = i2) : n3 && (d2 = d2.mod(t4));
                }
                if (o3) {
                  if (0 === (o3 = u(o3 / 2))) break;
                  p2 = o3 % 2;
                } else if ($(e4 = e4.times(r4), e4.e + 1, 1), e4.e > 14) p2 = w(e4);
                else {
                  if (0 === (o3 = +Q(e4))) break;
                  p2 = o3 % 2;
                }
                h2 = h2.times(h2), i2 ? h2.c && h2.c.length > i2 && (h2.c.length = i2) : n3 && (h2 = h2.mod(t4));
              }
              return n3 ? d2 : (l2 && (d2 = R.div(d2)), t4 ? d2.mod(t4) : i2 ? $(d2, D, j, void 0) : d2);
            }, I.integerValue = function(e4) {
              var t4 = new H(this);
              return null == e4 ? e4 = j : b(e4, 0, 8), $(t4, t4.e + 1, e4);
            }, I.isEqualTo = I.eq = function(e4, t4) {
              return 0 === g(this, new H(e4, t4));
            }, I.isFinite = function() {
              return !!this.c;
            }, I.isGreaterThan = I.gt = function(e4, t4) {
              return g(this, new H(e4, t4)) > 0;
            }, I.isGreaterThanOrEqualTo = I.gte = function(e4, t4) {
              return 1 === (t4 = g(this, new H(e4, t4))) || 0 === t4;
            }, I.isInteger = function() {
              return !!this.c && m(this.e / f) > this.c.length - 2;
            }, I.isLessThan = I.lt = function(e4, t4) {
              return g(this, new H(e4, t4)) < 0;
            }, I.isLessThanOrEqualTo = I.lte = function(e4, t4) {
              return -1 === (t4 = g(this, new H(e4, t4))) || 0 === t4;
            }, I.isNaN = function() {
              return !this.s;
            }, I.isNegative = function() {
              return this.s < 0;
            }, I.isPositive = function() {
              return this.s > 0;
            }, I.isZero = function() {
              return !!this.c && 0 == this.c[0];
            }, I.minus = function(e4, t4) {
              var r4, n3, o3, i2, a2 = this, u2 = a2.s;
              if (t4 = (e4 = new H(e4, t4)).s, !u2 || !t4) return new H(NaN);
              if (u2 != t4) return e4.s = -t4, a2.plus(e4);
              var s2 = a2.e / f, c2 = e4.e / f, p2 = a2.c, d2 = e4.c;
              if (!s2 || !c2) {
                if (!p2 || !d2) return p2 ? (e4.s = -t4, e4) : new H(d2 ? a2 : NaN);
                if (!p2[0] || !d2[0]) return d2[0] ? (e4.s = -t4, e4) : new H(p2[0] ? a2 : 3 == j ? -0 : 0);
              }
              if (s2 = m(s2), c2 = m(c2), p2 = p2.slice(), u2 = s2 - c2) {
                for ((i2 = u2 < 0) ? (u2 = -u2, o3 = p2) : (c2 = s2, o3 = d2), o3.reverse(), t4 = u2; t4--; o3.push(0)) ;
                o3.reverse();
              } else for (n3 = (i2 = (u2 = p2.length) < (t4 = d2.length)) ? u2 : t4, u2 = t4 = 0; t4 < n3; t4++) if (p2[t4] != d2[t4]) {
                i2 = p2[t4] < d2[t4];
                break;
              }
              if (i2 && (o3 = p2, p2 = d2, d2 = o3, e4.s = -e4.s), (t4 = (n3 = d2.length) - (r4 = p2.length)) > 0) for (; t4--; p2[r4++] = 0) ;
              for (t4 = l - 1; n3 > u2; ) {
                if (p2[--n3] < d2[n3]) {
                  for (r4 = n3; r4 && !p2[--r4]; p2[r4] = t4) ;
                  --p2[r4], p2[n3] += l;
                }
                p2[n3] -= d2[n3];
              }
              for (; 0 == p2[0]; p2.splice(0, 1), --c2) ;
              return p2[0] ? G(e4, p2, c2) : (e4.s = 3 == j ? -1 : 1, e4.c = [e4.e = 0], e4);
            }, I.modulo = I.mod = function(e4, t4) {
              var n3, o3, i2 = this;
              return e4 = new H(e4, t4), !i2.c || !e4.s || e4.c && !e4.c[0] ? new H(NaN) : !e4.c || i2.c && !i2.c[0] ? new H(i2) : (9 == F ? (o3 = e4.s, e4.s = 1, n3 = r3(i2, e4, 0, 3), e4.s = o3, n3.s *= o3) : n3 = r3(i2, e4, 0, F), (e4 = i2.minus(n3.times(e4))).c[0] || 1 != F || (e4.s = i2.s), e4);
            }, I.multipliedBy = I.times = function(e4, t4) {
              var r4, n3, o3, i2, a2, u2, s2, c2, p2, d2, y2, v2, g2, b2, w2, S2 = this, k2 = S2.c, E2 = (e4 = new H(e4, t4)).c;
              if (!(k2 && E2 && k2[0] && E2[0])) return !S2.s || !e4.s || k2 && !k2[0] && !E2 || E2 && !E2[0] && !k2 ? e4.c = e4.e = e4.s = null : (e4.s *= S2.s, k2 && E2 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = null), e4;
              for (n3 = m(S2.e / f) + m(e4.e / f), e4.s *= S2.s, (s2 = k2.length) < (d2 = E2.length) && (g2 = k2, k2 = E2, E2 = g2, o3 = s2, s2 = d2, d2 = o3), o3 = s2 + d2, g2 = []; o3--; g2.push(0)) ;
              for (b2 = l, w2 = h, o3 = d2; --o3 >= 0; ) {
                for (r4 = 0, y2 = E2[o3] % w2, v2 = E2[o3] / w2 | 0, i2 = o3 + (a2 = s2); i2 > o3; ) r4 = ((c2 = y2 * (c2 = k2[--a2] % w2) + (u2 = v2 * c2 + (p2 = k2[a2] / w2 | 0) * y2) % w2 * w2 + g2[i2] + r4) / b2 | 0) + (u2 / w2 | 0) + v2 * p2, g2[i2--] = c2 % b2;
                g2[i2] = r4;
              }
              return r4 ? ++n3 : g2.splice(0, 1), G(e4, g2, n3);
            }, I.negated = function() {
              var e4 = new H(this);
              return e4.s = -e4.s || null, e4;
            }, I.plus = function(e4, t4) {
              var r4, n3 = this, o3 = n3.s;
              if (t4 = (e4 = new H(e4, t4)).s, !o3 || !t4) return new H(NaN);
              if (o3 != t4) return e4.s = -t4, n3.minus(e4);
              var i2 = n3.e / f, a2 = e4.e / f, u2 = n3.c, s2 = e4.c;
              if (!i2 || !a2) {
                if (!u2 || !s2) return new H(o3 / 0);
                if (!u2[0] || !s2[0]) return s2[0] ? e4 : new H(u2[0] ? n3 : 0 * o3);
              }
              if (i2 = m(i2), a2 = m(a2), u2 = u2.slice(), o3 = i2 - a2) {
                for (o3 > 0 ? (a2 = i2, r4 = s2) : (o3 = -o3, r4 = u2), r4.reverse(); o3--; r4.push(0)) ;
                r4.reverse();
              }
              for ((o3 = u2.length) - (t4 = s2.length) < 0 && (r4 = s2, s2 = u2, u2 = r4, t4 = o3), o3 = 0; t4; ) o3 = (u2[--t4] = u2[t4] + s2[t4] + o3) / l | 0, u2[t4] = l === u2[t4] ? 0 : u2[t4] % l;
              return o3 && (u2 = [o3].concat(u2), ++a2), G(e4, u2, a2);
            }, I.precision = I.sd = function(e4, t4) {
              var r4, n3, o3, i2 = this;
              if (null != e4 && e4 !== !!e4) return b(e4, 1, y), null == t4 ? t4 = j : b(t4, 0, 8), $(new H(i2), e4, t4);
              if (!(r4 = i2.c)) return null;
              if (n3 = (o3 = r4.length - 1) * f + 1, o3 = r4[o3]) {
                for (; o3 % 10 == 0; o3 /= 10, n3--) ;
                for (o3 = r4[0]; o3 >= 10; o3 /= 10, n3++) ;
              }
              return e4 && i2.e + 1 > n3 && (n3 = i2.e + 1), n3;
            }, I.shiftedBy = function(e4) {
              return b(e4, -9007199254740991, p), this.times("1e" + e4);
            }, I.squareRoot = I.sqrt = function() {
              var e4, t4, n3, o3, i2, a2 = this, u2 = a2.c, s2 = a2.s, c2 = a2.e, l2 = C + 4, f2 = new H("0.5");
              if (1 !== s2 || !u2 || !u2[0]) return new H(!s2 || s2 < 0 && (!u2 || u2[0]) ? NaN : u2 ? a2 : 1 / 0);
              if (0 == (s2 = Math.sqrt(+Q(a2))) || s2 == 1 / 0 ? (((t4 = v(u2)).length + c2) % 2 == 0 && (t4 += "0"), s2 = Math.sqrt(+t4), c2 = m((c2 + 1) / 2) - (c2 < 0 || c2 % 2), n3 = new H(t4 = s2 == 1 / 0 ? "5e" + c2 : (t4 = s2.toExponential()).slice(0, t4.indexOf("e") + 1) + c2)) : n3 = new H(s2 + ""), n3.c[0]) {
                for ((s2 = (c2 = n3.e) + l2) < 3 && (s2 = 0); ; ) if (i2 = n3, n3 = f2.times(i2.plus(r3(a2, i2, l2, 1))), v(i2.c).slice(0, s2) === (t4 = v(n3.c)).slice(0, s2)) {
                  if (n3.e < c2 && --s2, "9999" != (t4 = t4.slice(s2 - 3, s2 + 1)) && (o3 || "4999" != t4)) {
                    +t4 && (+t4.slice(1) || "5" != t4.charAt(0)) || ($(n3, n3.e + C + 2, 1), e4 = !n3.times(n3).eq(a2));
                    break;
                  }
                  if (!o3 && ($(i2, i2.e + C + 2, 0), i2.times(i2).eq(a2))) {
                    n3 = i2;
                    break;
                  }
                  l2 += 4, s2 += 4, o3 = 1;
                }
              }
              return $(n3, n3.e + C + 1, j, e4);
            }, I.toExponential = function(e4, t4) {
              return null != e4 && (b(e4, 0, y), e4++), z(this, e4, t4, 1);
            }, I.toFixed = function(e4, t4) {
              return null != e4 && (b(e4, 0, y), e4 = e4 + this.e + 1), z(this, e4, t4);
            }, I.toFormat = function(e4, t4, r4) {
              var n3, o3 = this;
              if (null == r4) null != e4 && t4 && "object" == typeof t4 ? (r4 = t4, t4 = null) : e4 && "object" == typeof e4 ? (r4 = e4, e4 = t4 = null) : r4 = V;
              else if ("object" != typeof r4) throw Error(s + "Argument not an object: " + r4);
              if (n3 = o3.toFixed(e4, t4), o3.c) {
                var i2, a2 = n3.split("."), u2 = +r4.groupSize, c2 = +r4.secondaryGroupSize, l2 = r4.groupSeparator || "", f2 = a2[0], p2 = a2[1], d2 = o3.s < 0, h2 = d2 ? f2.slice(1) : f2, y2 = h2.length;
                if (c2 && (i2 = u2, u2 = c2, c2 = i2, y2 -= i2), u2 > 0 && y2 > 0) {
                  for (i2 = y2 % u2 || u2, f2 = h2.substr(0, i2); i2 < y2; i2 += u2) f2 += l2 + h2.substr(i2, u2);
                  c2 > 0 && (f2 += l2 + h2.slice(i2)), d2 && (f2 = "-" + f2);
                }
                n3 = p2 ? f2 + (r4.decimalSeparator || "") + ((c2 = +r4.fractionGroupSize) ? p2.replace(new RegExp("\\d{" + c2 + "}\\B", "g"), "$&" + (r4.fractionGroupSeparator || "")) : p2) : f2;
              }
              return (r4.prefix || "") + n3 + (r4.suffix || "");
            }, I.toFraction = function(e4) {
              var t4, n3, o3, i2, a2, u2, c2, l2, p2, h2, y2, m2, g2 = this, b2 = g2.c;
              if (null != e4 && (!(c2 = new H(e4)).isInteger() && (c2.c || 1 !== c2.s) || c2.lt(R))) throw Error(s + "Argument " + (c2.isInteger() ? "out of range: " : "not an integer: ") + Q(c2));
              if (!b2) return new H(g2);
              for (t4 = new H(R), p2 = n3 = new H(R), o3 = l2 = new H(R), m2 = v(b2), a2 = t4.e = m2.length - g2.e - 1, t4.c[0] = d[(u2 = a2 % f) < 0 ? f + u2 : u2], e4 = !e4 || c2.comparedTo(t4) > 0 ? a2 > 0 ? t4 : p2 : c2, u2 = U, U = 1 / 0, c2 = new H(m2), l2.c[0] = 0; h2 = r3(c2, t4, 0, 1), 1 != (i2 = n3.plus(h2.times(o3))).comparedTo(e4); ) n3 = o3, o3 = i2, p2 = l2.plus(h2.times(i2 = p2)), l2 = i2, t4 = c2.minus(h2.times(i2 = t4)), c2 = i2;
              return i2 = r3(e4.minus(n3), o3, 0, 1), l2 = l2.plus(i2.times(p2)), n3 = n3.plus(i2.times(o3)), l2.s = p2.s = g2.s, y2 = r3(p2, o3, a2 *= 2, j).minus(g2).abs().comparedTo(r3(l2, n3, a2, j).minus(g2).abs()) < 1 ? [p2, o3] : [l2, n3], U = u2, y2;
            }, I.toNumber = function() {
              return +Q(this);
            }, I.toPrecision = function(e4, t4) {
              return null != e4 && b(e4, 1, y), z(this, e4, t4, 2);
            }, I.toString = function(e4) {
              var t4, r4 = this, o3 = r4.s, i2 = r4.e;
              return null === i2 ? o3 ? (t4 = "Infinity", o3 < 0 && (t4 = "-" + t4)) : t4 = "NaN" : (null == e4 ? t4 = i2 <= B || i2 >= L ? S(v(r4.c), i2) : k(v(r4.c), i2, "0") : 10 === e4 && K ? t4 = k(v((r4 = $(new H(r4), C + i2 + 1, j)).c), r4.e, "0") : (b(e4, 2, q.length, "Base"), t4 = n2(k(v(r4.c), i2, "0"), 10, e4, o3, true)), o3 < 0 && r4.c[0] && (t4 = "-" + t4)), t4;
            }, I.valueOf = I.toJSON = function() {
              return Q(this);
            }, I._isBigNumber = true, null != t3 && H.set(t3), H;
          }(), o.default = o.BigNumber = o, void 0 === (n = (function() {
            return o;
          }).call(t2, r2, t2, e2)) || (e2.exports = n);
        }();
      }, 8242: (e2, t2, r2) => {
        "use strict";
        r2.r(t2), r2.d(t2, { Api: () => {
        } });
      }, 8287: (e2, t2, r2) => {
        "use strict";
        const n = r2(7526), o = r2(251), i = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        t2.Buffer = s, t2.SlowBuffer = function(e3) {
          +e3 != e3 && (e3 = 0);
          return s.alloc(+e3);
        }, t2.INSPECT_MAX_BYTES = 50;
        const a = 2147483647;
        function u(e3) {
          if (e3 > a) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
          const t3 = new Uint8Array(e3);
          return Object.setPrototypeOf(t3, s.prototype), t3;
        }
        function s(e3, t3, r3) {
          if ("number" == typeof e3) {
            if ("string" == typeof t3) throw new TypeError('The "string" argument must be of type string. Received type number');
            return f(e3);
          }
          return c(e3, t3, r3);
        }
        function c(e3, t3, r3) {
          if ("string" == typeof e3) return function(e4, t4) {
            "string" == typeof t4 && "" !== t4 || (t4 = "utf8");
            if (!s.isEncoding(t4)) throw new TypeError("Unknown encoding: " + t4);
            const r4 = 0 | y(e4, t4);
            let n3 = u(r4);
            const o3 = n3.write(e4, t4);
            o3 !== r4 && (n3 = n3.slice(0, o3));
            return n3;
          }(e3, t3);
          if (ArrayBuffer.isView(e3)) return function(e4) {
            if (Q(e4, Uint8Array)) {
              const t4 = new Uint8Array(e4);
              return d(t4.buffer, t4.byteOffset, t4.byteLength);
            }
            return p(e4);
          }(e3);
          if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
          if (Q(e3, ArrayBuffer) || e3 && Q(e3.buffer, ArrayBuffer)) return d(e3, t3, r3);
          if ("undefined" != typeof SharedArrayBuffer && (Q(e3, SharedArrayBuffer) || e3 && Q(e3.buffer, SharedArrayBuffer))) return d(e3, t3, r3);
          if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
          const n2 = e3.valueOf && e3.valueOf();
          if (null != n2 && n2 !== e3) return s.from(n2, t3, r3);
          const o2 = function(e4) {
            if (s.isBuffer(e4)) {
              const t4 = 0 | h(e4.length), r4 = u(t4);
              return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
            }
            if (void 0 !== e4.length) return "number" != typeof e4.length || W(e4.length) ? u(0) : p(e4);
            if ("Buffer" === e4.type && Array.isArray(e4.data)) return p(e4.data);
          }(e3);
          if (o2) return o2;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return s.from(e3[Symbol.toPrimitive]("string"), t3, r3);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
        }
        function l(e3) {
          if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
          if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
        }
        function f(e3) {
          return l(e3), u(e3 < 0 ? 0 : 0 | h(e3));
        }
        function p(e3) {
          const t3 = e3.length < 0 ? 0 : 0 | h(e3.length), r3 = u(t3);
          for (let n2 = 0; n2 < t3; n2 += 1) r3[n2] = 255 & e3[n2];
          return r3;
        }
        function d(e3, t3, r3) {
          if (t3 < 0 || e3.byteLength < t3) throw new RangeError('"offset" is outside of buffer bounds');
          if (e3.byteLength < t3 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let n2;
          return n2 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n2, s.prototype), n2;
        }
        function h(e3) {
          if (e3 >= a) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
          return 0 | e3;
        }
        function y(e3, t3) {
          if (s.isBuffer(e3)) return e3.length;
          if (ArrayBuffer.isView(e3) || Q(e3, ArrayBuffer)) return e3.byteLength;
          if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
          const r3 = e3.length, n2 = arguments.length > 2 && true === arguments[2];
          if (!n2 && 0 === r3) return 0;
          let o2 = false;
          for (; ; ) switch (t3) {
            case "ascii":
            case "latin1":
            case "binary":
              return r3;
            case "utf8":
            case "utf-8":
              return X(e3).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r3;
            case "hex":
              return r3 >>> 1;
            case "base64":
              return G(e3).length;
            default:
              if (o2) return n2 ? -1 : X(e3).length;
              t3 = ("" + t3).toLowerCase(), o2 = true;
          }
        }
        function m(e3, t3, r3) {
          let n2 = false;
          if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
          if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
          if ((r3 >>>= 0) <= (t3 >>>= 0)) return "";
          for (e3 || (e3 = "utf8"); ; ) switch (e3) {
            case "hex":
              return I(this, t3, r3);
            case "utf8":
            case "utf-8":
              return O(this, t3, r3);
            case "ascii":
              return A(this, t3, r3);
            case "latin1":
            case "binary":
              return P(this, t3, r3);
            case "base64":
              return T(this, t3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return R(this, t3, r3);
            default:
              if (n2) throw new TypeError("Unknown encoding: " + e3);
              e3 = (e3 + "").toLowerCase(), n2 = true;
          }
        }
        function v(e3, t3, r3) {
          const n2 = e3[t3];
          e3[t3] = e3[r3], e3[r3] = n2;
        }
        function g(e3, t3, r3, n2, o2) {
          if (0 === e3.length) return -1;
          if ("string" == typeof r3 ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), W(r3 = +r3) && (r3 = o2 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
            if (o2) return -1;
            r3 = e3.length - 1;
          } else if (r3 < 0) {
            if (!o2) return -1;
            r3 = 0;
          }
          if ("string" == typeof t3 && (t3 = s.from(t3, n2)), s.isBuffer(t3)) return 0 === t3.length ? -1 : b(e3, t3, r3, n2, o2);
          if ("number" == typeof t3) return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o2 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : b(e3, [t3], r3, n2, o2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function b(e3, t3, r3, n2, o2) {
          let i2, a2 = 1, u2 = e3.length, s2 = t3.length;
          if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
            if (e3.length < 2 || t3.length < 2) return -1;
            a2 = 2, u2 /= 2, s2 /= 2, r3 /= 2;
          }
          function c2(e4, t4) {
            return 1 === a2 ? e4[t4] : e4.readUInt16BE(t4 * a2);
          }
          if (o2) {
            let n3 = -1;
            for (i2 = r3; i2 < u2; i2++) if (c2(e3, i2) === c2(t3, -1 === n3 ? 0 : i2 - n3)) {
              if (-1 === n3 && (n3 = i2), i2 - n3 + 1 === s2) return n3 * a2;
            } else -1 !== n3 && (i2 -= i2 - n3), n3 = -1;
          } else for (r3 + s2 > u2 && (r3 = u2 - s2), i2 = r3; i2 >= 0; i2--) {
            let r4 = true;
            for (let n3 = 0; n3 < s2; n3++) if (c2(e3, i2 + n3) !== c2(t3, n3)) {
              r4 = false;
              break;
            }
            if (r4) return i2;
          }
          return -1;
        }
        function w(e3, t3, r3, n2) {
          r3 = Number(r3) || 0;
          const o2 = e3.length - r3;
          n2 ? (n2 = Number(n2)) > o2 && (n2 = o2) : n2 = o2;
          const i2 = t3.length;
          let a2;
          for (n2 > i2 / 2 && (n2 = i2 / 2), a2 = 0; a2 < n2; ++a2) {
            const n3 = parseInt(t3.substr(2 * a2, 2), 16);
            if (W(n3)) return a2;
            e3[r3 + a2] = n3;
          }
          return a2;
        }
        function S(e3, t3, r3, n2) {
          return $(X(t3, e3.length - r3), e3, r3, n2);
        }
        function k(e3, t3, r3, n2) {
          return $(function(e4) {
            const t4 = [];
            for (let r4 = 0; r4 < e4.length; ++r4) t4.push(255 & e4.charCodeAt(r4));
            return t4;
          }(t3), e3, r3, n2);
        }
        function E(e3, t3, r3, n2) {
          return $(G(t3), e3, r3, n2);
        }
        function _(e3, t3, r3, n2) {
          return $(function(e4, t4) {
            let r4, n3, o2;
            const i2 = [];
            for (let a2 = 0; a2 < e4.length && !((t4 -= 2) < 0); ++a2) r4 = e4.charCodeAt(a2), n3 = r4 >> 8, o2 = r4 % 256, i2.push(o2), i2.push(n3);
            return i2;
          }(t3, e3.length - r3), e3, r3, n2);
        }
        function T(e3, t3, r3) {
          return 0 === t3 && r3 === e3.length ? n.fromByteArray(e3) : n.fromByteArray(e3.slice(t3, r3));
        }
        function O(e3, t3, r3) {
          r3 = Math.min(e3.length, r3);
          const n2 = [];
          let o2 = t3;
          for (; o2 < r3; ) {
            const t4 = e3[o2];
            let i2 = null, a2 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
            if (o2 + a2 <= r3) {
              let r4, n3, u2, s2;
              switch (a2) {
                case 1:
                  t4 < 128 && (i2 = t4);
                  break;
                case 2:
                  r4 = e3[o2 + 1], 128 == (192 & r4) && (s2 = (31 & t4) << 6 | 63 & r4, s2 > 127 && (i2 = s2));
                  break;
                case 3:
                  r4 = e3[o2 + 1], n3 = e3[o2 + 2], 128 == (192 & r4) && 128 == (192 & n3) && (s2 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n3, s2 > 2047 && (s2 < 55296 || s2 > 57343) && (i2 = s2));
                  break;
                case 4:
                  r4 = e3[o2 + 1], n3 = e3[o2 + 2], u2 = e3[o2 + 3], 128 == (192 & r4) && 128 == (192 & n3) && 128 == (192 & u2) && (s2 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n3) << 6 | 63 & u2, s2 > 65535 && s2 < 1114112 && (i2 = s2));
              }
            }
            null === i2 ? (i2 = 65533, a2 = 1) : i2 > 65535 && (i2 -= 65536, n2.push(i2 >>> 10 & 1023 | 55296), i2 = 56320 | 1023 & i2), n2.push(i2), o2 += a2;
          }
          return function(e4) {
            const t4 = e4.length;
            if (t4 <= x) return String.fromCharCode.apply(String, e4);
            let r4 = "", n3 = 0;
            for (; n3 < t4; ) r4 += String.fromCharCode.apply(String, e4.slice(n3, n3 += x));
            return r4;
          }(n2);
        }
        t2.kMaxLength = a, s.TYPED_ARRAY_SUPPORT = function() {
          try {
            const e3 = new Uint8Array(1), t3 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
          } catch (e3) {
            return false;
          }
        }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
          if (s.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
          if (s.isBuffer(this)) return this.byteOffset;
        } }), s.poolSize = 8192, s.from = function(e3, t3, r3) {
          return c(e3, t3, r3);
        }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array), s.alloc = function(e3, t3, r3) {
          return function(e4, t4, r4) {
            return l(e4), e4 <= 0 ? u(e4) : void 0 !== t4 ? "string" == typeof r4 ? u(e4).fill(t4, r4) : u(e4).fill(t4) : u(e4);
          }(e3, t3, r3);
        }, s.allocUnsafe = function(e3) {
          return f(e3);
        }, s.allocUnsafeSlow = function(e3) {
          return f(e3);
        }, s.isBuffer = function(e3) {
          return null != e3 && true === e3._isBuffer && e3 !== s.prototype;
        }, s.compare = function(e3, t3) {
          if (Q(e3, Uint8Array) && (e3 = s.from(e3, e3.offset, e3.byteLength)), Q(t3, Uint8Array) && (t3 = s.from(t3, t3.offset, t3.byteLength)), !s.isBuffer(e3) || !s.isBuffer(t3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e3 === t3) return 0;
          let r3 = e3.length, n2 = t3.length;
          for (let o2 = 0, i2 = Math.min(r3, n2); o2 < i2; ++o2) if (e3[o2] !== t3[o2]) {
            r3 = e3[o2], n2 = t3[o2];
            break;
          }
          return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
        }, s.isEncoding = function(e3) {
          switch (String(e3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, s.concat = function(e3, t3) {
          if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e3.length) return s.alloc(0);
          let r3;
          if (void 0 === t3) for (t3 = 0, r3 = 0; r3 < e3.length; ++r3) t3 += e3[r3].length;
          const n2 = s.allocUnsafe(t3);
          let o2 = 0;
          for (r3 = 0; r3 < e3.length; ++r3) {
            let t4 = e3[r3];
            if (Q(t4, Uint8Array)) o2 + t4.length > n2.length ? (s.isBuffer(t4) || (t4 = s.from(t4)), t4.copy(n2, o2)) : Uint8Array.prototype.set.call(n2, t4, o2);
            else {
              if (!s.isBuffer(t4)) throw new TypeError('"list" argument must be an Array of Buffers');
              t4.copy(n2, o2);
            }
            o2 += t4.length;
          }
          return n2;
        }, s.byteLength = y, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
          const e3 = this.length;
          if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let t3 = 0; t3 < e3; t3 += 2) v(this, t3, t3 + 1);
          return this;
        }, s.prototype.swap32 = function() {
          const e3 = this.length;
          if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let t3 = 0; t3 < e3; t3 += 4) v(this, t3, t3 + 3), v(this, t3 + 1, t3 + 2);
          return this;
        }, s.prototype.swap64 = function() {
          const e3 = this.length;
          if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let t3 = 0; t3 < e3; t3 += 8) v(this, t3, t3 + 7), v(this, t3 + 1, t3 + 6), v(this, t3 + 2, t3 + 5), v(this, t3 + 3, t3 + 4);
          return this;
        }, s.prototype.toString = function() {
          const e3 = this.length;
          return 0 === e3 ? "" : 0 === arguments.length ? O(this, 0, e3) : m.apply(this, arguments);
        }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e3) {
          if (!s.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
          return this === e3 || 0 === s.compare(this, e3);
        }, s.prototype.inspect = function() {
          let e3 = "";
          const r3 = t2.INSPECT_MAX_BYTES;
          return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
        }, i && (s.prototype[i] = s.prototype.inspect), s.prototype.compare = function(e3, t3, r3, n2, o2) {
          if (Q(e3, Uint8Array) && (e3 = s.from(e3, e3.offset, e3.byteLength)), !s.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
          if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n2 && (n2 = 0), void 0 === o2 && (o2 = this.length), t3 < 0 || r3 > e3.length || n2 < 0 || o2 > this.length) throw new RangeError("out of range index");
          if (n2 >= o2 && t3 >= r3) return 0;
          if (n2 >= o2) return -1;
          if (t3 >= r3) return 1;
          if (this === e3) return 0;
          let i2 = (o2 >>>= 0) - (n2 >>>= 0), a2 = (r3 >>>= 0) - (t3 >>>= 0);
          const u2 = Math.min(i2, a2), c2 = this.slice(n2, o2), l2 = e3.slice(t3, r3);
          for (let e4 = 0; e4 < u2; ++e4) if (c2[e4] !== l2[e4]) {
            i2 = c2[e4], a2 = l2[e4];
            break;
          }
          return i2 < a2 ? -1 : a2 < i2 ? 1 : 0;
        }, s.prototype.includes = function(e3, t3, r3) {
          return -1 !== this.indexOf(e3, t3, r3);
        }, s.prototype.indexOf = function(e3, t3, r3) {
          return g(this, e3, t3, r3, true);
        }, s.prototype.lastIndexOf = function(e3, t3, r3) {
          return g(this, e3, t3, r3, false);
        }, s.prototype.write = function(e3, t3, r3, n2) {
          if (void 0 === t3) n2 = "utf8", r3 = this.length, t3 = 0;
          else if (void 0 === r3 && "string" == typeof t3) n2 = t3, r3 = this.length, t3 = 0;
          else {
            if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r3, r3 = void 0);
          }
          const o2 = this.length - t3;
          if ((void 0 === r3 || r3 > o2) && (r3 = o2), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          n2 || (n2 = "utf8");
          let i2 = false;
          for (; ; ) switch (n2) {
            case "hex":
              return w(this, e3, t3, r3);
            case "utf8":
            case "utf-8":
              return S(this, e3, t3, r3);
            case "ascii":
            case "latin1":
            case "binary":
              return k(this, e3, t3, r3);
            case "base64":
              return E(this, e3, t3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return _(this, e3, t3, r3);
            default:
              if (i2) throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), i2 = true;
          }
        }, s.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const x = 4096;
        function A(e3, t3, r3) {
          let n2 = "";
          r3 = Math.min(e3.length, r3);
          for (let o2 = t3; o2 < r3; ++o2) n2 += String.fromCharCode(127 & e3[o2]);
          return n2;
        }
        function P(e3, t3, r3) {
          let n2 = "";
          r3 = Math.min(e3.length, r3);
          for (let o2 = t3; o2 < r3; ++o2) n2 += String.fromCharCode(e3[o2]);
          return n2;
        }
        function I(e3, t3, r3) {
          const n2 = e3.length;
          (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
          let o2 = "";
          for (let n3 = t3; n3 < r3; ++n3) o2 += Y[e3[n3]];
          return o2;
        }
        function R(e3, t3, r3) {
          const n2 = e3.slice(t3, r3);
          let o2 = "";
          for (let e4 = 0; e4 < n2.length - 1; e4 += 2) o2 += String.fromCharCode(n2[e4] + 256 * n2[e4 + 1]);
          return o2;
        }
        function C(e3, t3, r3) {
          if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
          if (e3 + t3 > r3) throw new RangeError("Trying to access beyond buffer length");
        }
        function j(e3, t3, r3, n2, o2, i2) {
          if (!s.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t3 > o2 || t3 < i2) throw new RangeError('"value" argument is out of bounds');
          if (r3 + n2 > e3.length) throw new RangeError("Index out of range");
        }
        function B(e3, t3, r3, n2, o2) {
          q(t3, n2, o2, e3, r3, 7);
          let i2 = Number(t3 & BigInt(4294967295));
          e3[r3++] = i2, i2 >>= 8, e3[r3++] = i2, i2 >>= 8, e3[r3++] = i2, i2 >>= 8, e3[r3++] = i2;
          let a2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
          return e3[r3++] = a2, a2 >>= 8, e3[r3++] = a2, a2 >>= 8, e3[r3++] = a2, a2 >>= 8, e3[r3++] = a2, r3;
        }
        function L(e3, t3, r3, n2, o2) {
          q(t3, n2, o2, e3, r3, 7);
          let i2 = Number(t3 & BigInt(4294967295));
          e3[r3 + 7] = i2, i2 >>= 8, e3[r3 + 6] = i2, i2 >>= 8, e3[r3 + 5] = i2, i2 >>= 8, e3[r3 + 4] = i2;
          let a2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
          return e3[r3 + 3] = a2, a2 >>= 8, e3[r3 + 2] = a2, a2 >>= 8, e3[r3 + 1] = a2, a2 >>= 8, e3[r3] = a2, r3 + 8;
        }
        function N(e3, t3, r3, n2, o2, i2) {
          if (r3 + n2 > e3.length) throw new RangeError("Index out of range");
          if (r3 < 0) throw new RangeError("Index out of range");
        }
        function U(e3, t3, r3, n2, i2) {
          return t3 = +t3, r3 >>>= 0, i2 || N(e3, 0, r3, 4), o.write(e3, t3, r3, n2, 23, 4), r3 + 4;
        }
        function M(e3, t3, r3, n2, i2) {
          return t3 = +t3, r3 >>>= 0, i2 || N(e3, 0, r3, 8), o.write(e3, t3, r3, n2, 52, 8), r3 + 8;
        }
        s.prototype.slice = function(e3, t3) {
          const r3 = this.length;
          (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
          const n2 = this.subarray(e3, t3);
          return Object.setPrototypeOf(n2, s.prototype), n2;
        }, s.prototype.readUintLE = s.prototype.readUIntLE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || C(e3, t3, this.length);
          let n2 = this[e3], o2 = 1, i2 = 0;
          for (; ++i2 < t3 && (o2 *= 256); ) n2 += this[e3 + i2] * o2;
          return n2;
        }, s.prototype.readUintBE = s.prototype.readUIntBE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || C(e3, t3, this.length);
          let n2 = this[e3 + --t3], o2 = 1;
          for (; t3 > 0 && (o2 *= 256); ) n2 += this[e3 + --t3] * o2;
          return n2;
        }, s.prototype.readUint8 = s.prototype.readUInt8 = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 1, this.length), this[e3];
        }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
        }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
        }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
        }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
        }, s.prototype.readBigUInt64LE = J(function(e3) {
          K(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n2 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, o2 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
          return BigInt(n2) + (BigInt(o2) << BigInt(32));
        }), s.prototype.readBigUInt64BE = J(function(e3) {
          K(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n2 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], o2 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
          return (BigInt(n2) << BigInt(32)) + BigInt(o2);
        }), s.prototype.readIntLE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || C(e3, t3, this.length);
          let n2 = this[e3], o2 = 1, i2 = 0;
          for (; ++i2 < t3 && (o2 *= 256); ) n2 += this[e3 + i2] * o2;
          return o2 *= 128, n2 >= o2 && (n2 -= Math.pow(2, 8 * t3)), n2;
        }, s.prototype.readIntBE = function(e3, t3, r3) {
          e3 >>>= 0, t3 >>>= 0, r3 || C(e3, t3, this.length);
          let n2 = t3, o2 = 1, i2 = this[e3 + --n2];
          for (; n2 > 0 && (o2 *= 256); ) i2 += this[e3 + --n2] * o2;
          return o2 *= 128, i2 >= o2 && (i2 -= Math.pow(2, 8 * t3)), i2;
        }, s.prototype.readInt8 = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
        }, s.prototype.readInt16LE = function(e3, t3) {
          e3 >>>= 0, t3 || C(e3, 2, this.length);
          const r3 = this[e3] | this[e3 + 1] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, s.prototype.readInt16BE = function(e3, t3) {
          e3 >>>= 0, t3 || C(e3, 2, this.length);
          const r3 = this[e3 + 1] | this[e3] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, s.prototype.readInt32LE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
        }, s.prototype.readInt32BE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
        }, s.prototype.readBigInt64LE = J(function(e3) {
          K(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n2 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
          return (BigInt(n2) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
        }), s.prototype.readBigInt64BE = J(function(e3) {
          K(e3 >>>= 0, "offset");
          const t3 = this[e3], r3 = this[e3 + 7];
          void 0 !== t3 && void 0 !== r3 || H(e3, this.length - 8);
          const n2 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
          return (BigInt(n2) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
        }), s.prototype.readFloatLE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 4, this.length), o.read(this, e3, true, 23, 4);
        }, s.prototype.readFloatBE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 4, this.length), o.read(this, e3, false, 23, 4);
        }, s.prototype.readDoubleLE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 8, this.length), o.read(this, e3, true, 52, 8);
        }, s.prototype.readDoubleBE = function(e3, t3) {
          return e3 >>>= 0, t3 || C(e3, 8, this.length), o.read(this, e3, false, 52, 8);
        }, s.prototype.writeUintLE = s.prototype.writeUIntLE = function(e3, t3, r3, n2) {
          if (e3 = +e3, t3 >>>= 0, r3 >>>= 0, !n2) {
            j(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
          }
          let o2 = 1, i2 = 0;
          for (this[t3] = 255 & e3; ++i2 < r3 && (o2 *= 256); ) this[t3 + i2] = e3 / o2 & 255;
          return t3 + r3;
        }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(e3, t3, r3, n2) {
          if (e3 = +e3, t3 >>>= 0, r3 >>>= 0, !n2) {
            j(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
          }
          let o2 = r3 - 1, i2 = 1;
          for (this[t3 + o2] = 255 & e3; --o2 >= 0 && (i2 *= 256); ) this[t3 + o2] = e3 / i2 & 255;
          return t3 + r3;
        }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
        }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
        }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
        }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
        }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
        }, s.prototype.writeBigUInt64LE = J(function(e3, t3 = 0) {
          return B(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), s.prototype.writeBigUInt64BE = J(function(e3, t3 = 0) {
          return L(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), s.prototype.writeIntLE = function(e3, t3, r3, n2) {
          if (e3 = +e3, t3 >>>= 0, !n2) {
            const n3 = Math.pow(2, 8 * r3 - 1);
            j(this, e3, t3, r3, n3 - 1, -n3);
          }
          let o2 = 0, i2 = 1, a2 = 0;
          for (this[t3] = 255 & e3; ++o2 < r3 && (i2 *= 256); ) e3 < 0 && 0 === a2 && 0 !== this[t3 + o2 - 1] && (a2 = 1), this[t3 + o2] = (e3 / i2 | 0) - a2 & 255;
          return t3 + r3;
        }, s.prototype.writeIntBE = function(e3, t3, r3, n2) {
          if (e3 = +e3, t3 >>>= 0, !n2) {
            const n3 = Math.pow(2, 8 * r3 - 1);
            j(this, e3, t3, r3, n3 - 1, -n3);
          }
          let o2 = r3 - 1, i2 = 1, a2 = 0;
          for (this[t3 + o2] = 255 & e3; --o2 >= 0 && (i2 *= 256); ) e3 < 0 && 0 === a2 && 0 !== this[t3 + o2 + 1] && (a2 = 1), this[t3 + o2] = (e3 / i2 | 0) - a2 & 255;
          return t3 + r3;
        }, s.prototype.writeInt8 = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
        }, s.prototype.writeInt16LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
        }, s.prototype.writeInt16BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
        }, s.prototype.writeInt32LE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
        }, s.prototype.writeInt32BE = function(e3, t3, r3) {
          return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
        }, s.prototype.writeBigInt64LE = J(function(e3, t3 = 0) {
          return B(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), s.prototype.writeBigInt64BE = J(function(e3, t3 = 0) {
          return L(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), s.prototype.writeFloatLE = function(e3, t3, r3) {
          return U(this, e3, t3, true, r3);
        }, s.prototype.writeFloatBE = function(e3, t3, r3) {
          return U(this, e3, t3, false, r3);
        }, s.prototype.writeDoubleLE = function(e3, t3, r3) {
          return M(this, e3, t3, true, r3);
        }, s.prototype.writeDoubleBE = function(e3, t3, r3) {
          return M(this, e3, t3, false, r3);
        }, s.prototype.copy = function(e3, t3, r3, n2) {
          if (!s.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
          if (r3 || (r3 = 0), n2 || 0 === n2 || (n2 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3) return 0;
          if (0 === e3.length || 0 === this.length) return 0;
          if (t3 < 0) throw new RangeError("targetStart out of bounds");
          if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
          if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
          n2 > this.length && (n2 = this.length), e3.length - t3 < n2 - r3 && (n2 = e3.length - t3 + r3);
          const o2 = n2 - r3;
          return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, r3, n2) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n2), t3), o2;
        }, s.prototype.fill = function(e3, t3, r3, n2) {
          if ("string" == typeof e3) {
            if ("string" == typeof t3 ? (n2 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n2 = r3, r3 = this.length), void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
            if ("string" == typeof n2 && !s.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
            if (1 === e3.length) {
              const t4 = e3.charCodeAt(0);
              ("utf8" === n2 && t4 < 128 || "latin1" === n2) && (e3 = t4);
            }
          } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
          if (t3 < 0 || this.length < t3 || this.length < r3) throw new RangeError("Out of range index");
          if (r3 <= t3) return this;
          let o2;
          if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (o2 = t3; o2 < r3; ++o2) this[o2] = e3;
          else {
            const i2 = s.isBuffer(e3) ? e3 : s.from(e3, n2), a2 = i2.length;
            if (0 === a2) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
            for (o2 = 0; o2 < r3 - t3; ++o2) this[o2 + t3] = i2[o2 % a2];
          }
          return this;
        };
        const F = {};
        function D(e3, t3, r3) {
          F[e3] = class extends r3 {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
            }
            get code() {
              return e3;
            }
            set code(e4) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
            }
            toString() {
              return `${this.name} [${e3}]: ${this.message}`;
            }
          };
        }
        function V(e3) {
          let t3 = "", r3 = e3.length;
          const n2 = "-" === e3[0] ? 1 : 0;
          for (; r3 >= n2 + 4; r3 -= 3) t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
          return `${e3.slice(0, r3)}${t3}`;
        }
        function q(e3, t3, r3, n2, o2, i2) {
          if (e3 > r3 || e3 < t3) {
            const n3 = "bigint" == typeof t3 ? "n" : "";
            let o3;
            throw o3 = i2 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (i2 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (i2 + 1) - 1}${n3}) and < 2 ** ${8 * (i2 + 1) - 1}${n3}` : `>= ${t3}${n3} and <= ${r3}${n3}`, new F.ERR_OUT_OF_RANGE("value", o3, e3);
          }
          !function(e4, t4, r4) {
            K(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + r4] || H(t4, e4.length - (r4 + 1));
          }(n2, o2, i2);
        }
        function K(e3, t3) {
          if ("number" != typeof e3) throw new F.ERR_INVALID_ARG_TYPE(t3, "number", e3);
        }
        function H(e3, t3, r3) {
          if (Math.floor(e3) !== e3) throw K(e3, r3), new F.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
          if (t3 < 0) throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new F.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
        }
        D("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
          return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), D("ERR_INVALID_ARG_TYPE", function(e3, t3) {
          return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
        }, TypeError), D("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
          let n2 = `The value of "${e3}" is out of range.`, o2 = r3;
          return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? o2 = V(String(r3)) : "bigint" == typeof r3 && (o2 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (o2 = V(o2)), o2 += "n"), n2 += ` It must be ${t3}. Received ${o2}`, n2;
        }, RangeError);
        const z = /[^+/0-9A-Za-z-_]/g;
        function X(e3, t3) {
          let r3;
          t3 = t3 || 1 / 0;
          const n2 = e3.length;
          let o2 = null;
          const i2 = [];
          for (let a2 = 0; a2 < n2; ++a2) {
            if (r3 = e3.charCodeAt(a2), r3 > 55295 && r3 < 57344) {
              if (!o2) {
                if (r3 > 56319) {
                  (t3 -= 3) > -1 && i2.push(239, 191, 189);
                  continue;
                }
                if (a2 + 1 === n2) {
                  (t3 -= 3) > -1 && i2.push(239, 191, 189);
                  continue;
                }
                o2 = r3;
                continue;
              }
              if (r3 < 56320) {
                (t3 -= 3) > -1 && i2.push(239, 191, 189), o2 = r3;
                continue;
              }
              r3 = 65536 + (o2 - 55296 << 10 | r3 - 56320);
            } else o2 && (t3 -= 3) > -1 && i2.push(239, 191, 189);
            if (o2 = null, r3 < 128) {
              if ((t3 -= 1) < 0) break;
              i2.push(r3);
            } else if (r3 < 2048) {
              if ((t3 -= 2) < 0) break;
              i2.push(r3 >> 6 | 192, 63 & r3 | 128);
            } else if (r3 < 65536) {
              if ((t3 -= 3) < 0) break;
              i2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            } else {
              if (!(r3 < 1114112)) throw new Error("Invalid code point");
              if ((t3 -= 4) < 0) break;
              i2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            }
          }
          return i2;
        }
        function G(e3) {
          return n.toByteArray(function(e4) {
            if ((e4 = (e4 = e4.split("=")[0]).trim().replace(z, "")).length < 2) return "";
            for (; e4.length % 4 != 0; ) e4 += "=";
            return e4;
          }(e3));
        }
        function $(e3, t3, r3, n2) {
          let o2;
          for (o2 = 0; o2 < n2 && !(o2 + r3 >= t3.length || o2 >= e3.length); ++o2) t3[o2 + r3] = e3[o2];
          return o2;
        }
        function Q(e3, t3) {
          return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
        }
        function W(e3) {
          return e3 != e3;
        }
        const Y = function() {
          const e3 = "0123456789abcdef", t3 = new Array(256);
          for (let r3 = 0; r3 < 16; ++r3) {
            const n2 = 16 * r3;
            for (let o2 = 0; o2 < 16; ++o2) t3[n2 + o2] = e3[r3] + e3[o2];
          }
          return t3;
        }();
        function J(e3) {
          return "undefined" == typeof BigInt ? Z : e3;
        }
        function Z() {
          throw new Error("BigInt not supported");
        }
      }, 8549: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Int128", { enumerable: true, get: function() {
          return a.Int128;
        } }), Object.defineProperty(t2, "Int256", { enumerable: true, get: function() {
          return u.Int256;
        } }), Object.defineProperty(t2, "ScInt", { enumerable: true, get: function() {
          return s.ScInt;
        } }), Object.defineProperty(t2, "Uint128", { enumerable: true, get: function() {
          return o.Uint128;
        } }), Object.defineProperty(t2, "Uint256", { enumerable: true, get: function() {
          return i.Uint256;
        } }), Object.defineProperty(t2, "XdrLargeInt", { enumerable: true, get: function() {
          return n.XdrLargeInt;
        } }), t2.scValToBigInt = function(e3) {
          var t3 = n.XdrLargeInt.getType(e3.switch().name);
          switch (e3.switch().name) {
            case "scvU32":
            case "scvI32":
              return BigInt(e3.value());
            case "scvU64":
            case "scvI64":
              return new n.XdrLargeInt(t3, e3.value()).toBigInt();
            case "scvU128":
            case "scvI128":
              return new n.XdrLargeInt(t3, [e3.value().lo(), e3.value().hi()]).toBigInt();
            case "scvU256":
            case "scvI256":
              return new n.XdrLargeInt(t3, [e3.value().loLo(), e3.value().loHi(), e3.value().hiLo(), e3.value().hiHi()]).toBigInt();
            default:
              throw TypeError("expected integer type, got ".concat(e3.switch()));
          }
        };
        var n = r2(7429), o = r2(6272), i = r2(8672), a = r2(5487), u = r2(4063), s = r2(3317);
      }, 8672: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Uint256 = void 0;
        var o = r2(3740);
        function i(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, a(n2.key), n2);
          }
        }
        function a(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        function u(e3, t3, r3) {
          return t3 = c(t3), function(e4, t4) {
            if (t4 && ("object" == n(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, s() ? Reflect.construct(t3, r3 || [], c(e3).constructor) : t3.apply(e3, r3));
        }
        function s() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (s = function() {
            return !!e3;
          })();
        }
        function c(e3) {
          return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, c(e3);
        }
        function l(e3, t3) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, l(e3, t3);
        }
        (t2.Uint256 = function(e3) {
          function t3() {
            !function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3);
            for (var e4 = arguments.length, r4 = new Array(e4), n3 = 0; n3 < e4; n3++) r4[n3] = arguments[n3];
            return u(this, t3, [r4]);
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && l(e4, t4);
          }(t3, e3), r3 = t3, (n2 = [{ key: "unsigned", get: function() {
            return true;
          } }, { key: "size", get: function() {
            return 256;
          } }]) && i(r3.prototype, n2), o2 && i(r3, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
          var r3, n2, o2;
        }(o.LargeInt)).defineIntBoundaries();
      }, 8680: (e2, t2, r2) => {
        "use strict";
        r2.d(t2, { X: () => a });
        var n = r2(356), o = r2(4076), i = r2(784);
        function a(e3, t3) {
          if ("innerTransaction" in e3) return a(e3.innerTransaction, t3);
          if (!function(e4) {
            if (1 !== e4.operations.length) return false;
            switch (e4.operations[0].type) {
              case "invokeHostFunction":
              case "extendFootprintTtl":
              case "restoreFootprint":
                return true;
              default:
                return false;
            }
          }(e3)) throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
          var r3 = (0, i.jr)(t3);
          if (!o.j.isSimulationSuccess(r3)) throw new Error("simulation incorrect: ".concat(JSON.stringify(r3)));
          var u = parseInt(e3.fee) || 0, s = parseInt(r3.minResourceFee) || 0, c = n.TransactionBuilder.cloneFrom(e3, { fee: (u + s).toString(), sorobanData: r3.transactionData.build(), networkPassphrase: e3.networkPassphrase });
          if ("invokeHostFunction" === e3.operations[0].type) {
            var l;
            c.clearOperations();
            var f = e3.operations[0], p = null !== (l = f.auth) && void 0 !== l ? l : [];
            c.addOperation(n.Operation.invokeHostFunction({ source: f.source, func: f.func, auth: p.length > 0 ? p : r3.result.auth }));
          }
          return c;
        }
      }, 8732: (e2, t2, r2) => {
        "use strict";
        function n(e3) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, n(e3);
        }
        function o(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, s(n2.key), n2);
          }
        }
        function i(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function a(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? i(Object(r3), true).forEach(function(t4) {
              u(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : i(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function u(e3, t3, r3) {
          return (t3 = s(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function s(e3) {
          var t3 = function(e4, t4) {
            if ("object" != n(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var o2 = r3.call(e4, t4 || "default");
              if ("object" != n(o2)) return o2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == n(t3) ? t3 : t3 + "";
        }
        r2.d(t2, { T: () => h });
        var c, l, f, p = { allowHttp: false, timeout: 0 }, d = a({}, p), h = (c = function e3() {
          !function(e4, t3) {
            if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
          }(this, e3);
        }, f = [{ key: "setAllowHttp", value: function(e3) {
          d.allowHttp = e3;
        } }, { key: "setTimeout", value: function(e3) {
          d.timeout = e3;
        } }, { key: "isAllowHttp", value: function() {
          return d.allowHttp;
        } }, { key: "getTimeout", value: function() {
          return d.timeout;
        } }, { key: "setDefault", value: function() {
          d = a({}, p);
        } }], (l = null) && o(c.prototype, l), f && o(c, f), Object.defineProperty(c, "prototype", { writable: false }), c);
      }, 8733: (e2, t2, r2) => {
        "use strict";
        var n;
        r2.r(t2), r2.d(t2, { AccountResponse: () => m, AxiosClient: () => $, HorizonApi: () => n, SERVER_TIME_MAP: () => z, Server: () => Xr, ServerApi: () => i, default: () => Gr, getCurrentServerTime: () => Q }), function(e3) {
          var t3 = function(e4) {
            return e4.constantProduct = "constant_product", e4;
          }({});
          e3.LiquidityPoolType = t3;
          var r3 = function(e4) {
            return e4.createAccount = "create_account", e4.payment = "payment", e4.pathPayment = "path_payment_strict_receive", e4.createPassiveOffer = "create_passive_sell_offer", e4.manageOffer = "manage_sell_offer", e4.setOptions = "set_options", e4.changeTrust = "change_trust", e4.allowTrust = "allow_trust", e4.accountMerge = "account_merge", e4.inflation = "inflation", e4.manageData = "manage_data", e4.bumpSequence = "bump_sequence", e4.manageBuyOffer = "manage_buy_offer", e4.pathPaymentStrictSend = "path_payment_strict_send", e4.createClaimableBalance = "create_claimable_balance", e4.claimClaimableBalance = "claim_claimable_balance", e4.beginSponsoringFutureReserves = "begin_sponsoring_future_reserves", e4.endSponsoringFutureReserves = "end_sponsoring_future_reserves", e4.revokeSponsorship = "revoke_sponsorship", e4.clawback = "clawback", e4.clawbackClaimableBalance = "clawback_claimable_balance", e4.setTrustLineFlags = "set_trust_line_flags", e4.liquidityPoolDeposit = "liquidity_pool_deposit", e4.liquidityPoolWithdraw = "liquidity_pool_withdraw", e4.invokeHostFunction = "invoke_host_function", e4.bumpFootprintExpiration = "bump_footprint_expiration", e4.restoreFootprint = "restore_footprint", e4;
          }({});
          e3.OperationResponseType = r3;
          var n2 = function(e4) {
            return e4[e4.createAccount = 0] = "createAccount", e4[e4.payment = 1] = "payment", e4[e4.pathPayment = 2] = "pathPayment", e4[e4.createPassiveOffer = 3] = "createPassiveOffer", e4[e4.manageOffer = 4] = "manageOffer", e4[e4.setOptions = 5] = "setOptions", e4[e4.changeTrust = 6] = "changeTrust", e4[e4.allowTrust = 7] = "allowTrust", e4[e4.accountMerge = 8] = "accountMerge", e4[e4.inflation = 9] = "inflation", e4[e4.manageData = 10] = "manageData", e4[e4.bumpSequence = 11] = "bumpSequence", e4[e4.manageBuyOffer = 12] = "manageBuyOffer", e4[e4.pathPaymentStrictSend = 13] = "pathPaymentStrictSend", e4[e4.createClaimableBalance = 14] = "createClaimableBalance", e4[e4.claimClaimableBalance = 15] = "claimClaimableBalance", e4[e4.beginSponsoringFutureReserves = 16] = "beginSponsoringFutureReserves", e4[e4.endSponsoringFutureReserves = 17] = "endSponsoringFutureReserves", e4[e4.revokeSponsorship = 18] = "revokeSponsorship", e4[e4.clawback = 19] = "clawback", e4[e4.clawbackClaimableBalance = 20] = "clawbackClaimableBalance", e4[e4.setTrustLineFlags = 21] = "setTrustLineFlags", e4[e4.liquidityPoolDeposit = 22] = "liquidityPoolDeposit", e4[e4.liquidityPoolWithdraw = 23] = "liquidityPoolWithdraw", e4[e4.invokeHostFunction = 24] = "invokeHostFunction", e4[e4.bumpFootprintExpiration = 25] = "bumpFootprintExpiration", e4[e4.restoreFootprint = 26] = "restoreFootprint", e4;
          }({});
          e3.OperationResponseTypeI = n2;
          var o2 = function(e4) {
            return e4.TX_FAILED = "tx_failed", e4.TX_BAD_SEQ = "tx_bad_seq", e4.TX_BAD_AUTH = "tx_bad_auth", e4.TX_BAD_AUTH_EXTRA = "tx_bad_auth_extra", e4.TX_FEE_BUMP_INNER_SUCCESS = "tx_fee_bump_inner_success", e4.TX_FEE_BUMP_INNER_FAILED = "tx_fee_bump_inner_failed", e4.TX_NOT_SUPPORTED = "tx_not_supported", e4.TX_SUCCESS = "tx_success", e4.TX_TOO_EARLY = "tx_too_early", e4.TX_TOO_LATE = "tx_too_late", e4.TX_MISSING_OPERATION = "tx_missing_operation", e4.TX_INSUFFICIENT_BALANCE = "tx_insufficient_balance", e4.TX_NO_SOURCE_ACCOUNT = "tx_no_source_account", e4.TX_INSUFFICIENT_FEE = "tx_insufficient_fee", e4.TX_INTERNAL_ERROR = "tx_internal_error", e4;
          }({});
          e3.TransactionFailedResultCodes = o2;
        }(n || (n = {}));
        var o, i, a = ((o = {})[o.account_created = 0] = "account_created", o[o.account_removed = 1] = "account_removed", o[o.account_credited = 2] = "account_credited", o[o.account_debited = 3] = "account_debited", o[o.account_thresholds_updated = 4] = "account_thresholds_updated", o[o.account_home_domain_updated = 5] = "account_home_domain_updated", o[o.account_flags_updated = 6] = "account_flags_updated", o[o.account_inflation_destination_updated = 7] = "account_inflation_destination_updated", o[o.signer_created = 10] = "signer_created", o[o.signer_removed = 11] = "signer_removed", o[o.signer_updated = 12] = "signer_updated", o[o.trustline_created = 20] = "trustline_created", o[o.trustline_removed = 21] = "trustline_removed", o[o.trustline_updated = 22] = "trustline_updated", o[o.trustline_authorized = 23] = "trustline_authorized", o[o.trustline_deauthorized = 24] = "trustline_deauthorized", o[o.trustline_authorized_to_maintain_liabilities = 25] = "trustline_authorized_to_maintain_liabilities", o[o.trustline_flags_updated = 26] = "trustline_flags_updated", o[o.offer_created = 30] = "offer_created", o[o.offer_removed = 31] = "offer_removed", o[o.offer_updated = 32] = "offer_updated", o[o.trade = 33] = "trade", o[o.data_created = 40] = "data_created", o[o.data_removed = 41] = "data_removed", o[o.data_updated = 42] = "data_updated", o[o.sequence_bumped = 43] = "sequence_bumped", o[o.claimable_balance_created = 50] = "claimable_balance_created", o[o.claimable_balance_claimant_created = 51] = "claimable_balance_claimant_created", o[o.claimable_balance_claimed = 52] = "claimable_balance_claimed", o[o.account_sponsorship_created = 60] = "account_sponsorship_created", o[o.account_sponsorship_updated = 61] = "account_sponsorship_updated", o[o.account_sponsorship_removed = 62] = "account_sponsorship_removed", o[o.trustline_sponsorship_created = 63] = "trustline_sponsorship_created", o[o.trustline_sponsorship_updated = 64] = "trustline_sponsorship_updated", o[o.trustline_sponsorship_removed = 65] = "trustline_sponsorship_removed", o[o.data_sponsorship_created = 66] = "data_sponsorship_created", o[o.data_sponsorship_updated = 67] = "data_sponsorship_updated", o[o.data_sponsorship_removed = 68] = "data_sponsorship_removed", o[o.claimable_balance_sponsorship_created = 69] = "claimable_balance_sponsorship_created", o[o.claimable_balance_sponsorship_updated = 70] = "claimable_balance_sponsorship_updated", o[o.claimable_balance_sponsorship_removed = 71] = "claimable_balance_sponsorship_removed", o[o.signer_sponsorship_created = 72] = "signer_sponsorship_created", o[o.signer_sponsorship_updated = 73] = "signer_sponsorship_updated", o[o.signer_sponsorship_removed = 74] = "signer_sponsorship_removed", o[o.claimable_balance_clawed_back = 80] = "claimable_balance_clawed_back", o[o.liquidity_pool_deposited = 90] = "liquidity_pool_deposited", o[o.liquidity_pool_withdrew = 91] = "liquidity_pool_withdrew", o[o.liquidity_pool_trade = 92] = "liquidity_pool_trade", o[o.liquidity_pool_created = 93] = "liquidity_pool_created", o[o.liquidity_pool_removed = 94] = "liquidity_pool_removed", o[o.liquidity_pool_revoked = 95] = "liquidity_pool_revoked", o[o.contract_credited = 96] = "contract_credited", o[o.contract_debited = 97] = "contract_debited", o);
        !function(e3) {
          e3.EffectType = a;
          var t3 = function(e4) {
            return e4.all = "all", e4.liquidityPools = "liquidity_pool", e4.orderbook = "orderbook", e4;
          }({});
          e3.TradeType = t3;
          n.OperationResponseType, n.OperationResponseTypeI;
        }(i || (i = {}));
        var u = r2(356);
        function s(e3) {
          return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, s(e3);
        }
        function c(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4)) return e4;
          }(e3) || function(e4, t4) {
            var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (null != r3) {
              var n2, o2, i2, a2, u2 = [], s2 = true, c2 = false;
              try {
                if (i2 = (r3 = r3.call(e4)).next, 0 === t4) {
                  if (Object(r3) !== r3) return;
                  s2 = false;
                } else for (; !(s2 = (n2 = i2.call(r3)).done) && (u2.push(n2.value), u2.length !== t4); s2 = true) ;
              } catch (e5) {
                c2 = true, o2 = e5;
              } finally {
                try {
                  if (!s2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2)) return;
                } finally {
                  if (c2) throw o2;
                }
              }
              return u2;
            }
          }(e3, t3) || function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return l(e4, t4);
              var r3 = {}.toString.call(e4).slice(8, -1);
              return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? l(e4, t4) : void 0;
            }
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function l(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n2 = Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
          return n2;
        }
        function f(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, p(n2.key), n2);
          }
        }
        function p(e3) {
          var t3 = function(e4, t4) {
            if ("object" != s(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != s(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == s(t3) ? t3 : t3 + "";
        }
        var d, h, y, m = (d = function e3(t3) {
          var r3 = this;
          !function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), this._baseAccount = new u.Account(t3.account_id, t3.sequence), Object.entries(t3).forEach(function(e4) {
            var t4 = c(e4, 2), n2 = t4[0], o2 = t4[1];
            r3[n2] = o2;
          });
        }, (h = [{ key: "accountId", value: function() {
          return this._baseAccount.accountId();
        } }, { key: "sequenceNumber", value: function() {
          return this._baseAccount.sequenceNumber();
        } }, { key: "incrementSequenceNumber", value: function() {
          this._baseAccount.incrementSequenceNumber(), this.sequence = this._baseAccount.sequenceNumber();
        } }]) && f(d.prototype, h), y && f(d, y), Object.defineProperty(d, "prototype", { writable: false }), d), v = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, g = Math.ceil, b = Math.floor, w = "[BigNumber Error] ", S = w + "Number primitive has more than 15 significant digits: ", k = 1e14, E = 14, _ = 9007199254740991, T = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], O = 1e7, x = 1e9;
        function A(e3) {
          var t3 = 0 | e3;
          return e3 > 0 || e3 === t3 ? t3 : t3 - 1;
        }
        function P(e3) {
          for (var t3, r3, n2 = 1, o2 = e3.length, i2 = e3[0] + ""; n2 < o2; ) {
            for (t3 = e3[n2++] + "", r3 = E - t3.length; r3--; t3 = "0" + t3) ;
            i2 += t3;
          }
          for (o2 = i2.length; 48 === i2.charCodeAt(--o2); ) ;
          return i2.slice(0, o2 + 1 || 1);
        }
        function I(e3, t3) {
          var r3, n2, o2 = e3.c, i2 = t3.c, a2 = e3.s, u2 = t3.s, s2 = e3.e, c2 = t3.e;
          if (!a2 || !u2) return null;
          if (r3 = o2 && !o2[0], n2 = i2 && !i2[0], r3 || n2) return r3 ? n2 ? 0 : -u2 : a2;
          if (a2 != u2) return a2;
          if (r3 = a2 < 0, n2 = s2 == c2, !o2 || !i2) return n2 ? 0 : !o2 ^ r3 ? 1 : -1;
          if (!n2) return s2 > c2 ^ r3 ? 1 : -1;
          for (u2 = (s2 = o2.length) < (c2 = i2.length) ? s2 : c2, a2 = 0; a2 < u2; a2++) if (o2[a2] != i2[a2]) return o2[a2] > i2[a2] ^ r3 ? 1 : -1;
          return s2 == c2 ? 0 : s2 > c2 ^ r3 ? 1 : -1;
        }
        function R(e3, t3, r3, n2) {
          if (e3 < t3 || e3 > r3 || e3 !== b(e3)) throw Error(w + (n2 || "Argument") + ("number" == typeof e3 ? e3 < t3 || e3 > r3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e3));
        }
        function C(e3) {
          var t3 = e3.c.length - 1;
          return A(e3.e / E) == t3 && e3.c[t3] % 2 != 0;
        }
        function j(e3, t3) {
          return (e3.length > 1 ? e3.charAt(0) + "." + e3.slice(1) : e3) + (t3 < 0 ? "e" : "e+") + t3;
        }
        function B(e3, t3, r3) {
          var n2, o2;
          if (t3 < 0) {
            for (o2 = r3 + "."; ++t3; o2 += r3) ;
            e3 = o2 + e3;
          } else if (++t3 > (n2 = e3.length)) {
            for (o2 = r3, t3 -= n2; --t3; o2 += r3) ;
            e3 += o2;
          } else t3 < n2 && (e3 = e3.slice(0, t3) + "." + e3.slice(t3));
          return e3;
        }
        var L = function e3(t3) {
          var r3, n2, o2, i2, a2, u2, s2, c2, l2, f2, p2 = H2.prototype = { constructor: H2, toString: null, valueOf: null }, d2 = new H2(1), h2 = 20, y2 = 4, m2 = -7, L2 = 21, N2 = -1e7, U2 = 1e7, M2 = false, F2 = 1, D2 = 0, V2 = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, q2 = "0123456789abcdefghijklmnopqrstuvwxyz", K2 = true;
          function H2(e4, t4) {
            var r4, i3, a3, u3, s3, c3, l3, f3, p3 = this;
            if (!(p3 instanceof H2)) return new H2(e4, t4);
            if (null == t4) {
              if (e4 && true === e4._isBigNumber) return p3.s = e4.s, void (!e4.c || e4.e > U2 ? p3.c = p3.e = null : e4.e < N2 ? p3.c = [p3.e = 0] : (p3.e = e4.e, p3.c = e4.c.slice()));
              if ((c3 = "number" == typeof e4) && 0 * e4 == 0) {
                if (p3.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {
                  for (u3 = 0, s3 = e4; s3 >= 10; s3 /= 10, u3++) ;
                  return void (u3 > U2 ? p3.c = p3.e = null : (p3.e = u3, p3.c = [e4]));
                }
                f3 = String(e4);
              } else {
                if (!v.test(f3 = String(e4))) return o2(p3, f3, c3);
                p3.s = 45 == f3.charCodeAt(0) ? (f3 = f3.slice(1), -1) : 1;
              }
              (u3 = f3.indexOf(".")) > -1 && (f3 = f3.replace(".", "")), (s3 = f3.search(/e/i)) > 0 ? (u3 < 0 && (u3 = s3), u3 += +f3.slice(s3 + 1), f3 = f3.substring(0, s3)) : u3 < 0 && (u3 = f3.length);
            } else {
              if (R(t4, 2, q2.length, "Base"), 10 == t4 && K2) return $2(p3 = new H2(e4), h2 + p3.e + 1, y2);
              if (f3 = String(e4), c3 = "number" == typeof e4) {
                if (0 * e4 != 0) return o2(p3, f3, c3, t4);
                if (p3.s = 1 / e4 < 0 ? (f3 = f3.slice(1), -1) : 1, H2.DEBUG && f3.replace(/^0\.0*|\./, "").length > 15) throw Error(S + e4);
              } else p3.s = 45 === f3.charCodeAt(0) ? (f3 = f3.slice(1), -1) : 1;
              for (r4 = q2.slice(0, t4), u3 = s3 = 0, l3 = f3.length; s3 < l3; s3++) if (r4.indexOf(i3 = f3.charAt(s3)) < 0) {
                if ("." == i3) {
                  if (s3 > u3) {
                    u3 = l3;
                    continue;
                  }
                } else if (!a3 && (f3 == f3.toUpperCase() && (f3 = f3.toLowerCase()) || f3 == f3.toLowerCase() && (f3 = f3.toUpperCase()))) {
                  a3 = true, s3 = -1, u3 = 0;
                  continue;
                }
                return o2(p3, String(e4), c3, t4);
              }
              c3 = false, (u3 = (f3 = n2(f3, t4, 10, p3.s)).indexOf(".")) > -1 ? f3 = f3.replace(".", "") : u3 = f3.length;
            }
            for (s3 = 0; 48 === f3.charCodeAt(s3); s3++) ;
            for (l3 = f3.length; 48 === f3.charCodeAt(--l3); ) ;
            if (f3 = f3.slice(s3, ++l3)) {
              if (l3 -= s3, c3 && H2.DEBUG && l3 > 15 && (e4 > _ || e4 !== b(e4))) throw Error(S + p3.s * e4);
              if ((u3 = u3 - s3 - 1) > U2) p3.c = p3.e = null;
              else if (u3 < N2) p3.c = [p3.e = 0];
              else {
                if (p3.e = u3, p3.c = [], s3 = (u3 + 1) % E, u3 < 0 && (s3 += E), s3 < l3) {
                  for (s3 && p3.c.push(+f3.slice(0, s3)), l3 -= E; s3 < l3; ) p3.c.push(+f3.slice(s3, s3 += E));
                  s3 = E - (f3 = f3.slice(s3)).length;
                } else s3 -= l3;
                for (; s3--; f3 += "0") ;
                p3.c.push(+f3);
              }
            } else p3.c = [p3.e = 0];
          }
          function z2(e4, t4, r4, n3) {
            var o3, i3, a3, u3, s3;
            if (null == r4 ? r4 = y2 : R(r4, 0, 8), !e4.c) return e4.toString();
            if (o3 = e4.c[0], a3 = e4.e, null == t4) s3 = P(e4.c), s3 = 1 == n3 || 2 == n3 && (a3 <= m2 || a3 >= L2) ? j(s3, a3) : B(s3, a3, "0");
            else if (i3 = (e4 = $2(new H2(e4), t4, r4)).e, u3 = (s3 = P(e4.c)).length, 1 == n3 || 2 == n3 && (t4 <= i3 || i3 <= m2)) {
              for (; u3 < t4; s3 += "0", u3++) ;
              s3 = j(s3, i3);
            } else if (t4 -= a3, s3 = B(s3, i3, "0"), i3 + 1 > u3) {
              if (--t4 > 0) for (s3 += "."; t4--; s3 += "0") ;
            } else if ((t4 += i3 - u3) > 0) for (i3 + 1 == u3 && (s3 += "."); t4--; s3 += "0") ;
            return e4.s < 0 && o3 ? "-" + s3 : s3;
          }
          function X2(e4, t4) {
            for (var r4, n3, o3 = 1, i3 = new H2(e4[0]); o3 < e4.length; o3++) (!(n3 = new H2(e4[o3])).s || (r4 = I(i3, n3)) === t4 || 0 === r4 && i3.s === t4) && (i3 = n3);
            return i3;
          }
          function G2(e4, t4, r4) {
            for (var n3 = 1, o3 = t4.length; !t4[--o3]; t4.pop()) ;
            for (o3 = t4[0]; o3 >= 10; o3 /= 10, n3++) ;
            return (r4 = n3 + r4 * E - 1) > U2 ? e4.c = e4.e = null : r4 < N2 ? e4.c = [e4.e = 0] : (e4.e = r4, e4.c = t4), e4;
          }
          function $2(e4, t4, r4, n3) {
            var o3, i3, a3, u3, s3, c3, l3, f3 = e4.c, p3 = T;
            if (f3) {
              e: {
                for (o3 = 1, u3 = f3[0]; u3 >= 10; u3 /= 10, o3++) ;
                if ((i3 = t4 - o3) < 0) i3 += E, a3 = t4, s3 = f3[c3 = 0], l3 = b(s3 / p3[o3 - a3 - 1] % 10);
                else if ((c3 = g((i3 + 1) / E)) >= f3.length) {
                  if (!n3) break e;
                  for (; f3.length <= c3; f3.push(0)) ;
                  s3 = l3 = 0, o3 = 1, a3 = (i3 %= E) - E + 1;
                } else {
                  for (s3 = u3 = f3[c3], o3 = 1; u3 >= 10; u3 /= 10, o3++) ;
                  l3 = (a3 = (i3 %= E) - E + o3) < 0 ? 0 : b(s3 / p3[o3 - a3 - 1] % 10);
                }
                if (n3 = n3 || t4 < 0 || null != f3[c3 + 1] || (a3 < 0 ? s3 : s3 % p3[o3 - a3 - 1]), n3 = r4 < 4 ? (l3 || n3) && (0 == r4 || r4 == (e4.s < 0 ? 3 : 2)) : l3 > 5 || 5 == l3 && (4 == r4 || n3 || 6 == r4 && (i3 > 0 ? a3 > 0 ? s3 / p3[o3 - a3] : 0 : f3[c3 - 1]) % 10 & 1 || r4 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !f3[0]) return f3.length = 0, n3 ? (t4 -= e4.e + 1, f3[0] = p3[(E - t4 % E) % E], e4.e = -t4 || 0) : f3[0] = e4.e = 0, e4;
                if (0 == i3 ? (f3.length = c3, u3 = 1, c3--) : (f3.length = c3 + 1, u3 = p3[E - i3], f3[c3] = a3 > 0 ? b(s3 / p3[o3 - a3] % p3[a3]) * u3 : 0), n3) for (; ; ) {
                  if (0 == c3) {
                    for (i3 = 1, a3 = f3[0]; a3 >= 10; a3 /= 10, i3++) ;
                    for (a3 = f3[0] += u3, u3 = 1; a3 >= 10; a3 /= 10, u3++) ;
                    i3 != u3 && (e4.e++, f3[0] == k && (f3[0] = 1));
                    break;
                  }
                  if (f3[c3] += u3, f3[c3] != k) break;
                  f3[c3--] = 0, u3 = 1;
                }
                for (i3 = f3.length; 0 === f3[--i3]; f3.pop()) ;
              }
              e4.e > U2 ? e4.c = e4.e = null : e4.e < N2 && (e4.c = [e4.e = 0]);
            }
            return e4;
          }
          function Q2(e4) {
            var t4, r4 = e4.e;
            return null === r4 ? e4.toString() : (t4 = P(e4.c), t4 = r4 <= m2 || r4 >= L2 ? j(t4, r4) : B(t4, r4, "0"), e4.s < 0 ? "-" + t4 : t4);
          }
          return H2.clone = e3, H2.ROUND_UP = 0, H2.ROUND_DOWN = 1, H2.ROUND_CEIL = 2, H2.ROUND_FLOOR = 3, H2.ROUND_HALF_UP = 4, H2.ROUND_HALF_DOWN = 5, H2.ROUND_HALF_EVEN = 6, H2.ROUND_HALF_CEIL = 7, H2.ROUND_HALF_FLOOR = 8, H2.EUCLID = 9, H2.config = H2.set = function(e4) {
            var t4, r4;
            if (null != e4) {
              if ("object" != typeof e4) throw Error(w + "Object expected: " + e4);
              if (e4.hasOwnProperty(t4 = "DECIMAL_PLACES") && (R(r4 = e4[t4], 0, x, t4), h2 = r4), e4.hasOwnProperty(t4 = "ROUNDING_MODE") && (R(r4 = e4[t4], 0, 8, t4), y2 = r4), e4.hasOwnProperty(t4 = "EXPONENTIAL_AT") && ((r4 = e4[t4]) && r4.pop ? (R(r4[0], -x, 0, t4), R(r4[1], 0, x, t4), m2 = r4[0], L2 = r4[1]) : (R(r4, -x, x, t4), m2 = -(L2 = r4 < 0 ? -r4 : r4))), e4.hasOwnProperty(t4 = "RANGE")) if ((r4 = e4[t4]) && r4.pop) R(r4[0], -x, -1, t4), R(r4[1], 1, x, t4), N2 = r4[0], U2 = r4[1];
              else {
                if (R(r4, -x, x, t4), !r4) throw Error(w + t4 + " cannot be zero: " + r4);
                N2 = -(U2 = r4 < 0 ? -r4 : r4);
              }
              if (e4.hasOwnProperty(t4 = "CRYPTO")) {
                if ((r4 = e4[t4]) !== !!r4) throw Error(w + t4 + " not true or false: " + r4);
                if (r4) {
                  if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw M2 = !r4, Error(w + "crypto unavailable");
                  M2 = r4;
                } else M2 = r4;
              }
              if (e4.hasOwnProperty(t4 = "MODULO_MODE") && (R(r4 = e4[t4], 0, 9, t4), F2 = r4), e4.hasOwnProperty(t4 = "POW_PRECISION") && (R(r4 = e4[t4], 0, x, t4), D2 = r4), e4.hasOwnProperty(t4 = "FORMAT")) {
                if ("object" != typeof (r4 = e4[t4])) throw Error(w + t4 + " not an object: " + r4);
                V2 = r4;
              }
              if (e4.hasOwnProperty(t4 = "ALPHABET")) {
                if ("string" != typeof (r4 = e4[t4]) || /^.?$|[+\-.\s]|(.).*\1/.test(r4)) throw Error(w + t4 + " invalid: " + r4);
                K2 = "0123456789" == r4.slice(0, 10), q2 = r4;
              }
            }
            return { DECIMAL_PLACES: h2, ROUNDING_MODE: y2, EXPONENTIAL_AT: [m2, L2], RANGE: [N2, U2], CRYPTO: M2, MODULO_MODE: F2, POW_PRECISION: D2, FORMAT: V2, ALPHABET: q2 };
          }, H2.isBigNumber = function(e4) {
            if (!e4 || true !== e4._isBigNumber) return false;
            if (!H2.DEBUG) return true;
            var t4, r4, n3 = e4.c, o3 = e4.e, i3 = e4.s;
            e: if ("[object Array]" == {}.toString.call(n3)) {
              if ((1 === i3 || -1 === i3) && o3 >= -x && o3 <= x && o3 === b(o3)) {
                if (0 === n3[0]) {
                  if (0 === o3 && 1 === n3.length) return true;
                  break e;
                }
                if ((t4 = (o3 + 1) % E) < 1 && (t4 += E), String(n3[0]).length == t4) {
                  for (t4 = 0; t4 < n3.length; t4++) if ((r4 = n3[t4]) < 0 || r4 >= k || r4 !== b(r4)) break e;
                  if (0 !== r4) return true;
                }
              }
            } else if (null === n3 && null === o3 && (null === i3 || 1 === i3 || -1 === i3)) return true;
            throw Error(w + "Invalid BigNumber: " + e4);
          }, H2.maximum = H2.max = function() {
            return X2(arguments, -1);
          }, H2.minimum = H2.min = function() {
            return X2(arguments, 1);
          }, H2.random = (i2 = 9007199254740992, a2 = Math.random() * i2 & 2097151 ? function() {
            return b(Math.random() * i2);
          } : function() {
            return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
          }, function(e4) {
            var t4, r4, n3, o3, i3, u3 = 0, s3 = [], c3 = new H2(d2);
            if (null == e4 ? e4 = h2 : R(e4, 0, x), o3 = g(e4 / E), M2) if (crypto.getRandomValues) {
              for (t4 = crypto.getRandomValues(new Uint32Array(o3 *= 2)); u3 < o3; ) (i3 = 131072 * t4[u3] + (t4[u3 + 1] >>> 11)) >= 9e15 ? (r4 = crypto.getRandomValues(new Uint32Array(2)), t4[u3] = r4[0], t4[u3 + 1] = r4[1]) : (s3.push(i3 % 1e14), u3 += 2);
              u3 = o3 / 2;
            } else {
              if (!crypto.randomBytes) throw M2 = false, Error(w + "crypto unavailable");
              for (t4 = crypto.randomBytes(o3 *= 7); u3 < o3; ) (i3 = 281474976710656 * (31 & t4[u3]) + 1099511627776 * t4[u3 + 1] + 4294967296 * t4[u3 + 2] + 16777216 * t4[u3 + 3] + (t4[u3 + 4] << 16) + (t4[u3 + 5] << 8) + t4[u3 + 6]) >= 9e15 ? crypto.randomBytes(7).copy(t4, u3) : (s3.push(i3 % 1e14), u3 += 7);
              u3 = o3 / 7;
            }
            if (!M2) for (; u3 < o3; ) (i3 = a2()) < 9e15 && (s3[u3++] = i3 % 1e14);
            for (o3 = s3[--u3], e4 %= E, o3 && e4 && (i3 = T[E - e4], s3[u3] = b(o3 / i3) * i3); 0 === s3[u3]; s3.pop(), u3--) ;
            if (u3 < 0) s3 = [n3 = 0];
            else {
              for (n3 = -1; 0 === s3[0]; s3.splice(0, 1), n3 -= E) ;
              for (u3 = 1, i3 = s3[0]; i3 >= 10; i3 /= 10, u3++) ;
              u3 < E && (n3 -= E - u3);
            }
            return c3.e = n3, c3.c = s3, c3;
          }), H2.sum = function() {
            for (var e4 = 1, t4 = arguments, r4 = new H2(t4[0]); e4 < t4.length; ) r4 = r4.plus(t4[e4++]);
            return r4;
          }, n2 = /* @__PURE__ */ function() {
            var e4 = "0123456789";
            function t4(e5, t5, r4, n3) {
              for (var o3, i3, a3 = [0], u3 = 0, s3 = e5.length; u3 < s3; ) {
                for (i3 = a3.length; i3--; a3[i3] *= t5) ;
                for (a3[0] += n3.indexOf(e5.charAt(u3++)), o3 = 0; o3 < a3.length; o3++) a3[o3] > r4 - 1 && (null == a3[o3 + 1] && (a3[o3 + 1] = 0), a3[o3 + 1] += a3[o3] / r4 | 0, a3[o3] %= r4);
              }
              return a3.reverse();
            }
            return function(n3, o3, i3, a3, u3) {
              var s3, c3, l3, f3, p3, d3, m3, v2, g2 = n3.indexOf("."), b2 = h2, w2 = y2;
              for (g2 >= 0 && (f3 = D2, D2 = 0, n3 = n3.replace(".", ""), d3 = (v2 = new H2(o3)).pow(n3.length - g2), D2 = f3, v2.c = t4(B(P(d3.c), d3.e, "0"), 10, i3, e4), v2.e = v2.c.length), l3 = f3 = (m3 = t4(n3, o3, i3, u3 ? (s3 = q2, e4) : (s3 = e4, q2))).length; 0 == m3[--f3]; m3.pop()) ;
              if (!m3[0]) return s3.charAt(0);
              if (g2 < 0 ? --l3 : (d3.c = m3, d3.e = l3, d3.s = a3, m3 = (d3 = r3(d3, v2, b2, w2, i3)).c, p3 = d3.r, l3 = d3.e), g2 = m3[c3 = l3 + b2 + 1], f3 = i3 / 2, p3 = p3 || c3 < 0 || null != m3[c3 + 1], p3 = w2 < 4 ? (null != g2 || p3) && (0 == w2 || w2 == (d3.s < 0 ? 3 : 2)) : g2 > f3 || g2 == f3 && (4 == w2 || p3 || 6 == w2 && 1 & m3[c3 - 1] || w2 == (d3.s < 0 ? 8 : 7)), c3 < 1 || !m3[0]) n3 = p3 ? B(s3.charAt(1), -b2, s3.charAt(0)) : s3.charAt(0);
              else {
                if (m3.length = c3, p3) for (--i3; ++m3[--c3] > i3; ) m3[c3] = 0, c3 || (++l3, m3 = [1].concat(m3));
                for (f3 = m3.length; !m3[--f3]; ) ;
                for (g2 = 0, n3 = ""; g2 <= f3; n3 += s3.charAt(m3[g2++])) ;
                n3 = B(n3, l3, s3.charAt(0));
              }
              return n3;
            };
          }(), r3 = /* @__PURE__ */ function() {
            function e4(e5, t5, r5) {
              var n3, o3, i3, a3, u3 = 0, s3 = e5.length, c3 = t5 % O, l3 = t5 / O | 0;
              for (e5 = e5.slice(); s3--; ) u3 = ((o3 = c3 * (i3 = e5[s3] % O) + (n3 = l3 * i3 + (a3 = e5[s3] / O | 0) * c3) % O * O + u3) / r5 | 0) + (n3 / O | 0) + l3 * a3, e5[s3] = o3 % r5;
              return u3 && (e5 = [u3].concat(e5)), e5;
            }
            function t4(e5, t5, r5, n3) {
              var o3, i3;
              if (r5 != n3) i3 = r5 > n3 ? 1 : -1;
              else for (o3 = i3 = 0; o3 < r5; o3++) if (e5[o3] != t5[o3]) {
                i3 = e5[o3] > t5[o3] ? 1 : -1;
                break;
              }
              return i3;
            }
            function r4(e5, t5, r5, n3) {
              for (var o3 = 0; r5--; ) e5[r5] -= o3, o3 = e5[r5] < t5[r5] ? 1 : 0, e5[r5] = o3 * n3 + e5[r5] - t5[r5];
              for (; !e5[0] && e5.length > 1; e5.splice(0, 1)) ;
            }
            return function(n3, o3, i3, a3, u3) {
              var s3, c3, l3, f3, p3, d3, h3, y3, m3, v2, g2, w2, S2, _2, T2, O2, x2, P2 = n3.s == o3.s ? 1 : -1, I2 = n3.c, R2 = o3.c;
              if (!(I2 && I2[0] && R2 && R2[0])) return new H2(n3.s && o3.s && (I2 ? !R2 || I2[0] != R2[0] : R2) ? I2 && 0 == I2[0] || !R2 ? 0 * P2 : P2 / 0 : NaN);
              for (m3 = (y3 = new H2(P2)).c = [], P2 = i3 + (c3 = n3.e - o3.e) + 1, u3 || (u3 = k, c3 = A(n3.e / E) - A(o3.e / E), P2 = P2 / E | 0), l3 = 0; R2[l3] == (I2[l3] || 0); l3++) ;
              if (R2[l3] > (I2[l3] || 0) && c3--, P2 < 0) m3.push(1), f3 = true;
              else {
                for (_2 = I2.length, O2 = R2.length, l3 = 0, P2 += 2, (p3 = b(u3 / (R2[0] + 1))) > 1 && (R2 = e4(R2, p3, u3), I2 = e4(I2, p3, u3), O2 = R2.length, _2 = I2.length), S2 = O2, g2 = (v2 = I2.slice(0, O2)).length; g2 < O2; v2[g2++] = 0) ;
                x2 = R2.slice(), x2 = [0].concat(x2), T2 = R2[0], R2[1] >= u3 / 2 && T2++;
                do {
                  if (p3 = 0, (s3 = t4(R2, v2, O2, g2)) < 0) {
                    if (w2 = v2[0], O2 != g2 && (w2 = w2 * u3 + (v2[1] || 0)), (p3 = b(w2 / T2)) > 1) for (p3 >= u3 && (p3 = u3 - 1), h3 = (d3 = e4(R2, p3, u3)).length, g2 = v2.length; 1 == t4(d3, v2, h3, g2); ) p3--, r4(d3, O2 < h3 ? x2 : R2, h3, u3), h3 = d3.length, s3 = 1;
                    else 0 == p3 && (s3 = p3 = 1), h3 = (d3 = R2.slice()).length;
                    if (h3 < g2 && (d3 = [0].concat(d3)), r4(v2, d3, g2, u3), g2 = v2.length, -1 == s3) for (; t4(R2, v2, O2, g2) < 1; ) p3++, r4(v2, O2 < g2 ? x2 : R2, g2, u3), g2 = v2.length;
                  } else 0 === s3 && (p3++, v2 = [0]);
                  m3[l3++] = p3, v2[0] ? v2[g2++] = I2[S2] || 0 : (v2 = [I2[S2]], g2 = 1);
                } while ((S2++ < _2 || null != v2[0]) && P2--);
                f3 = null != v2[0], m3[0] || m3.splice(0, 1);
              }
              if (u3 == k) {
                for (l3 = 1, P2 = m3[0]; P2 >= 10; P2 /= 10, l3++) ;
                $2(y3, i3 + (y3.e = l3 + c3 * E - 1) + 1, a3, f3);
              } else y3.e = c3, y3.r = +f3;
              return y3;
            };
          }(), u2 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, s2 = /^([^.]+)\.$/, c2 = /^\.([^.]+)$/, l2 = /^-?(Infinity|NaN)$/, f2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g, o2 = function(e4, t4, r4, n3) {
            var o3, i3 = r4 ? t4 : t4.replace(f2, "");
            if (l2.test(i3)) e4.s = isNaN(i3) ? null : i3 < 0 ? -1 : 1;
            else {
              if (!r4 && (i3 = i3.replace(u2, function(e5, t5, r5) {
                return o3 = "x" == (r5 = r5.toLowerCase()) ? 16 : "b" == r5 ? 2 : 8, n3 && n3 != o3 ? e5 : t5;
              }), n3 && (o3 = n3, i3 = i3.replace(s2, "$1").replace(c2, "0.$1")), t4 != i3)) return new H2(i3, o3);
              if (H2.DEBUG) throw Error(w + "Not a" + (n3 ? " base " + n3 : "") + " number: " + t4);
              e4.s = null;
            }
            e4.c = e4.e = null;
          }, p2.absoluteValue = p2.abs = function() {
            var e4 = new H2(this);
            return e4.s < 0 && (e4.s = 1), e4;
          }, p2.comparedTo = function(e4, t4) {
            return I(this, new H2(e4, t4));
          }, p2.decimalPlaces = p2.dp = function(e4, t4) {
            var r4, n3, o3, i3 = this;
            if (null != e4) return R(e4, 0, x), null == t4 ? t4 = y2 : R(t4, 0, 8), $2(new H2(i3), e4 + i3.e + 1, t4);
            if (!(r4 = i3.c)) return null;
            if (n3 = ((o3 = r4.length - 1) - A(this.e / E)) * E, o3 = r4[o3]) for (; o3 % 10 == 0; o3 /= 10, n3--) ;
            return n3 < 0 && (n3 = 0), n3;
          }, p2.dividedBy = p2.div = function(e4, t4) {
            return r3(this, new H2(e4, t4), h2, y2);
          }, p2.dividedToIntegerBy = p2.idiv = function(e4, t4) {
            return r3(this, new H2(e4, t4), 0, 1);
          }, p2.exponentiatedBy = p2.pow = function(e4, t4) {
            var r4, n3, o3, i3, a3, u3, s3, c3, l3 = this;
            if ((e4 = new H2(e4)).c && !e4.isInteger()) throw Error(w + "Exponent not an integer: " + Q2(e4));
            if (null != t4 && (t4 = new H2(t4)), a3 = e4.e > 14, !l3.c || !l3.c[0] || 1 == l3.c[0] && !l3.e && 1 == l3.c.length || !e4.c || !e4.c[0]) return c3 = new H2(Math.pow(+Q2(l3), a3 ? e4.s * (2 - C(e4)) : +Q2(e4))), t4 ? c3.mod(t4) : c3;
            if (u3 = e4.s < 0, t4) {
              if (t4.c ? !t4.c[0] : !t4.s) return new H2(NaN);
              (n3 = !u3 && l3.isInteger() && t4.isInteger()) && (l3 = l3.mod(t4));
            } else {
              if (e4.e > 9 && (l3.e > 0 || l3.e < -1 || (0 == l3.e ? l3.c[0] > 1 || a3 && l3.c[1] >= 24e7 : l3.c[0] < 8e13 || a3 && l3.c[0] <= 9999975e7))) return i3 = l3.s < 0 && C(e4) ? -0 : 0, l3.e > -1 && (i3 = 1 / i3), new H2(u3 ? 1 / i3 : i3);
              D2 && (i3 = g(D2 / E + 2));
            }
            for (a3 ? (r4 = new H2(0.5), u3 && (e4.s = 1), s3 = C(e4)) : s3 = (o3 = Math.abs(+Q2(e4))) % 2, c3 = new H2(d2); ; ) {
              if (s3) {
                if (!(c3 = c3.times(l3)).c) break;
                i3 ? c3.c.length > i3 && (c3.c.length = i3) : n3 && (c3 = c3.mod(t4));
              }
              if (o3) {
                if (0 === (o3 = b(o3 / 2))) break;
                s3 = o3 % 2;
              } else if ($2(e4 = e4.times(r4), e4.e + 1, 1), e4.e > 14) s3 = C(e4);
              else {
                if (0 === (o3 = +Q2(e4))) break;
                s3 = o3 % 2;
              }
              l3 = l3.times(l3), i3 ? l3.c && l3.c.length > i3 && (l3.c.length = i3) : n3 && (l3 = l3.mod(t4));
            }
            return n3 ? c3 : (u3 && (c3 = d2.div(c3)), t4 ? c3.mod(t4) : i3 ? $2(c3, D2, y2, void 0) : c3);
          }, p2.integerValue = function(e4) {
            var t4 = new H2(this);
            return null == e4 ? e4 = y2 : R(e4, 0, 8), $2(t4, t4.e + 1, e4);
          }, p2.isEqualTo = p2.eq = function(e4, t4) {
            return 0 === I(this, new H2(e4, t4));
          }, p2.isFinite = function() {
            return !!this.c;
          }, p2.isGreaterThan = p2.gt = function(e4, t4) {
            return I(this, new H2(e4, t4)) > 0;
          }, p2.isGreaterThanOrEqualTo = p2.gte = function(e4, t4) {
            return 1 === (t4 = I(this, new H2(e4, t4))) || 0 === t4;
          }, p2.isInteger = function() {
            return !!this.c && A(this.e / E) > this.c.length - 2;
          }, p2.isLessThan = p2.lt = function(e4, t4) {
            return I(this, new H2(e4, t4)) < 0;
          }, p2.isLessThanOrEqualTo = p2.lte = function(e4, t4) {
            return -1 === (t4 = I(this, new H2(e4, t4))) || 0 === t4;
          }, p2.isNaN = function() {
            return !this.s;
          }, p2.isNegative = function() {
            return this.s < 0;
          }, p2.isPositive = function() {
            return this.s > 0;
          }, p2.isZero = function() {
            return !!this.c && 0 == this.c[0];
          }, p2.minus = function(e4, t4) {
            var r4, n3, o3, i3, a3 = this, u3 = a3.s;
            if (t4 = (e4 = new H2(e4, t4)).s, !u3 || !t4) return new H2(NaN);
            if (u3 != t4) return e4.s = -t4, a3.plus(e4);
            var s3 = a3.e / E, c3 = e4.e / E, l3 = a3.c, f3 = e4.c;
            if (!s3 || !c3) {
              if (!l3 || !f3) return l3 ? (e4.s = -t4, e4) : new H2(f3 ? a3 : NaN);
              if (!l3[0] || !f3[0]) return f3[0] ? (e4.s = -t4, e4) : new H2(l3[0] ? a3 : 3 == y2 ? -0 : 0);
            }
            if (s3 = A(s3), c3 = A(c3), l3 = l3.slice(), u3 = s3 - c3) {
              for ((i3 = u3 < 0) ? (u3 = -u3, o3 = l3) : (c3 = s3, o3 = f3), o3.reverse(), t4 = u3; t4--; o3.push(0)) ;
              o3.reverse();
            } else for (n3 = (i3 = (u3 = l3.length) < (t4 = f3.length)) ? u3 : t4, u3 = t4 = 0; t4 < n3; t4++) if (l3[t4] != f3[t4]) {
              i3 = l3[t4] < f3[t4];
              break;
            }
            if (i3 && (o3 = l3, l3 = f3, f3 = o3, e4.s = -e4.s), (t4 = (n3 = f3.length) - (r4 = l3.length)) > 0) for (; t4--; l3[r4++] = 0) ;
            for (t4 = k - 1; n3 > u3; ) {
              if (l3[--n3] < f3[n3]) {
                for (r4 = n3; r4 && !l3[--r4]; l3[r4] = t4) ;
                --l3[r4], l3[n3] += k;
              }
              l3[n3] -= f3[n3];
            }
            for (; 0 == l3[0]; l3.splice(0, 1), --c3) ;
            return l3[0] ? G2(e4, l3, c3) : (e4.s = 3 == y2 ? -1 : 1, e4.c = [e4.e = 0], e4);
          }, p2.modulo = p2.mod = function(e4, t4) {
            var n3, o3, i3 = this;
            return e4 = new H2(e4, t4), !i3.c || !e4.s || e4.c && !e4.c[0] ? new H2(NaN) : !e4.c || i3.c && !i3.c[0] ? new H2(i3) : (9 == F2 ? (o3 = e4.s, e4.s = 1, n3 = r3(i3, e4, 0, 3), e4.s = o3, n3.s *= o3) : n3 = r3(i3, e4, 0, F2), (e4 = i3.minus(n3.times(e4))).c[0] || 1 != F2 || (e4.s = i3.s), e4);
          }, p2.multipliedBy = p2.times = function(e4, t4) {
            var r4, n3, o3, i3, a3, u3, s3, c3, l3, f3, p3, d3, h3, y3, m3, v2 = this, g2 = v2.c, b2 = (e4 = new H2(e4, t4)).c;
            if (!(g2 && b2 && g2[0] && b2[0])) return !v2.s || !e4.s || g2 && !g2[0] && !b2 || b2 && !b2[0] && !g2 ? e4.c = e4.e = e4.s = null : (e4.s *= v2.s, g2 && b2 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = null), e4;
            for (n3 = A(v2.e / E) + A(e4.e / E), e4.s *= v2.s, (s3 = g2.length) < (f3 = b2.length) && (h3 = g2, g2 = b2, b2 = h3, o3 = s3, s3 = f3, f3 = o3), o3 = s3 + f3, h3 = []; o3--; h3.push(0)) ;
            for (y3 = k, m3 = O, o3 = f3; --o3 >= 0; ) {
              for (r4 = 0, p3 = b2[o3] % m3, d3 = b2[o3] / m3 | 0, i3 = o3 + (a3 = s3); i3 > o3; ) r4 = ((c3 = p3 * (c3 = g2[--a3] % m3) + (u3 = d3 * c3 + (l3 = g2[a3] / m3 | 0) * p3) % m3 * m3 + h3[i3] + r4) / y3 | 0) + (u3 / m3 | 0) + d3 * l3, h3[i3--] = c3 % y3;
              h3[i3] = r4;
            }
            return r4 ? ++n3 : h3.splice(0, 1), G2(e4, h3, n3);
          }, p2.negated = function() {
            var e4 = new H2(this);
            return e4.s = -e4.s || null, e4;
          }, p2.plus = function(e4, t4) {
            var r4, n3 = this, o3 = n3.s;
            if (t4 = (e4 = new H2(e4, t4)).s, !o3 || !t4) return new H2(NaN);
            if (o3 != t4) return e4.s = -t4, n3.minus(e4);
            var i3 = n3.e / E, a3 = e4.e / E, u3 = n3.c, s3 = e4.c;
            if (!i3 || !a3) {
              if (!u3 || !s3) return new H2(o3 / 0);
              if (!u3[0] || !s3[0]) return s3[0] ? e4 : new H2(u3[0] ? n3 : 0 * o3);
            }
            if (i3 = A(i3), a3 = A(a3), u3 = u3.slice(), o3 = i3 - a3) {
              for (o3 > 0 ? (a3 = i3, r4 = s3) : (o3 = -o3, r4 = u3), r4.reverse(); o3--; r4.push(0)) ;
              r4.reverse();
            }
            for ((o3 = u3.length) - (t4 = s3.length) < 0 && (r4 = s3, s3 = u3, u3 = r4, t4 = o3), o3 = 0; t4; ) o3 = (u3[--t4] = u3[t4] + s3[t4] + o3) / k | 0, u3[t4] = k === u3[t4] ? 0 : u3[t4] % k;
            return o3 && (u3 = [o3].concat(u3), ++a3), G2(e4, u3, a3);
          }, p2.precision = p2.sd = function(e4, t4) {
            var r4, n3, o3, i3 = this;
            if (null != e4 && e4 !== !!e4) return R(e4, 1, x), null == t4 ? t4 = y2 : R(t4, 0, 8), $2(new H2(i3), e4, t4);
            if (!(r4 = i3.c)) return null;
            if (n3 = (o3 = r4.length - 1) * E + 1, o3 = r4[o3]) {
              for (; o3 % 10 == 0; o3 /= 10, n3--) ;
              for (o3 = r4[0]; o3 >= 10; o3 /= 10, n3++) ;
            }
            return e4 && i3.e + 1 > n3 && (n3 = i3.e + 1), n3;
          }, p2.shiftedBy = function(e4) {
            return R(e4, -9007199254740991, _), this.times("1e" + e4);
          }, p2.squareRoot = p2.sqrt = function() {
            var e4, t4, n3, o3, i3, a3 = this, u3 = a3.c, s3 = a3.s, c3 = a3.e, l3 = h2 + 4, f3 = new H2("0.5");
            if (1 !== s3 || !u3 || !u3[0]) return new H2(!s3 || s3 < 0 && (!u3 || u3[0]) ? NaN : u3 ? a3 : 1 / 0);
            if (0 == (s3 = Math.sqrt(+Q2(a3))) || s3 == 1 / 0 ? (((t4 = P(u3)).length + c3) % 2 == 0 && (t4 += "0"), s3 = Math.sqrt(+t4), c3 = A((c3 + 1) / 2) - (c3 < 0 || c3 % 2), n3 = new H2(t4 = s3 == 1 / 0 ? "5e" + c3 : (t4 = s3.toExponential()).slice(0, t4.indexOf("e") + 1) + c3)) : n3 = new H2(s3 + ""), n3.c[0]) {
              for ((s3 = (c3 = n3.e) + l3) < 3 && (s3 = 0); ; ) if (i3 = n3, n3 = f3.times(i3.plus(r3(a3, i3, l3, 1))), P(i3.c).slice(0, s3) === (t4 = P(n3.c)).slice(0, s3)) {
                if (n3.e < c3 && --s3, "9999" != (t4 = t4.slice(s3 - 3, s3 + 1)) && (o3 || "4999" != t4)) {
                  +t4 && (+t4.slice(1) || "5" != t4.charAt(0)) || ($2(n3, n3.e + h2 + 2, 1), e4 = !n3.times(n3).eq(a3));
                  break;
                }
                if (!o3 && ($2(i3, i3.e + h2 + 2, 0), i3.times(i3).eq(a3))) {
                  n3 = i3;
                  break;
                }
                l3 += 4, s3 += 4, o3 = 1;
              }
            }
            return $2(n3, n3.e + h2 + 1, y2, e4);
          }, p2.toExponential = function(e4, t4) {
            return null != e4 && (R(e4, 0, x), e4++), z2(this, e4, t4, 1);
          }, p2.toFixed = function(e4, t4) {
            return null != e4 && (R(e4, 0, x), e4 = e4 + this.e + 1), z2(this, e4, t4);
          }, p2.toFormat = function(e4, t4, r4) {
            var n3, o3 = this;
            if (null == r4) null != e4 && t4 && "object" == typeof t4 ? (r4 = t4, t4 = null) : e4 && "object" == typeof e4 ? (r4 = e4, e4 = t4 = null) : r4 = V2;
            else if ("object" != typeof r4) throw Error(w + "Argument not an object: " + r4);
            if (n3 = o3.toFixed(e4, t4), o3.c) {
              var i3, a3 = n3.split("."), u3 = +r4.groupSize, s3 = +r4.secondaryGroupSize, c3 = r4.groupSeparator || "", l3 = a3[0], f3 = a3[1], p3 = o3.s < 0, d3 = p3 ? l3.slice(1) : l3, h3 = d3.length;
              if (s3 && (i3 = u3, u3 = s3, s3 = i3, h3 -= i3), u3 > 0 && h3 > 0) {
                for (i3 = h3 % u3 || u3, l3 = d3.substr(0, i3); i3 < h3; i3 += u3) l3 += c3 + d3.substr(i3, u3);
                s3 > 0 && (l3 += c3 + d3.slice(i3)), p3 && (l3 = "-" + l3);
              }
              n3 = f3 ? l3 + (r4.decimalSeparator || "") + ((s3 = +r4.fractionGroupSize) ? f3.replace(new RegExp("\\d{" + s3 + "}\\B", "g"), "$&" + (r4.fractionGroupSeparator || "")) : f3) : l3;
            }
            return (r4.prefix || "") + n3 + (r4.suffix || "");
          }, p2.toFraction = function(e4) {
            var t4, n3, o3, i3, a3, u3, s3, c3, l3, f3, p3, h3, m3 = this, v2 = m3.c;
            if (null != e4 && (!(s3 = new H2(e4)).isInteger() && (s3.c || 1 !== s3.s) || s3.lt(d2))) throw Error(w + "Argument " + (s3.isInteger() ? "out of range: " : "not an integer: ") + Q2(s3));
            if (!v2) return new H2(m3);
            for (t4 = new H2(d2), l3 = n3 = new H2(d2), o3 = c3 = new H2(d2), h3 = P(v2), a3 = t4.e = h3.length - m3.e - 1, t4.c[0] = T[(u3 = a3 % E) < 0 ? E + u3 : u3], e4 = !e4 || s3.comparedTo(t4) > 0 ? a3 > 0 ? t4 : l3 : s3, u3 = U2, U2 = 1 / 0, s3 = new H2(h3), c3.c[0] = 0; f3 = r3(s3, t4, 0, 1), 1 != (i3 = n3.plus(f3.times(o3))).comparedTo(e4); ) n3 = o3, o3 = i3, l3 = c3.plus(f3.times(i3 = l3)), c3 = i3, t4 = s3.minus(f3.times(i3 = t4)), s3 = i3;
            return i3 = r3(e4.minus(n3), o3, 0, 1), c3 = c3.plus(i3.times(l3)), n3 = n3.plus(i3.times(o3)), c3.s = l3.s = m3.s, p3 = r3(l3, o3, a3 *= 2, y2).minus(m3).abs().comparedTo(r3(c3, n3, a3, y2).minus(m3).abs()) < 1 ? [l3, o3] : [c3, n3], U2 = u3, p3;
          }, p2.toNumber = function() {
            return +Q2(this);
          }, p2.toPrecision = function(e4, t4) {
            return null != e4 && R(e4, 1, x), z2(this, e4, t4, 2);
          }, p2.toString = function(e4) {
            var t4, r4 = this, o3 = r4.s, i3 = r4.e;
            return null === i3 ? o3 ? (t4 = "Infinity", o3 < 0 && (t4 = "-" + t4)) : t4 = "NaN" : (null == e4 ? t4 = i3 <= m2 || i3 >= L2 ? j(P(r4.c), i3) : B(P(r4.c), i3, "0") : 10 === e4 && K2 ? t4 = B(P((r4 = $2(new H2(r4), h2 + i3 + 1, y2)).c), r4.e, "0") : (R(e4, 2, q2.length, "Base"), t4 = n2(B(P(r4.c), i3, "0"), 10, e4, o3, true)), o3 < 0 && r4.c[0] && (t4 = "-" + t4)), t4;
          }, p2.valueOf = p2.toJSON = function() {
            return Q2(this);
          }, p2._isBigNumber = true, p2[Symbol.toStringTag] = "BigNumber", p2[Symbol.for("nodejs.util.inspect.custom")] = p2.valueOf, null != t3 && H2.set(t3), H2;
        }();
        const N = L;
        var U = r2(4193), M = r2.n(U), F = r2(9127), D = r2.n(F), V = r2(5976), q = r2(6371);
        function K(e3) {
          return K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, K(e3);
        }
        var H = "13.3.0", z = {}, X = (0, q.vt)({ headers: { "X-Client-Name": "js-stellar-sdk", "X-Client-Version": H } });
        function G(e3) {
          return Math.floor(e3 / 1e3);
        }
        X.interceptors.response.use(function(e3) {
          var t3 = M()(e3.config.url).hostname(), r3 = 0;
          if (e3.headers instanceof Headers) {
            var n2 = e3.headers.get("date");
            n2 && (r3 = G(Date.parse(n2)));
          } else if ("object" === K(e3.headers) && "date" in e3.headers) {
            var o2 = e3.headers;
            "string" == typeof o2.date && (r3 = G(Date.parse(o2.date)));
          }
          var i2 = G((/* @__PURE__ */ new Date()).getTime());
          return Number.isNaN(r3) || (z[t3] = { serverTime: r3, localTimeRecorded: i2 }), e3;
        });
        const $ = X;
        function Q(e3) {
          var t3 = z[e3];
          if (!t3 || !t3.localTimeRecorded || !t3.serverTime) return null;
          var r3 = t3.serverTime, n2 = t3.localTimeRecorded, o2 = G((/* @__PURE__ */ new Date()).getTime());
          return o2 - n2 > 300 ? null : o2 - n2 + r3;
        }
        function W(e3) {
          return W = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, W(e3);
        }
        function Y() {
          Y = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof v2 ? t4 : v2, a3 = Object.create(i3.prototype), u3 = new I2(n3 || []);
            return o2(a3, "_invoke", { value: O2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function v2() {
          }
          function g2() {
          }
          function b2() {
          }
          var w2 = {};
          c2(w2, a2, function() {
            return this;
          });
          var S2 = Object.getPrototypeOf, k2 = S2 && S2(S2(R2([])));
          k2 && k2 !== r3 && n2.call(k2, a2) && (w2 = k2);
          var E2 = b2.prototype = v2.prototype = Object.create(w2);
          function _2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == W(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function O2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = x2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function x2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, x2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function A2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function P2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function I2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
          }
          function R2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(W(t4) + " is not iterable");
          }
          return g2.prototype = b2, o2(E2, "constructor", { value: b2, configurable: true }), o2(b2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(b2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === g2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, b2) : (e4.__proto__ = b2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(E2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, _2(T2.prototype), c2(T2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new T2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, _2(E2), c2(E2, s2, "Generator"), c2(E2, a2, function() {
            return this;
          }), c2(E2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = R2, I2.prototype = { constructor: I2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), P2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  P2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: R2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function J(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function Z(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                J(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                J(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function ee(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, te(n2.key), n2);
          }
        }
        function te(e3) {
          var t3 = function(e4, t4) {
            if ("object" != W(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != W(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == W(t3) ? t3 : t3 + "";
        }
        var re, ne, oe = ["transaction"], ie = function(e3, t3, r3) {
          return t3 && ee(e3.prototype, t3), r3 && ee(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        }(function e3(t3) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
          !function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), this.url = t3.clone(), this.filter = [], this.originalSegments = this.url.segment() || [], this.neighborRoot = r3;
        }, [{ key: "call", value: function() {
          var e3 = this;
          return this.checkFilter(), this._sendNormalRequest(this.url).then(function(t3) {
            return e3._parseResponse(t3);
          });
        } }, { key: "stream", value: function() {
          throw new Error("Streaming requires eventsource to be enabled. If you need this functionality, compile with USE_EVENTSOURCE=true.");
        } }, { key: "cursor", value: function(e3) {
          return this.url.setQuery("cursor", e3), this;
        } }, { key: "limit", value: function(e3) {
          return this.url.setQuery("limit", e3.toString()), this;
        } }, { key: "order", value: function(e3) {
          return this.url.setQuery("order", e3), this;
        } }, { key: "join", value: function(e3) {
          return this.url.setQuery("join", e3), this;
        } }, { key: "forEndpoint", value: function(e3, t3) {
          if ("" === this.neighborRoot) throw new Error("Invalid usage: neighborRoot not set in constructor");
          return this.filter.push([e3, t3, this.neighborRoot]), this;
        } }, { key: "checkFilter", value: function() {
          if (this.filter.length >= 2) throw new V.v7("Too many filters specified", this.filter);
          if (1 === this.filter.length) {
            var e3 = this.originalSegments.concat(this.filter[0]);
            this.url.segment(e3);
          }
        } }, { key: "_requestFnForLink", value: function(e3) {
          var t3 = this;
          return Z(Y().mark(function r3() {
            var n2, o2, i2, a2, u2 = arguments;
            return Y().wrap(function(r4) {
              for (; ; ) switch (r4.prev = r4.next) {
                case 0:
                  return n2 = u2.length > 0 && void 0 !== u2[0] ? u2[0] : {}, e3.templated ? (i2 = D()(e3.href), o2 = M()(i2.expand(n2))) : o2 = M()(e3.href), r4.next = 4, t3._sendNormalRequest(o2);
                case 4:
                  return a2 = r4.sent, r4.abrupt("return", t3._parseResponse(a2));
                case 6:
                case "end":
                  return r4.stop();
              }
            }, r3);
          }));
        } }, { key: "_parseRecord", value: function(e3) {
          var t3 = this;
          return e3._links ? (Object.keys(e3._links).forEach(function(r3) {
            var n2 = e3._links[r3], o2 = false;
            if (void 0 !== e3[r3] && (e3["".concat(r3, "_attr")] = e3[r3], o2 = true), o2 && oe.indexOf(r3) >= 0) {
              var i2 = t3._parseRecord(e3[r3]);
              e3[r3] = Z(Y().mark(function e4() {
                return Y().wrap(function(e5) {
                  for (; ; ) switch (e5.prev = e5.next) {
                    case 0:
                      return e5.abrupt("return", i2);
                    case 1:
                    case "end":
                      return e5.stop();
                  }
                }, e4);
              }));
            } else e3[r3] = t3._requestFnForLink(n2);
          }), e3) : e3;
        } }, { key: "_sendNormalRequest", value: (ne = Z(Y().mark(function e3(t3) {
          var r3;
          return Y().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return "" === (r3 = t3).authority() && (r3 = r3.authority(this.url.authority())), "" === r3.protocol() && (r3 = r3.protocol(this.url.protocol())), e4.abrupt("return", X.get(r3.toString()).then(function(e5) {
                  return e5.data;
                }).catch(this._handleNetworkError));
              case 4:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return ne.apply(this, arguments);
        }) }, { key: "_parseResponse", value: function(e3) {
          return e3._embedded && e3._embedded.records ? this._toCollectionPage(e3) : this._parseRecord(e3);
        } }, { key: "_toCollectionPage", value: function(e3) {
          for (var t3, r3, n2 = this, o2 = 0; o2 < e3._embedded.records.length; o2 += 1) e3._embedded.records[o2] = this._parseRecord(e3._embedded.records[o2]);
          return { records: e3._embedded.records, next: (r3 = Z(Y().mark(function t4() {
            var r4;
            return Y().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return t5.next = 2, n2._sendNormalRequest(M()(e3._links.next.href));
                case 2:
                  return r4 = t5.sent, t5.abrupt("return", n2._toCollectionPage(r4));
                case 4:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function() {
            return r3.apply(this, arguments);
          }), prev: (t3 = Z(Y().mark(function t4() {
            var r4;
            return Y().wrap(function(t5) {
              for (; ; ) switch (t5.prev = t5.next) {
                case 0:
                  return t5.next = 2, n2._sendNormalRequest(M()(e3._links.prev.href));
                case 2:
                  return r4 = t5.sent, t5.abrupt("return", n2._toCollectionPage(r4));
                case 4:
                case "end":
                  return t5.stop();
              }
            }, t4);
          })), function() {
            return t3.apply(this, arguments);
          }) };
        } }, { key: "_handleNetworkError", value: (re = Z(Y().mark(function e3(t3) {
          var r3, n2;
          return Y().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if (!t3.response || !t3.response.status) {
                  e4.next = 8;
                  break;
                }
                e4.t0 = t3.response.status, e4.next = 404 === e4.t0 ? 4 : 5;
                break;
              case 4:
                return e4.abrupt("return", Promise.reject(new V.m_(null !== (r3 = t3.response.statusText) && void 0 !== r3 ? r3 : "Not Found", t3.response.data)));
              case 5:
                return e4.abrupt("return", Promise.reject(new V.Dr(null !== (n2 = t3.response.statusText) && void 0 !== n2 ? n2 : "Unknown", t3.response.data)));
              case 6:
                e4.next = 9;
                break;
              case 8:
                return e4.abrupt("return", Promise.reject(new Error(t3.message)));
              case 9:
              case "end":
                return e4.stop();
            }
          }, e3);
        })), function(e3) {
          return re.apply(this, arguments);
        }) }]), ae = r2(8732);
        function ue(e3) {
          return ue = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, ue(e3);
        }
        function se(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, ce(n2.key), n2);
          }
        }
        function ce(e3) {
          var t3 = function(e4, t4) {
            if ("object" != ue(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != ue(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == ue(t3) ? t3 : t3 + "";
        }
        function le(e3, t3, r3) {
          return t3 = pe(t3), function(e4, t4) {
            if (t4 && ("object" == ue(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, fe() ? Reflect.construct(t3, r3 || [], pe(e3).constructor) : t3.apply(e3, r3));
        }
        function fe() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (fe = function() {
            return !!e3;
          })();
        }
        function pe(e3) {
          return pe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, pe(e3);
        }
        function de(e3, t3) {
          return de = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, de(e3, t3);
        }
        var he = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = le(this, t3, [e4])).url.segment("accounts"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && de(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && se(e4.prototype, t4), r3 && se(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "accountId", value: function(e4) {
            var t4 = new ie(this.url.clone());
            return t4.filter.push([e4]), t4;
          } }, { key: "forSigner", value: function(e4) {
            return this.url.setQuery("signer", e4), this;
          } }, { key: "forAsset", value: function(e4) {
            return this.url.setQuery("asset", "".concat(e4)), this;
          } }, { key: "sponsor", value: function(e4) {
            return this.url.setQuery("sponsor", e4), this;
          } }, { key: "forLiquidityPool", value: function(e4) {
            return this.url.setQuery("liquidity_pool", e4), this;
          } }]);
        }(ie);
        function ye(e3) {
          return ye = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, ye(e3);
        }
        function me(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, ve(n2.key), n2);
          }
        }
        function ve(e3) {
          var t3 = function(e4, t4) {
            if ("object" != ye(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != ye(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == ye(t3) ? t3 : t3 + "";
        }
        function ge(e3, t3, r3) {
          return t3 = we(t3), function(e4, t4) {
            if (t4 && ("object" == ye(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, be() ? Reflect.construct(t3, r3 || [], we(e3).constructor) : t3.apply(e3, r3));
        }
        function be() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (be = function() {
            return !!e3;
          })();
        }
        function we(e3) {
          return we = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, we(e3);
        }
        function Se(e3, t3) {
          return Se = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Se(e3, t3);
        }
        var ke = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = ge(this, t3, [e4])).url.segment("assets"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Se(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && me(e4.prototype, t4), r3 && me(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "forCode", value: function(e4) {
            return this.url.setQuery("asset_code", e4), this;
          } }, { key: "forIssuer", value: function(e4) {
            return this.url.setQuery("asset_issuer", e4), this;
          } }]);
        }(ie);
        function Ee(e3) {
          return Ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Ee(e3);
        }
        function _e(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Te(n2.key), n2);
          }
        }
        function Te(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Ee(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Ee(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Ee(t3) ? t3 : t3 + "";
        }
        function Oe(e3, t3, r3) {
          return t3 = Ae(t3), function(e4, t4) {
            if (t4 && ("object" == Ee(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, xe() ? Reflect.construct(t3, r3 || [], Ae(e3).constructor) : t3.apply(e3, r3));
        }
        function xe() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (xe = function() {
            return !!e3;
          })();
        }
        function Ae(e3) {
          return Ae = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, Ae(e3);
        }
        function Pe(e3, t3) {
          return Pe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Pe(e3, t3);
        }
        var Ie = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = Oe(this, t3, [e4])).url.segment("claimable_balances"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Pe(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && _e(e4.prototype, t4), r3 && _e(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "claimableBalance", value: function(e4) {
            var t4 = new ie(this.url.clone());
            return t4.filter.push([e4]), t4;
          } }, { key: "sponsor", value: function(e4) {
            return this.url.setQuery("sponsor", e4), this;
          } }, { key: "claimant", value: function(e4) {
            return this.url.setQuery("claimant", e4), this;
          } }, { key: "asset", value: function(e4) {
            return this.url.setQuery("asset", e4.toString()), this;
          } }]);
        }(ie);
        function Re(e3) {
          return Re = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Re(e3);
        }
        function Ce(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, je(n2.key), n2);
          }
        }
        function je(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Re(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Re(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Re(t3) ? t3 : t3 + "";
        }
        function Be(e3, t3, r3) {
          return t3 = Ne(t3), function(e4, t4) {
            if (t4 && ("object" == Re(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, Le() ? Reflect.construct(t3, r3 || [], Ne(e3).constructor) : t3.apply(e3, r3));
        }
        function Le() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (Le = function() {
            return !!e3;
          })();
        }
        function Ne(e3) {
          return Ne = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, Ne(e3);
        }
        function Ue(e3, t3) {
          return Ue = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Ue(e3, t3);
        }
        var Me = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = Be(this, t3, [e4, "effects"])).url.segment("effects"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Ue(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && Ce(e4.prototype, t4), r3 && Ce(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "forAccount", value: function(e4) {
            return this.forEndpoint("accounts", e4);
          } }, { key: "forLedger", value: function(e4) {
            return this.forEndpoint("ledgers", e4.toString());
          } }, { key: "forTransaction", value: function(e4) {
            return this.forEndpoint("transactions", e4);
          } }, { key: "forOperation", value: function(e4) {
            return this.forEndpoint("operations", e4);
          } }, { key: "forLiquidityPool", value: function(e4) {
            return this.forEndpoint("liquidity_pools", e4);
          } }]);
        }(ie);
        function Fe(e3) {
          return Fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Fe(e3);
        }
        function De(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Ve(n2.key), n2);
          }
        }
        function Ve(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Fe(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Fe(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Fe(t3) ? t3 : t3 + "";
        }
        function qe(e3, t3, r3) {
          return t3 = He(t3), function(e4, t4) {
            if (t4 && ("object" == Fe(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, Ke() ? Reflect.construct(t3, r3 || [], He(e3).constructor) : t3.apply(e3, r3));
        }
        function Ke() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (Ke = function() {
            return !!e3;
          })();
        }
        function He(e3) {
          return He = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, He(e3);
        }
        function ze(e3, t3) {
          return ze = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, ze(e3, t3);
        }
        var Xe = function(e3) {
          function t3(e4, r3) {
            var n2;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (n2 = qe(this, t3, [e4])).url.segment("friendbot"), n2.url.setQuery("addr", r3), n2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && ze(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && De(e4.prototype, t4), r3 && De(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3);
        }(ie);
        function Ge(e3) {
          return Ge = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Ge(e3);
        }
        function $e(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Qe(n2.key), n2);
          }
        }
        function Qe(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Ge(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Ge(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Ge(t3) ? t3 : t3 + "";
        }
        function We(e3, t3, r3) {
          return t3 = Je(t3), function(e4, t4) {
            if (t4 && ("object" == Ge(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, Ye() ? Reflect.construct(t3, r3 || [], Je(e3).constructor) : t3.apply(e3, r3));
        }
        function Ye() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (Ye = function() {
            return !!e3;
          })();
        }
        function Je(e3) {
          return Je = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, Je(e3);
        }
        function Ze(e3, t3) {
          return Ze = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Ze(e3, t3);
        }
        var et = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = We(this, t3, [e4])).url.segment("ledgers"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Ze(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && $e(e4.prototype, t4), r3 && $e(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "ledger", value: function(e4) {
            return this.filter.push(["ledgers", e4.toString()]), this;
          } }]);
        }(ie);
        function tt(e3) {
          return tt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, tt(e3);
        }
        function rt(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, nt(n2.key), n2);
          }
        }
        function nt(e3) {
          var t3 = function(e4, t4) {
            if ("object" != tt(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != tt(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == tt(t3) ? t3 : t3 + "";
        }
        function ot(e3, t3, r3) {
          return t3 = at(t3), function(e4, t4) {
            if (t4 && ("object" == tt(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, it() ? Reflect.construct(t3, r3 || [], at(e3).constructor) : t3.apply(e3, r3));
        }
        function it() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (it = function() {
            return !!e3;
          })();
        }
        function at(e3) {
          return at = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, at(e3);
        }
        function ut(e3, t3) {
          return ut = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, ut(e3, t3);
        }
        var st = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = ot(this, t3, [e4])).url.segment("liquidity_pools"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && ut(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && rt(e4.prototype, t4), r3 && rt(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "forAssets", value: function() {
            for (var e4 = arguments.length, t4 = new Array(e4), r3 = 0; r3 < e4; r3++) t4[r3] = arguments[r3];
            var n2 = t4.map(function(e5) {
              return e5.toString();
            }).join(",");
            return this.url.setQuery("reserves", n2), this;
          } }, { key: "forAccount", value: function(e4) {
            return this.url.setQuery("account", e4), this;
          } }, { key: "liquidityPoolId", value: function(e4) {
            if (!e4.match(/[a-fA-F0-9]{64}/)) throw new TypeError("".concat(e4, " does not look like a liquidity pool ID"));
            var t4 = new ie(this.url.clone());
            return t4.filter.push([e4.toLowerCase()]), t4;
          } }]);
        }(ie);
        function ct(e3) {
          return ct = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, ct(e3);
        }
        function lt(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, ft(n2.key), n2);
          }
        }
        function ft(e3) {
          var t3 = function(e4, t4) {
            if ("object" != ct(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != ct(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == ct(t3) ? t3 : t3 + "";
        }
        function pt(e3, t3, r3) {
          return t3 = ht(t3), function(e4, t4) {
            if (t4 && ("object" == ct(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, dt() ? Reflect.construct(t3, r3 || [], ht(e3).constructor) : t3.apply(e3, r3));
        }
        function dt() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (dt = function() {
            return !!e3;
          })();
        }
        function ht(e3) {
          return ht = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, ht(e3);
        }
        function yt(e3, t3) {
          return yt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, yt(e3, t3);
        }
        var mt = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = pt(this, t3, [e4, "offers"])).url.segment("offers"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && yt(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && lt(e4.prototype, t4), r3 && lt(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "offer", value: function(e4) {
            var t4 = new ie(this.url.clone());
            return t4.filter.push([e4]), t4;
          } }, { key: "forAccount", value: function(e4) {
            return this.forEndpoint("accounts", e4);
          } }, { key: "buying", value: function(e4) {
            return e4.isNative() ? this.url.setQuery("buying_asset_type", "native") : (this.url.setQuery("buying_asset_type", e4.getAssetType()), this.url.setQuery("buying_asset_code", e4.getCode()), this.url.setQuery("buying_asset_issuer", e4.getIssuer())), this;
          } }, { key: "selling", value: function(e4) {
            return e4.isNative() ? this.url.setQuery("selling_asset_type", "native") : (this.url.setQuery("selling_asset_type", e4.getAssetType()), this.url.setQuery("selling_asset_code", e4.getCode()), this.url.setQuery("selling_asset_issuer", e4.getIssuer())), this;
          } }, { key: "sponsor", value: function(e4) {
            return this.url.setQuery("sponsor", e4), this;
          } }, { key: "seller", value: function(e4) {
            return this.url.setQuery("seller", e4), this;
          } }]);
        }(ie);
        function vt(e3) {
          return vt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, vt(e3);
        }
        function gt(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, bt(n2.key), n2);
          }
        }
        function bt(e3) {
          var t3 = function(e4, t4) {
            if ("object" != vt(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != vt(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == vt(t3) ? t3 : t3 + "";
        }
        function wt(e3, t3, r3) {
          return t3 = kt(t3), function(e4, t4) {
            if (t4 && ("object" == vt(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, St() ? Reflect.construct(t3, r3 || [], kt(e3).constructor) : t3.apply(e3, r3));
        }
        function St() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (St = function() {
            return !!e3;
          })();
        }
        function kt(e3) {
          return kt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, kt(e3);
        }
        function Et(e3, t3) {
          return Et = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Et(e3, t3);
        }
        var _t = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = wt(this, t3, [e4, "operations"])).url.segment("operations"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Et(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && gt(e4.prototype, t4), r3 && gt(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "operation", value: function(e4) {
            var t4 = new ie(this.url.clone());
            return t4.filter.push([e4]), t4;
          } }, { key: "forAccount", value: function(e4) {
            return this.forEndpoint("accounts", e4);
          } }, { key: "forClaimableBalance", value: function(e4) {
            return this.forEndpoint("claimable_balances", e4);
          } }, { key: "forLedger", value: function(e4) {
            return this.forEndpoint("ledgers", e4.toString());
          } }, { key: "forTransaction", value: function(e4) {
            return this.forEndpoint("transactions", e4);
          } }, { key: "forLiquidityPool", value: function(e4) {
            return this.forEndpoint("liquidity_pools", e4);
          } }, { key: "includeFailed", value: function(e4) {
            return this.url.setQuery("include_failed", e4.toString()), this;
          } }]);
        }(ie);
        function Tt(e3) {
          return Tt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Tt(e3);
        }
        function Ot(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, xt(n2.key), n2);
          }
        }
        function xt(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Tt(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Tt(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Tt(t3) ? t3 : t3 + "";
        }
        function At(e3, t3, r3) {
          return t3 = It(t3), function(e4, t4) {
            if (t4 && ("object" == Tt(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, Pt() ? Reflect.construct(t3, r3 || [], It(e3).constructor) : t3.apply(e3, r3));
        }
        function Pt() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (Pt = function() {
            return !!e3;
          })();
        }
        function It(e3) {
          return It = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, It(e3);
        }
        function Rt(e3, t3) {
          return Rt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Rt(e3, t3);
        }
        var Ct = function(e3) {
          function t3(e4, r3, n2) {
            var o2;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (o2 = At(this, t3, [e4])).url.segment("order_book"), r3.isNative() ? o2.url.setQuery("selling_asset_type", "native") : (o2.url.setQuery("selling_asset_type", r3.getAssetType()), o2.url.setQuery("selling_asset_code", r3.getCode()), o2.url.setQuery("selling_asset_issuer", r3.getIssuer())), n2.isNative() ? o2.url.setQuery("buying_asset_type", "native") : (o2.url.setQuery("buying_asset_type", n2.getAssetType()), o2.url.setQuery("buying_asset_code", n2.getCode()), o2.url.setQuery("buying_asset_issuer", n2.getIssuer())), o2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Rt(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && Ot(e4.prototype, t4), r3 && Ot(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3);
        }(ie);
        function jt(e3) {
          return jt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, jt(e3);
        }
        function Bt(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Lt(n2.key), n2);
          }
        }
        function Lt(e3) {
          var t3 = function(e4, t4) {
            if ("object" != jt(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != jt(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == jt(t3) ? t3 : t3 + "";
        }
        function Nt(e3, t3, r3) {
          return t3 = Mt(t3), function(e4, t4) {
            if (t4 && ("object" == jt(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, Ut() ? Reflect.construct(t3, r3 || [], Mt(e3).constructor) : t3.apply(e3, r3));
        }
        function Ut() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (Ut = function() {
            return !!e3;
          })();
        }
        function Mt(e3) {
          return Mt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, Mt(e3);
        }
        function Ft(e3, t3) {
          return Ft = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Ft(e3, t3);
        }
        var Dt = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = Nt(this, t3, [e4, "payments"])).url.segment("payments"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Ft(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && Bt(e4.prototype, t4), r3 && Bt(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "forAccount", value: function(e4) {
            return this.forEndpoint("accounts", e4);
          } }, { key: "forLedger", value: function(e4) {
            return this.forEndpoint("ledgers", e4.toString());
          } }, { key: "forTransaction", value: function(e4) {
            return this.forEndpoint("transactions", e4);
          } }, { key: "includeFailed", value: function(e4) {
            return this.url.setQuery("include_failed", e4.toString()), this;
          } }]);
        }(ie);
        function Vt(e3) {
          return Vt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Vt(e3);
        }
        function qt(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Kt(n2.key), n2);
          }
        }
        function Kt(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Vt(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Vt(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Vt(t3) ? t3 : t3 + "";
        }
        function Ht(e3, t3, r3) {
          return t3 = Xt(t3), function(e4, t4) {
            if (t4 && ("object" == Vt(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, zt() ? Reflect.construct(t3, r3 || [], Xt(e3).constructor) : t3.apply(e3, r3));
        }
        function zt() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (zt = function() {
            return !!e3;
          })();
        }
        function Xt(e3) {
          return Xt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, Xt(e3);
        }
        function Gt(e3, t3) {
          return Gt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Gt(e3, t3);
        }
        var $t = function(e3) {
          function t3(e4, r3, n2, o2) {
            var i2;
            if (function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (i2 = Ht(this, t3, [e4])).url.segment("paths/strict-receive"), "string" == typeof r3) i2.url.setQuery("source_account", r3);
            else {
              var a2 = r3.map(function(e5) {
                return e5.isNative() ? "native" : "".concat(e5.getCode(), ":").concat(e5.getIssuer());
              }).join(",");
              i2.url.setQuery("source_assets", a2);
            }
            return i2.url.setQuery("destination_amount", o2), n2.isNative() ? i2.url.setQuery("destination_asset_type", "native") : (i2.url.setQuery("destination_asset_type", n2.getAssetType()), i2.url.setQuery("destination_asset_code", n2.getCode()), i2.url.setQuery("destination_asset_issuer", n2.getIssuer())), i2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Gt(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && qt(e4.prototype, t4), r3 && qt(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3);
        }(ie);
        function Qt(e3) {
          return Qt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Qt(e3);
        }
        function Wt(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Yt(n2.key), n2);
          }
        }
        function Yt(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Qt(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Qt(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Qt(t3) ? t3 : t3 + "";
        }
        function Jt(e3, t3, r3) {
          return t3 = er(t3), function(e4, t4) {
            if (t4 && ("object" == Qt(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, Zt() ? Reflect.construct(t3, r3 || [], er(e3).constructor) : t3.apply(e3, r3));
        }
        function Zt() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (Zt = function() {
            return !!e3;
          })();
        }
        function er(e3) {
          return er = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, er(e3);
        }
        function tr(e3, t3) {
          return tr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, tr(e3, t3);
        }
        var rr = function(e3) {
          function t3(e4, r3, n2, o2) {
            var i2;
            if (function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (i2 = Jt(this, t3, [e4])).url.segment("paths/strict-send"), r3.isNative() ? i2.url.setQuery("source_asset_type", "native") : (i2.url.setQuery("source_asset_type", r3.getAssetType()), i2.url.setQuery("source_asset_code", r3.getCode()), i2.url.setQuery("source_asset_issuer", r3.getIssuer())), i2.url.setQuery("source_amount", n2), "string" == typeof o2) i2.url.setQuery("destination_account", o2);
            else {
              var a2 = o2.map(function(e5) {
                return e5.isNative() ? "native" : "".concat(e5.getCode(), ":").concat(e5.getIssuer());
              }).join(",");
              i2.url.setQuery("destination_assets", a2);
            }
            return i2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && tr(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && Wt(e4.prototype, t4), r3 && Wt(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3);
        }(ie);
        function nr(e3) {
          return nr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, nr(e3);
        }
        function or(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, ir(n2.key), n2);
          }
        }
        function ir(e3) {
          var t3 = function(e4, t4) {
            if ("object" != nr(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != nr(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == nr(t3) ? t3 : t3 + "";
        }
        function ar(e3, t3, r3) {
          return t3 = sr(t3), function(e4, t4) {
            if (t4 && ("object" == nr(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, ur() ? Reflect.construct(t3, r3 || [], sr(e3).constructor) : t3.apply(e3, r3));
        }
        function ur() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (ur = function() {
            return !!e3;
          })();
        }
        function sr(e3) {
          return sr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, sr(e3);
        }
        function cr(e3, t3) {
          return cr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, cr(e3, t3);
        }
        var lr = [6e4, 3e5, 9e5, 36e5, 864e5, 6048e5], fr = function(e3) {
          function t3(e4, r3, n2, o2, i2, a2, u2) {
            var s2;
            if (function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (s2 = ar(this, t3, [e4])).url.segment("trade_aggregations"), r3.isNative() ? s2.url.setQuery("base_asset_type", "native") : (s2.url.setQuery("base_asset_type", r3.getAssetType()), s2.url.setQuery("base_asset_code", r3.getCode()), s2.url.setQuery("base_asset_issuer", r3.getIssuer())), n2.isNative() ? s2.url.setQuery("counter_asset_type", "native") : (s2.url.setQuery("counter_asset_type", n2.getAssetType()), s2.url.setQuery("counter_asset_code", n2.getCode()), s2.url.setQuery("counter_asset_issuer", n2.getIssuer())), "number" != typeof o2 || "number" != typeof i2) throw new V.v7("Invalid time bounds", [o2, i2]);
            if (s2.url.setQuery("start_time", o2.toString()), s2.url.setQuery("end_time", i2.toString()), !s2.isValidResolution(a2)) throw new V.v7("Invalid resolution", a2);
            if (s2.url.setQuery("resolution", a2.toString()), !s2.isValidOffset(u2, a2)) throw new V.v7("Invalid offset", u2);
            return s2.url.setQuery("offset", u2.toString()), s2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && cr(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && or(e4.prototype, t4), r3 && or(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "isValidResolution", value: function(e4) {
            return lr.some(function(t4) {
              return t4 === e4;
            });
          } }, { key: "isValidOffset", value: function(e4, t4) {
            var r3 = 36e5;
            return !(e4 > t4 || e4 >= 24 * r3 || e4 % r3 != 0);
          } }]);
        }(ie);
        function pr(e3) {
          return pr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, pr(e3);
        }
        function dr(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, hr(n2.key), n2);
          }
        }
        function hr(e3) {
          var t3 = function(e4, t4) {
            if ("object" != pr(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != pr(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == pr(t3) ? t3 : t3 + "";
        }
        function yr(e3, t3, r3) {
          return t3 = vr(t3), function(e4, t4) {
            if (t4 && ("object" == pr(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, mr() ? Reflect.construct(t3, r3 || [], vr(e3).constructor) : t3.apply(e3, r3));
        }
        function mr() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (mr = function() {
            return !!e3;
          })();
        }
        function vr(e3) {
          return vr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, vr(e3);
        }
        function gr(e3, t3) {
          return gr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, gr(e3, t3);
        }
        var br = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = yr(this, t3, [e4, "trades"])).url.segment("trades"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && gr(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && dr(e4.prototype, t4), r3 && dr(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "forAssetPair", value: function(e4, t4) {
            return e4.isNative() ? this.url.setQuery("base_asset_type", "native") : (this.url.setQuery("base_asset_type", e4.getAssetType()), this.url.setQuery("base_asset_code", e4.getCode()), this.url.setQuery("base_asset_issuer", e4.getIssuer())), t4.isNative() ? this.url.setQuery("counter_asset_type", "native") : (this.url.setQuery("counter_asset_type", t4.getAssetType()), this.url.setQuery("counter_asset_code", t4.getCode()), this.url.setQuery("counter_asset_issuer", t4.getIssuer())), this;
          } }, { key: "forOffer", value: function(e4) {
            return this.url.setQuery("offer_id", e4), this;
          } }, { key: "forType", value: function(e4) {
            return this.url.setQuery("trade_type", e4), this;
          } }, { key: "forAccount", value: function(e4) {
            return this.forEndpoint("accounts", e4);
          } }, { key: "forLiquidityPool", value: function(e4) {
            return this.forEndpoint("liquidity_pools", e4);
          } }]);
        }(ie);
        function wr(e3) {
          return wr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, wr(e3);
        }
        function Sr(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, kr(n2.key), n2);
          }
        }
        function kr(e3) {
          var t3 = function(e4, t4) {
            if ("object" != wr(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != wr(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == wr(t3) ? t3 : t3 + "";
        }
        function Er(e3, t3, r3) {
          return t3 = Tr(t3), function(e4, t4) {
            if (t4 && ("object" == wr(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, _r() ? Reflect.construct(t3, r3 || [], Tr(e3).constructor) : t3.apply(e3, r3));
        }
        function _r() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (_r = function() {
            return !!e3;
          })();
        }
        function Tr(e3) {
          return Tr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, Tr(e3);
        }
        function Or(e3, t3) {
          return Or = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, Or(e3, t3);
        }
        var xr = function(e3) {
          function t3(e4) {
            var r3;
            return function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), (r3 = Er(this, t3, [e4, "transactions"])).url.segment("transactions"), r3;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && Or(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && Sr(e4.prototype, t4), r3 && Sr(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "transaction", value: function(e4) {
            var t4 = new ie(this.url.clone());
            return t4.filter.push([e4]), t4;
          } }, { key: "forAccount", value: function(e4) {
            return this.forEndpoint("accounts", e4);
          } }, { key: "forClaimableBalance", value: function(e4) {
            return this.forEndpoint("claimable_balances", e4);
          } }, { key: "forLedger", value: function(e4) {
            return this.forEndpoint("ledgers", e4.toString());
          } }, { key: "forLiquidityPool", value: function(e4) {
            return this.forEndpoint("liquidity_pools", e4);
          } }, { key: "includeFailed", value: function(e4) {
            return this.url.setQuery("include_failed", e4.toString()), this;
          } }]);
        }(ie);
        function Ar(e3) {
          return Ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, Ar(e3);
        }
        function Pr(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function Ir(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Pr(Object(r3), true).forEach(function(t4) {
              Rr(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : Pr(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function Rr(e3, t3, r3) {
          return (t3 = Nr(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function Cr() {
          Cr = function() {
            return t3;
          };
          var e3, t3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(e4, t4, r4) {
            e4[t4] = r4.value;
          }, i2 = "function" == typeof Symbol ? Symbol : {}, a2 = i2.iterator || "@@iterator", u2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
          function c2(e4, t4, r4) {
            return Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }), e4[t4];
          }
          try {
            c2({}, "");
          } catch (e4) {
            c2 = function(e5, t4, r4) {
              return e5[t4] = r4;
            };
          }
          function l2(e4, t4, r4, n3) {
            var i3 = t4 && t4.prototype instanceof v2 ? t4 : v2, a3 = Object.create(i3.prototype), u3 = new I2(n3 || []);
            return o2(a3, "_invoke", { value: O2(e4, r4, u3) }), a3;
          }
          function f2(e4, t4, r4) {
            try {
              return { type: "normal", arg: e4.call(t4, r4) };
            } catch (e5) {
              return { type: "throw", arg: e5 };
            }
          }
          t3.wrap = l2;
          var p2 = "suspendedStart", d2 = "suspendedYield", h2 = "executing", y2 = "completed", m2 = {};
          function v2() {
          }
          function g2() {
          }
          function b2() {
          }
          var w2 = {};
          c2(w2, a2, function() {
            return this;
          });
          var S2 = Object.getPrototypeOf, k2 = S2 && S2(S2(R2([])));
          k2 && k2 !== r3 && n2.call(k2, a2) && (w2 = k2);
          var E2 = b2.prototype = v2.prototype = Object.create(w2);
          function _2(e4) {
            ["next", "throw", "return"].forEach(function(t4) {
              c2(e4, t4, function(e5) {
                return this._invoke(t4, e5);
              });
            });
          }
          function T2(e4, t4) {
            function r4(o3, i4, a3, u3) {
              var s3 = f2(e4[o3], e4, i4);
              if ("throw" !== s3.type) {
                var c3 = s3.arg, l3 = c3.value;
                return l3 && "object" == Ar(l3) && n2.call(l3, "__await") ? t4.resolve(l3.__await).then(function(e5) {
                  r4("next", e5, a3, u3);
                }, function(e5) {
                  r4("throw", e5, a3, u3);
                }) : t4.resolve(l3).then(function(e5) {
                  c3.value = e5, a3(c3);
                }, function(e5) {
                  return r4("throw", e5, a3, u3);
                });
              }
              u3(s3.arg);
            }
            var i3;
            o2(this, "_invoke", { value: function(e5, n3) {
              function o3() {
                return new t4(function(t5, o4) {
                  r4(e5, n3, t5, o4);
                });
              }
              return i3 = i3 ? i3.then(o3, o3) : o3();
            } });
          }
          function O2(t4, r4, n3) {
            var o3 = p2;
            return function(i3, a3) {
              if (o3 === h2) throw Error("Generator is already running");
              if (o3 === y2) {
                if ("throw" === i3) throw a3;
                return { value: e3, done: true };
              }
              for (n3.method = i3, n3.arg = a3; ; ) {
                var u3 = n3.delegate;
                if (u3) {
                  var s3 = x2(u3, n3);
                  if (s3) {
                    if (s3 === m2) continue;
                    return s3;
                  }
                }
                if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
                else if ("throw" === n3.method) {
                  if (o3 === p2) throw o3 = y2, n3.arg;
                  n3.dispatchException(n3.arg);
                } else "return" === n3.method && n3.abrupt("return", n3.arg);
                o3 = h2;
                var c3 = f2(t4, r4, n3);
                if ("normal" === c3.type) {
                  if (o3 = n3.done ? y2 : d2, c3.arg === m2) continue;
                  return { value: c3.arg, done: n3.done };
                }
                "throw" === c3.type && (o3 = y2, n3.method = "throw", n3.arg = c3.arg);
              }
            };
          }
          function x2(t4, r4) {
            var n3 = r4.method, o3 = t4.iterator[n3];
            if (o3 === e3) return r4.delegate = null, "throw" === n3 && t4.iterator.return && (r4.method = "return", r4.arg = e3, x2(t4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), m2;
            var i3 = f2(o3, t4.iterator, r4.arg);
            if ("throw" === i3.type) return r4.method = "throw", r4.arg = i3.arg, r4.delegate = null, m2;
            var a3 = i3.arg;
            return a3 ? a3.done ? (r4[t4.resultName] = a3.value, r4.next = t4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = e3), r4.delegate = null, m2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, m2);
          }
          function A2(e4) {
            var t4 = { tryLoc: e4[0] };
            1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
          }
          function P2(e4) {
            var t4 = e4.completion || {};
            t4.type = "normal", delete t4.arg, e4.completion = t4;
          }
          function I2(e4) {
            this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
          }
          function R2(t4) {
            if (t4 || "" === t4) {
              var r4 = t4[a2];
              if (r4) return r4.call(t4);
              if ("function" == typeof t4.next) return t4;
              if (!isNaN(t4.length)) {
                var o3 = -1, i3 = function r5() {
                  for (; ++o3 < t4.length; ) if (n2.call(t4, o3)) return r5.value = t4[o3], r5.done = false, r5;
                  return r5.value = e3, r5.done = true, r5;
                };
                return i3.next = i3;
              }
            }
            throw new TypeError(Ar(t4) + " is not iterable");
          }
          return g2.prototype = b2, o2(E2, "constructor", { value: b2, configurable: true }), o2(b2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(b2, s2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
            var t4 = "function" == typeof e4 && e4.constructor;
            return !!t4 && (t4 === g2 || "GeneratorFunction" === (t4.displayName || t4.name));
          }, t3.mark = function(e4) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e4, b2) : (e4.__proto__ = b2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(E2), e4;
          }, t3.awrap = function(e4) {
            return { __await: e4 };
          }, _2(T2.prototype), c2(T2.prototype, u2, function() {
            return this;
          }), t3.AsyncIterator = T2, t3.async = function(e4, r4, n3, o3, i3) {
            void 0 === i3 && (i3 = Promise);
            var a3 = new T2(l2(e4, r4, n3, o3), i3);
            return t3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(e5) {
              return e5.done ? e5.value : a3.next();
            });
          }, _2(E2), c2(E2, s2, "Generator"), c2(E2, a2, function() {
            return this;
          }), c2(E2, "toString", function() {
            return "[object Generator]";
          }), t3.keys = function(e4) {
            var t4 = Object(e4), r4 = [];
            for (var n3 in t4) r4.push(n3);
            return r4.reverse(), function e5() {
              for (; r4.length; ) {
                var n4 = r4.pop();
                if (n4 in t4) return e5.value = n4, e5.done = false, e5;
              }
              return e5.done = true, e5;
            };
          }, t3.values = R2, I2.prototype = { constructor: I2, reset: function(t4) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(P2), !t4) for (var r4 in this) "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = e3);
          }, stop: function() {
            this.done = true;
            var e4 = this.tryEntries[0].completion;
            if ("throw" === e4.type) throw e4.arg;
            return this.rval;
          }, dispatchException: function(t4) {
            if (this.done) throw t4;
            var r4 = this;
            function o3(n3, o4) {
              return u3.type = "throw", u3.arg = t4, r4.next = n3, o4 && (r4.method = "next", r4.arg = e3), !!o4;
            }
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var a3 = this.tryEntries[i3], u3 = a3.completion;
              if ("root" === a3.tryLoc) return o3("end");
              if (a3.tryLoc <= this.prev) {
                var s3 = n2.call(a3, "catchLoc"), c3 = n2.call(a3, "finallyLoc");
                if (s3 && c3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                } else if (s3) {
                  if (this.prev < a3.catchLoc) return o3(a3.catchLoc, true);
                } else {
                  if (!c3) throw Error("try statement without catch or finally");
                  if (this.prev < a3.finallyLoc) return o3(a3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e4, t4) {
            for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
              var o3 = this.tryEntries[r4];
              if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
                var i3 = o3;
                break;
              }
            }
            i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
            var a3 = i3 ? i3.completion : {};
            return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, m2) : this.complete(a3);
          }, complete: function(e4, t4) {
            if ("throw" === e4.type) throw e4.arg;
            return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m2;
          }, finish: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.finallyLoc === e4) return this.complete(r4.completion, r4.afterLoc), P2(r4), m2;
            }
          }, catch: function(e4) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r4 = this.tryEntries[t4];
              if (r4.tryLoc === e4) {
                var n3 = r4.completion;
                if ("throw" === n3.type) {
                  var o3 = n3.arg;
                  P2(r4);
                }
                return o3;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(t4, r4, n3) {
            return this.delegate = { iterator: R2(t4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = e3), m2;
          } }, t3;
        }
        function jr(e3, t3, r3, n2, o2, i2, a2) {
          try {
            var u2 = e3[i2](a2), s2 = u2.value;
          } catch (e4) {
            return void r3(e4);
          }
          u2.done ? t3(s2) : Promise.resolve(s2).then(n2, o2);
        }
        function Br(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, o2) {
              var i2 = e3.apply(t3, r3);
              function a2(e4) {
                jr(i2, n2, o2, a2, u2, "next", e4);
              }
              function u2(e4) {
                jr(i2, n2, o2, a2, u2, "throw", e4);
              }
              a2(void 0);
            });
          };
        }
        function Lr(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Nr(n2.key), n2);
          }
        }
        function Nr(e3) {
          var t3 = function(e4, t4) {
            if ("object" != Ar(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != Ar(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == Ar(t3) ? t3 : t3 + "";
        }
        function Ur(e3) {
          return new N(e3).div(1e7).toString();
        }
        var Mr, Fr, Dr, Vr, qr, Kr, Hr, zr, Xr = function(e3, t3, r3) {
          return t3 && Lr(e3.prototype, t3), r3 && Lr(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
        }(function e3(t3) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          !function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), this.serverURL = M()(t3);
          var n2 = void 0 === r3.allowHttp ? ae.T.isAllowHttp() : r3.allowHttp, o2 = {};
          if (r3.appName && (o2["X-App-Name"] = r3.appName), r3.appVersion && (o2["X-App-Version"] = r3.appVersion), r3.authToken && (o2["X-Auth-Token"] = r3.authToken), r3.headers && Object.assign(o2, r3.headers), Object.keys(o2).length > 0 && $.interceptors.request.use(function(e4) {
            return e4.headers = e4.headers || {}, e4.headers = Object.assign(e4.headers, o2), e4;
          }), "https" !== this.serverURL.protocol() && !n2) throw new Error("Cannot connect to insecure horizon server");
        }, [{ key: "fetchTimebounds", value: (zr = Br(Cr().mark(function e3(t3) {
          var r3, n2, o2 = arguments;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if (r3 = o2.length > 1 && void 0 !== o2[1] && o2[1], !(n2 = Q(this.serverURL.hostname()))) {
                  e4.next = 4;
                  break;
                }
                return e4.abrupt("return", { minTime: 0, maxTime: n2 + t3 });
              case 4:
                if (!r3) {
                  e4.next = 6;
                  break;
                }
                return e4.abrupt("return", { minTime: 0, maxTime: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3) + t3 });
              case 6:
                return e4.next = 8, $.get(M()(this.serverURL).toString());
              case 8:
                return e4.abrupt("return", this.fetchTimebounds(t3, true));
              case 9:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return zr.apply(this, arguments);
        }) }, { key: "fetchBaseFee", value: (Hr = Br(Cr().mark(function e3() {
          var t3;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.next = 2, this.feeStats();
              case 2:
                return t3 = e4.sent, e4.abrupt("return", parseInt(t3.last_ledger_base_fee, 10) || 100);
              case 4:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return Hr.apply(this, arguments);
        }) }, { key: "feeStats", value: (Kr = Br(Cr().mark(function e3() {
          var t3;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return (t3 = new ie(M()(this.serverURL))).filter.push(["fee_stats"]), e4.abrupt("return", t3.call());
              case 3:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return Kr.apply(this, arguments);
        }) }, { key: "root", value: (qr = Br(Cr().mark(function e3() {
          var t3;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return t3 = new ie(M()(this.serverURL)), e4.abrupt("return", t3.call());
              case 2:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function() {
          return qr.apply(this, arguments);
        }) }, { key: "submitTransaction", value: (Vr = Br(Cr().mark(function e3(t3) {
          var r3, n2 = arguments;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if ((n2.length > 1 && void 0 !== n2[1] ? n2[1] : { skipMemoRequiredCheck: false }).skipMemoRequiredCheck) {
                  e4.next = 4;
                  break;
                }
                return e4.next = 4, this.checkMemoRequired(t3);
              case 4:
                return r3 = encodeURIComponent(t3.toEnvelope().toXDR().toString("base64")), e4.abrupt("return", $.post(M()(this.serverURL).segment("transactions").toString(), "tx=".concat(r3), { timeout: 6e4 }).then(function(e5) {
                  if (!e5.data.result_xdr) return e5.data;
                  var t4, r4, n3 = u.xdr.TransactionResult.fromXDR(e5.data.result_xdr, "base64").result().value();
                  return n3.length && (t4 = n3.map(function(e6, t5) {
                    if ("manageBuyOffer" !== e6.value().switch().name && "manageSellOffer" !== e6.value().switch().name) return null;
                    r4 = true;
                    var n4, o2 = new N(0), i2 = new N(0), a2 = e6.value().value().success(), s2 = a2.offersClaimed().map(function(e7) {
                      var t6 = e7.value(), r5 = "";
                      switch (e7.switch()) {
                        case u.xdr.ClaimAtomType.claimAtomTypeV0():
                          r5 = u.StrKey.encodeEd25519PublicKey(t6.sellerEd25519());
                          break;
                        case u.xdr.ClaimAtomType.claimAtomTypeOrderBook():
                          r5 = u.StrKey.encodeEd25519PublicKey(t6.sellerId().ed25519());
                          break;
                        default:
                          throw new Error("Invalid offer result type: ".concat(e7.switch()));
                      }
                      var n5 = new N(t6.amountBought().toString()), a3 = new N(t6.amountSold().toString());
                      o2 = o2.plus(a3), i2 = i2.plus(n5);
                      var s3 = u.Asset.fromOperation(t6.assetSold()), c3 = u.Asset.fromOperation(t6.assetBought()), l3 = { type: s3.getAssetType(), assetCode: s3.getCode(), issuer: s3.getIssuer() }, f3 = { type: c3.getAssetType(), assetCode: c3.getCode(), issuer: c3.getIssuer() };
                      return { sellerId: r5, offerId: t6.offerId().toString(), assetSold: l3, amountSold: Ur(a3), assetBought: f3, amountBought: Ur(n5) };
                    }), c2 = a2.offer().switch().name;
                    if ("function" == typeof a2.offer().value && a2.offer().value()) {
                      var l2 = a2.offer().value();
                      n4 = { offerId: l2.offerId().toString(), selling: {}, buying: {}, amount: Ur(l2.amount().toString()), price: { n: l2.price().n(), d: l2.price().d() } };
                      var f2 = u.Asset.fromOperation(l2.selling());
                      n4.selling = { type: f2.getAssetType(), assetCode: f2.getCode(), issuer: f2.getIssuer() };
                      var p2 = u.Asset.fromOperation(l2.buying());
                      n4.buying = { type: p2.getAssetType(), assetCode: p2.getCode(), issuer: p2.getIssuer() };
                    }
                    return { offersClaimed: s2, effect: c2, operationIndex: t5, currentOffer: n4, amountBought: Ur(o2), amountSold: Ur(i2), isFullyOpen: !s2.length && "manageOfferDeleted" !== c2, wasPartiallyFilled: !!s2.length && "manageOfferDeleted" !== c2, wasImmediatelyFilled: !!s2.length && "manageOfferDeleted" === c2, wasImmediatelyDeleted: !s2.length && "manageOfferDeleted" === c2 };
                  }).filter(function(e6) {
                    return !!e6;
                  })), Ir(Ir({}, e5.data), {}, { offerResults: r4 ? t4 : void 0 });
                }).catch(function(e5) {
                  return e5 instanceof Error ? Promise.reject(e5) : Promise.reject(new V.nS("Transaction submission failed. Server responded: ".concat(e5.status, " ").concat(e5.statusText), e5.data));
                }));
              case 6:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return Vr.apply(this, arguments);
        }) }, { key: "submitAsyncTransaction", value: (Dr = Br(Cr().mark(function e3(t3) {
          var r3, n2 = arguments;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if ((n2.length > 1 && void 0 !== n2[1] ? n2[1] : { skipMemoRequiredCheck: false }).skipMemoRequiredCheck) {
                  e4.next = 4;
                  break;
                }
                return e4.next = 4, this.checkMemoRequired(t3);
              case 4:
                return r3 = encodeURIComponent(t3.toEnvelope().toXDR().toString("base64")), e4.abrupt("return", $.post(M()(this.serverURL).segment("transactions_async").toString(), "tx=".concat(r3)).then(function(e5) {
                  return e5.data;
                }).catch(function(e5) {
                  return e5 instanceof Error ? Promise.reject(e5) : Promise.reject(new V.nS("Transaction submission failed. Server responded: ".concat(e5.status, " ").concat(e5.statusText), e5.data));
                }));
              case 6:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return Dr.apply(this, arguments);
        }) }, { key: "accounts", value: function() {
          return new he(M()(this.serverURL));
        } }, { key: "claimableBalances", value: function() {
          return new Ie(M()(this.serverURL));
        } }, { key: "ledgers", value: function() {
          return new et(M()(this.serverURL));
        } }, { key: "transactions", value: function() {
          return new xr(M()(this.serverURL));
        } }, { key: "offers", value: function() {
          return new mt(M()(this.serverURL));
        } }, { key: "orderbook", value: function(e3, t3) {
          return new Ct(M()(this.serverURL), e3, t3);
        } }, { key: "trades", value: function() {
          return new br(M()(this.serverURL));
        } }, { key: "operations", value: function() {
          return new _t(M()(this.serverURL));
        } }, { key: "liquidityPools", value: function() {
          return new st(M()(this.serverURL));
        } }, { key: "strictReceivePaths", value: function(e3, t3, r3) {
          return new $t(M()(this.serverURL), e3, t3, r3);
        } }, { key: "strictSendPaths", value: function(e3, t3, r3) {
          return new rr(M()(this.serverURL), e3, t3, r3);
        } }, { key: "payments", value: function() {
          return new Dt(M()(this.serverURL));
        } }, { key: "effects", value: function() {
          return new Me(M()(this.serverURL));
        } }, { key: "friendbot", value: function(e3) {
          return new Xe(M()(this.serverURL), e3);
        } }, { key: "assets", value: function() {
          return new ke(M()(this.serverURL));
        } }, { key: "loadAccount", value: (Fr = Br(Cr().mark(function e3(t3) {
          var r3;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                return e4.next = 2, this.accounts().accountId(t3).call();
              case 2:
                return r3 = e4.sent, e4.abrupt("return", new m(r3));
              case 4:
              case "end":
                return e4.stop();
            }
          }, e3, this);
        })), function(e3) {
          return Fr.apply(this, arguments);
        }) }, { key: "tradeAggregation", value: function(e3, t3, r3, n2, o2, i2) {
          return new fr(M()(this.serverURL), e3, t3, r3, n2, o2, i2);
        } }, { key: "checkMemoRequired", value: (Mr = Br(Cr().mark(function e3(t3) {
          var r3, n2, o2, i2;
          return Cr().wrap(function(e4) {
            for (; ; ) switch (e4.prev = e4.next) {
              case 0:
                if (t3 instanceof u.FeeBumpTransaction && (t3 = t3.innerTransaction), "none" === t3.memo.type) {
                  e4.next = 3;
                  break;
                }
                return e4.abrupt("return");
              case 3:
                r3 = /* @__PURE__ */ new Set(), n2 = 0;
              case 5:
                if (!(n2 < t3.operations.length)) {
                  e4.next = 36;
                  break;
                }
                o2 = t3.operations[n2], e4.t0 = o2.type, e4.next = "payment" === e4.t0 || "pathPaymentStrictReceive" === e4.t0 || "pathPaymentStrictSend" === e4.t0 || "accountMerge" === e4.t0 ? 10 : 11;
                break;
              case 10:
                return e4.abrupt("break", 12);
              case 11:
                return e4.abrupt("continue", 33);
              case 12:
                if (i2 = o2.destination, !r3.has(i2)) {
                  e4.next = 15;
                  break;
                }
                return e4.abrupt("continue", 33);
              case 15:
                if (r3.add(i2), !i2.startsWith("M")) {
                  e4.next = 18;
                  break;
                }
                return e4.abrupt("continue", 33);
              case 18:
                return e4.prev = 18, e4.next = 21, this.loadAccount(i2);
              case 21:
                if ("MQ==" !== e4.sent.data_attr["config.memo_required"]) {
                  e4.next = 24;
                  break;
                }
                throw new V.Cu("account requires memo", i2, n2);
              case 24:
                e4.next = 33;
                break;
              case 26:
                if (e4.prev = 26, e4.t1 = e4.catch(18), !(e4.t1 instanceof V.Cu)) {
                  e4.next = 30;
                  break;
                }
                throw e4.t1;
              case 30:
                if (e4.t1 instanceof V.m_) {
                  e4.next = 32;
                  break;
                }
                throw e4.t1;
              case 32:
                return e4.abrupt("continue", 33);
              case 33:
                n2 += 1, e4.next = 5;
                break;
              case 36:
              case "end":
                return e4.stop();
            }
          }, e3, this, [[18, 26]]);
        })), function(e3) {
          return Mr.apply(this, arguments);
        }) }]);
        const Gr = (e2 = r2.hmd(e2)).exports;
      }, 8752: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.extendFootprintTtl = function(e3) {
          var t3;
          if ((null !== (t3 = e3.extendTo) && void 0 !== t3 ? t3 : -1) <= 0) throw new RangeError("extendTo has to be positive");
          var r3 = new o.default.ExtendFootprintTtlOp({ ext: new o.default.ExtensionPoint(0), extendTo: e3.extendTo }), n2 = { body: o.default.OperationBody.extendFootprintTtl(r3) };
          return this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 8920: (e2, t2, r2) => {
        "use strict";
        var _a;
        async function n(e3, t3) {
          const r3 = { config: e3 };
          return r3.status = t3.status, r3.statusText = t3.statusText, r3.headers = t3.headers, "stream" === e3.responseType ? (r3.data = t3.body, r3) : t3[e3.responseType || "text"]().then((n2) => {
            e3.transformResponse ? (Array.isArray(e3.transformResponse) ? e3.transformResponse.map((r4) => n2 = r4.call(e3, n2, t3 == null ? void 0 : t3.headers, t3 == null ? void 0 : t3.status)) : n2 = e3.transformResponse(n2, t3 == null ? void 0 : t3.headers, t3 == null ? void 0 : t3.status), r3.data = n2) : (r3.data = n2, r3.data = JSON.parse(n2));
          }).catch(Object).then(() => r3);
        }
        function o(e3) {
          let t3 = e3.url || "";
          return e3.baseURL && e3.url && (t3 = e3.url.replace(/^(?!.*\/\/)\/?/, `${e3.baseURL}/`)), e3.params && Object.keys(e3.params).length > 0 && e3.url && (t3 += (~e3.url.indexOf("?") ? "&" : "?") + (e3.paramsSerializer ? e3.paramsSerializer(e3.params) : new URLSearchParams(e3.params))), t3;
        }
        function i(e3, t3) {
          const r3 = { ...t3, ...e3 };
          if ((t3 == null ? void 0 : t3.params) && (e3 == null ? void 0 : e3.params) && (r3.params = { ...t3 == null ? void 0 : t3.params, ...e3 == null ? void 0 : e3.params }), (t3 == null ? void 0 : t3.headers) && (e3 == null ? void 0 : e3.headers)) {
            r3.headers = new Headers(t3.headers || {});
            new Headers(e3.headers || {}).forEach((e4, t4) => {
              r3.headers.set(t4, e4);
            });
          }
          return r3;
        }
        function a(e3, t3) {
          const r3 = t3.get("content-type");
          return r3 ? "application/x-www-form-urlencoded" !== r3 || e3 instanceof URLSearchParams ? "application/json" === r3 && "object" == typeof e3 && (e3 = JSON.stringify(e3)) : e3 = new URLSearchParams(e3) : "string" == typeof e3 ? t3.set("content-type", "text/plain") : e3 instanceof URLSearchParams ? t3.set("content-type", "application/x-www-form-urlencoded") : e3 instanceof Blob || e3 instanceof ArrayBuffer || ArrayBuffer.isView(e3) ? t3.set("content-type", "application/octet-stream") : "object" == typeof e3 && "function" != typeof e3.append && "function" != typeof e3.text && (e3 = JSON.stringify(e3), t3.set("content-type", "application/json")), e3;
        }
        async function u(e3, t3, r3, s2, c2, p2) {
          var _a2;
          "string" == typeof e3 ? (t3 = t3 || {}).url = e3 : t3 = e3 || {};
          const d2 = i(t3, r3 || {});
          if (d2.fetchOptions = d2.fetchOptions || {}, d2.timeout = d2.timeout || 0, d2.headers = new Headers(d2.headers || {}), d2.transformRequest = d2.transformRequest ?? a, p2 = p2 || d2.data, d2.transformRequest && p2 && (Array.isArray(d2.transformRequest) ? d2.transformRequest.map((e4) => p2 = e4.call(d2, p2, d2.headers)) : p2 = d2.transformRequest(p2, d2.headers)), d2.url = o(d2), d2.method = s2 || d2.method || "get", c2 && c2.request.handlers.length > 0) {
            const e4 = c2.request.handlers.filter((e5) => !(e5 == null ? void 0 : e5.runWhen) || "function" == typeof e5.runWhen && e5.runWhen(d2)).flatMap((e5) => [e5.fulfilled, e5.rejected]);
            let t4 = d2;
            for (let r4 = 0, n2 = e4.length; r4 < n2; r4 += 2) {
              const n3 = e4[r4], o2 = e4[r4 + 1];
              try {
                n3 && (t4 = n3(t4));
              } catch (e5) {
                o2 && (o2 == null ? void 0 : o2(e5));
                break;
              }
            }
          }
          const h2 = function(e4, t4) {
            const r4 = { ...t4, ...e4 };
            (t4 == null ? void 0 : t4.headers) && (e4 == null ? void 0 : e4.headers) && (r4.headers = new Headers(t4.headers || {}), new Headers(e4.headers || {}).forEach((e5, t5) => {
              r4.headers.set(t5, e5);
            }));
            return r4;
          }({ method: (_a2 = d2.method) == null ? void 0 : _a2.toUpperCase(), body: p2, headers: d2.headers, credentials: d2.withCredentials ? "include" : void 0, signal: d2.signal }, d2.fetchOptions);
          let y2 = async function(e4, t4) {
            let r4 = null;
            if ("any" in AbortSignal) {
              const r5 = [];
              e4.timeout && r5.push(AbortSignal.timeout(e4.timeout)), e4.signal && r5.push(e4.signal), r5.length > 0 && (t4.signal = AbortSignal.any(r5));
            } else e4.timeout && (t4.signal = AbortSignal.timeout(e4.timeout));
            try {
              return r4 = await fetch(e4.url, t4), (e4.validateStatus ? e4.validateStatus(r4.status) : r4.ok) ? await n(e4, r4) : Promise.reject(new l(`Request failed with status code ${r4 == null ? void 0 : r4.status}`, [l.ERR_BAD_REQUEST, l.ERR_BAD_RESPONSE][Math.floor((r4 == null ? void 0 : r4.status) / 100) - 4], e4, new Request(e4.url, t4), await n(e4, r4)));
            } catch (t5) {
              if ("AbortError" === t5.name || "TimeoutError" === t5.name) {
                const r5 = "TimeoutError" === t5.name;
                return Promise.reject(r5 ? new l(e4.timeoutErrorMessage || `timeout of ${e4.timeout} ms exceeded`, l.ECONNABORTED, e4, u) : new f(null, e4));
              }
              return Promise.reject(new l(t5.message, void 0, e4, u, void 0));
            }
          }(d2, h2);
          if (c2 && c2.response.handlers.length > 0) {
            const e4 = c2.response.handlers.flatMap((e5) => [e5.fulfilled, e5.rejected]);
            for (let t4 = 0, r4 = e4.length; t4 < r4; t4 += 2) y2 = y2.then(e4[t4], e4[t4 + 1]);
          }
          return y2;
        }
        r2.r(t2), r2.d(t2, { create: () => O, fetchClient: () => x });
        var s = class {
          constructor() {
            __publicField(this, "handlers", []);
            __publicField(this, "use", (e3, t3, r3) => (this.handlers.push({ fulfilled: e3, rejected: t3, runWhen: r3 == null ? void 0 : r3.runWhen }), this.handlers.length - 1));
            __publicField(this, "eject", (e3) => {
              this.handlers[e3] && (this.handlers[e3] = null);
            });
            __publicField(this, "clear", () => {
              this.handlers = [];
            });
            this.handlers = [];
          }
        };
        function c(e3) {
          e3 = e3 || {};
          const t3 = { request: new s(), response: new s() }, r3 = (r4, n2) => u(r4, n2, e3, void 0, t3);
          return r3.defaults = e3, r3.interceptors = t3, r3.getUri = (t4) => o(i(t4 || {}, e3)), r3.request = (r4) => u(r4, void 0, e3, void 0, t3), ["get", "delete", "head", "options"].forEach((n2) => {
            r3[n2] = (r4, o2) => u(r4, o2, e3, n2, t3);
          }), ["post", "put", "patch"].forEach((n2) => {
            r3[n2] = (r4, o2, i2) => u(r4, i2, e3, n2, t3, o2);
          }), ["postForm", "putForm", "patchForm"].forEach((n2) => {
            r3[n2] = (r4, o2, i2) => ((i2 = i2 || {}).headers = new Headers(i2.headers || {}), i2.headers.set("content-type", "application/x-www-form-urlencoded"), u(r4, i2, e3, n2.replace("Form", ""), t3, o2));
          }), r3;
        }
        var l = (_a = class extends Error {
          constructor(e3, t3, r3, n2, o2) {
            super(e3);
            __publicField(this, "config");
            __publicField(this, "code");
            __publicField(this, "request");
            __publicField(this, "response");
            __publicField(this, "status");
            __publicField(this, "isAxiosError");
            Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.name = "AxiosError", this.code = t3, this.config = r3, this.request = n2, this.response = o2, this.isAxiosError = true;
          }
        }, __publicField(_a, "ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION_VALUE"), __publicField(_a, "ERR_BAD_OPTION", "ERR_BAD_OPTION"), __publicField(_a, "ERR_NETWORK", "ERR_NETWORK"), __publicField(_a, "ERR_BAD_RESPONSE", "ERR_BAD_RESPONSE"), __publicField(_a, "ERR_BAD_REQUEST", "ERR_BAD_REQUEST"), __publicField(_a, "ERR_INVALID_URL", "ERR_INVALID_URL"), __publicField(_a, "ERR_CANCELED", "ERR_CANCELED"), __publicField(_a, "ECONNABORTED", "ECONNABORTED"), __publicField(_a, "ETIMEDOUT", "ETIMEDOUT"), _a), f = class extends l {
          constructor(e3, t3, r3) {
            super(e3 || "canceled", l.ERR_CANCELED, t3, r3), this.name = "CanceledError";
          }
        };
        var p = c();
        p.create = (e3) => c(e3);
        var d = p, h = r2(5798);
        function y(e3) {
          return y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, y(e3);
        }
        function m(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e3);
            t3 && (n2 = n2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function v(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? m(Object(r3), true).forEach(function(t4) {
              b(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : m(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function g(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, w(n2.key), n2);
          }
        }
        function b(e3, t3, r3) {
          return (t3 = w(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function w(e3) {
          var t3 = function(e4, t4) {
            if ("object" != y(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != y(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == y(t3) ? t3 : t3 + "";
        }
        var S, k, E, _ = (S = function e3() {
          !function(e4, t3) {
            if (!(e4 instanceof t3)) throw new TypeError("Cannot call a class as a function");
          }(this, e3), b(this, "handlers", []);
        }, (k = [{ key: "use", value: function(e3, t3) {
          return this.handlers.push({ fulfilled: e3, rejected: t3 }), this.handlers.length - 1;
        } }, { key: "eject", value: function(e3) {
          this.handlers[e3] && (this.handlers[e3] = null);
        } }, { key: "forEach", value: function(e3) {
          this.handlers.forEach(function(t3) {
            null !== t3 && e3(t3);
          });
        } }]) && g(S.prototype, k), E && g(S, E), Object.defineProperty(S, "prototype", { writable: false }), S);
        function T(e3) {
          var t3 = e3 || {};
          return t3.headers = new Headers(t3.headers || {}), t3.headers.set("Content-Type", "application/x-www-form-urlencoded"), t3;
        }
        function O() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = v(v({}, e3), {}, { headers: e3.headers || {} }), r3 = d.create(t3), n2 = new _(), o2 = new _();
          return { interceptors: { request: n2, response: o2 }, defaults: v(v({}, t3), {}, { adapter: function(e4) {
            return r3.request(e4);
          } }), create: function(e4) {
            return O(v(v({}, this.defaults), e4));
          }, makeRequest: function(e4) {
            var t4 = this;
            return new Promise(function(r4, i2) {
              var a2 = new AbortController();
              e4.signal = a2.signal, e4.cancelToken && e4.cancelToken.promise.then(function() {
                a2.abort(), i2(new Error("Request canceled"));
              });
              var u2 = e4;
              if (n2.handlers.length > 0) for (var s2 = n2.handlers.filter(function(e5) {
                return null !== e5;
              }).flatMap(function(e5) {
                return [e5.fulfilled, e5.rejected];
              }), c2 = 0, l2 = s2.length; c2 < l2; c2 += 2) {
                var f2 = s2[c2], p2 = s2[c2 + 1];
                try {
                  f2 && (u2 = f2(u2));
                } catch (e5) {
                  return p2 && (null == p2 || p2(e5)), void i2(e5);
                }
              }
              var d2 = u2.adapter || t4.defaults.adapter;
              if (!d2) throw new Error("No adapter available");
              var h2 = d2(u2).then(function(e5) {
                return { data: e5.data, headers: e5.headers, config: e5.config, status: e5.status, statusText: e5.statusText };
              });
              if (o2.handlers.length > 0) for (var y2 = o2.handlers.filter(function(e5) {
                return null !== e5;
              }).flatMap(function(e5) {
                return [e5.fulfilled, e5.rejected];
              }), m2 = function(e5) {
                h2 = h2.then(function(t5) {
                  var r5 = y2[e5];
                  return "function" == typeof r5 ? r5(t5) : t5;
                }, function(t5) {
                  var r5 = y2[e5 + 1];
                  if ("function" == typeof r5) return r5(t5);
                  throw t5;
                }).then(function(e6) {
                  return e6;
                });
              }, v2 = 0, g2 = y2.length; v2 < g2; v2 += 2) m2(v2);
              h2.then(r4).catch(i2);
            });
          }, get: function(e4, t4) {
            return this.makeRequest(v(v(v({}, this.defaults), t4), {}, { url: e4, method: "get" }));
          }, delete: function(e4, t4) {
            return this.makeRequest(v(v(v({}, this.defaults), t4), {}, { url: e4, method: "delete" }));
          }, head: function(e4, t4) {
            return this.makeRequest(v(v(v({}, this.defaults), t4), {}, { url: e4, method: "head" }));
          }, options: function(e4, t4) {
            return this.makeRequest(v(v(v({}, this.defaults), t4), {}, { url: e4, method: "options" }));
          }, post: function(e4, t4, r4) {
            return this.makeRequest(v(v(v({}, this.defaults), r4), {}, { url: e4, method: "post", data: t4 }));
          }, put: function(e4, t4, r4) {
            return this.makeRequest(v(v(v({}, this.defaults), r4), {}, { url: e4, method: "put", data: t4 }));
          }, patch: function(e4, t4, r4) {
            return this.makeRequest(v(v(v({}, this.defaults), r4), {}, { url: e4, method: "patch", data: t4 }));
          }, postForm: function(e4, t4, r4) {
            var n3 = T(r4);
            return this.makeRequest(v(v(v({}, this.defaults), n3), {}, { url: e4, method: "post", data: t4 }));
          }, putForm: function(e4, t4, r4) {
            var n3 = T(r4);
            return this.makeRequest(v(v(v({}, this.defaults), n3), {}, { url: e4, method: "put", data: t4 }));
          }, patchForm: function(e4, t4, r4) {
            var n3 = T(r4);
            return this.makeRequest(v(v(v({}, this.defaults), n3), {}, { url: e4, method: "patch", data: t4 }));
          }, CancelToken: h.q, isCancel: function(e4) {
            return e4 instanceof Error && "Request canceled" === e4.message;
          } };
        }
        var x = O();
      }, 9073: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createPassiveSellOffer = function(e3) {
          var t3 = {};
          if (t3.selling = e3.selling.toXDRObject(), t3.buying = e3.buying.toXDRObject(), !this.isValidAmount(e3.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (t3.amount = this._toXDRAmount(e3.amount), void 0 === e3.price) throw new TypeError("price argument is required");
          t3.price = this._toXDRPrice(e3.price);
          var r3 = new o.default.CreatePassiveSellOfferOp(t3), n2 = {};
          return n2.body = o.default.OperationBody.createPassiveSellOffer(r3), this.setSourceAccount(n2, e3), new o.default.Operation(n2);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      }, 9127: function(e2, t2, r2) {
        var n, o, i;
        !function(a, u) {
          "use strict";
          e2.exports ? e2.exports = u(r2(4193)) : (o = [r2(4193)], void 0 === (i = "function" == typeof (n = u) ? n.apply(t2, o) : n) || (e2.exports = i));
        }(0, function(e3, t3) {
          "use strict";
          var r3 = t3 && t3.URITemplate, n2 = Object.prototype.hasOwnProperty;
          function o2(e4) {
            return o2._cache[e4] ? o2._cache[e4] : this instanceof o2 ? (this.expression = e4, o2._cache[e4] = this, this) : new o2(e4);
          }
          function i2(e4) {
            this.data = e4, this.cache = {};
          }
          var a = o2.prototype, u = { "": { prefix: "", separator: ",", named: false, empty_name_separator: false, encode: "encode" }, "+": { prefix: "", separator: ",", named: false, empty_name_separator: false, encode: "encodeReserved" }, "#": { prefix: "#", separator: ",", named: false, empty_name_separator: false, encode: "encodeReserved" }, ".": { prefix: ".", separator: ".", named: false, empty_name_separator: false, encode: "encode" }, "/": { prefix: "/", separator: "/", named: false, empty_name_separator: false, encode: "encode" }, ";": { prefix: ";", separator: ";", named: true, empty_name_separator: false, encode: "encode" }, "?": { prefix: "?", separator: "&", named: true, empty_name_separator: true, encode: "encode" }, "&": { prefix: "&", separator: "&", named: true, empty_name_separator: true, encode: "encode" } };
          return o2._cache = {}, o2.EXPRESSION_PATTERN = /\{([^a-zA-Z0-9%_]?)([^\}]+)(\}|$)/g, o2.VARIABLE_PATTERN = /^([^*:.](?:\.?[^*:.])*)((\*)|:(\d+))?$/, o2.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/, o2.LITERAL_PATTERN = /[<>{}"`^| \\]/, o2.expand = function(e4, t4, r4) {
            var n3, i3, a2, s = u[e4.operator], c = s.named ? "Named" : "Unnamed", l = e4.variables, f = [];
            for (a2 = 0; i3 = l[a2]; a2++) {
              if (0 === (n3 = t4.get(i3.name)).type && r4 && r4.strict) throw new Error('Missing expansion value for variable "' + i3.name + '"');
              if (n3.val.length) {
                if (n3.type > 1 && i3.maxlength) throw new Error('Invalid expression: Prefix modifier not applicable to variable "' + i3.name + '"');
                f.push(o2["expand" + c](n3, s, i3.explode, i3.explode && s.separator || ",", i3.maxlength, i3.name));
              } else n3.type && f.push("");
            }
            return f.length ? s.prefix + f.join(s.separator) : "";
          }, o2.expandNamed = function(t4, r4, n3, o3, i3, a2) {
            var u2, s, c, l = "", f = r4.encode, p = r4.empty_name_separator, d = !t4[f].length, h = 2 === t4.type ? "" : e3[f](a2);
            for (s = 0, c = t4.val.length; s < c; s++) i3 ? (u2 = e3[f](t4.val[s][1].substring(0, i3)), 2 === t4.type && (h = e3[f](t4.val[s][0].substring(0, i3)))) : d ? (u2 = e3[f](t4.val[s][1]), 2 === t4.type ? (h = e3[f](t4.val[s][0]), t4[f].push([h, u2])) : t4[f].push([void 0, u2])) : (u2 = t4[f][s][1], 2 === t4.type && (h = t4[f][s][0])), l && (l += o3), n3 ? l += h + (p || u2 ? "=" : "") + u2 : (s || (l += e3[f](a2) + (p || u2 ? "=" : "")), 2 === t4.type && (l += h + ","), l += u2);
            return l;
          }, o2.expandUnnamed = function(t4, r4, n3, o3, i3) {
            var a2, u2, s, c = "", l = r4.encode, f = r4.empty_name_separator, p = !t4[l].length;
            for (u2 = 0, s = t4.val.length; u2 < s; u2++) i3 ? a2 = e3[l](t4.val[u2][1].substring(0, i3)) : p ? (a2 = e3[l](t4.val[u2][1]), t4[l].push([2 === t4.type ? e3[l](t4.val[u2][0]) : void 0, a2])) : a2 = t4[l][u2][1], c && (c += o3), 2 === t4.type && (c += i3 ? e3[l](t4.val[u2][0].substring(0, i3)) : t4[l][u2][0], c += n3 ? f || a2 ? "=" : "" : ","), c += a2;
            return c;
          }, o2.noConflict = function() {
            return t3.URITemplate === o2 && (t3.URITemplate = r3), o2;
          }, a.expand = function(e4, t4) {
            var r4 = "";
            this.parts && this.parts.length || this.parse(), e4 instanceof i2 || (e4 = new i2(e4));
            for (var n3 = 0, a2 = this.parts.length; n3 < a2; n3++) r4 += "string" == typeof this.parts[n3] ? this.parts[n3] : o2.expand(this.parts[n3], e4, t4);
            return r4;
          }, a.parse = function() {
            var e4, t4, r4, n3 = this.expression, i3 = o2.EXPRESSION_PATTERN, a2 = o2.VARIABLE_PATTERN, s = o2.VARIABLE_NAME_PATTERN, c = o2.LITERAL_PATTERN, l = [], f = 0, p = function(e5) {
              if (e5.match(c)) throw new Error('Invalid Literal "' + e5 + '"');
              return e5;
            };
            for (i3.lastIndex = 0; ; ) {
              if (null === (t4 = i3.exec(n3))) {
                l.push(p(n3.substring(f)));
                break;
              }
              if (l.push(p(n3.substring(f, t4.index))), f = t4.index + t4[0].length, !u[t4[1]]) throw new Error('Unknown Operator "' + t4[1] + '" in "' + t4[0] + '"');
              if (!t4[3]) throw new Error('Unclosed Expression "' + t4[0] + '"');
              for (var d = 0, h = (e4 = t4[2].split(",")).length; d < h; d++) {
                if (null === (r4 = e4[d].match(a2))) throw new Error('Invalid Variable "' + e4[d] + '" in "' + t4[0] + '"');
                if (r4[1].match(s)) throw new Error('Invalid Variable Name "' + r4[1] + '" in "' + t4[0] + '"');
                e4[d] = { name: r4[1], explode: !!r4[3], maxlength: r4[4] && parseInt(r4[4], 10) };
              }
              if (!e4.length) throw new Error('Expression Missing Variable(s) "' + t4[0] + '"');
              l.push({ expression: t4[0], operator: t4[1], variables: e4 });
            }
            return l.length || l.push(p(n3)), this.parts = l, this;
          }, i2.prototype.get = function(e4) {
            var t4, r4, o3, i3 = this.data, a2 = { type: 0, val: [], encode: [], encodeReserved: [] };
            if (void 0 !== this.cache[e4]) return this.cache[e4];
            if (this.cache[e4] = a2, null == (o3 = "[object Function]" === String(Object.prototype.toString.call(i3)) ? i3(e4) : "[object Function]" === String(Object.prototype.toString.call(i3[e4])) ? i3[e4](e4) : i3[e4])) return a2;
            if ("[object Array]" === String(Object.prototype.toString.call(o3))) {
              for (t4 = 0, r4 = o3.length; t4 < r4; t4++) void 0 !== o3[t4] && null !== o3[t4] && a2.val.push([void 0, String(o3[t4])]);
              a2.val.length && (a2.type = 3);
            } else if ("[object Object]" === String(Object.prototype.toString.call(o3))) {
              for (t4 in o3) n2.call(o3, t4) && void 0 !== o3[t4] && null !== o3[t4] && a2.val.push([t4, String(o3[t4])]);
              a2.val.length && (a2.type = 2);
            } else a2.type = 1, a2.val.push([void 0, String(o3)]);
            return a2;
          }, e3.expand = function(t4, r4) {
            var n3 = new o2(t4).expand(r4);
            return new e3(n3);
          }, o2;
        });
      }, 9152: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.hash = function(e3) {
          var t3 = new n.sha256();
          return t3.update(e3, "utf8"), t3.digest();
        };
        var n = r2(2802);
      }, 9260: (e2, t2, r2) => {
        "use strict";
        var n = r2(8287).Buffer;
        function o(e3) {
          return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, o(e3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FeeBumpTransaction = void 0;
        var i, a = (i = r2(1918)) && i.__esModule ? i : { default: i }, u = r2(9152), s = r2(380), c = r2(3758), l = r2(6160);
        function f(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, p(n2.key), n2);
          }
        }
        function p(e3) {
          var t3 = function(e4, t4) {
            if ("object" != o(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != o(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == o(t3) ? t3 : t3 + "";
        }
        function d(e3, t3, r3) {
          return t3 = y(t3), function(e4, t4) {
            if (t4 && ("object" == o(t4) || "function" == typeof t4)) return t4;
            if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
            return function(e5) {
              if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e5;
            }(e4);
          }(e3, h() ? Reflect.construct(t3, r3 || [], y(e3).constructor) : t3.apply(e3, r3));
        }
        function h() {
          try {
            var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (e4) {
          }
          return (h = function() {
            return !!e3;
          })();
        }
        function y(e3) {
          return y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          }, y(e3);
        }
        function m(e3, t3) {
          return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
            return e4.__proto__ = t4, e4;
          }, m(e3, t3);
        }
        t2.FeeBumpTransaction = function(e3) {
          function t3(e4, r3) {
            var o2;
            if (function(e5, t4) {
              if (!(e5 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, t3), "string" == typeof e4) {
              var i2 = n.from(e4, "base64");
              e4 = a.default.TransactionEnvelope.fromXDR(i2);
            }
            var u2 = e4.switch();
            if (u2 !== a.default.EnvelopeType.envelopeTypeTxFeeBump()) throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(u2.name, "."));
            var c2 = e4.value(), f2 = c2.tx(), p2 = f2.fee().toString();
            o2 = d(this, t3, [f2, (c2.signatures() || []).slice(), p2, r3]);
            var h2 = a.default.TransactionEnvelope.envelopeTypeTx(f2.innerTx().v1());
            return o2._feeSource = (0, l.encodeMuxedAccountToAddress)(o2.tx.feeSource()), o2._innerTransaction = new s.Transaction(h2, r3), o2;
          }
          return function(e4, t4) {
            if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && m(e4, t4);
          }(t3, e3), function(e4, t4, r3) {
            return t4 && f(e4.prototype, t4), r3 && f(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }(t3, [{ key: "innerTransaction", get: function() {
            return this._innerTransaction;
          } }, { key: "operations", get: function() {
            return this._innerTransaction.operations;
          } }, { key: "feeSource", get: function() {
            return this._feeSource;
          } }, { key: "signatureBase", value: function() {
            var e4 = new a.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
            return new a.default.TransactionSignaturePayload({ networkId: a.default.Hash.fromXDR((0, u.hash)(this.networkPassphrase)), taggedTransaction: e4 }).toXDR();
          } }, { key: "toEnvelope", value: function() {
            var e4 = new a.default.FeeBumpTransactionEnvelope({ tx: a.default.FeeBumpTransaction.fromXDR(this.tx.toXDR()), signatures: this.signatures.slice() });
            return new a.default.TransactionEnvelope.envelopeTypeTxFeeBump(e4);
          } }]);
        }(c.TransactionBase);
      }, 9340: function(e2, t2, r2) {
        var n;
        e2 = r2.nmd(e2), function() {
          t2 && t2.nodeType, e2 && e2.nodeType;
          var o = "object" == typeof r2.g && r2.g;
          o.global !== o && o.window !== o && o.self;
          var i, a = 2147483647, u = 36, s = /^xn--/, c = /[^\x20-\x7E]/, l = /[\x2E\u3002\uFF0E\uFF61]/g, f = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, p = Math.floor, d = String.fromCharCode;
          function h(e3) {
            throw new RangeError(f[e3]);
          }
          function y(e3, t3) {
            for (var r3 = e3.length, n2 = []; r3--; ) n2[r3] = t3(e3[r3]);
            return n2;
          }
          function m(e3, t3) {
            var r3 = e3.split("@"), n2 = "";
            return r3.length > 1 && (n2 = r3[0] + "@", e3 = r3[1]), n2 + y((e3 = e3.replace(l, ".")).split("."), t3).join(".");
          }
          function v(e3) {
            for (var t3, r3, n2 = [], o2 = 0, i2 = e3.length; o2 < i2; ) (t3 = e3.charCodeAt(o2++)) >= 55296 && t3 <= 56319 && o2 < i2 ? 56320 == (64512 & (r3 = e3.charCodeAt(o2++))) ? n2.push(((1023 & t3) << 10) + (1023 & r3) + 65536) : (n2.push(t3), o2--) : n2.push(t3);
            return n2;
          }
          function g(e3) {
            return y(e3, function(e4) {
              var t3 = "";
              return e4 > 65535 && (t3 += d((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t3 += d(e4);
            }).join("");
          }
          function b(e3, t3) {
            return e3 + 22 + 75 * (e3 < 26) - ((0 != t3) << 5);
          }
          function w(e3, t3, r3) {
            var n2 = 0;
            for (e3 = r3 ? p(e3 / 700) : e3 >> 1, e3 += p(e3 / t3); e3 > 455; n2 += u) e3 = p(e3 / 35);
            return p(n2 + 36 * e3 / (e3 + 38));
          }
          function S(e3) {
            var t3, r3, n2, o2, i2, s2, c2, l2, f2, d2, y2, m2 = [], v2 = e3.length, b2 = 0, S2 = 128, k2 = 72;
            for ((r3 = e3.lastIndexOf("-")) < 0 && (r3 = 0), n2 = 0; n2 < r3; ++n2) e3.charCodeAt(n2) >= 128 && h("not-basic"), m2.push(e3.charCodeAt(n2));
            for (o2 = r3 > 0 ? r3 + 1 : 0; o2 < v2; ) {
              for (i2 = b2, s2 = 1, c2 = u; o2 >= v2 && h("invalid-input"), ((l2 = (y2 = e3.charCodeAt(o2++)) - 48 < 10 ? y2 - 22 : y2 - 65 < 26 ? y2 - 65 : y2 - 97 < 26 ? y2 - 97 : u) >= u || l2 > p((a - b2) / s2)) && h("overflow"), b2 += l2 * s2, !(l2 < (f2 = c2 <= k2 ? 1 : c2 >= k2 + 26 ? 26 : c2 - k2)); c2 += u) s2 > p(a / (d2 = u - f2)) && h("overflow"), s2 *= d2;
              k2 = w(b2 - i2, t3 = m2.length + 1, 0 == i2), p(b2 / t3) > a - S2 && h("overflow"), S2 += p(b2 / t3), b2 %= t3, m2.splice(b2++, 0, S2);
            }
            return g(m2);
          }
          function k(e3) {
            var t3, r3, n2, o2, i2, s2, c2, l2, f2, y2, m2, g2, S2, k2, E, _ = [];
            for (g2 = (e3 = v(e3)).length, t3 = 128, r3 = 0, i2 = 72, s2 = 0; s2 < g2; ++s2) (m2 = e3[s2]) < 128 && _.push(d(m2));
            for (n2 = o2 = _.length, o2 && _.push("-"); n2 < g2; ) {
              for (c2 = a, s2 = 0; s2 < g2; ++s2) (m2 = e3[s2]) >= t3 && m2 < c2 && (c2 = m2);
              for (c2 - t3 > p((a - r3) / (S2 = n2 + 1)) && h("overflow"), r3 += (c2 - t3) * S2, t3 = c2, s2 = 0; s2 < g2; ++s2) if ((m2 = e3[s2]) < t3 && ++r3 > a && h("overflow"), m2 == t3) {
                for (l2 = r3, f2 = u; !(l2 < (y2 = f2 <= i2 ? 1 : f2 >= i2 + 26 ? 26 : f2 - i2)); f2 += u) E = l2 - y2, k2 = u - y2, _.push(d(b(y2 + E % k2, 0))), l2 = p(E / k2);
                _.push(d(b(l2, 0))), i2 = w(r3, S2, n2 == o2), r3 = 0, ++n2;
              }
              ++r3, ++t3;
            }
            return _.join("");
          }
          i = { version: "1.3.2", ucs2: { decode: v, encode: g }, decode: S, encode: k, toASCII: function(e3) {
            return m(e3, function(e4) {
              return c.test(e4) ? "xn--" + k(e4) : e4;
            });
          }, toUnicode: function(e3) {
            return m(e3, function(e4) {
              return s.test(e4) ? S(e4.slice(4).toLowerCase()) : e4;
            });
          } }, void 0 === (n = (function() {
            return i;
          }).call(t2, r2, t2, e2)) || (e2.exports = n);
        }();
      }, 9353: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LiquidityPoolId = void 0;
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
        function i(e3) {
          return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, i(e3);
        }
        function a(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, u(n2.key), n2);
          }
        }
        function u(e3) {
          var t3 = function(e4, t4) {
            if ("object" != i(e4) || !e4) return e4;
            var r3 = e4[Symbol.toPrimitive];
            if (void 0 !== r3) {
              var n2 = r3.call(e4, t4 || "default");
              if ("object" != i(n2)) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e4);
          }(e3, "string");
          return "symbol" == i(t3) ? t3 : t3 + "";
        }
        t2.LiquidityPoolId = function() {
          return function(e3, t3, r3) {
            return t3 && a(e3.prototype, t3), r3 && a(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }(function e3(t3) {
            if (function(e4, t4) {
              if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            }(this, e3), !t3) throw new Error("liquidityPoolId cannot be empty");
            if (!/^[a-f0-9]{64}$/.test(t3)) throw new Error("Liquidity pool ID is not a valid hash");
            this.liquidityPoolId = t3;
          }, [{ key: "toXDRObject", value: function() {
            var e3 = o.default.PoolId.fromXDR(this.liquidityPoolId, "hex");
            return new o.default.TrustLineAsset("assetTypePoolShare", e3);
          } }, { key: "getLiquidityPoolId", value: function() {
            return String(this.liquidityPoolId);
          } }, { key: "getAssetType", value: function() {
            return "liquidity_pool_shares";
          } }, { key: "equals", value: function(e3) {
            return this.liquidityPoolId === e3.getLiquidityPoolId();
          } }, { key: "toString", value: function() {
            return "liquidity_pool:".concat(this.liquidityPoolId);
          } }], [{ key: "fromOperation", value: function(e3) {
            var t3 = e3.switch();
            if (t3 === o.default.AssetType.assetTypePoolShare()) return new this(e3.liquidityPoolId().toString("hex"));
            throw new Error("Invalid asset type: ".concat(t3.name));
          } }]);
        }();
      }, 9845: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.liquidityPoolDeposit = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = e3.liquidityPoolId, r3 = e3.maxAmountA, n2 = e3.maxAmountB, i = e3.minPrice, a = e3.maxPrice, u = {};
          if (!t3) throw new TypeError("liquidityPoolId argument is required");
          if (u.liquidityPoolId = o.default.PoolId.fromXDR(t3, "hex"), !this.isValidAmount(r3, true)) throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
          if (u.maxAmountA = this._toXDRAmount(r3), !this.isValidAmount(n2, true)) throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
          if (u.maxAmountB = this._toXDRAmount(n2), void 0 === i) throw new TypeError("minPrice argument is required");
          if (u.minPrice = this._toXDRPrice(i), void 0 === a) throw new TypeError("maxPrice argument is required");
          u.maxPrice = this._toXDRPrice(a);
          var s = new o.default.LiquidityPoolDepositOp(u), c = { body: o.default.OperationBody.liquidityPoolDeposit(s) };
          return this.setSourceAccount(c, e3), new o.default.Operation(c);
        };
        var n, o = (n = r2(1918)) && n.__esModule ? n : { default: n };
      } }, t = {};
      function r(n) {
        var o = t[n];
        if (void 0 !== o) return o.exports;
        var i = t[n] = { id: n, loaded: false, exports: {} };
        return e[n].call(i.exports, i, i.exports, r), i.loaded = true, i.exports;
      }
      return r.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return r.d(t2, { a: t2 }), t2;
      }, r.d = (e2, t2) => {
        for (var n in t2) r.o(t2, n) && !r.o(e2, n) && Object.defineProperty(e2, n, { enumerable: true, get: t2[n] });
      }, r.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e2) {
          if ("object" == typeof window) return window;
        }
      }(), r.hmd = (e2) => ((e2 = Object.create(e2)).children || (e2.children = []), Object.defineProperty(e2, "exports", { enumerable: true, set: () => {
        throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e2.id);
      } }), e2), r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, r.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2), r(1924);
    })());
  }
});

// node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/base64url/dist/pad-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
        buffer.write("=", position++);
      }
      return buffer.toString();
    }
    exports.default = padString;
  }
});

// node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/base64url/dist/base64url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode(base64url4, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url4), "base64").toString(encoding);
    }
    function toBase64(base64url4) {
      base64url4 = base64url4.toString();
      return pad_string_1.default(base64url4).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url4) {
      return Buffer.from(toBase64(base64url4), "base64");
    }
    var base64url3 = encode;
    base64url3.encode = encode;
    base64url3.decode = decode;
    base64url3.toBase64 = toBase64;
    base64url3.fromBase64 = fromBase64;
    base64url3.toBuffer = toBuffer;
    exports.default = base64url3;
  }
});

// node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/base64url/index.js"(exports, module) {
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/api.js
var require_api2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Api = void 0;
    var Api;
    (function(_Api) {
      var GetTransactionStatus = function(GetTransactionStatus2) {
        GetTransactionStatus2["SUCCESS"] = "SUCCESS";
        GetTransactionStatus2["NOT_FOUND"] = "NOT_FOUND";
        GetTransactionStatus2["FAILED"] = "FAILED";
        return GetTransactionStatus2;
      }({});
      _Api.GetTransactionStatus = GetTransactionStatus;
      function isSimulationError(sim) {
        return "error" in sim;
      }
      _Api.isSimulationError = isSimulationError;
      function isSimulationSuccess(sim) {
        return "transactionData" in sim;
      }
      _Api.isSimulationSuccess = isSimulationSuccess;
      function isSimulationRestore(sim) {
        return isSimulationSuccess(sim) && "restorePreamble" in sim && !!sim.restorePreamble.transactionData;
      }
      _Api.isSimulationRestore = isSimulationRestore;
      function isSimulationRaw(sim) {
        return !sim._parsed;
      }
      _Api.isSimulationRaw = isSimulationRaw;
    })(Api || (exports.Api = Api = {}));
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js
var require_curr_generated2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var XDR = _interopRequireWildcard(require_xdr());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    var types = XDR.config(function(xdr3) {
      var SCSYMBOL_LIMIT = 32;
      var SC_SPEC_DOC_LIMIT = 1024;
      xdr3.typedef("Value", xdr3.varOpaque());
      xdr3.struct("ScpBallot", [["counter", xdr3.lookup("Uint32")], ["value", xdr3.lookup("Value")]]);
      xdr3["enum"]("ScpStatementType", {
        scpStPrepare: 0,
        scpStConfirm: 1,
        scpStExternalize: 2,
        scpStNominate: 3
      });
      xdr3.struct("ScpNomination", [["quorumSetHash", xdr3.lookup("Hash")], ["votes", xdr3.varArray(xdr3.lookup("Value"), 2147483647)], ["accepted", xdr3.varArray(xdr3.lookup("Value"), 2147483647)]]);
      xdr3.struct("ScpStatementPrepare", [["quorumSetHash", xdr3.lookup("Hash")], ["ballot", xdr3.lookup("ScpBallot")], ["prepared", xdr3.option(xdr3.lookup("ScpBallot"))], ["preparedPrime", xdr3.option(xdr3.lookup("ScpBallot"))], ["nC", xdr3.lookup("Uint32")], ["nH", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScpStatementConfirm", [["ballot", xdr3.lookup("ScpBallot")], ["nPrepared", xdr3.lookup("Uint32")], ["nCommit", xdr3.lookup("Uint32")], ["nH", xdr3.lookup("Uint32")], ["quorumSetHash", xdr3.lookup("Hash")]]);
      xdr3.struct("ScpStatementExternalize", [["commit", xdr3.lookup("ScpBallot")], ["nH", xdr3.lookup("Uint32")], ["commitQuorumSetHash", xdr3.lookup("Hash")]]);
      xdr3.union("ScpStatementPledges", {
        switchOn: xdr3.lookup("ScpStatementType"),
        switchName: "type",
        switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
        arms: {
          prepare: xdr3.lookup("ScpStatementPrepare"),
          confirm: xdr3.lookup("ScpStatementConfirm"),
          externalize: xdr3.lookup("ScpStatementExternalize"),
          nominate: xdr3.lookup("ScpNomination")
        }
      });
      xdr3.struct("ScpStatement", [["nodeId", xdr3.lookup("NodeId")], ["slotIndex", xdr3.lookup("Uint64")], ["pledges", xdr3.lookup("ScpStatementPledges")]]);
      xdr3.struct("ScpEnvelope", [["statement", xdr3.lookup("ScpStatement")], ["signature", xdr3.lookup("Signature")]]);
      xdr3.struct("ScpQuorumSet", [["threshold", xdr3.lookup("Uint32")], ["validators", xdr3.varArray(xdr3.lookup("NodeId"), 2147483647)], ["innerSets", xdr3.varArray(xdr3.lookup("ScpQuorumSet"), 2147483647)]]);
      xdr3.typedef("Thresholds", xdr3.opaque(4));
      xdr3.typedef("String32", xdr3.string(32));
      xdr3.typedef("String64", xdr3.string(64));
      xdr3.typedef("SequenceNumber", xdr3.lookup("Int64"));
      xdr3.typedef("DataValue", xdr3.varOpaque(64));
      xdr3.typedef("PoolId", xdr3.lookup("Hash"));
      xdr3.typedef("AssetCode4", xdr3.opaque(4));
      xdr3.typedef("AssetCode12", xdr3.opaque(12));
      xdr3["enum"]("AssetType", {
        assetTypeNative: 0,
        assetTypeCreditAlphanum4: 1,
        assetTypeCreditAlphanum12: 2,
        assetTypePoolShare: 3
      });
      xdr3.union("AssetCode", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
        arms: {
          assetCode4: xdr3.lookup("AssetCode4"),
          assetCode12: xdr3.lookup("AssetCode12")
        }
      });
      xdr3.struct("AlphaNum4", [["assetCode", xdr3.lookup("AssetCode4")], ["issuer", xdr3.lookup("AccountId")]]);
      xdr3.struct("AlphaNum12", [["assetCode", xdr3.lookup("AssetCode12")], ["issuer", xdr3.lookup("AccountId")]]);
      xdr3.union("Asset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12")
        }
      });
      xdr3.struct("Price", [["n", xdr3.lookup("Int32")], ["d", xdr3.lookup("Int32")]]);
      xdr3.struct("Liabilities", [["buying", xdr3.lookup("Int64")], ["selling", xdr3.lookup("Int64")]]);
      xdr3["enum"]("ThresholdIndices", {
        thresholdMasterWeight: 0,
        thresholdLow: 1,
        thresholdMed: 2,
        thresholdHigh: 3
      });
      xdr3["enum"]("LedgerEntryType", {
        account: 0,
        trustline: 1,
        offer: 2,
        data: 3,
        claimableBalance: 4,
        liquidityPool: 5,
        contractData: 6,
        contractCode: 7,
        configSetting: 8,
        ttl: 9
      });
      xdr3.struct("Signer", [["key", xdr3.lookup("SignerKey")], ["weight", xdr3.lookup("Uint32")]]);
      xdr3["enum"]("AccountFlags", {
        authRequiredFlag: 1,
        authRevocableFlag: 2,
        authImmutableFlag: 4,
        authClawbackEnabledFlag: 8
      });
      xdr3["const"]("MASK_ACCOUNT_FLAGS", 7);
      xdr3["const"]("MASK_ACCOUNT_FLAGS_V17", 15);
      xdr3["const"]("MAX_SIGNERS", 20);
      xdr3.typedef("SponsorshipDescriptor", xdr3.option(xdr3.lookup("AccountId")));
      xdr3.struct("AccountEntryExtensionV3", [["ext", xdr3.lookup("ExtensionPoint")], ["seqLedger", xdr3.lookup("Uint32")], ["seqTime", xdr3.lookup("TimePoint")]]);
      xdr3.union("AccountEntryExtensionV2Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [3, "v3"]],
        arms: {
          v3: xdr3.lookup("AccountEntryExtensionV3")
        }
      });
      xdr3.struct("AccountEntryExtensionV2", [["numSponsored", xdr3.lookup("Uint32")], ["numSponsoring", xdr3.lookup("Uint32")], ["signerSponsoringIDs", xdr3.varArray(xdr3.lookup("SponsorshipDescriptor"), xdr3.lookup("MAX_SIGNERS"))], ["ext", xdr3.lookup("AccountEntryExtensionV2Ext")]]);
      xdr3.union("AccountEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [2, "v2"]],
        arms: {
          v2: xdr3.lookup("AccountEntryExtensionV2")
        }
      });
      xdr3.struct("AccountEntryExtensionV1", [["liabilities", xdr3.lookup("Liabilities")], ["ext", xdr3.lookup("AccountEntryExtensionV1Ext")]]);
      xdr3.union("AccountEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("AccountEntryExtensionV1")
        }
      });
      xdr3.struct("AccountEntry", [["accountId", xdr3.lookup("AccountId")], ["balance", xdr3.lookup("Int64")], ["seqNum", xdr3.lookup("SequenceNumber")], ["numSubEntries", xdr3.lookup("Uint32")], ["inflationDest", xdr3.option(xdr3.lookup("AccountId"))], ["flags", xdr3.lookup("Uint32")], ["homeDomain", xdr3.lookup("String32")], ["thresholds", xdr3.lookup("Thresholds")], ["signers", xdr3.varArray(xdr3.lookup("Signer"), xdr3.lookup("MAX_SIGNERS"))], ["ext", xdr3.lookup("AccountEntryExt")]]);
      xdr3["enum"]("TrustLineFlags", {
        authorizedFlag: 1,
        authorizedToMaintainLiabilitiesFlag: 2,
        trustlineClawbackEnabledFlag: 4
      });
      xdr3["const"]("MASK_TRUSTLINE_FLAGS", 1);
      xdr3["const"]("MASK_TRUSTLINE_FLAGS_V13", 3);
      xdr3["const"]("MASK_TRUSTLINE_FLAGS_V17", 7);
      xdr3["enum"]("LiquidityPoolType", {
        liquidityPoolConstantProduct: 0
      });
      xdr3.union("TrustLineAsset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12"),
          liquidityPoolId: xdr3.lookup("PoolId")
        }
      });
      xdr3.union("TrustLineEntryExtensionV2Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", xdr3.lookup("Int32")], ["ext", xdr3.lookup("TrustLineEntryExtensionV2Ext")]]);
      xdr3.union("TrustLineEntryV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [2, "v2"]],
        arms: {
          v2: xdr3.lookup("TrustLineEntryExtensionV2")
        }
      });
      xdr3.struct("TrustLineEntryV1", [["liabilities", xdr3.lookup("Liabilities")], ["ext", xdr3.lookup("TrustLineEntryV1Ext")]]);
      xdr3.union("TrustLineEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("TrustLineEntryV1")
        }
      });
      xdr3.struct("TrustLineEntry", [["accountId", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("TrustLineAsset")], ["balance", xdr3.lookup("Int64")], ["limit", xdr3.lookup("Int64")], ["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("TrustLineEntryExt")]]);
      xdr3["enum"]("OfferEntryFlags", {
        passiveFlag: 1
      });
      xdr3["const"]("MASK_OFFERENTRY_FLAGS", 1);
      xdr3.union("OfferEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("OfferEntry", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")], ["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("OfferEntryExt")]]);
      xdr3.union("DataEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("DataEntry", [["accountId", xdr3.lookup("AccountId")], ["dataName", xdr3.lookup("String64")], ["dataValue", xdr3.lookup("DataValue")], ["ext", xdr3.lookup("DataEntryExt")]]);
      xdr3["enum"]("ClaimPredicateType", {
        claimPredicateUnconditional: 0,
        claimPredicateAnd: 1,
        claimPredicateOr: 2,
        claimPredicateNot: 3,
        claimPredicateBeforeAbsoluteTime: 4,
        claimPredicateBeforeRelativeTime: 5
      });
      xdr3.union("ClaimPredicate", {
        switchOn: xdr3.lookup("ClaimPredicateType"),
        switchName: "type",
        switches: [["claimPredicateUnconditional", xdr3["void"]()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
        arms: {
          andPredicates: xdr3.varArray(xdr3.lookup("ClaimPredicate"), 2),
          orPredicates: xdr3.varArray(xdr3.lookup("ClaimPredicate"), 2),
          notPredicate: xdr3.option(xdr3.lookup("ClaimPredicate")),
          absBefore: xdr3.lookup("Int64"),
          relBefore: xdr3.lookup("Int64")
        }
      });
      xdr3["enum"]("ClaimantType", {
        claimantTypeV0: 0
      });
      xdr3.struct("ClaimantV0", [["destination", xdr3.lookup("AccountId")], ["predicate", xdr3.lookup("ClaimPredicate")]]);
      xdr3.union("Claimant", {
        switchOn: xdr3.lookup("ClaimantType"),
        switchName: "type",
        switches: [["claimantTypeV0", "v0"]],
        arms: {
          v0: xdr3.lookup("ClaimantV0")
        }
      });
      xdr3["enum"]("ClaimableBalanceIdType", {
        claimableBalanceIdTypeV0: 0
      });
      xdr3.union("ClaimableBalanceId", {
        switchOn: xdr3.lookup("ClaimableBalanceIdType"),
        switchName: "type",
        switches: [["claimableBalanceIdTypeV0", "v0"]],
        arms: {
          v0: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ClaimableBalanceFlags", {
        claimableBalanceClawbackEnabledFlag: 1
      });
      xdr3["const"]("MASK_CLAIMABLE_BALANCE_FLAGS", 1);
      xdr3.union("ClaimableBalanceEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("ClaimableBalanceEntryExtensionV1", [["ext", xdr3.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", xdr3.lookup("Uint32")]]);
      xdr3.union("ClaimableBalanceEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("ClaimableBalanceEntryExtensionV1")
        }
      });
      xdr3.struct("ClaimableBalanceEntry", [["balanceId", xdr3.lookup("ClaimableBalanceId")], ["claimants", xdr3.varArray(xdr3.lookup("Claimant"), 10)], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["ext", xdr3.lookup("ClaimableBalanceEntryExt")]]);
      xdr3.struct("LiquidityPoolConstantProductParameters", [["assetA", xdr3.lookup("Asset")], ["assetB", xdr3.lookup("Asset")], ["fee", xdr3.lookup("Int32")]]);
      xdr3.struct("LiquidityPoolEntryConstantProduct", [["params", xdr3.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", xdr3.lookup("Int64")], ["reserveB", xdr3.lookup("Int64")], ["totalPoolShares", xdr3.lookup("Int64")], ["poolSharesTrustLineCount", xdr3.lookup("Int64")]]);
      xdr3.union("LiquidityPoolEntryBody", {
        switchOn: xdr3.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr3.lookup("LiquidityPoolEntryConstantProduct")
        }
      });
      xdr3.struct("LiquidityPoolEntry", [["liquidityPoolId", xdr3.lookup("PoolId")], ["body", xdr3.lookup("LiquidityPoolEntryBody")]]);
      xdr3["enum"]("ContractDataDurability", {
        temporary: 0,
        persistent: 1
      });
      xdr3.struct("ContractDataEntry", [["ext", xdr3.lookup("ExtensionPoint")], ["contract", xdr3.lookup("ScAddress")], ["key", xdr3.lookup("ScVal")], ["durability", xdr3.lookup("ContractDataDurability")], ["val", xdr3.lookup("ScVal")]]);
      xdr3.struct("ContractCodeCostInputs", [["ext", xdr3.lookup("ExtensionPoint")], ["nInstructions", xdr3.lookup("Uint32")], ["nFunctions", xdr3.lookup("Uint32")], ["nGlobals", xdr3.lookup("Uint32")], ["nTableEntries", xdr3.lookup("Uint32")], ["nTypes", xdr3.lookup("Uint32")], ["nDataSegments", xdr3.lookup("Uint32")], ["nElemSegments", xdr3.lookup("Uint32")], ["nImports", xdr3.lookup("Uint32")], ["nExports", xdr3.lookup("Uint32")], ["nDataSegmentBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("ContractCodeEntryV1", [["ext", xdr3.lookup("ExtensionPoint")], ["costInputs", xdr3.lookup("ContractCodeCostInputs")]]);
      xdr3.union("ContractCodeEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("ContractCodeEntryV1")
        }
      });
      xdr3.struct("ContractCodeEntry", [["ext", xdr3.lookup("ContractCodeEntryExt")], ["hash", xdr3.lookup("Hash")], ["code", xdr3.varOpaque()]]);
      xdr3.struct("TtlEntry", [["keyHash", xdr3.lookup("Hash")], ["liveUntilLedgerSeq", xdr3.lookup("Uint32")]]);
      xdr3.union("LedgerEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerEntryExtensionV1", [["sponsoringId", xdr3.lookup("SponsorshipDescriptor")], ["ext", xdr3.lookup("LedgerEntryExtensionV1Ext")]]);
      xdr3.union("LedgerEntryData", {
        switchOn: xdr3.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr3.lookup("AccountEntry"),
          trustLine: xdr3.lookup("TrustLineEntry"),
          offer: xdr3.lookup("OfferEntry"),
          data: xdr3.lookup("DataEntry"),
          claimableBalance: xdr3.lookup("ClaimableBalanceEntry"),
          liquidityPool: xdr3.lookup("LiquidityPoolEntry"),
          contractData: xdr3.lookup("ContractDataEntry"),
          contractCode: xdr3.lookup("ContractCodeEntry"),
          configSetting: xdr3.lookup("ConfigSettingEntry"),
          ttl: xdr3.lookup("TtlEntry")
        }
      });
      xdr3.union("LedgerEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerEntryExtensionV1")
        }
      });
      xdr3.struct("LedgerEntry", [["lastModifiedLedgerSeq", xdr3.lookup("Uint32")], ["data", xdr3.lookup("LedgerEntryData")], ["ext", xdr3.lookup("LedgerEntryExt")]]);
      xdr3.struct("LedgerKeyAccount", [["accountId", xdr3.lookup("AccountId")]]);
      xdr3.struct("LedgerKeyTrustLine", [["accountId", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("TrustLineAsset")]]);
      xdr3.struct("LedgerKeyOffer", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("LedgerKeyData", [["accountId", xdr3.lookup("AccountId")], ["dataName", xdr3.lookup("String64")]]);
      xdr3.struct("LedgerKeyClaimableBalance", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", xdr3.lookup("PoolId")]]);
      xdr3.struct("LedgerKeyContractData", [["contract", xdr3.lookup("ScAddress")], ["key", xdr3.lookup("ScVal")], ["durability", xdr3.lookup("ContractDataDurability")]]);
      xdr3.struct("LedgerKeyContractCode", [["hash", xdr3.lookup("Hash")]]);
      xdr3.struct("LedgerKeyConfigSetting", [["configSettingId", xdr3.lookup("ConfigSettingId")]]);
      xdr3.struct("LedgerKeyTtl", [["keyHash", xdr3.lookup("Hash")]]);
      xdr3.union("LedgerKey", {
        switchOn: xdr3.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr3.lookup("LedgerKeyAccount"),
          trustLine: xdr3.lookup("LedgerKeyTrustLine"),
          offer: xdr3.lookup("LedgerKeyOffer"),
          data: xdr3.lookup("LedgerKeyData"),
          claimableBalance: xdr3.lookup("LedgerKeyClaimableBalance"),
          liquidityPool: xdr3.lookup("LedgerKeyLiquidityPool"),
          contractData: xdr3.lookup("LedgerKeyContractData"),
          contractCode: xdr3.lookup("LedgerKeyContractCode"),
          configSetting: xdr3.lookup("LedgerKeyConfigSetting"),
          ttl: xdr3.lookup("LedgerKeyTtl")
        }
      });
      xdr3["enum"]("EnvelopeType", {
        envelopeTypeTxV0: 0,
        envelopeTypeScp: 1,
        envelopeTypeTx: 2,
        envelopeTypeAuth: 3,
        envelopeTypeScpvalue: 4,
        envelopeTypeTxFeeBump: 5,
        envelopeTypeOpId: 6,
        envelopeTypePoolRevokeOpId: 7,
        envelopeTypeContractId: 8,
        envelopeTypeSorobanAuthorization: 9
      });
      xdr3["enum"]("BucketListType", {
        live: 0,
        hotArchive: 1,
        coldArchive: 2
      });
      xdr3["enum"]("BucketEntryType", {
        metaentry: -1,
        liveentry: 0,
        deadentry: 1,
        initentry: 2
      });
      xdr3["enum"]("HotArchiveBucketEntryType", {
        hotArchiveMetaentry: -1,
        hotArchiveArchived: 0,
        hotArchiveLive: 1,
        hotArchiveDeleted: 2
      });
      xdr3["enum"]("ColdArchiveBucketEntryType", {
        coldArchiveMetaentry: -1,
        coldArchiveArchivedLeaf: 0,
        coldArchiveDeletedLeaf: 1,
        coldArchiveBoundaryLeaf: 2,
        coldArchiveHash: 3
      });
      xdr3.union("BucketMetadataExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "bucketListType"]],
        arms: {
          bucketListType: xdr3.lookup("BucketListType")
        }
      });
      xdr3.struct("BucketMetadata", [["ledgerVersion", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("BucketMetadataExt")]]);
      xdr3.union("BucketEntry", {
        switchOn: xdr3.lookup("BucketEntryType"),
        switchName: "type",
        switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
        arms: {
          liveEntry: xdr3.lookup("LedgerEntry"),
          deadEntry: xdr3.lookup("LedgerKey"),
          metaEntry: xdr3.lookup("BucketMetadata")
        }
      });
      xdr3.union("HotArchiveBucketEntry", {
        switchOn: xdr3.lookup("HotArchiveBucketEntryType"),
        switchName: "type",
        switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]],
        arms: {
          archivedEntry: xdr3.lookup("LedgerEntry"),
          key: xdr3.lookup("LedgerKey"),
          metaEntry: xdr3.lookup("BucketMetadata")
        }
      });
      xdr3.struct("ColdArchiveArchivedLeaf", [["index", xdr3.lookup("Uint32")], ["archivedEntry", xdr3.lookup("LedgerEntry")]]);
      xdr3.struct("ColdArchiveDeletedLeaf", [["index", xdr3.lookup("Uint32")], ["deletedKey", xdr3.lookup("LedgerKey")]]);
      xdr3.struct("ColdArchiveBoundaryLeaf", [["index", xdr3.lookup("Uint32")], ["isLowerBound", xdr3.bool()]]);
      xdr3.struct("ColdArchiveHashEntry", [["index", xdr3.lookup("Uint32")], ["level", xdr3.lookup("Uint32")], ["hash", xdr3.lookup("Hash")]]);
      xdr3.union("ColdArchiveBucketEntry", {
        switchOn: xdr3.lookup("ColdArchiveBucketEntryType"),
        switchName: "type",
        switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]],
        arms: {
          metaEntry: xdr3.lookup("BucketMetadata"),
          archivedLeaf: xdr3.lookup("ColdArchiveArchivedLeaf"),
          deletedLeaf: xdr3.lookup("ColdArchiveDeletedLeaf"),
          boundaryLeaf: xdr3.lookup("ColdArchiveBoundaryLeaf"),
          hashEntry: xdr3.lookup("ColdArchiveHashEntry")
        }
      });
      xdr3.typedef("UpgradeType", xdr3.varOpaque(128));
      xdr3["enum"]("StellarValueType", {
        stellarValueBasic: 0,
        stellarValueSigned: 1
      });
      xdr3.struct("LedgerCloseValueSignature", [["nodeId", xdr3.lookup("NodeId")], ["signature", xdr3.lookup("Signature")]]);
      xdr3.union("StellarValueExt", {
        switchOn: xdr3.lookup("StellarValueType"),
        switchName: "v",
        switches: [["stellarValueBasic", xdr3["void"]()], ["stellarValueSigned", "lcValueSignature"]],
        arms: {
          lcValueSignature: xdr3.lookup("LedgerCloseValueSignature")
        }
      });
      xdr3.struct("StellarValue", [["txSetHash", xdr3.lookup("Hash")], ["closeTime", xdr3.lookup("TimePoint")], ["upgrades", xdr3.varArray(xdr3.lookup("UpgradeType"), 6)], ["ext", xdr3.lookup("StellarValueExt")]]);
      xdr3["const"]("MASK_LEDGER_HEADER_FLAGS", 7);
      xdr3["enum"]("LedgerHeaderFlags", {
        disableLiquidityPoolTradingFlag: 1,
        disableLiquidityPoolDepositFlag: 2,
        disableLiquidityPoolWithdrawalFlag: 4
      });
      xdr3.union("LedgerHeaderExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerHeaderExtensionV1", [["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("LedgerHeaderExtensionV1Ext")]]);
      xdr3.union("LedgerHeaderExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerHeaderExtensionV1")
        }
      });
      xdr3.struct("LedgerHeader", [["ledgerVersion", xdr3.lookup("Uint32")], ["previousLedgerHash", xdr3.lookup("Hash")], ["scpValue", xdr3.lookup("StellarValue")], ["txSetResultHash", xdr3.lookup("Hash")], ["bucketListHash", xdr3.lookup("Hash")], ["ledgerSeq", xdr3.lookup("Uint32")], ["totalCoins", xdr3.lookup("Int64")], ["feePool", xdr3.lookup("Int64")], ["inflationSeq", xdr3.lookup("Uint32")], ["idPool", xdr3.lookup("Uint64")], ["baseFee", xdr3.lookup("Uint32")], ["baseReserve", xdr3.lookup("Uint32")], ["maxTxSetSize", xdr3.lookup("Uint32")], ["skipList", xdr3.array(xdr3.lookup("Hash"), 4)], ["ext", xdr3.lookup("LedgerHeaderExt")]]);
      xdr3["enum"]("LedgerUpgradeType", {
        ledgerUpgradeVersion: 1,
        ledgerUpgradeBaseFee: 2,
        ledgerUpgradeMaxTxSetSize: 3,
        ledgerUpgradeBaseReserve: 4,
        ledgerUpgradeFlags: 5,
        ledgerUpgradeConfig: 6,
        ledgerUpgradeMaxSorobanTxSetSize: 7
      });
      xdr3.struct("ConfigUpgradeSetKey", [["contractId", xdr3.lookup("Hash")], ["contentHash", xdr3.lookup("Hash")]]);
      xdr3.union("LedgerUpgrade", {
        switchOn: xdr3.lookup("LedgerUpgradeType"),
        switchName: "type",
        switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]],
        arms: {
          newLedgerVersion: xdr3.lookup("Uint32"),
          newBaseFee: xdr3.lookup("Uint32"),
          newMaxTxSetSize: xdr3.lookup("Uint32"),
          newBaseReserve: xdr3.lookup("Uint32"),
          newFlags: xdr3.lookup("Uint32"),
          newConfig: xdr3.lookup("ConfigUpgradeSetKey"),
          newMaxSorobanTxSetSize: xdr3.lookup("Uint32")
        }
      });
      xdr3.struct("ConfigUpgradeSet", [["updatedEntry", xdr3.varArray(xdr3.lookup("ConfigSettingEntry"), 2147483647)]]);
      xdr3["enum"]("TxSetComponentType", {
        txsetCompTxsMaybeDiscountedFee: 0
      });
      xdr3.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", xdr3.option(xdr3.lookup("Int64"))], ["txes", xdr3.varArray(xdr3.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr3.union("TxSetComponent", {
        switchOn: xdr3.lookup("TxSetComponentType"),
        switchName: "type",
        switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]],
        arms: {
          txsMaybeDiscountedFee: xdr3.lookup("TxSetComponentTxsMaybeDiscountedFee")
        }
      });
      xdr3.union("TransactionPhase", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0Components"]],
        arms: {
          v0Components: xdr3.varArray(xdr3.lookup("TxSetComponent"), 2147483647)
        }
      });
      xdr3.struct("TransactionSet", [["previousLedgerHash", xdr3.lookup("Hash")], ["txes", xdr3.varArray(xdr3.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr3.struct("TransactionSetV1", [["previousLedgerHash", xdr3.lookup("Hash")], ["phases", xdr3.varArray(xdr3.lookup("TransactionPhase"), 2147483647)]]);
      xdr3.union("GeneralizedTransactionSet", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[1, "v1TxSet"]],
        arms: {
          v1TxSet: xdr3.lookup("TransactionSetV1")
        }
      });
      xdr3.struct("TransactionResultPair", [["transactionHash", xdr3.lookup("Hash")], ["result", xdr3.lookup("TransactionResult")]]);
      xdr3.struct("TransactionResultSet", [["results", xdr3.varArray(xdr3.lookup("TransactionResultPair"), 2147483647)]]);
      xdr3.union("TransactionHistoryEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "generalizedTxSet"]],
        arms: {
          generalizedTxSet: xdr3.lookup("GeneralizedTransactionSet")
        }
      });
      xdr3.struct("TransactionHistoryEntry", [["ledgerSeq", xdr3.lookup("Uint32")], ["txSet", xdr3.lookup("TransactionSet")], ["ext", xdr3.lookup("TransactionHistoryEntryExt")]]);
      xdr3.union("TransactionHistoryResultEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionHistoryResultEntry", [["ledgerSeq", xdr3.lookup("Uint32")], ["txResultSet", xdr3.lookup("TransactionResultSet")], ["ext", xdr3.lookup("TransactionHistoryResultEntryExt")]]);
      xdr3.union("LedgerHeaderHistoryEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerHeaderHistoryEntry", [["hash", xdr3.lookup("Hash")], ["header", xdr3.lookup("LedgerHeader")], ["ext", xdr3.lookup("LedgerHeaderHistoryEntryExt")]]);
      xdr3.struct("LedgerScpMessages", [["ledgerSeq", xdr3.lookup("Uint32")], ["messages", xdr3.varArray(xdr3.lookup("ScpEnvelope"), 2147483647)]]);
      xdr3.struct("ScpHistoryEntryV0", [["quorumSets", xdr3.varArray(xdr3.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", xdr3.lookup("LedgerScpMessages")]]);
      xdr3.union("ScpHistoryEntry", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("ScpHistoryEntryV0")
        }
      });
      xdr3["enum"]("LedgerEntryChangeType", {
        ledgerEntryCreated: 0,
        ledgerEntryUpdated: 1,
        ledgerEntryRemoved: 2,
        ledgerEntryState: 3
      });
      xdr3.union("LedgerEntryChange", {
        switchOn: xdr3.lookup("LedgerEntryChangeType"),
        switchName: "type",
        switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
        arms: {
          created: xdr3.lookup("LedgerEntry"),
          updated: xdr3.lookup("LedgerEntry"),
          removed: xdr3.lookup("LedgerKey"),
          state: xdr3.lookup("LedgerEntry")
        }
      });
      xdr3.typedef("LedgerEntryChanges", xdr3.varArray(xdr3.lookup("LedgerEntryChange"), 2147483647));
      xdr3.struct("OperationMeta", [["changes", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3.struct("TransactionMetaV1", [["txChanges", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)]]);
      xdr3.struct("TransactionMetaV2", [["txChangesBefore", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3["enum"]("ContractEventType", {
        system: 0,
        contract: 1,
        diagnostic: 2
      });
      xdr3.struct("ContractEventV0", [["topics", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)], ["data", xdr3.lookup("ScVal")]]);
      xdr3.union("ContractEventBody", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("ContractEventV0")
        }
      });
      xdr3.struct("ContractEvent", [["ext", xdr3.lookup("ExtensionPoint")], ["contractId", xdr3.option(xdr3.lookup("Hash"))], ["type", xdr3.lookup("ContractEventType")], ["body", xdr3.lookup("ContractEventBody")]]);
      xdr3.struct("DiagnosticEvent", [["inSuccessfulContractCall", xdr3.bool()], ["event", xdr3.lookup("ContractEvent")]]);
      xdr3.typedef("DiagnosticEvents", xdr3.varArray(xdr3.lookup("DiagnosticEvent"), 2147483647));
      xdr3.struct("SorobanTransactionMetaExtV1", [["ext", xdr3.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", xdr3.lookup("Int64")], ["totalRefundableResourceFeeCharged", xdr3.lookup("Int64")], ["rentFeeCharged", xdr3.lookup("Int64")]]);
      xdr3.union("SorobanTransactionMetaExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("SorobanTransactionMetaExtV1")
        }
      });
      xdr3.struct("SorobanTransactionMeta", [["ext", xdr3.lookup("SorobanTransactionMetaExt")], ["events", xdr3.varArray(xdr3.lookup("ContractEvent"), 2147483647)], ["returnValue", xdr3.lookup("ScVal")], ["diagnosticEvents", xdr3.varArray(xdr3.lookup("DiagnosticEvent"), 2147483647)]]);
      xdr3.struct("TransactionMetaV3", [["ext", xdr3.lookup("ExtensionPoint")], ["txChangesBefore", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr3.lookup("LedgerEntryChanges")], ["sorobanMeta", xdr3.option(xdr3.lookup("SorobanTransactionMeta"))]]);
      xdr3.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", xdr3.lookup("ScVal")], ["events", xdr3.varArray(xdr3.lookup("ContractEvent"), 2147483647)]]);
      xdr3.union("TransactionMeta", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]],
        arms: {
          operations: xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647),
          v1: xdr3.lookup("TransactionMetaV1"),
          v2: xdr3.lookup("TransactionMetaV2"),
          v3: xdr3.lookup("TransactionMetaV3")
        }
      });
      xdr3.struct("TransactionResultMeta", [["result", xdr3.lookup("TransactionResultPair")], ["feeProcessing", xdr3.lookup("LedgerEntryChanges")], ["txApplyProcessing", xdr3.lookup("TransactionMeta")]]);
      xdr3.struct("UpgradeEntryMeta", [["upgrade", xdr3.lookup("LedgerUpgrade")], ["changes", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3.struct("LedgerCloseMetaV0", [["ledgerHeader", xdr3.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr3.lookup("TransactionSet")], ["txProcessing", xdr3.varArray(xdr3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr3.varArray(xdr3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr3.varArray(xdr3.lookup("ScpHistoryEntry"), 2147483647)]]);
      xdr3.struct("LedgerCloseMetaExtV1", [["ext", xdr3.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", xdr3.lookup("Int64")]]);
      xdr3.union("LedgerCloseMetaExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerCloseMetaExtV1")
        }
      });
      xdr3.struct("LedgerCloseMetaV1", [["ext", xdr3.lookup("LedgerCloseMetaExt")], ["ledgerHeader", xdr3.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr3.lookup("GeneralizedTransactionSet")], ["txProcessing", xdr3.varArray(xdr3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr3.varArray(xdr3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr3.varArray(xdr3.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", xdr3.lookup("Uint64")], ["evictedTemporaryLedgerKeys", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", xdr3.varArray(xdr3.lookup("LedgerEntry"), 2147483647)]]);
      xdr3.union("LedgerCloseMeta", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"], [1, "v1"]],
        arms: {
          v0: xdr3.lookup("LedgerCloseMetaV0"),
          v1: xdr3.lookup("LedgerCloseMetaV1")
        }
      });
      xdr3["enum"]("ErrorCode", {
        errMisc: 0,
        errData: 1,
        errConf: 2,
        errAuth: 3,
        errLoad: 4
      });
      xdr3.struct("Error", [["code", xdr3.lookup("ErrorCode")], ["msg", xdr3.string(100)]]);
      xdr3.struct("SendMore", [["numMessages", xdr3.lookup("Uint32")]]);
      xdr3.struct("SendMoreExtended", [["numMessages", xdr3.lookup("Uint32")], ["numBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("AuthCert", [["pubkey", xdr3.lookup("Curve25519Public")], ["expiration", xdr3.lookup("Uint64")], ["sig", xdr3.lookup("Signature")]]);
      xdr3.struct("Hello", [["ledgerVersion", xdr3.lookup("Uint32")], ["overlayVersion", xdr3.lookup("Uint32")], ["overlayMinVersion", xdr3.lookup("Uint32")], ["networkId", xdr3.lookup("Hash")], ["versionStr", xdr3.string(100)], ["listeningPort", xdr3["int"]()], ["peerId", xdr3.lookup("NodeId")], ["cert", xdr3.lookup("AuthCert")], ["nonce", xdr3.lookup("Uint256")]]);
      xdr3["const"]("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200);
      xdr3.struct("Auth", [["flags", xdr3["int"]()]]);
      xdr3["enum"]("IpAddrType", {
        iPv4: 0,
        iPv6: 1
      });
      xdr3.union("PeerAddressIp", {
        switchOn: xdr3.lookup("IpAddrType"),
        switchName: "type",
        switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
        arms: {
          ipv4: xdr3.opaque(4),
          ipv6: xdr3.opaque(16)
        }
      });
      xdr3.struct("PeerAddress", [["ip", xdr3.lookup("PeerAddressIp")], ["port", xdr3.lookup("Uint32")], ["numFailures", xdr3.lookup("Uint32")]]);
      xdr3["enum"]("MessageType", {
        errorMsg: 0,
        auth: 2,
        dontHave: 3,
        getPeers: 4,
        peers: 5,
        getTxSet: 6,
        txSet: 7,
        generalizedTxSet: 17,
        transaction: 8,
        getScpQuorumset: 9,
        scpQuorumset: 10,
        scpMessage: 11,
        getScpState: 12,
        hello: 13,
        surveyRequest: 14,
        surveyResponse: 15,
        sendMore: 16,
        sendMoreExtended: 20,
        floodAdvert: 18,
        floodDemand: 19,
        timeSlicedSurveyRequest: 21,
        timeSlicedSurveyResponse: 22,
        timeSlicedSurveyStartCollecting: 23,
        timeSlicedSurveyStopCollecting: 24
      });
      xdr3.struct("DontHave", [["type", xdr3.lookup("MessageType")], ["reqHash", xdr3.lookup("Uint256")]]);
      xdr3["enum"]("SurveyMessageCommandType", {
        surveyTopology: 0,
        timeSlicedSurveyTopology: 1
      });
      xdr3["enum"]("SurveyMessageResponseType", {
        surveyTopologyResponseV0: 0,
        surveyTopologyResponseV1: 1,
        surveyTopologyResponseV2: 2
      });
      xdr3.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", xdr3.lookup("NodeId")], ["nonce", xdr3.lookup("Uint32")], ["ledgerNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", xdr3.lookup("Signature")], ["startCollecting", xdr3.lookup("TimeSlicedSurveyStartCollectingMessage")]]);
      xdr3.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", xdr3.lookup("NodeId")], ["nonce", xdr3.lookup("Uint32")], ["ledgerNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", xdr3.lookup("Signature")], ["stopCollecting", xdr3.lookup("TimeSlicedSurveyStopCollectingMessage")]]);
      xdr3.struct("SurveyRequestMessage", [["surveyorPeerId", xdr3.lookup("NodeId")], ["surveyedPeerId", xdr3.lookup("NodeId")], ["ledgerNum", xdr3.lookup("Uint32")], ["encryptionKey", xdr3.lookup("Curve25519Public")], ["commandType", xdr3.lookup("SurveyMessageCommandType")]]);
      xdr3.struct("TimeSlicedSurveyRequestMessage", [["request", xdr3.lookup("SurveyRequestMessage")], ["nonce", xdr3.lookup("Uint32")], ["inboundPeersIndex", xdr3.lookup("Uint32")], ["outboundPeersIndex", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedSurveyRequestMessage", [["requestSignature", xdr3.lookup("Signature")], ["request", xdr3.lookup("SurveyRequestMessage")]]);
      xdr3.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", xdr3.lookup("Signature")], ["request", xdr3.lookup("TimeSlicedSurveyRequestMessage")]]);
      xdr3.typedef("EncryptedBody", xdr3.varOpaque(64e3));
      xdr3.struct("SurveyResponseMessage", [["surveyorPeerId", xdr3.lookup("NodeId")], ["surveyedPeerId", xdr3.lookup("NodeId")], ["ledgerNum", xdr3.lookup("Uint32")], ["commandType", xdr3.lookup("SurveyMessageCommandType")], ["encryptedBody", xdr3.lookup("EncryptedBody")]]);
      xdr3.struct("TimeSlicedSurveyResponseMessage", [["response", xdr3.lookup("SurveyResponseMessage")], ["nonce", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedSurveyResponseMessage", [["responseSignature", xdr3.lookup("Signature")], ["response", xdr3.lookup("SurveyResponseMessage")]]);
      xdr3.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", xdr3.lookup("Signature")], ["response", xdr3.lookup("TimeSlicedSurveyResponseMessage")]]);
      xdr3.struct("PeerStats", [["id", xdr3.lookup("NodeId")], ["versionStr", xdr3.string(100)], ["messagesRead", xdr3.lookup("Uint64")], ["messagesWritten", xdr3.lookup("Uint64")], ["bytesRead", xdr3.lookup("Uint64")], ["bytesWritten", xdr3.lookup("Uint64")], ["secondsConnected", xdr3.lookup("Uint64")], ["uniqueFloodBytesRecv", xdr3.lookup("Uint64")], ["duplicateFloodBytesRecv", xdr3.lookup("Uint64")], ["uniqueFetchBytesRecv", xdr3.lookup("Uint64")], ["duplicateFetchBytesRecv", xdr3.lookup("Uint64")], ["uniqueFloodMessageRecv", xdr3.lookup("Uint64")], ["duplicateFloodMessageRecv", xdr3.lookup("Uint64")], ["uniqueFetchMessageRecv", xdr3.lookup("Uint64")], ["duplicateFetchMessageRecv", xdr3.lookup("Uint64")]]);
      xdr3.typedef("PeerStatList", xdr3.varArray(xdr3.lookup("PeerStats"), 25));
      xdr3.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", xdr3.lookup("Uint32")], ["droppedAuthenticatedPeers", xdr3.lookup("Uint32")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", xdr3.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", xdr3.lookup("Uint32")], ["lostSyncCount", xdr3.lookup("Uint32")], ["isValidator", xdr3.bool()], ["maxInboundPeerCount", xdr3.lookup("Uint32")], ["maxOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TimeSlicedPeerData", [["peerStats", xdr3.lookup("PeerStats")], ["averageLatencyMs", xdr3.lookup("Uint32")]]);
      xdr3.typedef("TimeSlicedPeerDataList", xdr3.varArray(xdr3.lookup("TimeSlicedPeerData"), 25));
      xdr3.struct("TopologyResponseBodyV0", [["inboundPeers", xdr3.lookup("PeerStatList")], ["outboundPeers", xdr3.lookup("PeerStatList")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TopologyResponseBodyV1", [["inboundPeers", xdr3.lookup("PeerStatList")], ["outboundPeers", xdr3.lookup("PeerStatList")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")], ["maxInboundPeerCount", xdr3.lookup("Uint32")], ["maxOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TopologyResponseBodyV2", [["inboundPeers", xdr3.lookup("TimeSlicedPeerDataList")], ["outboundPeers", xdr3.lookup("TimeSlicedPeerDataList")], ["nodeData", xdr3.lookup("TimeSlicedNodeData")]]);
      xdr3.union("SurveyResponseBody", {
        switchOn: xdr3.lookup("SurveyMessageResponseType"),
        switchName: "type",
        switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]],
        arms: {
          topologyResponseBodyV0: xdr3.lookup("TopologyResponseBodyV0"),
          topologyResponseBodyV1: xdr3.lookup("TopologyResponseBodyV1"),
          topologyResponseBodyV2: xdr3.lookup("TopologyResponseBodyV2")
        }
      });
      xdr3["const"]("TX_ADVERT_VECTOR_MAX_SIZE", 1e3);
      xdr3.typedef("TxAdvertVector", xdr3.varArray(xdr3.lookup("Hash"), xdr3.lookup("TX_ADVERT_VECTOR_MAX_SIZE")));
      xdr3.struct("FloodAdvert", [["txHashes", xdr3.lookup("TxAdvertVector")]]);
      xdr3["const"]("TX_DEMAND_VECTOR_MAX_SIZE", 1e3);
      xdr3.typedef("TxDemandVector", xdr3.varArray(xdr3.lookup("Hash"), xdr3.lookup("TX_DEMAND_VECTOR_MAX_SIZE")));
      xdr3.struct("FloodDemand", [["txHashes", xdr3.lookup("TxDemandVector")]]);
      xdr3.union("StellarMessage", {
        switchOn: xdr3.lookup("MessageType"),
        switchName: "type",
        switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", xdr3["void"]()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]],
        arms: {
          error: xdr3.lookup("Error"),
          hello: xdr3.lookup("Hello"),
          auth: xdr3.lookup("Auth"),
          dontHave: xdr3.lookup("DontHave"),
          peers: xdr3.varArray(xdr3.lookup("PeerAddress"), 100),
          txSetHash: xdr3.lookup("Uint256"),
          txSet: xdr3.lookup("TransactionSet"),
          generalizedTxSet: xdr3.lookup("GeneralizedTransactionSet"),
          transaction: xdr3.lookup("TransactionEnvelope"),
          signedSurveyRequestMessage: xdr3.lookup("SignedSurveyRequestMessage"),
          signedSurveyResponseMessage: xdr3.lookup("SignedSurveyResponseMessage"),
          signedTimeSlicedSurveyRequestMessage: xdr3.lookup("SignedTimeSlicedSurveyRequestMessage"),
          signedTimeSlicedSurveyResponseMessage: xdr3.lookup("SignedTimeSlicedSurveyResponseMessage"),
          signedTimeSlicedSurveyStartCollectingMessage: xdr3.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),
          signedTimeSlicedSurveyStopCollectingMessage: xdr3.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),
          qSetHash: xdr3.lookup("Uint256"),
          qSet: xdr3.lookup("ScpQuorumSet"),
          envelope: xdr3.lookup("ScpEnvelope"),
          getScpLedgerSeq: xdr3.lookup("Uint32"),
          sendMoreMessage: xdr3.lookup("SendMore"),
          sendMoreExtendedMessage: xdr3.lookup("SendMoreExtended"),
          floodAdvert: xdr3.lookup("FloodAdvert"),
          floodDemand: xdr3.lookup("FloodDemand")
        }
      });
      xdr3.struct("AuthenticatedMessageV0", [["sequence", xdr3.lookup("Uint64")], ["message", xdr3.lookup("StellarMessage")], ["mac", xdr3.lookup("HmacSha256Mac")]]);
      xdr3.union("AuthenticatedMessage", {
        switchOn: xdr3.lookup("Uint32"),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("AuthenticatedMessageV0")
        }
      });
      xdr3["const"]("MAX_OPS_PER_TX", 100);
      xdr3.union("LiquidityPoolParameters", {
        switchOn: xdr3.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr3.lookup("LiquidityPoolConstantProductParameters")
        }
      });
      xdr3.struct("MuxedAccountMed25519", [["id", xdr3.lookup("Uint64")], ["ed25519", xdr3.lookup("Uint256")]]);
      xdr3.union("MuxedAccount", {
        switchOn: xdr3.lookup("CryptoKeyType"),
        switchName: "type",
        switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
        arms: {
          ed25519: xdr3.lookup("Uint256"),
          med25519: xdr3.lookup("MuxedAccountMed25519")
        }
      });
      xdr3.struct("DecoratedSignature", [["hint", xdr3.lookup("SignatureHint")], ["signature", xdr3.lookup("Signature")]]);
      xdr3["enum"]("OperationType", {
        createAccount: 0,
        payment: 1,
        pathPaymentStrictReceive: 2,
        manageSellOffer: 3,
        createPassiveSellOffer: 4,
        setOptions: 5,
        changeTrust: 6,
        allowTrust: 7,
        accountMerge: 8,
        inflation: 9,
        manageData: 10,
        bumpSequence: 11,
        manageBuyOffer: 12,
        pathPaymentStrictSend: 13,
        createClaimableBalance: 14,
        claimClaimableBalance: 15,
        beginSponsoringFutureReserves: 16,
        endSponsoringFutureReserves: 17,
        revokeSponsorship: 18,
        clawback: 19,
        clawbackClaimableBalance: 20,
        setTrustLineFlags: 21,
        liquidityPoolDeposit: 22,
        liquidityPoolWithdraw: 23,
        invokeHostFunction: 24,
        extendFootprintTtl: 25,
        restoreFootprint: 26
      });
      xdr3.struct("CreateAccountOp", [["destination", xdr3.lookup("AccountId")], ["startingBalance", xdr3.lookup("Int64")]]);
      xdr3.struct("PaymentOp", [["destination", xdr3.lookup("MuxedAccount")], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("PathPaymentStrictReceiveOp", [["sendAsset", xdr3.lookup("Asset")], ["sendMax", xdr3.lookup("Int64")], ["destination", xdr3.lookup("MuxedAccount")], ["destAsset", xdr3.lookup("Asset")], ["destAmount", xdr3.lookup("Int64")], ["path", xdr3.varArray(xdr3.lookup("Asset"), 5)]]);
      xdr3.struct("PathPaymentStrictSendOp", [["sendAsset", xdr3.lookup("Asset")], ["sendAmount", xdr3.lookup("Int64")], ["destination", xdr3.lookup("MuxedAccount")], ["destAsset", xdr3.lookup("Asset")], ["destMin", xdr3.lookup("Int64")], ["path", xdr3.varArray(xdr3.lookup("Asset"), 5)]]);
      xdr3.struct("ManageSellOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("ManageBuyOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["buyAmount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("CreatePassiveSellOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")]]);
      xdr3.struct("SetOptionsOp", [["inflationDest", xdr3.option(xdr3.lookup("AccountId"))], ["clearFlags", xdr3.option(xdr3.lookup("Uint32"))], ["setFlags", xdr3.option(xdr3.lookup("Uint32"))], ["masterWeight", xdr3.option(xdr3.lookup("Uint32"))], ["lowThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["medThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["highThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["homeDomain", xdr3.option(xdr3.lookup("String32"))], ["signer", xdr3.option(xdr3.lookup("Signer"))]]);
      xdr3.union("ChangeTrustAsset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12"),
          liquidityPool: xdr3.lookup("LiquidityPoolParameters")
        }
      });
      xdr3.struct("ChangeTrustOp", [["line", xdr3.lookup("ChangeTrustAsset")], ["limit", xdr3.lookup("Int64")]]);
      xdr3.struct("AllowTrustOp", [["trustor", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("AssetCode")], ["authorize", xdr3.lookup("Uint32")]]);
      xdr3.struct("ManageDataOp", [["dataName", xdr3.lookup("String64")], ["dataValue", xdr3.option(xdr3.lookup("DataValue"))]]);
      xdr3.struct("BumpSequenceOp", [["bumpTo", xdr3.lookup("SequenceNumber")]]);
      xdr3.struct("CreateClaimableBalanceOp", [["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["claimants", xdr3.varArray(xdr3.lookup("Claimant"), 10)]]);
      xdr3.struct("ClaimClaimableBalanceOp", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", xdr3.lookup("AccountId")]]);
      xdr3["enum"]("RevokeSponsorshipType", {
        revokeSponsorshipLedgerEntry: 0,
        revokeSponsorshipSigner: 1
      });
      xdr3.struct("RevokeSponsorshipOpSigner", [["accountId", xdr3.lookup("AccountId")], ["signerKey", xdr3.lookup("SignerKey")]]);
      xdr3.union("RevokeSponsorshipOp", {
        switchOn: xdr3.lookup("RevokeSponsorshipType"),
        switchName: "type",
        switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
        arms: {
          ledgerKey: xdr3.lookup("LedgerKey"),
          signer: xdr3.lookup("RevokeSponsorshipOpSigner")
        }
      });
      xdr3.struct("ClawbackOp", [["asset", xdr3.lookup("Asset")], ["from", xdr3.lookup("MuxedAccount")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("ClawbackClaimableBalanceOp", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("SetTrustLineFlagsOp", [["trustor", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("Asset")], ["clearFlags", xdr3.lookup("Uint32")], ["setFlags", xdr3.lookup("Uint32")]]);
      xdr3["const"]("LIQUIDITY_POOL_FEE_V18", 30);
      xdr3.struct("LiquidityPoolDepositOp", [["liquidityPoolId", xdr3.lookup("PoolId")], ["maxAmountA", xdr3.lookup("Int64")], ["maxAmountB", xdr3.lookup("Int64")], ["minPrice", xdr3.lookup("Price")], ["maxPrice", xdr3.lookup("Price")]]);
      xdr3.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", xdr3.lookup("PoolId")], ["amount", xdr3.lookup("Int64")], ["minAmountA", xdr3.lookup("Int64")], ["minAmountB", xdr3.lookup("Int64")]]);
      xdr3["enum"]("HostFunctionType", {
        hostFunctionTypeInvokeContract: 0,
        hostFunctionTypeCreateContract: 1,
        hostFunctionTypeUploadContractWasm: 2,
        hostFunctionTypeCreateContractV2: 3
      });
      xdr3["enum"]("ContractIdPreimageType", {
        contractIdPreimageFromAddress: 0,
        contractIdPreimageFromAsset: 1
      });
      xdr3.struct("ContractIdPreimageFromAddress", [["address", xdr3.lookup("ScAddress")], ["salt", xdr3.lookup("Uint256")]]);
      xdr3.union("ContractIdPreimage", {
        switchOn: xdr3.lookup("ContractIdPreimageType"),
        switchName: "type",
        switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]],
        arms: {
          fromAddress: xdr3.lookup("ContractIdPreimageFromAddress"),
          fromAsset: xdr3.lookup("Asset")
        }
      });
      xdr3.struct("CreateContractArgs", [["contractIdPreimage", xdr3.lookup("ContractIdPreimage")], ["executable", xdr3.lookup("ContractExecutable")]]);
      xdr3.struct("CreateContractArgsV2", [["contractIdPreimage", xdr3.lookup("ContractIdPreimage")], ["executable", xdr3.lookup("ContractExecutable")], ["constructorArgs", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)]]);
      xdr3.struct("InvokeContractArgs", [["contractAddress", xdr3.lookup("ScAddress")], ["functionName", xdr3.lookup("ScSymbol")], ["args", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)]]);
      xdr3.union("HostFunction", {
        switchOn: xdr3.lookup("HostFunctionType"),
        switchName: "type",
        switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]],
        arms: {
          invokeContract: xdr3.lookup("InvokeContractArgs"),
          createContract: xdr3.lookup("CreateContractArgs"),
          wasm: xdr3.varOpaque(),
          createContractV2: xdr3.lookup("CreateContractArgsV2")
        }
      });
      xdr3["enum"]("SorobanAuthorizedFunctionType", {
        sorobanAuthorizedFunctionTypeContractFn: 0,
        sorobanAuthorizedFunctionTypeCreateContractHostFn: 1,
        sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2
      });
      xdr3.union("SorobanAuthorizedFunction", {
        switchOn: xdr3.lookup("SorobanAuthorizedFunctionType"),
        switchName: "type",
        switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]],
        arms: {
          contractFn: xdr3.lookup("InvokeContractArgs"),
          createContractHostFn: xdr3.lookup("CreateContractArgs"),
          createContractV2HostFn: xdr3.lookup("CreateContractArgsV2")
        }
      });
      xdr3.struct("SorobanAuthorizedInvocation", [["function", xdr3.lookup("SorobanAuthorizedFunction")], ["subInvocations", xdr3.varArray(xdr3.lookup("SorobanAuthorizedInvocation"), 2147483647)]]);
      xdr3.struct("SorobanAddressCredentials", [["address", xdr3.lookup("ScAddress")], ["nonce", xdr3.lookup("Int64")], ["signatureExpirationLedger", xdr3.lookup("Uint32")], ["signature", xdr3.lookup("ScVal")]]);
      xdr3["enum"]("SorobanCredentialsType", {
        sorobanCredentialsSourceAccount: 0,
        sorobanCredentialsAddress: 1
      });
      xdr3.union("SorobanCredentials", {
        switchOn: xdr3.lookup("SorobanCredentialsType"),
        switchName: "type",
        switches: [["sorobanCredentialsSourceAccount", xdr3["void"]()], ["sorobanCredentialsAddress", "address"]],
        arms: {
          address: xdr3.lookup("SorobanAddressCredentials")
        }
      });
      xdr3.struct("SorobanAuthorizationEntry", [["credentials", xdr3.lookup("SorobanCredentials")], ["rootInvocation", xdr3.lookup("SorobanAuthorizedInvocation")]]);
      xdr3.struct("InvokeHostFunctionOp", [["hostFunction", xdr3.lookup("HostFunction")], ["auth", xdr3.varArray(xdr3.lookup("SorobanAuthorizationEntry"), 2147483647)]]);
      xdr3.struct("ExtendFootprintTtlOp", [["ext", xdr3.lookup("ExtensionPoint")], ["extendTo", xdr3.lookup("Uint32")]]);
      xdr3.struct("RestoreFootprintOp", [["ext", xdr3.lookup("ExtensionPoint")]]);
      xdr3.union("OperationBody", {
        switchOn: xdr3.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", xdr3["void"]()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", xdr3["void"]()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]],
        arms: {
          createAccountOp: xdr3.lookup("CreateAccountOp"),
          paymentOp: xdr3.lookup("PaymentOp"),
          pathPaymentStrictReceiveOp: xdr3.lookup("PathPaymentStrictReceiveOp"),
          manageSellOfferOp: xdr3.lookup("ManageSellOfferOp"),
          createPassiveSellOfferOp: xdr3.lookup("CreatePassiveSellOfferOp"),
          setOptionsOp: xdr3.lookup("SetOptionsOp"),
          changeTrustOp: xdr3.lookup("ChangeTrustOp"),
          allowTrustOp: xdr3.lookup("AllowTrustOp"),
          destination: xdr3.lookup("MuxedAccount"),
          manageDataOp: xdr3.lookup("ManageDataOp"),
          bumpSequenceOp: xdr3.lookup("BumpSequenceOp"),
          manageBuyOfferOp: xdr3.lookup("ManageBuyOfferOp"),
          pathPaymentStrictSendOp: xdr3.lookup("PathPaymentStrictSendOp"),
          createClaimableBalanceOp: xdr3.lookup("CreateClaimableBalanceOp"),
          claimClaimableBalanceOp: xdr3.lookup("ClaimClaimableBalanceOp"),
          beginSponsoringFutureReservesOp: xdr3.lookup("BeginSponsoringFutureReservesOp"),
          revokeSponsorshipOp: xdr3.lookup("RevokeSponsorshipOp"),
          clawbackOp: xdr3.lookup("ClawbackOp"),
          clawbackClaimableBalanceOp: xdr3.lookup("ClawbackClaimableBalanceOp"),
          setTrustLineFlagsOp: xdr3.lookup("SetTrustLineFlagsOp"),
          liquidityPoolDepositOp: xdr3.lookup("LiquidityPoolDepositOp"),
          liquidityPoolWithdrawOp: xdr3.lookup("LiquidityPoolWithdrawOp"),
          invokeHostFunctionOp: xdr3.lookup("InvokeHostFunctionOp"),
          extendFootprintTtlOp: xdr3.lookup("ExtendFootprintTtlOp"),
          restoreFootprintOp: xdr3.lookup("RestoreFootprintOp")
        }
      });
      xdr3.struct("Operation", [["sourceAccount", xdr3.option(xdr3.lookup("MuxedAccount"))], ["body", xdr3.lookup("OperationBody")]]);
      xdr3.struct("HashIdPreimageOperationId", [["sourceAccount", xdr3.lookup("AccountId")], ["seqNum", xdr3.lookup("SequenceNumber")], ["opNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("HashIdPreimageRevokeId", [["sourceAccount", xdr3.lookup("AccountId")], ["seqNum", xdr3.lookup("SequenceNumber")], ["opNum", xdr3.lookup("Uint32")], ["liquidityPoolId", xdr3.lookup("PoolId")], ["asset", xdr3.lookup("Asset")]]);
      xdr3.struct("HashIdPreimageContractId", [["networkId", xdr3.lookup("Hash")], ["contractIdPreimage", xdr3.lookup("ContractIdPreimage")]]);
      xdr3.struct("HashIdPreimageSorobanAuthorization", [["networkId", xdr3.lookup("Hash")], ["nonce", xdr3.lookup("Int64")], ["signatureExpirationLedger", xdr3.lookup("Uint32")], ["invocation", xdr3.lookup("SorobanAuthorizedInvocation")]]);
      xdr3.union("HashIdPreimage", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]],
        arms: {
          operationId: xdr3.lookup("HashIdPreimageOperationId"),
          revokeId: xdr3.lookup("HashIdPreimageRevokeId"),
          contractId: xdr3.lookup("HashIdPreimageContractId"),
          sorobanAuthorization: xdr3.lookup("HashIdPreimageSorobanAuthorization")
        }
      });
      xdr3["enum"]("MemoType", {
        memoNone: 0,
        memoText: 1,
        memoId: 2,
        memoHash: 3,
        memoReturn: 4
      });
      xdr3.union("Memo", {
        switchOn: xdr3.lookup("MemoType"),
        switchName: "type",
        switches: [["memoNone", xdr3["void"]()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
        arms: {
          text: xdr3.string(28),
          id: xdr3.lookup("Uint64"),
          hash: xdr3.lookup("Hash"),
          retHash: xdr3.lookup("Hash")
        }
      });
      xdr3.struct("TimeBounds", [["minTime", xdr3.lookup("TimePoint")], ["maxTime", xdr3.lookup("TimePoint")]]);
      xdr3.struct("LedgerBounds", [["minLedger", xdr3.lookup("Uint32")], ["maxLedger", xdr3.lookup("Uint32")]]);
      xdr3.struct("PreconditionsV2", [["timeBounds", xdr3.option(xdr3.lookup("TimeBounds"))], ["ledgerBounds", xdr3.option(xdr3.lookup("LedgerBounds"))], ["minSeqNum", xdr3.option(xdr3.lookup("SequenceNumber"))], ["minSeqAge", xdr3.lookup("Duration")], ["minSeqLedgerGap", xdr3.lookup("Uint32")], ["extraSigners", xdr3.varArray(xdr3.lookup("SignerKey"), 2)]]);
      xdr3["enum"]("PreconditionType", {
        precondNone: 0,
        precondTime: 1,
        precondV2: 2
      });
      xdr3.union("Preconditions", {
        switchOn: xdr3.lookup("PreconditionType"),
        switchName: "type",
        switches: [["precondNone", xdr3["void"]()], ["precondTime", "timeBounds"], ["precondV2", "v2"]],
        arms: {
          timeBounds: xdr3.lookup("TimeBounds"),
          v2: xdr3.lookup("PreconditionsV2")
        }
      });
      xdr3.struct("LedgerFootprint", [["readOnly", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["readWrite", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)]]);
      xdr3["enum"]("ArchivalProofType", {
        existence: 0,
        nonexistence: 1
      });
      xdr3.struct("ArchivalProofNode", [["index", xdr3.lookup("Uint32")], ["hash", xdr3.lookup("Hash")]]);
      xdr3.typedef("ProofLevel", xdr3.varArray(xdr3.lookup("ArchivalProofNode"), 2147483647));
      xdr3.struct("NonexistenceProofBody", [["entriesToProve", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr3.varArray(xdr3.lookup("ProofLevel"), 2147483647)]]);
      xdr3.struct("ExistenceProofBody", [["keysToProve", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr3.varArray(xdr3.lookup("ProofLevel"), 2147483647)]]);
      xdr3.union("ArchivalProofBody", {
        switchOn: xdr3.lookup("ArchivalProofType"),
        switchName: "t",
        switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]],
        arms: {
          nonexistenceProof: xdr3.lookup("NonexistenceProofBody"),
          existenceProof: xdr3.lookup("ExistenceProofBody")
        }
      });
      xdr3.struct("ArchivalProof", [["epoch", xdr3.lookup("Uint32")], ["body", xdr3.lookup("ArchivalProofBody")]]);
      xdr3.struct("SorobanResources", [["footprint", xdr3.lookup("LedgerFootprint")], ["instructions", xdr3.lookup("Uint32")], ["readBytes", xdr3.lookup("Uint32")], ["writeBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("SorobanTransactionData", [["ext", xdr3.lookup("ExtensionPoint")], ["resources", xdr3.lookup("SorobanResources")], ["resourceFee", xdr3.lookup("Int64")]]);
      xdr3.union("TransactionV0Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionV0", [["sourceAccountEd25519", xdr3.lookup("Uint256")], ["fee", xdr3.lookup("Uint32")], ["seqNum", xdr3.lookup("SequenceNumber")], ["timeBounds", xdr3.option(xdr3.lookup("TimeBounds"))], ["memo", xdr3.lookup("Memo")], ["operations", xdr3.varArray(xdr3.lookup("Operation"), xdr3.lookup("MAX_OPS_PER_TX"))], ["ext", xdr3.lookup("TransactionV0Ext")]]);
      xdr3.struct("TransactionV0Envelope", [["tx", xdr3.lookup("TransactionV0")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("TransactionExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "sorobanData"]],
        arms: {
          sorobanData: xdr3.lookup("SorobanTransactionData")
        }
      });
      xdr3.struct("Transaction", [["sourceAccount", xdr3.lookup("MuxedAccount")], ["fee", xdr3.lookup("Uint32")], ["seqNum", xdr3.lookup("SequenceNumber")], ["cond", xdr3.lookup("Preconditions")], ["memo", xdr3.lookup("Memo")], ["operations", xdr3.varArray(xdr3.lookup("Operation"), xdr3.lookup("MAX_OPS_PER_TX"))], ["ext", xdr3.lookup("TransactionExt")]]);
      xdr3.struct("TransactionV1Envelope", [["tx", xdr3.lookup("Transaction")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("FeeBumpTransactionInnerTx", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "v1"]],
        arms: {
          v1: xdr3.lookup("TransactionV1Envelope")
        }
      });
      xdr3.union("FeeBumpTransactionExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("FeeBumpTransaction", [["feeSource", xdr3.lookup("MuxedAccount")], ["fee", xdr3.lookup("Int64")], ["innerTx", xdr3.lookup("FeeBumpTransactionInnerTx")], ["ext", xdr3.lookup("FeeBumpTransactionExt")]]);
      xdr3.struct("FeeBumpTransactionEnvelope", [["tx", xdr3.lookup("FeeBumpTransaction")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("TransactionEnvelope", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          v0: xdr3.lookup("TransactionV0Envelope"),
          v1: xdr3.lookup("TransactionV1Envelope"),
          feeBump: xdr3.lookup("FeeBumpTransactionEnvelope")
        }
      });
      xdr3.union("TransactionSignaturePayloadTaggedTransaction", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          tx: xdr3.lookup("Transaction"),
          feeBump: xdr3.lookup("FeeBumpTransaction")
        }
      });
      xdr3.struct("TransactionSignaturePayload", [["networkId", xdr3.lookup("Hash")], ["taggedTransaction", xdr3.lookup("TransactionSignaturePayloadTaggedTransaction")]]);
      xdr3["enum"]("ClaimAtomType", {
        claimAtomTypeV0: 0,
        claimAtomTypeOrderBook: 1,
        claimAtomTypeLiquidityPool: 2
      });
      xdr3.struct("ClaimOfferAtomV0", [["sellerEd25519", xdr3.lookup("Uint256")], ["offerId", xdr3.lookup("Int64")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.struct("ClaimOfferAtom", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.struct("ClaimLiquidityAtom", [["liquidityPoolId", xdr3.lookup("PoolId")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.union("ClaimAtom", {
        switchOn: xdr3.lookup("ClaimAtomType"),
        switchName: "type",
        switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
        arms: {
          v0: xdr3.lookup("ClaimOfferAtomV0"),
          orderBook: xdr3.lookup("ClaimOfferAtom"),
          liquidityPool: xdr3.lookup("ClaimLiquidityAtom")
        }
      });
      xdr3["enum"]("CreateAccountResultCode", {
        createAccountSuccess: 0,
        createAccountMalformed: -1,
        createAccountUnderfunded: -2,
        createAccountLowReserve: -3,
        createAccountAlreadyExist: -4
      });
      xdr3.union("CreateAccountResult", {
        switchOn: xdr3.lookup("CreateAccountResultCode"),
        switchName: "code",
        switches: [["createAccountSuccess", xdr3["void"]()], ["createAccountMalformed", xdr3["void"]()], ["createAccountUnderfunded", xdr3["void"]()], ["createAccountLowReserve", xdr3["void"]()], ["createAccountAlreadyExist", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("PaymentResultCode", {
        paymentSuccess: 0,
        paymentMalformed: -1,
        paymentUnderfunded: -2,
        paymentSrcNoTrust: -3,
        paymentSrcNotAuthorized: -4,
        paymentNoDestination: -5,
        paymentNoTrust: -6,
        paymentNotAuthorized: -7,
        paymentLineFull: -8,
        paymentNoIssuer: -9
      });
      xdr3.union("PaymentResult", {
        switchOn: xdr3.lookup("PaymentResultCode"),
        switchName: "code",
        switches: [["paymentSuccess", xdr3["void"]()], ["paymentMalformed", xdr3["void"]()], ["paymentUnderfunded", xdr3["void"]()], ["paymentSrcNoTrust", xdr3["void"]()], ["paymentSrcNotAuthorized", xdr3["void"]()], ["paymentNoDestination", xdr3["void"]()], ["paymentNoTrust", xdr3["void"]()], ["paymentNotAuthorized", xdr3["void"]()], ["paymentLineFull", xdr3["void"]()], ["paymentNoIssuer", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("PathPaymentStrictReceiveResultCode", {
        pathPaymentStrictReceiveSuccess: 0,
        pathPaymentStrictReceiveMalformed: -1,
        pathPaymentStrictReceiveUnderfunded: -2,
        pathPaymentStrictReceiveSrcNoTrust: -3,
        pathPaymentStrictReceiveSrcNotAuthorized: -4,
        pathPaymentStrictReceiveNoDestination: -5,
        pathPaymentStrictReceiveNoTrust: -6,
        pathPaymentStrictReceiveNotAuthorized: -7,
        pathPaymentStrictReceiveLineFull: -8,
        pathPaymentStrictReceiveNoIssuer: -9,
        pathPaymentStrictReceiveTooFewOffers: -10,
        pathPaymentStrictReceiveOfferCrossSelf: -11,
        pathPaymentStrictReceiveOverSendmax: -12
      });
      xdr3.struct("SimplePaymentResult", [["destination", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("PathPaymentStrictReceiveResultSuccess", [["offers", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["last", xdr3.lookup("SimplePaymentResult")]]);
      xdr3.union("PathPaymentStrictReceiveResult", {
        switchOn: xdr3.lookup("PathPaymentStrictReceiveResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", xdr3["void"]()], ["pathPaymentStrictReceiveUnderfunded", xdr3["void"]()], ["pathPaymentStrictReceiveSrcNoTrust", xdr3["void"]()], ["pathPaymentStrictReceiveSrcNotAuthorized", xdr3["void"]()], ["pathPaymentStrictReceiveNoDestination", xdr3["void"]()], ["pathPaymentStrictReceiveNoTrust", xdr3["void"]()], ["pathPaymentStrictReceiveNotAuthorized", xdr3["void"]()], ["pathPaymentStrictReceiveLineFull", xdr3["void"]()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", xdr3["void"]()], ["pathPaymentStrictReceiveOfferCrossSelf", xdr3["void"]()], ["pathPaymentStrictReceiveOverSendmax", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("PathPaymentStrictReceiveResultSuccess"),
          noIssuer: xdr3.lookup("Asset")
        }
      });
      xdr3["enum"]("PathPaymentStrictSendResultCode", {
        pathPaymentStrictSendSuccess: 0,
        pathPaymentStrictSendMalformed: -1,
        pathPaymentStrictSendUnderfunded: -2,
        pathPaymentStrictSendSrcNoTrust: -3,
        pathPaymentStrictSendSrcNotAuthorized: -4,
        pathPaymentStrictSendNoDestination: -5,
        pathPaymentStrictSendNoTrust: -6,
        pathPaymentStrictSendNotAuthorized: -7,
        pathPaymentStrictSendLineFull: -8,
        pathPaymentStrictSendNoIssuer: -9,
        pathPaymentStrictSendTooFewOffers: -10,
        pathPaymentStrictSendOfferCrossSelf: -11,
        pathPaymentStrictSendUnderDestmin: -12
      });
      xdr3.struct("PathPaymentStrictSendResultSuccess", [["offers", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["last", xdr3.lookup("SimplePaymentResult")]]);
      xdr3.union("PathPaymentStrictSendResult", {
        switchOn: xdr3.lookup("PathPaymentStrictSendResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", xdr3["void"]()], ["pathPaymentStrictSendUnderfunded", xdr3["void"]()], ["pathPaymentStrictSendSrcNoTrust", xdr3["void"]()], ["pathPaymentStrictSendSrcNotAuthorized", xdr3["void"]()], ["pathPaymentStrictSendNoDestination", xdr3["void"]()], ["pathPaymentStrictSendNoTrust", xdr3["void"]()], ["pathPaymentStrictSendNotAuthorized", xdr3["void"]()], ["pathPaymentStrictSendLineFull", xdr3["void"]()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", xdr3["void"]()], ["pathPaymentStrictSendOfferCrossSelf", xdr3["void"]()], ["pathPaymentStrictSendUnderDestmin", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("PathPaymentStrictSendResultSuccess"),
          noIssuer: xdr3.lookup("Asset")
        }
      });
      xdr3["enum"]("ManageSellOfferResultCode", {
        manageSellOfferSuccess: 0,
        manageSellOfferMalformed: -1,
        manageSellOfferSellNoTrust: -2,
        manageSellOfferBuyNoTrust: -3,
        manageSellOfferSellNotAuthorized: -4,
        manageSellOfferBuyNotAuthorized: -5,
        manageSellOfferLineFull: -6,
        manageSellOfferUnderfunded: -7,
        manageSellOfferCrossSelf: -8,
        manageSellOfferSellNoIssuer: -9,
        manageSellOfferBuyNoIssuer: -10,
        manageSellOfferNotFound: -11,
        manageSellOfferLowReserve: -12
      });
      xdr3["enum"]("ManageOfferEffect", {
        manageOfferCreated: 0,
        manageOfferUpdated: 1,
        manageOfferDeleted: 2
      });
      xdr3.union("ManageOfferSuccessResultOffer", {
        switchOn: xdr3.lookup("ManageOfferEffect"),
        switchName: "effect",
        switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", xdr3["void"]()]],
        arms: {
          offer: xdr3.lookup("OfferEntry")
        }
      });
      xdr3.struct("ManageOfferSuccessResult", [["offersClaimed", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["offer", xdr3.lookup("ManageOfferSuccessResultOffer")]]);
      xdr3.union("ManageSellOfferResult", {
        switchOn: xdr3.lookup("ManageSellOfferResultCode"),
        switchName: "code",
        switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", xdr3["void"]()], ["manageSellOfferSellNoTrust", xdr3["void"]()], ["manageSellOfferBuyNoTrust", xdr3["void"]()], ["manageSellOfferSellNotAuthorized", xdr3["void"]()], ["manageSellOfferBuyNotAuthorized", xdr3["void"]()], ["manageSellOfferLineFull", xdr3["void"]()], ["manageSellOfferUnderfunded", xdr3["void"]()], ["manageSellOfferCrossSelf", xdr3["void"]()], ["manageSellOfferSellNoIssuer", xdr3["void"]()], ["manageSellOfferBuyNoIssuer", xdr3["void"]()], ["manageSellOfferNotFound", xdr3["void"]()], ["manageSellOfferLowReserve", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("ManageOfferSuccessResult")
        }
      });
      xdr3["enum"]("ManageBuyOfferResultCode", {
        manageBuyOfferSuccess: 0,
        manageBuyOfferMalformed: -1,
        manageBuyOfferSellNoTrust: -2,
        manageBuyOfferBuyNoTrust: -3,
        manageBuyOfferSellNotAuthorized: -4,
        manageBuyOfferBuyNotAuthorized: -5,
        manageBuyOfferLineFull: -6,
        manageBuyOfferUnderfunded: -7,
        manageBuyOfferCrossSelf: -8,
        manageBuyOfferSellNoIssuer: -9,
        manageBuyOfferBuyNoIssuer: -10,
        manageBuyOfferNotFound: -11,
        manageBuyOfferLowReserve: -12
      });
      xdr3.union("ManageBuyOfferResult", {
        switchOn: xdr3.lookup("ManageBuyOfferResultCode"),
        switchName: "code",
        switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", xdr3["void"]()], ["manageBuyOfferSellNoTrust", xdr3["void"]()], ["manageBuyOfferBuyNoTrust", xdr3["void"]()], ["manageBuyOfferSellNotAuthorized", xdr3["void"]()], ["manageBuyOfferBuyNotAuthorized", xdr3["void"]()], ["manageBuyOfferLineFull", xdr3["void"]()], ["manageBuyOfferUnderfunded", xdr3["void"]()], ["manageBuyOfferCrossSelf", xdr3["void"]()], ["manageBuyOfferSellNoIssuer", xdr3["void"]()], ["manageBuyOfferBuyNoIssuer", xdr3["void"]()], ["manageBuyOfferNotFound", xdr3["void"]()], ["manageBuyOfferLowReserve", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("ManageOfferSuccessResult")
        }
      });
      xdr3["enum"]("SetOptionsResultCode", {
        setOptionsSuccess: 0,
        setOptionsLowReserve: -1,
        setOptionsTooManySigners: -2,
        setOptionsBadFlags: -3,
        setOptionsInvalidInflation: -4,
        setOptionsCantChange: -5,
        setOptionsUnknownFlag: -6,
        setOptionsThresholdOutOfRange: -7,
        setOptionsBadSigner: -8,
        setOptionsInvalidHomeDomain: -9,
        setOptionsAuthRevocableRequired: -10
      });
      xdr3.union("SetOptionsResult", {
        switchOn: xdr3.lookup("SetOptionsResultCode"),
        switchName: "code",
        switches: [["setOptionsSuccess", xdr3["void"]()], ["setOptionsLowReserve", xdr3["void"]()], ["setOptionsTooManySigners", xdr3["void"]()], ["setOptionsBadFlags", xdr3["void"]()], ["setOptionsInvalidInflation", xdr3["void"]()], ["setOptionsCantChange", xdr3["void"]()], ["setOptionsUnknownFlag", xdr3["void"]()], ["setOptionsThresholdOutOfRange", xdr3["void"]()], ["setOptionsBadSigner", xdr3["void"]()], ["setOptionsInvalidHomeDomain", xdr3["void"]()], ["setOptionsAuthRevocableRequired", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ChangeTrustResultCode", {
        changeTrustSuccess: 0,
        changeTrustMalformed: -1,
        changeTrustNoIssuer: -2,
        changeTrustInvalidLimit: -3,
        changeTrustLowReserve: -4,
        changeTrustSelfNotAllowed: -5,
        changeTrustTrustLineMissing: -6,
        changeTrustCannotDelete: -7,
        changeTrustNotAuthMaintainLiabilities: -8
      });
      xdr3.union("ChangeTrustResult", {
        switchOn: xdr3.lookup("ChangeTrustResultCode"),
        switchName: "code",
        switches: [["changeTrustSuccess", xdr3["void"]()], ["changeTrustMalformed", xdr3["void"]()], ["changeTrustNoIssuer", xdr3["void"]()], ["changeTrustInvalidLimit", xdr3["void"]()], ["changeTrustLowReserve", xdr3["void"]()], ["changeTrustSelfNotAllowed", xdr3["void"]()], ["changeTrustTrustLineMissing", xdr3["void"]()], ["changeTrustCannotDelete", xdr3["void"]()], ["changeTrustNotAuthMaintainLiabilities", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("AllowTrustResultCode", {
        allowTrustSuccess: 0,
        allowTrustMalformed: -1,
        allowTrustNoTrustLine: -2,
        allowTrustTrustNotRequired: -3,
        allowTrustCantRevoke: -4,
        allowTrustSelfNotAllowed: -5,
        allowTrustLowReserve: -6
      });
      xdr3.union("AllowTrustResult", {
        switchOn: xdr3.lookup("AllowTrustResultCode"),
        switchName: "code",
        switches: [["allowTrustSuccess", xdr3["void"]()], ["allowTrustMalformed", xdr3["void"]()], ["allowTrustNoTrustLine", xdr3["void"]()], ["allowTrustTrustNotRequired", xdr3["void"]()], ["allowTrustCantRevoke", xdr3["void"]()], ["allowTrustSelfNotAllowed", xdr3["void"]()], ["allowTrustLowReserve", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("AccountMergeResultCode", {
        accountMergeSuccess: 0,
        accountMergeMalformed: -1,
        accountMergeNoAccount: -2,
        accountMergeImmutableSet: -3,
        accountMergeHasSubEntries: -4,
        accountMergeSeqnumTooFar: -5,
        accountMergeDestFull: -6,
        accountMergeIsSponsor: -7
      });
      xdr3.union("AccountMergeResult", {
        switchOn: xdr3.lookup("AccountMergeResultCode"),
        switchName: "code",
        switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", xdr3["void"]()], ["accountMergeNoAccount", xdr3["void"]()], ["accountMergeImmutableSet", xdr3["void"]()], ["accountMergeHasSubEntries", xdr3["void"]()], ["accountMergeSeqnumTooFar", xdr3["void"]()], ["accountMergeDestFull", xdr3["void"]()], ["accountMergeIsSponsor", xdr3["void"]()]],
        arms: {
          sourceAccountBalance: xdr3.lookup("Int64")
        }
      });
      xdr3["enum"]("InflationResultCode", {
        inflationSuccess: 0,
        inflationNotTime: -1
      });
      xdr3.struct("InflationPayout", [["destination", xdr3.lookup("AccountId")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.union("InflationResult", {
        switchOn: xdr3.lookup("InflationResultCode"),
        switchName: "code",
        switches: [["inflationSuccess", "payouts"], ["inflationNotTime", xdr3["void"]()]],
        arms: {
          payouts: xdr3.varArray(xdr3.lookup("InflationPayout"), 2147483647)
        }
      });
      xdr3["enum"]("ManageDataResultCode", {
        manageDataSuccess: 0,
        manageDataNotSupportedYet: -1,
        manageDataNameNotFound: -2,
        manageDataLowReserve: -3,
        manageDataInvalidName: -4
      });
      xdr3.union("ManageDataResult", {
        switchOn: xdr3.lookup("ManageDataResultCode"),
        switchName: "code",
        switches: [["manageDataSuccess", xdr3["void"]()], ["manageDataNotSupportedYet", xdr3["void"]()], ["manageDataNameNotFound", xdr3["void"]()], ["manageDataLowReserve", xdr3["void"]()], ["manageDataInvalidName", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("BumpSequenceResultCode", {
        bumpSequenceSuccess: 0,
        bumpSequenceBadSeq: -1
      });
      xdr3.union("BumpSequenceResult", {
        switchOn: xdr3.lookup("BumpSequenceResultCode"),
        switchName: "code",
        switches: [["bumpSequenceSuccess", xdr3["void"]()], ["bumpSequenceBadSeq", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("CreateClaimableBalanceResultCode", {
        createClaimableBalanceSuccess: 0,
        createClaimableBalanceMalformed: -1,
        createClaimableBalanceLowReserve: -2,
        createClaimableBalanceNoTrust: -3,
        createClaimableBalanceNotAuthorized: -4,
        createClaimableBalanceUnderfunded: -5
      });
      xdr3.union("CreateClaimableBalanceResult", {
        switchOn: xdr3.lookup("CreateClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", xdr3["void"]()], ["createClaimableBalanceLowReserve", xdr3["void"]()], ["createClaimableBalanceNoTrust", xdr3["void"]()], ["createClaimableBalanceNotAuthorized", xdr3["void"]()], ["createClaimableBalanceUnderfunded", xdr3["void"]()]],
        arms: {
          balanceId: xdr3.lookup("ClaimableBalanceId")
        }
      });
      xdr3["enum"]("ClaimClaimableBalanceResultCode", {
        claimClaimableBalanceSuccess: 0,
        claimClaimableBalanceDoesNotExist: -1,
        claimClaimableBalanceCannotClaim: -2,
        claimClaimableBalanceLineFull: -3,
        claimClaimableBalanceNoTrust: -4,
        claimClaimableBalanceNotAuthorized: -5
      });
      xdr3.union("ClaimClaimableBalanceResult", {
        switchOn: xdr3.lookup("ClaimClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["claimClaimableBalanceSuccess", xdr3["void"]()], ["claimClaimableBalanceDoesNotExist", xdr3["void"]()], ["claimClaimableBalanceCannotClaim", xdr3["void"]()], ["claimClaimableBalanceLineFull", xdr3["void"]()], ["claimClaimableBalanceNoTrust", xdr3["void"]()], ["claimClaimableBalanceNotAuthorized", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("BeginSponsoringFutureReservesResultCode", {
        beginSponsoringFutureReservesSuccess: 0,
        beginSponsoringFutureReservesMalformed: -1,
        beginSponsoringFutureReservesAlreadySponsored: -2,
        beginSponsoringFutureReservesRecursive: -3
      });
      xdr3.union("BeginSponsoringFutureReservesResult", {
        switchOn: xdr3.lookup("BeginSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["beginSponsoringFutureReservesSuccess", xdr3["void"]()], ["beginSponsoringFutureReservesMalformed", xdr3["void"]()], ["beginSponsoringFutureReservesAlreadySponsored", xdr3["void"]()], ["beginSponsoringFutureReservesRecursive", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("EndSponsoringFutureReservesResultCode", {
        endSponsoringFutureReservesSuccess: 0,
        endSponsoringFutureReservesNotSponsored: -1
      });
      xdr3.union("EndSponsoringFutureReservesResult", {
        switchOn: xdr3.lookup("EndSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["endSponsoringFutureReservesSuccess", xdr3["void"]()], ["endSponsoringFutureReservesNotSponsored", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("RevokeSponsorshipResultCode", {
        revokeSponsorshipSuccess: 0,
        revokeSponsorshipDoesNotExist: -1,
        revokeSponsorshipNotSponsor: -2,
        revokeSponsorshipLowReserve: -3,
        revokeSponsorshipOnlyTransferable: -4,
        revokeSponsorshipMalformed: -5
      });
      xdr3.union("RevokeSponsorshipResult", {
        switchOn: xdr3.lookup("RevokeSponsorshipResultCode"),
        switchName: "code",
        switches: [["revokeSponsorshipSuccess", xdr3["void"]()], ["revokeSponsorshipDoesNotExist", xdr3["void"]()], ["revokeSponsorshipNotSponsor", xdr3["void"]()], ["revokeSponsorshipLowReserve", xdr3["void"]()], ["revokeSponsorshipOnlyTransferable", xdr3["void"]()], ["revokeSponsorshipMalformed", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ClawbackResultCode", {
        clawbackSuccess: 0,
        clawbackMalformed: -1,
        clawbackNotClawbackEnabled: -2,
        clawbackNoTrust: -3,
        clawbackUnderfunded: -4
      });
      xdr3.union("ClawbackResult", {
        switchOn: xdr3.lookup("ClawbackResultCode"),
        switchName: "code",
        switches: [["clawbackSuccess", xdr3["void"]()], ["clawbackMalformed", xdr3["void"]()], ["clawbackNotClawbackEnabled", xdr3["void"]()], ["clawbackNoTrust", xdr3["void"]()], ["clawbackUnderfunded", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ClawbackClaimableBalanceResultCode", {
        clawbackClaimableBalanceSuccess: 0,
        clawbackClaimableBalanceDoesNotExist: -1,
        clawbackClaimableBalanceNotIssuer: -2,
        clawbackClaimableBalanceNotClawbackEnabled: -3
      });
      xdr3.union("ClawbackClaimableBalanceResult", {
        switchOn: xdr3.lookup("ClawbackClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["clawbackClaimableBalanceSuccess", xdr3["void"]()], ["clawbackClaimableBalanceDoesNotExist", xdr3["void"]()], ["clawbackClaimableBalanceNotIssuer", xdr3["void"]()], ["clawbackClaimableBalanceNotClawbackEnabled", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("SetTrustLineFlagsResultCode", {
        setTrustLineFlagsSuccess: 0,
        setTrustLineFlagsMalformed: -1,
        setTrustLineFlagsNoTrustLine: -2,
        setTrustLineFlagsCantRevoke: -3,
        setTrustLineFlagsInvalidState: -4,
        setTrustLineFlagsLowReserve: -5
      });
      xdr3.union("SetTrustLineFlagsResult", {
        switchOn: xdr3.lookup("SetTrustLineFlagsResultCode"),
        switchName: "code",
        switches: [["setTrustLineFlagsSuccess", xdr3["void"]()], ["setTrustLineFlagsMalformed", xdr3["void"]()], ["setTrustLineFlagsNoTrustLine", xdr3["void"]()], ["setTrustLineFlagsCantRevoke", xdr3["void"]()], ["setTrustLineFlagsInvalidState", xdr3["void"]()], ["setTrustLineFlagsLowReserve", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("LiquidityPoolDepositResultCode", {
        liquidityPoolDepositSuccess: 0,
        liquidityPoolDepositMalformed: -1,
        liquidityPoolDepositNoTrust: -2,
        liquidityPoolDepositNotAuthorized: -3,
        liquidityPoolDepositUnderfunded: -4,
        liquidityPoolDepositLineFull: -5,
        liquidityPoolDepositBadPrice: -6,
        liquidityPoolDepositPoolFull: -7
      });
      xdr3.union("LiquidityPoolDepositResult", {
        switchOn: xdr3.lookup("LiquidityPoolDepositResultCode"),
        switchName: "code",
        switches: [["liquidityPoolDepositSuccess", xdr3["void"]()], ["liquidityPoolDepositMalformed", xdr3["void"]()], ["liquidityPoolDepositNoTrust", xdr3["void"]()], ["liquidityPoolDepositNotAuthorized", xdr3["void"]()], ["liquidityPoolDepositUnderfunded", xdr3["void"]()], ["liquidityPoolDepositLineFull", xdr3["void"]()], ["liquidityPoolDepositBadPrice", xdr3["void"]()], ["liquidityPoolDepositPoolFull", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("LiquidityPoolWithdrawResultCode", {
        liquidityPoolWithdrawSuccess: 0,
        liquidityPoolWithdrawMalformed: -1,
        liquidityPoolWithdrawNoTrust: -2,
        liquidityPoolWithdrawUnderfunded: -3,
        liquidityPoolWithdrawLineFull: -4,
        liquidityPoolWithdrawUnderMinimum: -5
      });
      xdr3.union("LiquidityPoolWithdrawResult", {
        switchOn: xdr3.lookup("LiquidityPoolWithdrawResultCode"),
        switchName: "code",
        switches: [["liquidityPoolWithdrawSuccess", xdr3["void"]()], ["liquidityPoolWithdrawMalformed", xdr3["void"]()], ["liquidityPoolWithdrawNoTrust", xdr3["void"]()], ["liquidityPoolWithdrawUnderfunded", xdr3["void"]()], ["liquidityPoolWithdrawLineFull", xdr3["void"]()], ["liquidityPoolWithdrawUnderMinimum", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("InvokeHostFunctionResultCode", {
        invokeHostFunctionSuccess: 0,
        invokeHostFunctionMalformed: -1,
        invokeHostFunctionTrapped: -2,
        invokeHostFunctionResourceLimitExceeded: -3,
        invokeHostFunctionEntryArchived: -4,
        invokeHostFunctionInsufficientRefundableFee: -5
      });
      xdr3.union("InvokeHostFunctionResult", {
        switchOn: xdr3.lookup("InvokeHostFunctionResultCode"),
        switchName: "code",
        switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", xdr3["void"]()], ["invokeHostFunctionTrapped", xdr3["void"]()], ["invokeHostFunctionResourceLimitExceeded", xdr3["void"]()], ["invokeHostFunctionEntryArchived", xdr3["void"]()], ["invokeHostFunctionInsufficientRefundableFee", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ExtendFootprintTtlResultCode", {
        extendFootprintTtlSuccess: 0,
        extendFootprintTtlMalformed: -1,
        extendFootprintTtlResourceLimitExceeded: -2,
        extendFootprintTtlInsufficientRefundableFee: -3
      });
      xdr3.union("ExtendFootprintTtlResult", {
        switchOn: xdr3.lookup("ExtendFootprintTtlResultCode"),
        switchName: "code",
        switches: [["extendFootprintTtlSuccess", xdr3["void"]()], ["extendFootprintTtlMalformed", xdr3["void"]()], ["extendFootprintTtlResourceLimitExceeded", xdr3["void"]()], ["extendFootprintTtlInsufficientRefundableFee", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("RestoreFootprintResultCode", {
        restoreFootprintSuccess: 0,
        restoreFootprintMalformed: -1,
        restoreFootprintResourceLimitExceeded: -2,
        restoreFootprintInsufficientRefundableFee: -3
      });
      xdr3.union("RestoreFootprintResult", {
        switchOn: xdr3.lookup("RestoreFootprintResultCode"),
        switchName: "code",
        switches: [["restoreFootprintSuccess", xdr3["void"]()], ["restoreFootprintMalformed", xdr3["void"]()], ["restoreFootprintResourceLimitExceeded", xdr3["void"]()], ["restoreFootprintInsufficientRefundableFee", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("OperationResultCode", {
        opInner: 0,
        opBadAuth: -1,
        opNoAccount: -2,
        opNotSupported: -3,
        opTooManySubentries: -4,
        opExceededWorkLimit: -5,
        opTooManySponsoring: -6
      });
      xdr3.union("OperationResultTr", {
        switchOn: xdr3.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]],
        arms: {
          createAccountResult: xdr3.lookup("CreateAccountResult"),
          paymentResult: xdr3.lookup("PaymentResult"),
          pathPaymentStrictReceiveResult: xdr3.lookup("PathPaymentStrictReceiveResult"),
          manageSellOfferResult: xdr3.lookup("ManageSellOfferResult"),
          createPassiveSellOfferResult: xdr3.lookup("ManageSellOfferResult"),
          setOptionsResult: xdr3.lookup("SetOptionsResult"),
          changeTrustResult: xdr3.lookup("ChangeTrustResult"),
          allowTrustResult: xdr3.lookup("AllowTrustResult"),
          accountMergeResult: xdr3.lookup("AccountMergeResult"),
          inflationResult: xdr3.lookup("InflationResult"),
          manageDataResult: xdr3.lookup("ManageDataResult"),
          bumpSeqResult: xdr3.lookup("BumpSequenceResult"),
          manageBuyOfferResult: xdr3.lookup("ManageBuyOfferResult"),
          pathPaymentStrictSendResult: xdr3.lookup("PathPaymentStrictSendResult"),
          createClaimableBalanceResult: xdr3.lookup("CreateClaimableBalanceResult"),
          claimClaimableBalanceResult: xdr3.lookup("ClaimClaimableBalanceResult"),
          beginSponsoringFutureReservesResult: xdr3.lookup("BeginSponsoringFutureReservesResult"),
          endSponsoringFutureReservesResult: xdr3.lookup("EndSponsoringFutureReservesResult"),
          revokeSponsorshipResult: xdr3.lookup("RevokeSponsorshipResult"),
          clawbackResult: xdr3.lookup("ClawbackResult"),
          clawbackClaimableBalanceResult: xdr3.lookup("ClawbackClaimableBalanceResult"),
          setTrustLineFlagsResult: xdr3.lookup("SetTrustLineFlagsResult"),
          liquidityPoolDepositResult: xdr3.lookup("LiquidityPoolDepositResult"),
          liquidityPoolWithdrawResult: xdr3.lookup("LiquidityPoolWithdrawResult"),
          invokeHostFunctionResult: xdr3.lookup("InvokeHostFunctionResult"),
          extendFootprintTtlResult: xdr3.lookup("ExtendFootprintTtlResult"),
          restoreFootprintResult: xdr3.lookup("RestoreFootprintResult")
        }
      });
      xdr3.union("OperationResult", {
        switchOn: xdr3.lookup("OperationResultCode"),
        switchName: "code",
        switches: [["opInner", "tr"], ["opBadAuth", xdr3["void"]()], ["opNoAccount", xdr3["void"]()], ["opNotSupported", xdr3["void"]()], ["opTooManySubentries", xdr3["void"]()], ["opExceededWorkLimit", xdr3["void"]()], ["opTooManySponsoring", xdr3["void"]()]],
        arms: {
          tr: xdr3.lookup("OperationResultTr")
        }
      });
      xdr3["enum"]("TransactionResultCode", {
        txFeeBumpInnerSuccess: 1,
        txSuccess: 0,
        txFailed: -1,
        txTooEarly: -2,
        txTooLate: -3,
        txMissingOperation: -4,
        txBadSeq: -5,
        txBadAuth: -6,
        txInsufficientBalance: -7,
        txNoAccount: -8,
        txInsufficientFee: -9,
        txBadAuthExtra: -10,
        txInternalError: -11,
        txNotSupported: -12,
        txFeeBumpInnerFailed: -13,
        txBadSponsorship: -14,
        txBadMinSeqAgeOrGap: -15,
        txMalformed: -16,
        txSorobanInvalid: -17
      });
      xdr3.union("InnerTransactionResultResult", {
        switchOn: xdr3.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr3["void"]()], ["txTooLate", xdr3["void"]()], ["txMissingOperation", xdr3["void"]()], ["txBadSeq", xdr3["void"]()], ["txBadAuth", xdr3["void"]()], ["txInsufficientBalance", xdr3["void"]()], ["txNoAccount", xdr3["void"]()], ["txInsufficientFee", xdr3["void"]()], ["txBadAuthExtra", xdr3["void"]()], ["txInternalError", xdr3["void"]()], ["txNotSupported", xdr3["void"]()], ["txBadSponsorship", xdr3["void"]()], ["txBadMinSeqAgeOrGap", xdr3["void"]()], ["txMalformed", xdr3["void"]()], ["txSorobanInvalid", xdr3["void"]()]],
        arms: {
          results: xdr3.varArray(xdr3.lookup("OperationResult"), 2147483647)
        }
      });
      xdr3.union("InnerTransactionResultExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("InnerTransactionResult", [["feeCharged", xdr3.lookup("Int64")], ["result", xdr3.lookup("InnerTransactionResultResult")], ["ext", xdr3.lookup("InnerTransactionResultExt")]]);
      xdr3.struct("InnerTransactionResultPair", [["transactionHash", xdr3.lookup("Hash")], ["result", xdr3.lookup("InnerTransactionResult")]]);
      xdr3.union("TransactionResultResult", {
        switchOn: xdr3.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr3["void"]()], ["txTooLate", xdr3["void"]()], ["txMissingOperation", xdr3["void"]()], ["txBadSeq", xdr3["void"]()], ["txBadAuth", xdr3["void"]()], ["txInsufficientBalance", xdr3["void"]()], ["txNoAccount", xdr3["void"]()], ["txInsufficientFee", xdr3["void"]()], ["txBadAuthExtra", xdr3["void"]()], ["txInternalError", xdr3["void"]()], ["txNotSupported", xdr3["void"]()], ["txBadSponsorship", xdr3["void"]()], ["txBadMinSeqAgeOrGap", xdr3["void"]()], ["txMalformed", xdr3["void"]()], ["txSorobanInvalid", xdr3["void"]()]],
        arms: {
          innerResultPair: xdr3.lookup("InnerTransactionResultPair"),
          results: xdr3.varArray(xdr3.lookup("OperationResult"), 2147483647)
        }
      });
      xdr3.union("TransactionResultExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionResult", [["feeCharged", xdr3.lookup("Int64")], ["result", xdr3.lookup("TransactionResultResult")], ["ext", xdr3.lookup("TransactionResultExt")]]);
      xdr3.typedef("Hash", xdr3.opaque(32));
      xdr3.typedef("Uint256", xdr3.opaque(32));
      xdr3.typedef("Uint32", xdr3.uint());
      xdr3.typedef("Int32", xdr3["int"]());
      xdr3.typedef("Uint64", xdr3.uhyper());
      xdr3.typedef("Int64", xdr3.hyper());
      xdr3.typedef("TimePoint", xdr3.lookup("Uint64"));
      xdr3.typedef("Duration", xdr3.lookup("Uint64"));
      xdr3.union("ExtensionPoint", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("CryptoKeyType", {
        keyTypeEd25519: 0,
        keyTypePreAuthTx: 1,
        keyTypeHashX: 2,
        keyTypeEd25519SignedPayload: 3,
        keyTypeMuxedEd25519: 256
      });
      xdr3["enum"]("PublicKeyType", {
        publicKeyTypeEd25519: 0
      });
      xdr3["enum"]("SignerKeyType", {
        signerKeyTypeEd25519: 0,
        signerKeyTypePreAuthTx: 1,
        signerKeyTypeHashX: 2,
        signerKeyTypeEd25519SignedPayload: 3
      });
      xdr3.union("PublicKey", {
        switchOn: xdr3.lookup("PublicKeyType"),
        switchName: "type",
        switches: [["publicKeyTypeEd25519", "ed25519"]],
        arms: {
          ed25519: xdr3.lookup("Uint256")
        }
      });
      xdr3.struct("SignerKeyEd25519SignedPayload", [["ed25519", xdr3.lookup("Uint256")], ["payload", xdr3.varOpaque(64)]]);
      xdr3.union("SignerKey", {
        switchOn: xdr3.lookup("SignerKeyType"),
        switchName: "type",
        switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]],
        arms: {
          ed25519: xdr3.lookup("Uint256"),
          preAuthTx: xdr3.lookup("Uint256"),
          hashX: xdr3.lookup("Uint256"),
          ed25519SignedPayload: xdr3.lookup("SignerKeyEd25519SignedPayload")
        }
      });
      xdr3.typedef("Signature", xdr3.varOpaque(64));
      xdr3.typedef("SignatureHint", xdr3.opaque(4));
      xdr3.typedef("NodeId", xdr3.lookup("PublicKey"));
      xdr3.typedef("AccountId", xdr3.lookup("PublicKey"));
      xdr3.struct("Curve25519Secret", [["key", xdr3.opaque(32)]]);
      xdr3.struct("Curve25519Public", [["key", xdr3.opaque(32)]]);
      xdr3.struct("HmacSha256Key", [["key", xdr3.opaque(32)]]);
      xdr3.struct("HmacSha256Mac", [["mac", xdr3.opaque(32)]]);
      xdr3.struct("ShortHashSeed", [["seed", xdr3.opaque(16)]]);
      xdr3["enum"]("BinaryFuseFilterType", {
        binaryFuseFilter8Bit: 0,
        binaryFuseFilter16Bit: 1,
        binaryFuseFilter32Bit: 2
      });
      xdr3.struct("SerializedBinaryFuseFilter", [["type", xdr3.lookup("BinaryFuseFilterType")], ["inputHashSeed", xdr3.lookup("ShortHashSeed")], ["filterSeed", xdr3.lookup("ShortHashSeed")], ["segmentLength", xdr3.lookup("Uint32")], ["segementLengthMask", xdr3.lookup("Uint32")], ["segmentCount", xdr3.lookup("Uint32")], ["segmentCountLength", xdr3.lookup("Uint32")], ["fingerprintLength", xdr3.lookup("Uint32")], ["fingerprints", xdr3.varOpaque()]]);
      xdr3["enum"]("ScValType", {
        scvBool: 0,
        scvVoid: 1,
        scvError: 2,
        scvU32: 3,
        scvI32: 4,
        scvU64: 5,
        scvI64: 6,
        scvTimepoint: 7,
        scvDuration: 8,
        scvU128: 9,
        scvI128: 10,
        scvU256: 11,
        scvI256: 12,
        scvBytes: 13,
        scvString: 14,
        scvSymbol: 15,
        scvVec: 16,
        scvMap: 17,
        scvAddress: 18,
        scvContractInstance: 19,
        scvLedgerKeyContractInstance: 20,
        scvLedgerKeyNonce: 21
      });
      xdr3["enum"]("ScErrorType", {
        sceContract: 0,
        sceWasmVm: 1,
        sceContext: 2,
        sceStorage: 3,
        sceObject: 4,
        sceCrypto: 5,
        sceEvents: 6,
        sceBudget: 7,
        sceValue: 8,
        sceAuth: 9
      });
      xdr3["enum"]("ScErrorCode", {
        scecArithDomain: 0,
        scecIndexBounds: 1,
        scecInvalidInput: 2,
        scecMissingValue: 3,
        scecExistingValue: 4,
        scecExceededLimit: 5,
        scecInvalidAction: 6,
        scecInternalError: 7,
        scecUnexpectedType: 8,
        scecUnexpectedSize: 9
      });
      xdr3.union("ScError", {
        switchOn: xdr3.lookup("ScErrorType"),
        switchName: "type",
        switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]],
        arms: {
          contractCode: xdr3.lookup("Uint32"),
          code: xdr3.lookup("ScErrorCode")
        }
      });
      xdr3.struct("UInt128Parts", [["hi", xdr3.lookup("Uint64")], ["lo", xdr3.lookup("Uint64")]]);
      xdr3.struct("Int128Parts", [["hi", xdr3.lookup("Int64")], ["lo", xdr3.lookup("Uint64")]]);
      xdr3.struct("UInt256Parts", [["hiHi", xdr3.lookup("Uint64")], ["hiLo", xdr3.lookup("Uint64")], ["loHi", xdr3.lookup("Uint64")], ["loLo", xdr3.lookup("Uint64")]]);
      xdr3.struct("Int256Parts", [["hiHi", xdr3.lookup("Int64")], ["hiLo", xdr3.lookup("Uint64")], ["loHi", xdr3.lookup("Uint64")], ["loLo", xdr3.lookup("Uint64")]]);
      xdr3["enum"]("ContractExecutableType", {
        contractExecutableWasm: 0,
        contractExecutableStellarAsset: 1
      });
      xdr3.union("ContractExecutable", {
        switchOn: xdr3.lookup("ContractExecutableType"),
        switchName: "type",
        switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", xdr3["void"]()]],
        arms: {
          wasmHash: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ScAddressType", {
        scAddressTypeAccount: 0,
        scAddressTypeContract: 1
      });
      xdr3.union("ScAddress", {
        switchOn: xdr3.lookup("ScAddressType"),
        switchName: "type",
        switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]],
        arms: {
          accountId: xdr3.lookup("AccountId"),
          contractId: xdr3.lookup("Hash")
        }
      });
      xdr3["const"]("SCSYMBOL_LIMIT", 32);
      xdr3.typedef("ScVec", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647));
      xdr3.typedef("ScMap", xdr3.varArray(xdr3.lookup("ScMapEntry"), 2147483647));
      xdr3.typedef("ScBytes", xdr3.varOpaque());
      xdr3.typedef("ScString", xdr3.string());
      xdr3.typedef("ScSymbol", xdr3.string(SCSYMBOL_LIMIT));
      xdr3.struct("ScNonceKey", [["nonce", xdr3.lookup("Int64")]]);
      xdr3.struct("ScContractInstance", [["executable", xdr3.lookup("ContractExecutable")], ["storage", xdr3.option(xdr3.lookup("ScMap"))]]);
      xdr3.union("ScVal", {
        switchOn: xdr3.lookup("ScValType"),
        switchName: "type",
        switches: [["scvBool", "b"], ["scvVoid", xdr3["void"]()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", xdr3["void"]()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]],
        arms: {
          b: xdr3.bool(),
          error: xdr3.lookup("ScError"),
          u32: xdr3.lookup("Uint32"),
          i32: xdr3.lookup("Int32"),
          u64: xdr3.lookup("Uint64"),
          i64: xdr3.lookup("Int64"),
          timepoint: xdr3.lookup("TimePoint"),
          duration: xdr3.lookup("Duration"),
          u128: xdr3.lookup("UInt128Parts"),
          i128: xdr3.lookup("Int128Parts"),
          u256: xdr3.lookup("UInt256Parts"),
          i256: xdr3.lookup("Int256Parts"),
          bytes: xdr3.lookup("ScBytes"),
          str: xdr3.lookup("ScString"),
          sym: xdr3.lookup("ScSymbol"),
          vec: xdr3.option(xdr3.lookup("ScVec")),
          map: xdr3.option(xdr3.lookup("ScMap")),
          address: xdr3.lookup("ScAddress"),
          nonceKey: xdr3.lookup("ScNonceKey"),
          instance: xdr3.lookup("ScContractInstance")
        }
      });
      xdr3.struct("ScMapEntry", [["key", xdr3.lookup("ScVal")], ["val", xdr3.lookup("ScVal")]]);
      xdr3["enum"]("ScEnvMetaKind", {
        scEnvMetaKindInterfaceVersion: 0
      });
      xdr3.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", xdr3.lookup("Uint32")], ["preRelease", xdr3.lookup("Uint32")]]);
      xdr3.union("ScEnvMetaEntry", {
        switchOn: xdr3.lookup("ScEnvMetaKind"),
        switchName: "kind",
        switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]],
        arms: {
          interfaceVersion: xdr3.lookup("ScEnvMetaEntryInterfaceVersion")
        }
      });
      xdr3.struct("ScMetaV0", [["key", xdr3.string()], ["val", xdr3.string()]]);
      xdr3["enum"]("ScMetaKind", {
        scMetaV0: 0
      });
      xdr3.union("ScMetaEntry", {
        switchOn: xdr3.lookup("ScMetaKind"),
        switchName: "kind",
        switches: [["scMetaV0", "v0"]],
        arms: {
          v0: xdr3.lookup("ScMetaV0")
        }
      });
      xdr3["const"]("SC_SPEC_DOC_LIMIT", 1024);
      xdr3["enum"]("ScSpecType", {
        scSpecTypeVal: 0,
        scSpecTypeBool: 1,
        scSpecTypeVoid: 2,
        scSpecTypeError: 3,
        scSpecTypeU32: 4,
        scSpecTypeI32: 5,
        scSpecTypeU64: 6,
        scSpecTypeI64: 7,
        scSpecTypeTimepoint: 8,
        scSpecTypeDuration: 9,
        scSpecTypeU128: 10,
        scSpecTypeI128: 11,
        scSpecTypeU256: 12,
        scSpecTypeI256: 13,
        scSpecTypeBytes: 14,
        scSpecTypeString: 16,
        scSpecTypeSymbol: 17,
        scSpecTypeAddress: 19,
        scSpecTypeOption: 1e3,
        scSpecTypeResult: 1001,
        scSpecTypeVec: 1002,
        scSpecTypeMap: 1004,
        scSpecTypeTuple: 1005,
        scSpecTypeBytesN: 1006,
        scSpecTypeUdt: 2e3
      });
      xdr3.struct("ScSpecTypeOption", [["valueType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeResult", [["okType", xdr3.lookup("ScSpecTypeDef")], ["errorType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeVec", [["elementType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeMap", [["keyType", xdr3.lookup("ScSpecTypeDef")], ["valueType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeTuple", [["valueTypes", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 12)]]);
      xdr3.struct("ScSpecTypeBytesN", [["n", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecTypeUdt", [["name", xdr3.string(60)]]);
      xdr3.union("ScSpecTypeDef", {
        switchOn: xdr3.lookup("ScSpecType"),
        switchName: "type",
        switches: [["scSpecTypeVal", xdr3["void"]()], ["scSpecTypeBool", xdr3["void"]()], ["scSpecTypeVoid", xdr3["void"]()], ["scSpecTypeError", xdr3["void"]()], ["scSpecTypeU32", xdr3["void"]()], ["scSpecTypeI32", xdr3["void"]()], ["scSpecTypeU64", xdr3["void"]()], ["scSpecTypeI64", xdr3["void"]()], ["scSpecTypeTimepoint", xdr3["void"]()], ["scSpecTypeDuration", xdr3["void"]()], ["scSpecTypeU128", xdr3["void"]()], ["scSpecTypeI128", xdr3["void"]()], ["scSpecTypeU256", xdr3["void"]()], ["scSpecTypeI256", xdr3["void"]()], ["scSpecTypeBytes", xdr3["void"]()], ["scSpecTypeString", xdr3["void"]()], ["scSpecTypeSymbol", xdr3["void"]()], ["scSpecTypeAddress", xdr3["void"]()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]],
        arms: {
          option: xdr3.lookup("ScSpecTypeOption"),
          result: xdr3.lookup("ScSpecTypeResult"),
          vec: xdr3.lookup("ScSpecTypeVec"),
          map: xdr3.lookup("ScSpecTypeMap"),
          tuple: xdr3.lookup("ScSpecTypeTuple"),
          bytesN: xdr3.lookup("ScSpecTypeBytesN"),
          udt: xdr3.lookup("ScSpecTypeUdt")
        }
      });
      xdr3.struct("ScSpecUdtStructFieldV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(30)], ["type", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecUdtStructV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["fields", xdr3.varArray(xdr3.lookup("ScSpecUdtStructFieldV0"), 40)]]);
      xdr3.struct("ScSpecUdtUnionCaseVoidV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)]]);
      xdr3.struct("ScSpecUdtUnionCaseTupleV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["type", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 12)]]);
      xdr3["enum"]("ScSpecUdtUnionCaseV0Kind", {
        scSpecUdtUnionCaseVoidV0: 0,
        scSpecUdtUnionCaseTupleV0: 1
      });
      xdr3.union("ScSpecUdtUnionCaseV0", {
        switchOn: xdr3.lookup("ScSpecUdtUnionCaseV0Kind"),
        switchName: "kind",
        switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]],
        arms: {
          voidCase: xdr3.lookup("ScSpecUdtUnionCaseVoidV0"),
          tupleCase: xdr3.lookup("ScSpecUdtUnionCaseTupleV0")
        }
      });
      xdr3.struct("ScSpecUdtUnionV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtUnionCaseV0"), 50)]]);
      xdr3.struct("ScSpecUdtEnumCaseV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["value", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecUdtEnumV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtEnumCaseV0"), 50)]]);
      xdr3.struct("ScSpecUdtErrorEnumCaseV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["value", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecUdtErrorEnumV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]);
      xdr3.struct("ScSpecFunctionInputV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(30)], ["type", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecFunctionV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.lookup("ScSymbol")], ["inputs", xdr3.varArray(xdr3.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 1)]]);
      xdr3["enum"]("ScSpecEntryKind", {
        scSpecEntryFunctionV0: 0,
        scSpecEntryUdtStructV0: 1,
        scSpecEntryUdtUnionV0: 2,
        scSpecEntryUdtEnumV0: 3,
        scSpecEntryUdtErrorEnumV0: 4
      });
      xdr3.union("ScSpecEntry", {
        switchOn: xdr3.lookup("ScSpecEntryKind"),
        switchName: "kind",
        switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]],
        arms: {
          functionV0: xdr3.lookup("ScSpecFunctionV0"),
          udtStructV0: xdr3.lookup("ScSpecUdtStructV0"),
          udtUnionV0: xdr3.lookup("ScSpecUdtUnionV0"),
          udtEnumV0: xdr3.lookup("ScSpecUdtEnumV0"),
          udtErrorEnumV0: xdr3.lookup("ScSpecUdtErrorEnumV0")
        }
      });
      xdr3.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", xdr3.lookup("Int64")], ["txMaxInstructions", xdr3.lookup("Int64")], ["feeRatePerInstructionsIncrement", xdr3.lookup("Int64")], ["txMemoryLimit", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", xdr3.lookup("Uint32")], ["ledgerMaxReadBytes", xdr3.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", xdr3.lookup("Uint32")], ["ledgerMaxWriteBytes", xdr3.lookup("Uint32")], ["txMaxReadLedgerEntries", xdr3.lookup("Uint32")], ["txMaxReadBytes", xdr3.lookup("Uint32")], ["txMaxWriteLedgerEntries", xdr3.lookup("Uint32")], ["txMaxWriteBytes", xdr3.lookup("Uint32")], ["feeReadLedgerEntry", xdr3.lookup("Int64")], ["feeWriteLedgerEntry", xdr3.lookup("Int64")], ["feeRead1Kb", xdr3.lookup("Int64")], ["bucketListTargetSizeBytes", xdr3.lookup("Int64")], ["writeFee1KbBucketListLow", xdr3.lookup("Int64")], ["writeFee1KbBucketListHigh", xdr3.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", xdr3.lookup("Int64")]]);
      xdr3.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", xdr3.lookup("Uint32")], ["feeContractEvents1Kb", xdr3.lookup("Int64")]]);
      xdr3.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", xdr3.lookup("Uint32")], ["txMaxSizeBytes", xdr3.lookup("Uint32")], ["feeTxSize1Kb", xdr3.lookup("Int64")]]);
      xdr3["enum"]("ContractCostType", {
        wasmInsnExec: 0,
        memAlloc: 1,
        memCpy: 2,
        memCmp: 3,
        dispatchHostFunction: 4,
        visitObject: 5,
        valSer: 6,
        valDeser: 7,
        computeSha256Hash: 8,
        computeEd25519PubKey: 9,
        verifyEd25519Sig: 10,
        vmInstantiation: 11,
        vmCachedInstantiation: 12,
        invokeVmFunction: 13,
        computeKeccak256Hash: 14,
        decodeEcdsaCurve256Sig: 15,
        recoverEcdsaSecp256k1Key: 16,
        int256AddSub: 17,
        int256Mul: 18,
        int256Div: 19,
        int256Pow: 20,
        int256Shift: 21,
        chaCha20DrawBytes: 22,
        parseWasmInstructions: 23,
        parseWasmFunctions: 24,
        parseWasmGlobals: 25,
        parseWasmTableEntries: 26,
        parseWasmTypes: 27,
        parseWasmDataSegments: 28,
        parseWasmElemSegments: 29,
        parseWasmImports: 30,
        parseWasmExports: 31,
        parseWasmDataSegmentBytes: 32,
        instantiateWasmInstructions: 33,
        instantiateWasmFunctions: 34,
        instantiateWasmGlobals: 35,
        instantiateWasmTableEntries: 36,
        instantiateWasmTypes: 37,
        instantiateWasmDataSegments: 38,
        instantiateWasmElemSegments: 39,
        instantiateWasmImports: 40,
        instantiateWasmExports: 41,
        instantiateWasmDataSegmentBytes: 42,
        sec1DecodePointUncompressed: 43,
        verifyEcdsaSecp256r1Sig: 44,
        bls12381EncodeFp: 45,
        bls12381DecodeFp: 46,
        bls12381G1CheckPointOnCurve: 47,
        bls12381G1CheckPointInSubgroup: 48,
        bls12381G2CheckPointOnCurve: 49,
        bls12381G2CheckPointInSubgroup: 50,
        bls12381G1ProjectiveToAffine: 51,
        bls12381G2ProjectiveToAffine: 52,
        bls12381G1Add: 53,
        bls12381G1Mul: 54,
        bls12381G1Msm: 55,
        bls12381MapFpToG1: 56,
        bls12381HashToG1: 57,
        bls12381G2Add: 58,
        bls12381G2Mul: 59,
        bls12381G2Msm: 60,
        bls12381MapFp2ToG2: 61,
        bls12381HashToG2: 62,
        bls12381Pairing: 63,
        bls12381FrFromU256: 64,
        bls12381FrToU256: 65,
        bls12381FrAddSub: 66,
        bls12381FrMul: 67,
        bls12381FrPow: 68,
        bls12381FrInv: 69
      });
      xdr3.struct("ContractCostParamEntry", [["ext", xdr3.lookup("ExtensionPoint")], ["constTerm", xdr3.lookup("Int64")], ["linearTerm", xdr3.lookup("Int64")]]);
      xdr3.struct("StateArchivalSettings", [["maxEntryTtl", xdr3.lookup("Uint32")], ["minTemporaryTtl", xdr3.lookup("Uint32")], ["minPersistentTtl", xdr3.lookup("Uint32")], ["persistentRentRateDenominator", xdr3.lookup("Int64")], ["tempRentRateDenominator", xdr3.lookup("Int64")], ["maxEntriesToArchive", xdr3.lookup("Uint32")], ["bucketListSizeWindowSampleSize", xdr3.lookup("Uint32")], ["bucketListWindowSamplePeriod", xdr3.lookup("Uint32")], ["evictionScanSize", xdr3.lookup("Uint32")], ["startingEvictionScanLevel", xdr3.lookup("Uint32")]]);
      xdr3.struct("EvictionIterator", [["bucketListLevel", xdr3.lookup("Uint32")], ["isCurrBucket", xdr3.bool()], ["bucketFileOffset", xdr3.lookup("Uint64")]]);
      xdr3["const"]("CONTRACT_COST_COUNT_LIMIT", 1024);
      xdr3.typedef("ContractCostParams", xdr3.varArray(xdr3.lookup("ContractCostParamEntry"), xdr3.lookup("CONTRACT_COST_COUNT_LIMIT")));
      xdr3["enum"]("ConfigSettingId", {
        configSettingContractMaxSizeBytes: 0,
        configSettingContractComputeV0: 1,
        configSettingContractLedgerCostV0: 2,
        configSettingContractHistoricalDataV0: 3,
        configSettingContractEventsV0: 4,
        configSettingContractBandwidthV0: 5,
        configSettingContractCostParamsCpuInstructions: 6,
        configSettingContractCostParamsMemoryBytes: 7,
        configSettingContractDataKeySizeBytes: 8,
        configSettingContractDataEntrySizeBytes: 9,
        configSettingStateArchival: 10,
        configSettingContractExecutionLanes: 11,
        configSettingBucketlistSizeWindow: 12,
        configSettingEvictionIterator: 13
      });
      xdr3.union("ConfigSettingEntry", {
        switchOn: xdr3.lookup("ConfigSettingId"),
        switchName: "configSettingId",
        switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]],
        arms: {
          contractMaxSizeBytes: xdr3.lookup("Uint32"),
          contractCompute: xdr3.lookup("ConfigSettingContractComputeV0"),
          contractLedgerCost: xdr3.lookup("ConfigSettingContractLedgerCostV0"),
          contractHistoricalData: xdr3.lookup("ConfigSettingContractHistoricalDataV0"),
          contractEvents: xdr3.lookup("ConfigSettingContractEventsV0"),
          contractBandwidth: xdr3.lookup("ConfigSettingContractBandwidthV0"),
          contractCostParamsCpuInsns: xdr3.lookup("ContractCostParams"),
          contractCostParamsMemBytes: xdr3.lookup("ContractCostParams"),
          contractDataKeySizeBytes: xdr3.lookup("Uint32"),
          contractDataEntrySizeBytes: xdr3.lookup("Uint32"),
          stateArchivalSettings: xdr3.lookup("StateArchivalSettings"),
          contractExecutionLanes: xdr3.lookup("ConfigSettingContractExecutionLanesV0"),
          bucketListSizeWindow: xdr3.varArray(xdr3.lookup("Uint64"), 2147483647),
          evictionIterator: xdr3.lookup("EvictionIterator")
        }
      });
    });
    var _default = exports["default"] = types;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/xdr.js
var require_xdr3 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/xdr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _curr_generated = _interopRequireDefault(require_curr_generated2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = _curr_generated["default"];
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/jsxdr.js
var require_jsxdr2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/jsxdr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _jsXdr = require_xdr();
    var cereal = {
      XdrWriter: _jsXdr.XdrWriter,
      XdrReader: _jsXdr.XdrReader
    };
    var _default = exports["default"] = cereal;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/hashing.js
var require_hashing2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hash = hash2;
    var _sha = require_sha2();
    function hash2(data) {
      var hasher = new _sha.sha256();
      hasher.update(data, "utf8");
      return hasher.digest();
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/signing.js
var require_signing2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FastSigning = void 0;
    exports.generate = generate;
    exports.sign = sign;
    exports.verify = verify;
    var actualMethods = {};
    var FastSigning = exports.FastSigning = checkFastSigning();
    function sign(data, secretKey) {
      return actualMethods.sign(data, secretKey);
    }
    function verify(data, signature, publicKey) {
      return actualMethods.verify(data, signature, publicKey);
    }
    function generate(secretKey) {
      return actualMethods.generate(secretKey);
    }
    function checkFastSigning() {
      return typeof window === "undefined" ? checkFastSigningNode() : checkFastSigningBrowser();
    }
    function checkFastSigningNode() {
      var sodium;
      try {
        sodium = require_sodium_native();
      } catch (err) {
        return checkFastSigningBrowser();
      }
      if (!Object.keys(sodium).length) {
        return checkFastSigningBrowser();
      }
      actualMethods.generate = function(secretKey) {
        var pk = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
        var sk = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
        sodium.crypto_sign_seed_keypair(pk, sk, secretKey);
        return pk;
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        var signature = Buffer.alloc(sodium.crypto_sign_BYTES);
        sodium.crypto_sign_detached(signature, data, secretKey);
        return signature;
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        try {
          return sodium.crypto_sign_verify_detached(signature, data, publicKey);
        } catch (e) {
          return false;
        }
      };
      return true;
    }
    function checkFastSigningBrowser() {
      var nacl = require_nacl_fast();
      actualMethods.generate = function(secretKey) {
        var secretKeyUint8 = new Uint8Array(secretKey);
        var naclKeys = nacl.sign.keyPair.fromSeed(secretKeyUint8);
        return Buffer.from(naclKeys.publicKey);
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        secretKey = new Uint8Array(secretKey.toJSON().data);
        var signature = nacl.sign.detached(data, secretKey);
        return Buffer.from(signature);
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        signature = new Uint8Array(signature.toJSON().data);
        publicKey = new Uint8Array(publicKey.toJSON().data);
        return nacl.sign.detached.verify(data, signature, publicKey);
      };
      return false;
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/util.js
var require_util2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.trimEnd = void 0;
    var trimEnd = exports.trimEnd = function trimEnd2(input, _char) {
      var isNumber = typeof input === "number";
      var str = String(input);
      while (str.endsWith(_char)) {
        str = str.slice(0, -1);
      }
      return isNumber ? Number(str) : str;
    };
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/checksum.js
var require_checksum2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/checksum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.verifyChecksum = verifyChecksum;
    function verifyChecksum(expected, actual) {
      if (expected.length !== actual.length) {
        return false;
      }
      if (expected.length === 0) {
        return true;
      }
      for (var i = 0; i < expected.length; i += 1) {
        if (expected[i] !== actual[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/strkey.js
var require_strkey2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/strkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StrKey = void 0;
    exports.decodeCheck = decodeCheck;
    exports.encodeCheck = encodeCheck;
    var _base = _interopRequireDefault(require_base32());
    var _checksum = require_checksum2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var versionBytes = {
      ed25519PublicKey: 6 << 3,
      // G (when encoded in base32)
      ed25519SecretSeed: 18 << 3,
      // S
      med25519PublicKey: 12 << 3,
      // M
      preAuthTx: 19 << 3,
      // T
      sha256Hash: 23 << 3,
      // X
      signedPayload: 15 << 3,
      // P
      contract: 2 << 3
      // C
    };
    var strkeyTypes = {
      G: "ed25519PublicKey",
      S: "ed25519SecretSeed",
      M: "med25519PublicKey",
      T: "preAuthTx",
      X: "sha256Hash",
      P: "signedPayload",
      C: "contract"
    };
    var StrKey2 = exports.StrKey = function() {
      function StrKey3() {
        _classCallCheck(this, StrKey3);
      }
      return _createClass(StrKey3, null, [{
        key: "encodeEd25519PublicKey",
        value: (
          /**
           * Encodes `data` to strkey ed25519 public key.
           *
           * @param   {Buffer} data   raw data to encode
           * @returns {string}        "G..." representation of the key
           */
          function encodeEd25519PublicKey(data) {
            return encodeCheck("ed25519PublicKey", data);
          }
        )
        /**
         * Decodes strkey ed25519 public key to raw data.
         *
         * If the parameter is a muxed account key ("M..."), this will only encode it
         * as a basic Ed25519 key (as if in "G..." format).
         *
         * @param   {string} data   "G..." (or "M...") key representation to decode
         * @returns {Buffer}        raw key
         */
      }, {
        key: "decodeEd25519PublicKey",
        value: function decodeEd25519PublicKey(data) {
          return decodeCheck("ed25519PublicKey", data);
        }
        /**
         * Returns true if the given Stellar public key is a valid ed25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519PublicKey",
        value: function isValidEd25519PublicKey(publicKey) {
          return isValid("ed25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey ed25519 seed.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeEd25519SecretSeed",
        value: function encodeEd25519SecretSeed(data) {
          return encodeCheck("ed25519SecretSeed", data);
        }
        /**
         * Decodes strkey ed25519 seed to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeEd25519SecretSeed",
        value: function decodeEd25519SecretSeed(address) {
          return decodeCheck("ed25519SecretSeed", address);
        }
        /**
         * Returns true if the given Stellar secret key is a valid ed25519 secret seed.
         * @param {string} seed seed to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519SecretSeed",
        value: function isValidEd25519SecretSeed(seed) {
          return isValid("ed25519SecretSeed", seed);
        }
        /**
         * Encodes data to strkey med25519 public key.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeMed25519PublicKey",
        value: function encodeMed25519PublicKey(data) {
          return encodeCheck("med25519PublicKey", data);
        }
        /**
         * Decodes strkey med25519 public key to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeMed25519PublicKey",
        value: function decodeMed25519PublicKey(address) {
          return decodeCheck("med25519PublicKey", address);
        }
        /**
         * Returns true if the given Stellar public key is a valid med25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidMed25519PublicKey",
        value: function isValidMed25519PublicKey(publicKey) {
          return isValid("med25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey preAuthTx.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodePreAuthTx",
        value: function encodePreAuthTx(data) {
          return encodeCheck("preAuthTx", data);
        }
        /**
         * Decodes strkey PreAuthTx to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodePreAuthTx",
        value: function decodePreAuthTx(address) {
          return decodeCheck("preAuthTx", address);
        }
        /**
         * Encodes data to strkey sha256 hash.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSha256Hash",
        value: function encodeSha256Hash(data) {
          return encodeCheck("sha256Hash", data);
        }
        /**
         * Decodes strkey sha256 hash to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSha256Hash",
        value: function decodeSha256Hash(address) {
          return decodeCheck("sha256Hash", address);
        }
        /**
         * Encodes raw data to strkey signed payload (P...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSignedPayload",
        value: function encodeSignedPayload(data) {
          return encodeCheck("signedPayload", data);
        }
        /**
         * Decodes strkey signed payload (P...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSignedPayload",
        value: function decodeSignedPayload(address) {
          return decodeCheck("signedPayload", address);
        }
        /**
         * Checks validity of alleged signed payload (P...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidSignedPayload",
        value: function isValidSignedPayload(address) {
          return isValid("signedPayload", address);
        }
        /**
         * Encodes raw data to strkey contract (C...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeContract",
        value: function encodeContract(data) {
          return encodeCheck("contract", data);
        }
        /**
         * Decodes strkey contract (C...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeContract",
        value: function decodeContract(address) {
          return decodeCheck("contract", address);
        }
        /**
         * Checks validity of alleged contract (C...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidContract",
        value: function isValidContract(address) {
          return isValid("contract", address);
        }
      }, {
        key: "getVersionByteForPrefix",
        value: function getVersionByteForPrefix(address) {
          return strkeyTypes[address[0]];
        }
      }]);
    }();
    function isValid(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
          if (encoded.length !== 56) {
            return false;
          }
          break;
        case "med25519PublicKey":
          if (encoded.length !== 69) {
            return false;
          }
          break;
        case "signedPayload":
          if (encoded.length < 56 || encoded.length > 165) {
            return false;
          }
          break;
        default:
          return false;
      }
      var decoded = "";
      try {
        decoded = decodeCheck(versionByteName, encoded);
      } catch (err) {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
          return decoded.length === 32;
        case "med25519PublicKey":
          return decoded.length === 40;
        case "signedPayload":
          return (
            // 32 for the signer, +4 for the payload size, then either +4 for the
            // min or +64 for the max payload
            decoded.length >= 32 + 4 + 4 && decoded.length <= 32 + 4 + 64
          );
        default:
          return false;
      }
    }
    function decodeCheck(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        throw new TypeError("encoded argument must be of type String");
      }
      var decoded = _base["default"].decode(encoded);
      var versionByte = decoded[0];
      var payload = decoded.slice(0, -2);
      var data = payload.slice(1);
      var checksum = decoded.slice(-2);
      if (encoded !== _base["default"].encode(decoded)) {
        throw new Error("invalid encoded string");
      }
      var expectedVersion = versionBytes[versionByteName];
      if (expectedVersion === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      if (versionByte !== expectedVersion) {
        throw new Error("invalid version byte. expected ".concat(expectedVersion, ", got ").concat(versionByte));
      }
      var expectedChecksum = calculateChecksum(payload);
      if (!(0, _checksum.verifyChecksum)(expectedChecksum, checksum)) {
        throw new Error("invalid checksum");
      }
      return Buffer.from(data);
    }
    function encodeCheck(versionByteName, data) {
      if (data === null || data === void 0) {
        throw new Error("cannot encode null data");
      }
      var versionByte = versionBytes[versionByteName];
      if (versionByte === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      data = Buffer.from(data);
      var versionBuffer = Buffer.from([versionByte]);
      var payload = Buffer.concat([versionBuffer, data]);
      var checksum = Buffer.from(calculateChecksum(payload));
      var unencoded = Buffer.concat([payload, checksum]);
      return _base["default"].encode(unencoded);
    }
    function calculateChecksum(payload) {
      var crcTable = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
      var crc16 = 0;
      for (var i = 0; i < payload.length; i += 1) {
        var _byte = payload[i];
        var lookupIndex = crc16 >> 8 ^ _byte;
        crc16 = crc16 << 8 ^ crcTable[lookupIndex];
        crc16 &= 65535;
      }
      var checksum = new Uint8Array(2);
      checksum[0] = crc16 & 255;
      checksum[1] = crc16 >> 8 & 255;
      return checksum;
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/keypair.js
var require_keypair2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/keypair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Keypair = void 0;
    var _tweetnacl = _interopRequireDefault(require_nacl_fast());
    var _signing = require_signing2();
    var _strkey = require_strkey2();
    var _hashing = require_hashing2();
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Keypair2 = exports.Keypair = function() {
      function Keypair3(keys) {
        _classCallCheck(this, Keypair3);
        if (keys.type !== "ed25519") {
          throw new Error("Invalid keys type");
        }
        this.type = keys.type;
        if (keys.secretKey) {
          keys.secretKey = Buffer.from(keys.secretKey);
          if (keys.secretKey.length !== 32) {
            throw new Error("secretKey length is invalid");
          }
          this._secretSeed = keys.secretKey;
          this._publicKey = (0, _signing.generate)(keys.secretKey);
          this._secretKey = Buffer.concat([keys.secretKey, this._publicKey]);
          if (keys.publicKey && !this._publicKey.equals(Buffer.from(keys.publicKey))) {
            throw new Error("secretKey does not match publicKey");
          }
        } else {
          this._publicKey = Buffer.from(keys.publicKey);
          if (this._publicKey.length !== 32) {
            throw new Error("publicKey length is invalid");
          }
        }
      }
      return _createClass(Keypair3, [{
        key: "xdrAccountId",
        value: function xdrAccountId() {
          return new _xdr["default"].AccountId.publicKeyTypeEd25519(this._publicKey);
        }
      }, {
        key: "xdrPublicKey",
        value: function xdrPublicKey() {
          return new _xdr["default"].PublicKey.publicKeyTypeEd25519(this._publicKey);
        }
        /**
         * Creates a {@link xdr.MuxedAccount} object from the public key.
         *
         * You will get a different type of muxed account depending on whether or not
         * you pass an ID.
         *
         * @param  {string} [id] - stringified integer indicating the underlying muxed
         *     ID of the new account object
         *
         * @return {xdr.MuxedAccount}
         */
      }, {
        key: "xdrMuxedAccount",
        value: function xdrMuxedAccount(id) {
          if (typeof id !== "undefined") {
            if (typeof id !== "string") {
              throw new TypeError("expected string for ID, got ".concat(_typeof(id)));
            }
            return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
              id: _xdr["default"].Uint64.fromString(id),
              ed25519: this._publicKey
            }));
          }
          return new _xdr["default"].MuxedAccount.keyTypeEd25519(this._publicKey);
        }
        /**
         * Returns raw public key
         * @returns {Buffer}
         */
      }, {
        key: "rawPublicKey",
        value: function rawPublicKey() {
          return this._publicKey;
        }
      }, {
        key: "signatureHint",
        value: function signatureHint() {
          var a = this.xdrAccountId().toXDR();
          return a.slice(a.length - 4);
        }
        /**
         * Returns public key associated with this `Keypair` object.
         * @returns {string}
         */
      }, {
        key: "publicKey",
        value: function publicKey() {
          return _strkey.StrKey.encodeEd25519PublicKey(this._publicKey);
        }
        /**
         * Returns secret key associated with this `Keypair` object
         * @returns {string}
         */
      }, {
        key: "secret",
        value: function secret() {
          if (!this._secretSeed) {
            throw new Error("no secret key available");
          }
          if (this.type === "ed25519") {
            return _strkey.StrKey.encodeEd25519SecretSeed(this._secretSeed);
          }
          throw new Error("Invalid Keypair type");
        }
        /**
         * Returns raw secret key.
         * @returns {Buffer}
         */
      }, {
        key: "rawSecretKey",
        value: function rawSecretKey() {
          return this._secretSeed;
        }
        /**
         * Returns `true` if this `Keypair` object contains secret key and can sign.
         * @returns {boolean}
         */
      }, {
        key: "canSign",
        value: function canSign() {
          return !!this._secretKey;
        }
        /**
         * Signs data.
         * @param {Buffer} data Data to sign
         * @returns {Buffer}
         */
      }, {
        key: "sign",
        value: function sign(data) {
          if (!this.canSign()) {
            throw new Error("cannot sign: no secret key available");
          }
          return (0, _signing.sign)(data, this._secretKey);
        }
        /**
         * Verifies if `signature` for `data` is valid.
         * @param {Buffer} data Signed data
         * @param {Buffer} signature Signature
         * @returns {boolean}
         */
      }, {
        key: "verify",
        value: function verify(data, signature) {
          return (0, _signing.verify)(data, signature, this._publicKey);
        }
        /**
         * Returns the decorated signature (hint+sig) for arbitrary data.
         *
         * @param  {Buffer} data  arbitrary data to sign
         * @return {xdr.DecoratedSignature}   the raw signature structure which can be
         *     added directly to a transaction envelope
         *
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signDecorated",
        value: function signDecorated(data) {
          var signature = this.sign(data);
          var hint = this.signatureHint();
          return new _xdr["default"].DecoratedSignature({
            hint,
            signature
          });
        }
        /**
         * Returns the raw decorated signature (hint+sig) for a signed payload signer.
         *
         *  The hint is defined as the last 4 bytes of the signer key XORed with last
         *  4 bytes of the payload (zero-left-padded if necessary).
         *
         * @param  {Buffer} data    data to both sign and treat as the payload
         * @return {xdr.DecoratedSignature}
         *
         * @see https://github.com/stellar/stellar-protocol/blob/master/core/cap-0040.md#signature-hint
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signPayloadDecorated",
        value: function signPayloadDecorated(data) {
          var signature = this.sign(data);
          var keyHint = this.signatureHint();
          var hint = Buffer.from(data.slice(-4));
          if (hint.length < 4) {
            hint = Buffer.concat([hint, Buffer.alloc(4 - data.length, 0)]);
          }
          return new _xdr["default"].DecoratedSignature({
            hint: hint.map(function(_byte, i) {
              return _byte ^ keyHint[i];
            }),
            signature
          });
        }
      }], [{
        key: "fromSecret",
        value: function fromSecret(secret) {
          var rawSecret = _strkey.StrKey.decodeEd25519SecretSeed(secret);
          return this.fromRawEd25519Seed(rawSecret);
        }
        /**
         * Creates a new `Keypair` object from ed25519 secret key seed raw bytes.
         *
         * @param {Buffer} rawSeed Raw 32-byte ed25519 secret key seed
         * @returns {Keypair}
         */
      }, {
        key: "fromRawEd25519Seed",
        value: function fromRawEd25519Seed(rawSeed) {
          return new this({
            type: "ed25519",
            secretKey: rawSeed
          });
        }
        /**
         * Returns `Keypair` object representing network master key.
         * @param {string} networkPassphrase passphrase of the target stellar network (e.g. "Public Global Stellar Network ; September 2015").
         * @returns {Keypair}
         */
      }, {
        key: "master",
        value: function master(networkPassphrase) {
          if (!networkPassphrase) {
            throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
          }
          return this.fromRawEd25519Seed((0, _hashing.hash)(networkPassphrase));
        }
        /**
         * Creates a new `Keypair` object from public key.
         * @param {string} publicKey public key (ex. `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`)
         * @returns {Keypair}
         */
      }, {
        key: "fromPublicKey",
        value: function fromPublicKey(publicKey) {
          publicKey = _strkey.StrKey.decodeEd25519PublicKey(publicKey);
          if (publicKey.length !== 32) {
            throw new Error("Invalid Stellar public key");
          }
          return new this({
            type: "ed25519",
            publicKey
          });
        }
        /**
         * Create a random `Keypair` object.
         * @returns {Keypair}
         */
      }, {
        key: "random",
        value: function random() {
          var secret = _tweetnacl["default"].randomBytes(32);
          return this.fromRawEd25519Seed(secret);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/asset.js
var require_asset2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Asset = void 0;
    var _util = require_util2();
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _strkey = require_strkey2();
    var _hashing = require_hashing2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Asset = exports.Asset = function() {
      function Asset2(code, issuer) {
        _classCallCheck(this, Asset2);
        if (!/^[a-zA-Z0-9]{1,12}$/.test(code)) {
          throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
        }
        if (String(code).toLowerCase() !== "xlm" && !issuer) {
          throw new Error("Issuer cannot be null");
        }
        if (issuer && !_strkey.StrKey.isValidEd25519PublicKey(issuer)) {
          throw new Error("Issuer is invalid");
        }
        if (String(code).toLowerCase() === "xlm") {
          this.code = "XLM";
        } else {
          this.code = code;
        }
        this.issuer = issuer;
      }
      return _createClass(Asset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr.Asset object for this asset.
           * @returns {xdr.Asset} XDR asset object
           */
          function toXDRObject() {
            return this._toXDRObject(_xdr["default"].Asset);
          }
        )
        /**
         * Returns the xdr.ChangeTrustAsset object for this asset.
         * @returns {xdr.ChangeTrustAsset} XDR asset object
         */
      }, {
        key: "toChangeTrustXDRObject",
        value: function toChangeTrustXDRObject() {
          return this._toXDRObject(_xdr["default"].ChangeTrustAsset);
        }
        /**
         * Returns the xdr.TrustLineAsset object for this asset.
         * @returns {xdr.TrustLineAsset} XDR asset object
         */
      }, {
        key: "toTrustLineXDRObject",
        value: function toTrustLineXDRObject() {
          return this._toXDRObject(_xdr["default"].TrustLineAsset);
        }
        /**
         * Returns the would-be contract ID (`C...` format) for this asset on a given
         * network.
         *
         * @param {string}    networkPassphrase   indicates which network the contract
         *    ID should refer to, since every network will have a unique ID for the
         *    same contract (see {@link Networks} for options)
         *
         * @returns {string}  the strkey-encoded (`C...`) contract ID for this asset
         *
         * @warning This makes no guarantee that this contract actually *exists*.
         */
      }, {
        key: "contractId",
        value: function contractId(networkPassphrase) {
          var networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
          var preimage = _xdr["default"].HashIdPreimage.envelopeTypeContractId(new _xdr["default"].HashIdPreimageContractId({
            networkId,
            contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())
          }));
          return _strkey.StrKey.encodeContract((0, _hashing.hash)(preimage.toXDR()));
        }
        /**
         * Returns the xdr object for this asset.
         * @param {xdr.Asset | xdr.ChangeTrustAsset} xdrAsset - The asset xdr object.
         * @returns {xdr.Asset | xdr.ChangeTrustAsset | xdr.TrustLineAsset} XDR Asset object
         */
      }, {
        key: "_toXDRObject",
        value: function _toXDRObject() {
          var xdrAsset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _xdr["default"].Asset;
          if (this.isNative()) {
            return xdrAsset.assetTypeNative();
          }
          var xdrType;
          var xdrTypeString;
          if (this.code.length <= 4) {
            xdrType = _xdr["default"].AlphaNum4;
            xdrTypeString = "assetTypeCreditAlphanum4";
          } else {
            xdrType = _xdr["default"].AlphaNum12;
            xdrTypeString = "assetTypeCreditAlphanum12";
          }
          var padLength = this.code.length <= 4 ? 4 : 12;
          var paddedCode = this.code.padEnd(padLength, "\0");
          var assetType = new xdrType({
            assetCode: paddedCode,
            issuer: _keypair.Keypair.fromPublicKey(this.issuer).xdrAccountId()
          });
          return new xdrAsset(xdrTypeString, assetType);
        }
        /**
         * @returns {string} Asset code
         */
      }, {
        key: "getCode",
        value: function getCode() {
          if (this.code === void 0) {
            return void 0;
          }
          return String(this.code);
        }
        /**
         * @returns {string} Asset issuer
         */
      }, {
        key: "getIssuer",
        value: function getIssuer() {
          if (this.issuer === void 0) {
            return void 0;
          }
          return String(this.issuer);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {string} Asset type. Can be one of following types:
         *
         *  - `native`,
         *  - `credit_alphanum4`,
         *  - `credit_alphanum12`, or
         *  - `unknown` as the error case (which should never occur)
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          switch (this.getRawAssetType().value) {
            case _xdr["default"].AssetType.assetTypeNative().value:
              return "native";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4().value:
              return "credit_alphanum4";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12().value:
              return "credit_alphanum12";
            default:
              return "unknown";
          }
        }
        /**
         * @returns {xdr.AssetType}  the raw XDR representation of the asset type
         */
      }, {
        key: "getRawAssetType",
        value: function getRawAssetType() {
          if (this.isNative()) {
            return _xdr["default"].AssetType.assetTypeNative();
          }
          if (this.code.length <= 4) {
            return _xdr["default"].AssetType.assetTypeCreditAlphanum4();
          }
          return _xdr["default"].AssetType.assetTypeCreditAlphanum12();
        }
        /**
         * @returns {boolean}  true if this asset object is the native asset.
         */
      }, {
        key: "isNative",
        value: function isNative() {
          return !this.issuer;
        }
        /**
         * @param {Asset} asset Asset to compare
         * @returns {boolean} true if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.code === asset.getCode() && this.issuer === asset.getIssuer();
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.isNative()) {
            return "native";
          }
          return "".concat(this.getCode(), ":").concat(this.getIssuer());
        }
        /**
         * Compares two assets according to the criteria:
         *
         *  1. First compare the type (native < alphanum4 < alphanum12).
         *  2. If the types are equal, compare the assets codes.
         *  3. If the asset codes are equal, compare the issuers.
         *
         * @param   {Asset} assetA - the first asset
         * @param   {Asset} assetB - the second asset
         * @returns {number} `-1` if assetA < assetB, `0` if assetA == assetB, `1` if assetA > assetB.
         *
         * @static
         * @memberof Asset
         */
      }], [{
        key: "native",
        value: function _native() {
          return new Asset2("XLM");
        }
        /**
         * Returns an asset object from its XDR object representation.
         * @param {xdr.Asset} assetXdr - The asset xdr object.
         * @returns {Asset}
         */
      }, {
        key: "fromOperation",
        value: function fromOperation(assetXdr) {
          var anum;
          var code;
          var issuer;
          switch (assetXdr["switch"]()) {
            case _xdr["default"].AssetType.assetTypeNative():
              return this["native"]();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4():
              anum = assetXdr.alphaNum4();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12():
              anum = anum || assetXdr.alphaNum12();
              issuer = _strkey.StrKey.encodeEd25519PublicKey(anum.issuer().ed25519());
              code = (0, _util.trimEnd)(anum.assetCode(), "\0");
              return new this(code, issuer);
            default:
              throw new Error("Invalid asset type: ".concat(assetXdr["switch"]().name));
          }
        }
      }, {
        key: "compare",
        value: function compare(assetA, assetB) {
          if (!assetA || !(assetA instanceof Asset2)) {
            throw new Error("assetA is invalid");
          }
          if (!assetB || !(assetB instanceof Asset2)) {
            throw new Error("assetB is invalid");
          }
          if (assetA.equals(assetB)) {
            return 0;
          }
          var xdrAtype = assetA.getRawAssetType().value;
          var xdrBtype = assetB.getRawAssetType().value;
          if (xdrAtype !== xdrBtype) {
            return xdrAtype < xdrBtype ? -1 : 1;
          }
          var result = asciiCompare(assetA.getCode(), assetB.getCode());
          if (result !== 0) {
            return result;
          }
          return asciiCompare(assetA.getIssuer(), assetB.getIssuer());
        }
      }]);
    }();
    function asciiCompare(a, b) {
      return Buffer.compare(Buffer.from(a, "ascii"), Buffer.from(b, "ascii"));
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js
var require_get_liquidity_pool_id2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolFeeV18 = void 0;
    exports.getLiquidityPoolId = getLiquidityPoolId;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _asset = require_asset2();
    var _hashing = require_hashing2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var LiquidityPoolFeeV18 = exports.LiquidityPoolFeeV18 = 30;
    function getLiquidityPoolId(liquidityPoolType) {
      var liquidityPoolParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (liquidityPoolType !== "constant_product") {
        throw new Error("liquidityPoolType is invalid");
      }
      var assetA = liquidityPoolParameters.assetA, assetB = liquidityPoolParameters.assetB, fee = liquidityPoolParameters.fee;
      if (!assetA || !(assetA instanceof _asset.Asset)) {
        throw new Error("assetA is invalid");
      }
      if (!assetB || !(assetB instanceof _asset.Asset)) {
        throw new Error("assetB is invalid");
      }
      if (!fee || fee !== LiquidityPoolFeeV18) {
        throw new Error("fee is invalid");
      }
      if (_asset.Asset.compare(assetA, assetB) !== -1) {
        throw new Error("Assets are not in lexicographic order");
      }
      var lpTypeData = _xdr["default"].LiquidityPoolType.liquidityPoolConstantProduct().toXDR();
      var lpParamsData = new _xdr["default"].LiquidityPoolConstantProductParameters({
        assetA: assetA.toXDRObject(),
        assetB: assetB.toXDRObject(),
        fee
      }).toXDR();
      var payload = Buffer.concat([lpTypeData, lpParamsData]);
      return (0, _hashing.hash)(payload);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/transaction_base.js
var require_transaction_base2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/transaction_base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBase = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _hashing = require_hashing2();
    var _keypair = require_keypair2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var TransactionBase = exports.TransactionBase = function() {
      function TransactionBase2(tx, signatures, fee, networkPassphrase) {
        _classCallCheck(this, TransactionBase2);
        if (typeof networkPassphrase !== "string") {
          throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(_typeof(networkPassphrase)));
        }
        this._networkPassphrase = networkPassphrase;
        this._tx = tx;
        this._signatures = signatures;
        this._fee = fee;
      }
      return _createClass(TransactionBase2, [{
        key: "signatures",
        get: function get() {
          return this._signatures;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
      }, {
        key: "tx",
        get: function get() {
          return this._tx;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "fee",
        get: function get() {
          return this._fee;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "networkPassphrase",
        get: function get() {
          return this._networkPassphrase;
        },
        set: function set(networkPassphrase) {
          this._networkPassphrase = networkPassphrase;
        }
        /**
         * Signs the transaction with the given {@link Keypair}.
         * @param {...Keypair} keypairs Keypairs of signers
         * @returns {void}
         */
      }, {
        key: "sign",
        value: function sign() {
          var _this = this;
          var txHash = this.hash();
          for (var _len = arguments.length, keypairs = new Array(_len), _key = 0; _key < _len; _key++) {
            keypairs[_key] = arguments[_key];
          }
          keypairs.forEach(function(kp) {
            var sig = kp.signDecorated(txHash);
            _this.signatures.push(sig);
          });
        }
        /**
         * Signs a transaction with the given {@link Keypair}. Useful if someone sends
         * you a transaction XDR for you to sign and return (see
         * [addSignature](#addSignature) for more information).
         *
         * When you get a transaction XDR to sign....
         * - Instantiate a `Transaction` object with the XDR
         * - Use {@link Keypair} to generate a keypair object for your Stellar seed.
         * - Run `getKeypairSignature` with that keypair
         * - Send back the signature along with your publicKey (not your secret seed!)
         *
         * Example:
         * ```javascript
         * // `transactionXDR` is a string from the person generating the transaction
         * const transaction = new Transaction(transactionXDR, networkPassphrase);
         * const keypair = Keypair.fromSecret(myStellarSeed);
         * return transaction.getKeypairSignature(keypair);
         * ```
         *
         * @param {Keypair} keypair Keypair of signer
         * @returns {string} Signature string
         */
      }, {
        key: "getKeypairSignature",
        value: function getKeypairSignature(keypair) {
          return keypair.sign(this.hash()).toString("base64");
        }
        /**
         * Add a signature to the transaction. Useful when a party wants to pre-sign
         * a transaction but doesn't want to give access to their secret keys.
         * This will also verify whether the signature is valid.
         *
         * Here's how you would use this feature to solicit multiple signatures.
         * - Use `TransactionBuilder` to build a new transaction.
         * - Make sure to set a long enough timeout on that transaction to give your
         * signers enough time to sign!
         * - Once you build the transaction, use `transaction.toXDR()` to get the
         * base64-encoded XDR string.
         * - _Warning!_ Once you've built this transaction, don't submit any other
         * transactions onto your account! Doing so will invalidate this pre-compiled
         * transaction!
         * - Send this XDR string to your other parties. They can use the instructions
         * for [getKeypairSignature](#getKeypairSignature) to sign the transaction.
         * - They should send you back their `publicKey` and the `signature` string
         * from [getKeypairSignature](#getKeypairSignature), both of which you pass to
         * this function.
         *
         * @param {string} publicKey The public key of the signer
         * @param {string} signature The base64 value of the signature XDR
         * @returns {void}
         */
      }, {
        key: "addSignature",
        value: function addSignature() {
          var publicKey = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var signature = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          if (!signature || typeof signature !== "string") {
            throw new Error("Invalid signature");
          }
          if (!publicKey || typeof publicKey !== "string") {
            throw new Error("Invalid publicKey");
          }
          var keypair;
          var hint;
          var signatureBuffer = Buffer.from(signature, "base64");
          try {
            keypair = _keypair.Keypair.fromPublicKey(publicKey);
            hint = keypair.signatureHint();
          } catch (e) {
            throw new Error("Invalid publicKey");
          }
          if (!keypair.verify(this.hash(), signatureBuffer)) {
            throw new Error("Invalid signature");
          }
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature: signatureBuffer
          }));
        }
        /**
         * Add a decorated signature directly to the transaction envelope.
         *
         * @param {xdr.DecoratedSignature} signature    raw signature to add
         * @returns {void}
         *
         * @see Keypair.signDecorated
         * @see Keypair.signPayloadDecorated
         */
      }, {
        key: "addDecoratedSignature",
        value: function addDecoratedSignature(signature) {
          this.signatures.push(signature);
        }
        /**
         * Add `hashX` signer preimage as signature.
         * @param {Buffer|String} preimage Preimage of hash used as signer
         * @returns {void}
         */
      }, {
        key: "signHashX",
        value: function signHashX(preimage) {
          if (typeof preimage === "string") {
            preimage = Buffer.from(preimage, "hex");
          }
          if (preimage.length > 64) {
            throw new Error("preimage cannnot be longer than 64 bytes");
          }
          var signature = preimage;
          var hashX = (0, _hashing.hash)(preimage);
          var hint = hashX.slice(hashX.length - 4);
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature
          }));
        }
        /**
         * Returns a hash for this transaction, suitable for signing.
         * @returns {Buffer}
         */
      }, {
        key: "hash",
        value: function hash2() {
          return (0, _hashing.hash)(this.signatureBase());
        }
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          throw new Error("Implement in subclass");
        }
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          throw new Error("Implement in subclass");
        }
        /**
         * Get the transaction envelope as a base64-encoded string
         * @returns {string} XDR string
         */
      }, {
        key: "toXDR",
        value: function toXDR() {
          return this.toEnvelope().toXDR().toString("base64");
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/bignumber.js
var require_bignumber3 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/bignumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var BigNumber = _bignumber["default"].clone();
    BigNumber.DEBUG = true;
    var _default = exports["default"] = BigNumber;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js
var require_continued_fraction2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.best_r = best_r;
    var _bignumber = _interopRequireDefault(require_bignumber3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var MAX_INT = (1 << 31 >>> 0) - 1;
    function best_r(rawNumber) {
      var number = new _bignumber["default"](rawNumber);
      var a;
      var f;
      var fractions = [[new _bignumber["default"](0), new _bignumber["default"](1)], [new _bignumber["default"](1), new _bignumber["default"](0)]];
      var i = 2;
      while (true) {
        if (number.gt(MAX_INT)) {
          break;
        }
        a = number.integerValue(_bignumber["default"].ROUND_FLOOR);
        f = number.minus(a);
        var h = a.times(fractions[i - 1][0]).plus(fractions[i - 2][0]);
        var k = a.times(fractions[i - 1][1]).plus(fractions[i - 2][1]);
        if (h.gt(MAX_INT) || k.gt(MAX_INT)) {
          break;
        }
        fractions.push([h, k]);
        if (f.eq(0)) {
          break;
        }
        number = new _bignumber["default"](1).div(f);
        i += 1;
      }
      var _fractions = _slicedToArray(fractions[fractions.length - 1], 2), n = _fractions[0], d = _fractions[1];
      if (n.isZero() || d.isZero()) {
        throw new Error("Couldn't find approximation");
      }
      return [n.toNumber(), d.toNumber()];
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js
var require_liquidity_pool_asset2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolAsset = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _asset = require_asset2();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolAsset = exports.LiquidityPoolAsset = function() {
      function LiquidityPoolAsset2(assetA, assetB, fee) {
        _classCallCheck(this, LiquidityPoolAsset2);
        if (!assetA || !(assetA instanceof _asset.Asset)) {
          throw new Error("assetA is invalid");
        }
        if (!assetB || !(assetB instanceof _asset.Asset)) {
          throw new Error("assetB is invalid");
        }
        if (_asset.Asset.compare(assetA, assetB) !== -1) {
          throw new Error("Assets are not in lexicographic order");
        }
        if (!fee || fee !== _get_liquidity_pool_id.LiquidityPoolFeeV18) {
          throw new Error("fee is invalid");
        }
        this.assetA = assetA;
        this.assetB = assetB;
        this.fee = fee;
      }
      return _createClass(LiquidityPoolAsset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.ChangeTrustAsset` object for this liquidity pool asset.
           *
           * Note: To convert from an {@link Asset `Asset`} to `xdr.ChangeTrustAsset`
           * please refer to the
           * {@link Asset.toChangeTrustXDRObject `Asset.toChangeTrustXDRObject`} method.
           *
           * @returns {xdr.ChangeTrustAsset} XDR ChangeTrustAsset object.
           */
          function toXDRObject() {
            var lpConstantProductParamsXdr = new _xdr["default"].LiquidityPoolConstantProductParameters({
              assetA: this.assetA.toXDRObject(),
              assetB: this.assetB.toXDRObject(),
              fee: this.fee
            });
            var lpParamsXdr = new _xdr["default"].LiquidityPoolParameters("liquidityPoolConstantProduct", lpConstantProductParamsXdr);
            return new _xdr["default"].ChangeTrustAsset("assetTypePoolShare", lpParamsXdr);
          }
        )
        /**
         * @returns {LiquidityPoolParameters} Liquidity pool parameters.
         */
      }, {
        key: "getLiquidityPoolParameters",
        value: function getLiquidityPoolParameters() {
          return _objectSpread(_objectSpread({}, this), {}, {
            assetA: this.assetA,
            assetB: this.assetB,
            fee: this.fee
          });
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolAsset} other the LiquidityPoolAsset to compare
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(other) {
          return this.assetA.equals(other.assetA) && this.assetB.equals(other.assetB) && this.fee === other.fee;
        }
      }, {
        key: "toString",
        value: function toString() {
          var poolId = (0, _get_liquidity_pool_id.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
          return "liquidity_pool:".concat(poolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(ctAssetXdr) {
          var assetType = ctAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolParameters = ctAssetXdr.liquidityPool().constantProduct();
            return new this(_asset.Asset.fromOperation(liquidityPoolParameters.assetA()), _asset.Asset.fromOperation(liquidityPoolParameters.assetB()), liquidityPoolParameters.fee());
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/claimant.js
var require_claimant2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/claimant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Claimant = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Claimant = exports.Claimant = function() {
      function Claimant2(destination, predicate) {
        _classCallCheck(this, Claimant2);
        if (destination && !_strkey.StrKey.isValidEd25519PublicKey(destination)) {
          throw new Error("Destination is invalid");
        }
        this._destination = destination;
        if (!predicate) {
          this._predicate = _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        } else if (predicate instanceof _xdr["default"].ClaimPredicate) {
          this._predicate = predicate;
        } else {
          throw new Error("Predicate should be an xdr.ClaimPredicate");
        }
      }
      return _createClass(Claimant2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr object for this claimant.
           * @returns {xdr.Claimant} XDR Claimant object
           */
          function toXDRObject() {
            var claimant = new _xdr["default"].ClaimantV0({
              destination: _keypair.Keypair.fromPublicKey(this._destination).xdrAccountId(),
              predicate: this._predicate
            });
            return _xdr["default"].Claimant.claimantTypeV0(claimant);
          }
        )
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "destination",
        get: function get() {
          return this._destination;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
        /**
         * @type {xdr.ClaimPredicate}
         * @readonly
         */
      }, {
        key: "predicate",
        get: function get() {
          return this._predicate;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
      }], [{
        key: "predicateUnconditional",
        value: function predicateUnconditional() {
          return _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        }
        /**
         * Returns an `and` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateAnd",
        value: function predicateAnd(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateAnd([left, right]);
        }
        /**
         * Returns an `or` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateOr",
        value: function predicateOr(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateOr([left, right]);
        }
        /**
         * Returns a `not` claim predicate
         * @param {xdr.ClaimPredicate} predicate an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateNot",
        value: function predicateNot(predicate) {
          if (!(predicate instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateNot(predicate);
        }
        /**
         * Returns a `BeforeAbsoluteTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation is less than this (absolute)
         * Unix timestamp (expressed in seconds).
         *
         * @param {string} absBefore Unix epoch (in seconds) as a string
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeAbsoluteTime",
        value: function predicateBeforeAbsoluteTime(absBefore) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeAbsoluteTime(_xdr["default"].Int64.fromString(absBefore));
        }
        /**
         * Returns a `BeforeRelativeTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation plus this relative time delta
         * (in seconds) is less than the current time.
         *
         * @param {strings} seconds seconds since closeTime of the ledger in which the ClaimableBalanceEntry was created (as string)
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeRelativeTime",
        value: function predicateBeforeRelativeTime(seconds) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeRelativeTime(_xdr["default"].Int64.fromString(seconds));
        }
        /**
         * Returns a claimant object from its XDR object representation.
         * @param {xdr.Claimant} claimantXdr - The claimant xdr object.
         * @returns {Claimant}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(claimantXdr) {
          var value;
          switch (claimantXdr["switch"]()) {
            case _xdr["default"].ClaimantType.claimantTypeV0():
              value = claimantXdr.v0();
              return new this(_strkey.StrKey.encodeEd25519PublicKey(value.destination().ed25519()), value.predicate());
            default:
              throw new Error("Invalid claimant type: ".concat(claimantXdr["switch"]().name));
          }
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js
var require_liquidity_pool_id2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolId = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolId = exports.LiquidityPoolId = function() {
      function LiquidityPoolId2(liquidityPoolId) {
        _classCallCheck(this, LiquidityPoolId2);
        if (!liquidityPoolId) {
          throw new Error("liquidityPoolId cannot be empty");
        }
        if (!/^[a-f0-9]{64}$/.test(liquidityPoolId)) {
          throw new Error("Liquidity pool ID is not a valid hash");
        }
        this.liquidityPoolId = liquidityPoolId;
      }
      return _createClass(LiquidityPoolId2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.TrustLineAsset` object for this liquidity pool ID.
           *
           * Note: To convert from {@link Asset `Asset`} to `xdr.TrustLineAsset` please
           * refer to the
           * {@link Asset.toTrustLineXDRObject `Asset.toTrustLineXDRObject`} method.
           *
           * @returns {xdr.TrustLineAsset} XDR LiquidityPoolId object
           */
          function toXDRObject() {
            var xdrPoolId = _xdr["default"].PoolId.fromXDR(this.liquidityPoolId, "hex");
            return new _xdr["default"].TrustLineAsset("assetTypePoolShare", xdrPoolId);
          }
        )
        /**
         * @returns {string} Liquidity pool ID.
         */
      }, {
        key: "getLiquidityPoolId",
        value: function getLiquidityPoolId() {
          return String(this.liquidityPoolId);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolId} asset LiquidityPoolId to compare.
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.liquidityPoolId === asset.getLiquidityPoolId();
        }
      }, {
        key: "toString",
        value: function toString() {
          return "liquidity_pool:".concat(this.liquidityPoolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(tlAssetXdr) {
          var assetType = tlAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolId = tlAssetXdr.liquidityPoolId().toString("hex");
            return new this(liquidityPoolId);
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js
var require_manage_sell_offer2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageSellOffer = manageSellOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageSellOfferOp = new _xdr["default"].ManageSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageSellOffer(manageSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js
var require_create_passive_sell_offer2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createPassiveSellOffer = createPassiveSellOffer;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createPassiveSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      var createPassiveSellOfferOp = new _xdr["default"].CreatePassiveSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createPassiveSellOffer(createPassiveSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js
var require_decode_encode_muxed_account2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;
    exports.encodeMuxedAccount = encodeMuxedAccount;
    exports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;
    exports.extractBaseAddress = extractBaseAddress;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function decodeAddressToMuxedAccount(address) {
      if (_strkey.StrKey.isValidMed25519PublicKey(address)) {
        return _decodeAddressFullyToMuxedAccount(address);
      }
      return _xdr["default"].MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));
    }
    function encodeMuxedAccountToAddress(muxedAccount) {
      if (muxedAccount["switch"]().value === _xdr["default"].CryptoKeyType.keyTypeMuxedEd25519().value) {
        return _encodeMuxedAccountFullyToAddress(muxedAccount);
      }
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());
    }
    function encodeMuxedAccount(address, id) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {
        throw new Error("address should be a Stellar account ID (G...)");
      }
      if (typeof id !== "string") {
        throw new Error("id should be a string representing a number (uint64)");
      }
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromString(id),
        ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)
      }));
    }
    function extractBaseAddress(address) {
      if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
        return address;
      }
      if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {
        throw new TypeError("expected muxed account (M...), got ".concat(address));
      }
      var muxedAccount = decodeAddressToMuxedAccount(address);
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());
    }
    function _decodeAddressFullyToMuxedAccount(address) {
      var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromXDR(rawBytes.subarray(-8)),
        ed25519: rawBytes.subarray(0, -8)
      }));
    }
    function _encodeMuxedAccountFullyToAddress(muxedAccount) {
      if (muxedAccount["switch"]() === _xdr["default"].CryptoKeyType.keyTypeEd25519()) {
        return encodeMuxedAccountToAddress(muxedAccount);
      }
      var muxed = muxedAccount.med25519();
      return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR("raw")]));
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/account_merge.js
var require_account_merge2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/account_merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.accountMerge = accountMerge;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function accountMerge(opts) {
      var opAttributes = {};
      try {
        opAttributes.body = _xdr["default"].OperationBody.accountMerge((0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination));
      } catch (e) {
        throw new Error("destination is invalid");
      }
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js
var require_allow_trust2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.allowTrust = allowTrust;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function allowTrust(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.trustor)) {
        throw new Error("trustor is invalid");
      }
      var attributes = {};
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      if (opts.assetCode.length <= 4) {
        var code = opts.assetCode.padEnd(4, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum4(code);
      } else if (opts.assetCode.length <= 12) {
        var _code = opts.assetCode.padEnd(12, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum12(_code);
      } else {
        throw new Error("Asset code must be 12 characters at max.");
      }
      if (typeof opts.authorize === "boolean") {
        if (opts.authorize) {
          attributes.authorize = _xdr["default"].TrustLineFlags.authorizedFlag().value;
        } else {
          attributes.authorize = 0;
        }
      } else {
        attributes.authorize = opts.authorize;
      }
      var allowTrustOp = new _xdr["default"].AllowTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.allowTrust(allowTrustOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js
var require_bump_sequence2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bumpSequence = bumpSequence;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber3());
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function bumpSequence(opts) {
      var attributes = {};
      if (typeof opts.bumpTo !== "string") {
        throw new Error("bumpTo must be a string");
      }
      try {
        new _bignumber["default"](opts.bumpTo);
      } catch (e) {
        throw new Error("bumpTo must be a stringified number");
      }
      attributes.bumpTo = _jsXdr.Hyper.fromString(opts.bumpTo);
      var bumpSequenceOp = new _xdr["default"].BumpSequenceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.bumpSequence(bumpSequenceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/change_trust.js
var require_change_trust2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/change_trust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.changeTrust = changeTrust;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber3());
    var _xdr = _interopRequireDefault(require_xdr3());
    var _asset = require_asset2();
    var _liquidity_pool_asset = require_liquidity_pool_asset2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var MAX_INT64 = "9223372036854775807";
    function changeTrust(opts) {
      var attributes = {};
      if (opts.asset instanceof _asset.Asset) {
        attributes.line = opts.asset.toChangeTrustXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_asset.LiquidityPoolAsset) {
        attributes.line = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be Asset or LiquidityPoolAsset");
      }
      if (opts.limit !== void 0 && !this.isValidAmount(opts.limit, true)) {
        throw new TypeError(this.constructAmountRequirementsError("limit"));
      }
      if (opts.limit) {
        attributes.limit = this._toXDRAmount(opts.limit);
      } else {
        attributes.limit = _jsXdr.Hyper.fromString(new _bignumber["default"](MAX_INT64).toString());
      }
      if (opts.source) {
        attributes.source = opts.source.masterKeypair;
      }
      var changeTrustOP = new _xdr["default"].ChangeTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.changeTrust(changeTrustOP);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/create_account.js
var require_create_account2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/create_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createAccount = createAccount;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createAccount(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.destination)) {
        throw new Error("destination is invalid");
      }
      if (!this.isValidAmount(opts.startingBalance, true)) {
        throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
      }
      var attributes = {};
      attributes.destination = _keypair.Keypair.fromPublicKey(opts.destination).xdrAccountId();
      attributes.startingBalance = this._toXDRAmount(opts.startingBalance);
      var createAccountOp = new _xdr["default"].CreateAccountOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createAccount(createAccountOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js
var require_create_claimable_balance2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createClaimableBalance = createClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _asset = require_asset2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createClaimableBalance(opts) {
      if (!(opts.asset instanceof _asset.Asset)) {
        throw new Error("must provide an asset for create claimable balance operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      if (!Array.isArray(opts.claimants) || opts.claimants.length === 0) {
        throw new Error("must provide at least one claimant");
      }
      var attributes = {};
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.claimants = Object.values(opts.claimants).map(function(c) {
        return c.toXDRObject();
      });
      var createClaimableBalanceOp = new _xdr["default"].CreateClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createClaimableBalance(createClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js
var require_claim_claimable_balance2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.claimClaimableBalance = claimClaimableBalance;
    exports.validateClaimableBalanceId = validateClaimableBalanceId;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function claimClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      validateClaimableBalanceId(opts.balanceId);
      var attributes = {};
      attributes.balanceId = _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex");
      var claimClaimableBalanceOp = new _xdr["default"].ClaimClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.claimClaimableBalance(claimClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function validateClaimableBalanceId(balanceId) {
      if (typeof balanceId !== "string" || balanceId.length !== 8 + 64) {
        throw new Error("must provide a valid claimable balance id");
      }
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js
var require_clawback_claimable_balance2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawbackClaimableBalance = clawbackClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _claim_claimable_balance = require_claim_claimable_balance2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawbackClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _claim_claimable_balance.validateClaimableBalanceId)(opts.balanceId);
      var attributes = {
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      };
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawbackClaimableBalance(new _xdr["default"].ClawbackClaimableBalanceOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/inflation.js
var require_inflation2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/inflation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inflation = inflation;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function inflation() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.inflation();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/manage_data.js
var require_manage_data2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/manage_data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageData = manageData;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageData(opts) {
      var attributes = {};
      if (!(typeof opts.name === "string" && opts.name.length <= 64)) {
        throw new Error("name must be a string, up to 64 characters");
      }
      attributes.dataName = opts.name;
      if (typeof opts.value !== "string" && !Buffer.isBuffer(opts.value) && opts.value !== null) {
        throw new Error("value must be a string, Buffer or null");
      }
      if (typeof opts.value === "string") {
        attributes.dataValue = Buffer.from(opts.value);
      } else {
        attributes.dataValue = opts.value;
      }
      if (attributes.dataValue !== null && attributes.dataValue.length > 64) {
        throw new Error("value cannot be longer that 64 bytes");
      }
      var manageDataOp = new _xdr["default"].ManageDataOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageData(manageDataOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js
var require_manage_buy_offer2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageBuyOffer = manageBuyOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageBuyOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.buyAmount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
      }
      attributes.buyAmount = this._toXDRAmount(opts.buyAmount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageBuyOfferOp = new _xdr["default"].ManageBuyOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageBuyOffer(manageBuyOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js
var require_path_payment_strict_receive2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictReceive = pathPaymentStrictReceive;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictReceive(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendMax):
          throw new TypeError(this.constructAmountRequirementsError("sendMax"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destAmount):
          throw new TypeError(this.constructAmountRequirementsError("destAmount"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendMax = this._toXDRAmount(opts.sendMax);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destAmount = this._toXDRAmount(opts.destAmount);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictReceiveOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictReceive(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js
var require_path_payment_strict_send2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictSend = pathPaymentStrictSend;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictSend(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendAmount):
          throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destMin):
          throw new TypeError(this.constructAmountRequirementsError("destMin"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendAmount = this._toXDRAmount(opts.sendAmount);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destMin = this._toXDRAmount(opts.destMin);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictSendOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictSend(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/payment.js
var require_payment2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/payment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.payment = payment;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function payment(opts) {
      if (!opts.asset) {
        throw new Error("Must provide an asset for a payment operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      var attributes = {};
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      var paymentOp = new _xdr["default"].PaymentOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.payment(paymentOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/set_options.js
var require_set_options2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/set_options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setOptions = setOptions;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function weightCheckFunction(value, name) {
      if (value >= 0 && value <= 255) {
        return true;
      }
      throw new Error("".concat(name, " value must be between 0 and 255"));
    }
    function setOptions(opts) {
      var attributes = {};
      if (opts.inflationDest) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.inflationDest)) {
          throw new Error("inflationDest is invalid");
        }
        attributes.inflationDest = _keypair.Keypair.fromPublicKey(opts.inflationDest).xdrAccountId();
      }
      attributes.clearFlags = this._checkUnsignedIntValue("clearFlags", opts.clearFlags);
      attributes.setFlags = this._checkUnsignedIntValue("setFlags", opts.setFlags);
      attributes.masterWeight = this._checkUnsignedIntValue("masterWeight", opts.masterWeight, weightCheckFunction);
      attributes.lowThreshold = this._checkUnsignedIntValue("lowThreshold", opts.lowThreshold, weightCheckFunction);
      attributes.medThreshold = this._checkUnsignedIntValue("medThreshold", opts.medThreshold, weightCheckFunction);
      attributes.highThreshold = this._checkUnsignedIntValue("highThreshold", opts.highThreshold, weightCheckFunction);
      if (opts.homeDomain !== void 0 && typeof opts.homeDomain !== "string") {
        throw new TypeError("homeDomain argument must be of type String");
      }
      attributes.homeDomain = opts.homeDomain;
      if (opts.signer) {
        var weight = this._checkUnsignedIntValue("signer.weight", opts.signer.weight, weightCheckFunction);
        var key;
        var setValues = 0;
        if (opts.signer.ed25519PublicKey) {
          if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
            throw new Error("signer.ed25519PublicKey is invalid.");
          }
          var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
          key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
          setValues += 1;
        }
        if (opts.signer.preAuthTx) {
          if (typeof opts.signer.preAuthTx === "string") {
            opts.signer.preAuthTx = Buffer.from(opts.signer.preAuthTx, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.preAuthTx) && opts.signer.preAuthTx.length === 32)) {
            throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(opts.signer.preAuthTx);
          setValues += 1;
        }
        if (opts.signer.sha256Hash) {
          if (typeof opts.signer.sha256Hash === "string") {
            opts.signer.sha256Hash = Buffer.from(opts.signer.sha256Hash, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.sha256Hash) && opts.signer.sha256Hash.length === 32)) {
            throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypeHashX(opts.signer.sha256Hash);
          setValues += 1;
        }
        if (opts.signer.ed25519SignedPayload) {
          if (!_strkey.StrKey.isValidSignedPayload(opts.signer.ed25519SignedPayload)) {
            throw new Error("signer.ed25519SignedPayload is invalid.");
          }
          var _rawKey = _strkey.StrKey.decodeSignedPayload(opts.signer.ed25519SignedPayload);
          var signedPayloadXdr = _xdr["default"].SignerKeyEd25519SignedPayload.fromXDR(_rawKey);
          key = _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload(signedPayloadXdr);
          setValues += 1;
        }
        if (setValues !== 1) {
          throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
        }
        attributes.signer = new _xdr["default"].Signer({
          key,
          weight
        });
      }
      var setOptionsOp = new _xdr["default"].SetOptionsOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.setOptions(setOptionsOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js
var require_begin_sponsoring_future_reserves2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.beginSponsoringFutureReserves = beginSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _strkey = require_strkey2();
    var _keypair = require_keypair2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function beginSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.sponsoredId)) {
        throw new Error("sponsoredId is invalid");
      }
      var op = new _xdr["default"].BeginSponsoringFutureReservesOp({
        sponsoredId: _keypair.Keypair.fromPublicKey(opts.sponsoredId).xdrAccountId()
      });
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.beginSponsoringFutureReserves(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js
var require_end_sponsoring_future_reserves2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.endSponsoringFutureReserves = endSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function endSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.endSponsoringFutureReserves();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js
var require_revoke_sponsorship2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.revokeAccountSponsorship = revokeAccountSponsorship;
    exports.revokeClaimableBalanceSponsorship = revokeClaimableBalanceSponsorship;
    exports.revokeDataSponsorship = revokeDataSponsorship;
    exports.revokeLiquidityPoolSponsorship = revokeLiquidityPoolSponsorship;
    exports.revokeOfferSponsorship = revokeOfferSponsorship;
    exports.revokeSignerSponsorship = revokeSignerSponsorship;
    exports.revokeTrustlineSponsorship = revokeTrustlineSponsorship;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _strkey = require_strkey2();
    var _keypair = require_keypair2();
    var _asset = require_asset2();
    var _liquidity_pool_id = require_liquidity_pool_id2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function revokeAccountSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.account(new _xdr["default"].LedgerKeyAccount({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId()
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeTrustlineSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var asset;
      if (opts.asset instanceof _asset.Asset) {
        asset = opts.asset.toTrustLineXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_id.LiquidityPoolId) {
        asset = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be an Asset or LiquidityPoolId");
      }
      var ledgerKey = _xdr["default"].LedgerKey.trustline(new _xdr["default"].LedgerKeyTrustLine({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        asset
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeOfferSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.seller)) {
        throw new Error("seller is invalid");
      }
      if (typeof opts.offerId !== "string") {
        throw new Error("offerId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.offer(new _xdr["default"].LedgerKeyOffer({
        sellerId: _keypair.Keypair.fromPublicKey(opts.seller).xdrAccountId(),
        offerId: _xdr["default"].Int64.fromString(opts.offerId)
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeDataSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      if (typeof opts.name !== "string" || opts.name.length > 64) {
        throw new Error("name must be a string, up to 64 characters");
      }
      var ledgerKey = _xdr["default"].LedgerKey.data(new _xdr["default"].LedgerKeyData({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        dataName: opts.name
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeClaimableBalanceSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.balanceId !== "string") {
        throw new Error("balanceId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.claimableBalance(new _xdr["default"].LedgerKeyClaimableBalance({
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeLiquidityPoolSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.liquidityPoolId !== "string") {
        throw new Error("liquidityPoolId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.liquidityPool(new _xdr["default"].LedgerKeyLiquidityPool({
        liquidityPoolId: _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {
        body: _xdr["default"].OperationBody.revokeSponsorship(op)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeSignerSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var key;
      if (opts.signer.ed25519PublicKey) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
          throw new Error("signer.ed25519PublicKey is invalid.");
        }
        var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
        key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
      } else if (opts.signer.preAuthTx) {
        var buffer;
        if (typeof opts.signer.preAuthTx === "string") {
          buffer = Buffer.from(opts.signer.preAuthTx, "hex");
        } else {
          buffer = opts.signer.preAuthTx;
        }
        if (!(Buffer.isBuffer(buffer) && buffer.length === 32)) {
          throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(buffer);
      } else if (opts.signer.sha256Hash) {
        var _buffer;
        if (typeof opts.signer.sha256Hash === "string") {
          _buffer = Buffer.from(opts.signer.sha256Hash, "hex");
        } else {
          _buffer = opts.signer.sha256Hash;
        }
        if (!(Buffer.isBuffer(_buffer) && _buffer.length === 32)) {
          throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypeHashX(_buffer);
      } else {
        throw new Error("signer is invalid");
      }
      var signer = new _xdr["default"].RevokeSponsorshipOpSigner({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        signerKey: key
      });
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipSigner(signer);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/clawback.js
var require_clawback2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/clawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawback = clawback;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawback(opts) {
      var attributes = {};
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.asset = opts.asset.toXDRObject();
      try {
        attributes.from = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.from);
      } catch (e) {
        throw new Error("from address is invalid");
      }
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawback(new _xdr["default"].ClawbackOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js
var require_set_trustline_flags2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setTrustLineFlags = setTrustLineFlags;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function setTrustLineFlags() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (_typeof(opts.flags) !== "object" || Object.keys(opts.flags).length === 0) {
        throw new Error("opts.flags must be a map of boolean flags to modify");
      }
      var mapping = {
        authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
        authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
        clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
      };
      var clearFlag = 0;
      var setFlag = 0;
      Object.keys(opts.flags).forEach(function(flagName) {
        if (!Object.prototype.hasOwnProperty.call(mapping, flagName)) {
          throw new Error("unsupported flag name specified: ".concat(flagName));
        }
        var flagValue = opts.flags[flagName];
        var bit = mapping[flagName].value;
        if (flagValue === true) {
          setFlag |= bit;
        } else if (flagValue === false) {
          clearFlag |= bit;
        }
      });
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      attributes.asset = opts.asset.toXDRObject();
      attributes.clearFlags = clearFlag;
      attributes.setFlags = setFlag;
      var opAttributes = {
        body: _xdr["default"].OperationBody.setTrustLineFlags(new _xdr["default"].SetTrustLineFlagsOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js
var require_liquidity_pool_deposit2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolDeposit = liquidityPoolDeposit;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolDeposit() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var liquidityPoolId = opts.liquidityPoolId, maxAmountA = opts.maxAmountA, maxAmountB = opts.maxAmountB, minPrice = opts.minPrice, maxPrice = opts.maxPrice;
      var attributes = {};
      if (!liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(liquidityPoolId, "hex");
      if (!this.isValidAmount(maxAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
      }
      attributes.maxAmountA = this._toXDRAmount(maxAmountA);
      if (!this.isValidAmount(maxAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
      }
      attributes.maxAmountB = this._toXDRAmount(maxAmountB);
      if (minPrice === void 0) {
        throw new TypeError("minPrice argument is required");
      }
      attributes.minPrice = this._toXDRPrice(minPrice);
      if (maxPrice === void 0) {
        throw new TypeError("maxPrice argument is required");
      }
      attributes.maxPrice = this._toXDRPrice(maxPrice);
      var liquidityPoolDepositOp = new _xdr["default"].LiquidityPoolDepositOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolDeposit(liquidityPoolDepositOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js
var require_liquidity_pool_withdraw2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolWithdraw = liquidityPoolWithdraw;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolWithdraw() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (!opts.liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex");
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (!this.isValidAmount(opts.minAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
      }
      attributes.minAmountA = this._toXDRAmount(opts.minAmountA);
      if (!this.isValidAmount(opts.minAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
      }
      attributes.minAmountB = this._toXDRAmount(opts.minAmountB);
      var liquidityPoolWithdrawOp = new _xdr["default"].LiquidityPoolWithdrawOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolWithdraw(liquidityPoolWithdrawOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/address.js
var require_address2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Address = void 0;
    var _strkey = require_strkey2();
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Address2 = exports.Address = function() {
      function Address3(address) {
        _classCallCheck(this, Address3);
        if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
          this._type = "account";
          this._key = _strkey.StrKey.decodeEd25519PublicKey(address);
        } else if (_strkey.StrKey.isValidContract(address)) {
          this._type = "contract";
          this._key = _strkey.StrKey.decodeContract(address);
        } else {
          throw new Error("Unsupported address type: ".concat(address));
        }
      }
      return _createClass(Address3, [{
        key: "toString",
        value: (
          /**
           * Serialize an address to string.
           *
           * @returns {string}
           */
          function toString() {
            switch (this._type) {
              case "account":
                return _strkey.StrKey.encodeEd25519PublicKey(this._key);
              case "contract":
                return _strkey.StrKey.encodeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          }
        )
        /**
         * Convert this Address to an xdr.ScVal type.
         *
         * @returns {xdr.ScVal}
         */
      }, {
        key: "toScVal",
        value: function toScVal() {
          return _xdr["default"].ScVal.scvAddress(this.toScAddress());
        }
        /**
         * Convert this Address to an xdr.ScAddress type.
         *
         * @returns {xdr.ScAddress}
         */
      }, {
        key: "toScAddress",
        value: function toScAddress() {
          switch (this._type) {
            case "account":
              return _xdr["default"].ScAddress.scAddressTypeAccount(_xdr["default"].PublicKey.publicKeyTypeEd25519(this._key));
            case "contract":
              return _xdr["default"].ScAddress.scAddressTypeContract(this._key);
            default:
              throw new Error("Unsupported address type");
          }
        }
        /**
         * Return the raw public key bytes for this address.
         *
         * @returns {Buffer}
         */
      }, {
        key: "toBuffer",
        value: function toBuffer() {
          return this._key;
        }
      }], [{
        key: "fromString",
        value: function fromString(address) {
          return new Address3(address);
        }
        /**
         * Creates a new account Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "account",
        value: function account(buffer) {
          return new Address3(_strkey.StrKey.encodeEd25519PublicKey(buffer));
        }
        /**
         * Creates a new contract Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "contract",
        value: function contract(buffer) {
          return new Address3(_strkey.StrKey.encodeContract(buffer));
        }
        /**
         * Convert this from an xdr.ScVal type
         *
         * @param {xdr.ScVal} scVal - The xdr.ScVal type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScVal",
        value: function fromScVal(scVal) {
          return Address3.fromScAddress(scVal.address());
        }
        /**
         * Convert this from an xdr.ScAddress type
         *
         * @param {xdr.ScAddress} scAddress - The xdr.ScAddress type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScAddress",
        value: function fromScAddress(scAddress) {
          switch (scAddress["switch"]().value) {
            case _xdr["default"].ScAddressType.scAddressTypeAccount().value:
              return Address3.account(scAddress.accountId().ed25519());
            case _xdr["default"].ScAddressType.scAddressTypeContract().value:
              return Address3.contract(scAddress.contractId());
            default:
              throw new Error("Unsupported address type");
          }
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js
var require_invoke_host_function2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createCustomContract = createCustomContract;
    exports.createStellarAssetContract = createStellarAssetContract;
    exports.invokeContractFunction = invokeContractFunction;
    exports.invokeHostFunction = invokeHostFunction;
    exports.uploadContractWasm = uploadContractWasm;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _address = require_address2();
    var _asset = require_asset2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function invokeHostFunction(opts) {
      if (!opts.func) {
        throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(opts), ")"));
      }
      var invokeHostFunctionOp = new _xdr["default"].InvokeHostFunctionOp({
        hostFunction: opts.func,
        auth: opts.auth || []
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.invokeHostFunction(invokeHostFunctionOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function invokeContractFunction(opts) {
      var c = new _address.Address(opts.contract);
      if (c._type !== "contract") {
        throw new TypeError("expected contract strkey instance, got ".concat(c));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeInvokeContract(new _xdr["default"].InvokeContractArgs({
          contractAddress: c.toScAddress(),
          functionName: opts["function"],
          args: opts.args
        }))
      });
    }
    function createCustomContract(opts) {
      var _opts$constructorArgs;
      var salt = Buffer.from(opts.salt || getSalty());
      if (!opts.wasmHash || opts.wasmHash.length !== 32) {
        throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(opts.wasmHash));
      }
      if (salt.length !== 32) {
        throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(opts.wasmHash));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContractV2(new _xdr["default"].CreateContractArgsV2({
          executable: _xdr["default"].ContractExecutable.contractExecutableWasm(Buffer.from(opts.wasmHash)),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAddress(new _xdr["default"].ContractIdPreimageFromAddress({
            address: opts.address.toScAddress(),
            salt
          })),
          constructorArgs: (_opts$constructorArgs = opts.constructorArgs) !== null && _opts$constructorArgs !== void 0 ? _opts$constructorArgs : []
        }))
      });
    }
    function createStellarAssetContract(opts) {
      var asset = opts.asset;
      if (typeof asset === "string") {
        var _asset$split = asset.split(":"), _asset$split2 = _slicedToArray(_asset$split, 2), code = _asset$split2[0], issuer = _asset$split2[1];
        asset = new _asset.Asset(code, issuer);
      }
      if (!(asset instanceof _asset.Asset)) {
        throw new TypeError("expected Asset in 'opts.asset', got ".concat(asset));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContract(new _xdr["default"].CreateContractArgs({
          executable: _xdr["default"].ContractExecutable.contractExecutableStellarAsset(),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(asset.toXDRObject())
        }))
      });
    }
    function uploadContractWasm(opts) {
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeUploadContractWasm(
          Buffer.from(opts.wasm)
          // coalesce so we can drop `Buffer` someday
        )
      });
    }
    function getSalty() {
      return _keypair.Keypair.random().xdrPublicKey().value();
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js
var require_extend_footprint_ttl2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extendFootprintTtl = extendFootprintTtl;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function extendFootprintTtl(opts) {
      var _opts$extendTo;
      if (((_opts$extendTo = opts.extendTo) !== null && _opts$extendTo !== void 0 ? _opts$extendTo : -1) <= 0) {
        throw new RangeError("extendTo has to be positive");
      }
      var extendFootprintOp = new _xdr["default"].ExtendFootprintTtlOp({
        ext: new _xdr["default"].ExtensionPoint(0),
        extendTo: opts.extendTo
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.extendFootprintTtl(extendFootprintOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js
var require_restore_footprint2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.restoreFootprint = restoreFootprint;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function restoreFootprint() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var op = new _xdr["default"].RestoreFootprintOp({
        ext: new _xdr["default"].ExtensionPoint(0)
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.restoreFootprint(op)
      };
      this.setSourceAccount(opAttributes, opts !== null && opts !== void 0 ? opts : {});
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/index.js
var require_operations2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operations/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "accountMerge", {
      enumerable: true,
      get: function get() {
        return _account_merge.accountMerge;
      }
    });
    Object.defineProperty(exports, "allowTrust", {
      enumerable: true,
      get: function get() {
        return _allow_trust.allowTrust;
      }
    });
    Object.defineProperty(exports, "beginSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _begin_sponsoring_future_reserves.beginSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "bumpSequence", {
      enumerable: true,
      get: function get() {
        return _bump_sequence.bumpSequence;
      }
    });
    Object.defineProperty(exports, "changeTrust", {
      enumerable: true,
      get: function get() {
        return _change_trust.changeTrust;
      }
    });
    Object.defineProperty(exports, "claimClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _claim_claimable_balance.claimClaimableBalance;
      }
    });
    Object.defineProperty(exports, "clawback", {
      enumerable: true,
      get: function get() {
        return _clawback.clawback;
      }
    });
    Object.defineProperty(exports, "clawbackClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _clawback_claimable_balance.clawbackClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createAccount", {
      enumerable: true,
      get: function get() {
        return _create_account.createAccount;
      }
    });
    Object.defineProperty(exports, "createClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _create_claimable_balance.createClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createCustomContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createCustomContract;
      }
    });
    Object.defineProperty(exports, "createPassiveSellOffer", {
      enumerable: true,
      get: function get() {
        return _create_passive_sell_offer.createPassiveSellOffer;
      }
    });
    Object.defineProperty(exports, "createStellarAssetContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createStellarAssetContract;
      }
    });
    Object.defineProperty(exports, "endSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _end_sponsoring_future_reserves.endSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "extendFootprintTtl", {
      enumerable: true,
      get: function get() {
        return _extend_footprint_ttl.extendFootprintTtl;
      }
    });
    Object.defineProperty(exports, "inflation", {
      enumerable: true,
      get: function get() {
        return _inflation.inflation;
      }
    });
    Object.defineProperty(exports, "invokeContractFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeContractFunction;
      }
    });
    Object.defineProperty(exports, "invokeHostFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeHostFunction;
      }
    });
    Object.defineProperty(exports, "liquidityPoolDeposit", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_deposit.liquidityPoolDeposit;
      }
    });
    Object.defineProperty(exports, "liquidityPoolWithdraw", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_withdraw.liquidityPoolWithdraw;
      }
    });
    Object.defineProperty(exports, "manageBuyOffer", {
      enumerable: true,
      get: function get() {
        return _manage_buy_offer.manageBuyOffer;
      }
    });
    Object.defineProperty(exports, "manageData", {
      enumerable: true,
      get: function get() {
        return _manage_data.manageData;
      }
    });
    Object.defineProperty(exports, "manageSellOffer", {
      enumerable: true,
      get: function get() {
        return _manage_sell_offer.manageSellOffer;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictReceive", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_receive.pathPaymentStrictReceive;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictSend", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_send.pathPaymentStrictSend;
      }
    });
    Object.defineProperty(exports, "payment", {
      enumerable: true,
      get: function get() {
        return _payment.payment;
      }
    });
    Object.defineProperty(exports, "restoreFootprint", {
      enumerable: true,
      get: function get() {
        return _restore_footprint.restoreFootprint;
      }
    });
    Object.defineProperty(exports, "revokeAccountSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeAccountSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeClaimableBalanceSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeClaimableBalanceSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeDataSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeDataSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeLiquidityPoolSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeLiquidityPoolSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeOfferSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeOfferSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeSignerSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeSignerSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeTrustlineSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeTrustlineSponsorship;
      }
    });
    Object.defineProperty(exports, "setOptions", {
      enumerable: true,
      get: function get() {
        return _set_options.setOptions;
      }
    });
    Object.defineProperty(exports, "setTrustLineFlags", {
      enumerable: true,
      get: function get() {
        return _set_trustline_flags.setTrustLineFlags;
      }
    });
    Object.defineProperty(exports, "uploadContractWasm", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.uploadContractWasm;
      }
    });
    var _manage_sell_offer = require_manage_sell_offer2();
    var _create_passive_sell_offer = require_create_passive_sell_offer2();
    var _account_merge = require_account_merge2();
    var _allow_trust = require_allow_trust2();
    var _bump_sequence = require_bump_sequence2();
    var _change_trust = require_change_trust2();
    var _create_account = require_create_account2();
    var _create_claimable_balance = require_create_claimable_balance2();
    var _claim_claimable_balance = require_claim_claimable_balance2();
    var _clawback_claimable_balance = require_clawback_claimable_balance2();
    var _inflation = require_inflation2();
    var _manage_data = require_manage_data2();
    var _manage_buy_offer = require_manage_buy_offer2();
    var _path_payment_strict_receive = require_path_payment_strict_receive2();
    var _path_payment_strict_send = require_path_payment_strict_send2();
    var _payment = require_payment2();
    var _set_options = require_set_options2();
    var _begin_sponsoring_future_reserves = require_begin_sponsoring_future_reserves2();
    var _end_sponsoring_future_reserves = require_end_sponsoring_future_reserves2();
    var _revoke_sponsorship = require_revoke_sponsorship2();
    var _clawback = require_clawback2();
    var _set_trustline_flags = require_set_trustline_flags2();
    var _liquidity_pool_deposit = require_liquidity_pool_deposit2();
    var _liquidity_pool_withdraw = require_liquidity_pool_withdraw2();
    var _invoke_host_function = require_invoke_host_function2();
    var _extend_footprint_ttl = require_extend_footprint_ttl2();
    var _restore_footprint = require_restore_footprint2();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operation.js
var require_operation2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Operation = exports.AuthRevocableFlag = exports.AuthRequiredFlag = exports.AuthImmutableFlag = exports.AuthClawbackEnabledFlag = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber3());
    var _util = require_util2();
    var _continued_fraction = require_continued_fraction2();
    var _asset = require_asset2();
    var _liquidity_pool_asset = require_liquidity_pool_asset2();
    var _claimant = require_claimant2();
    var _strkey = require_strkey2();
    var _liquidity_pool_id = require_liquidity_pool_id2();
    var _xdr = _interopRequireDefault(require_xdr3());
    var ops = _interopRequireWildcard(require_operations2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var ONE = 1e7;
    var MAX_INT64 = "9223372036854775807";
    var AuthRequiredFlag = exports.AuthRequiredFlag = 1 << 0;
    var AuthRevocableFlag = exports.AuthRevocableFlag = 1 << 1;
    var AuthImmutableFlag = exports.AuthImmutableFlag = 1 << 2;
    var AuthClawbackEnabledFlag = exports.AuthClawbackEnabledFlag = 1 << 3;
    var Operation2 = exports.Operation = function() {
      function Operation3() {
        _classCallCheck(this, Operation3);
      }
      return _createClass(Operation3, null, [{
        key: "setSourceAccount",
        value: function setSourceAccount(opAttributes, opts) {
          if (opts.source) {
            try {
              opAttributes.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.source);
            } catch (e) {
              throw new Error("Source address is invalid");
            }
          }
        }
        /**
         * Deconstructs the raw XDR operation object into the structured object that
         * was used to create the operation (i.e. the `opts` parameter to most ops).
         *
         * @param {xdr.Operation}   operation - An XDR Operation.
         * @return {Operation}
         */
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(operation) {
          var result = {};
          if (operation.sourceAccount()) {
            result.source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(operation.sourceAccount());
          }
          var attrs = operation.body().value();
          var operationName = operation.body()["switch"]().name;
          switch (operationName) {
            case "createAccount": {
              result.type = "createAccount";
              result.destination = accountIdtoAddress(attrs.destination());
              result.startingBalance = this._fromXDRAmount(attrs.startingBalance());
              break;
            }
            case "payment": {
              result.type = "payment";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              break;
            }
            case "pathPaymentStrictReceive": {
              result.type = "pathPaymentStrictReceive";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendMax = this._fromXDRAmount(attrs.sendMax());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destAmount = this._fromXDRAmount(attrs.destAmount());
              result.path = [];
              var path = attrs.path();
              Object.keys(path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(path[pathKey]));
              });
              break;
            }
            case "pathPaymentStrictSend": {
              result.type = "pathPaymentStrictSend";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendAmount = this._fromXDRAmount(attrs.sendAmount());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destMin = this._fromXDRAmount(attrs.destMin());
              result.path = [];
              var _path = attrs.path();
              Object.keys(_path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(_path[pathKey]));
              });
              break;
            }
            case "changeTrust": {
              result.type = "changeTrust";
              switch (attrs.line()["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.line = _liquidity_pool_asset.LiquidityPoolAsset.fromOperation(attrs.line());
                  break;
                default:
                  result.line = _asset.Asset.fromOperation(attrs.line());
                  break;
              }
              result.limit = this._fromXDRAmount(attrs.limit());
              break;
            }
            case "allowTrust": {
              result.type = "allowTrust";
              result.trustor = accountIdtoAddress(attrs.trustor());
              result.assetCode = attrs.asset().value().toString();
              result.assetCode = (0, _util.trimEnd)(result.assetCode, "\0");
              result.authorize = attrs.authorize();
              break;
            }
            case "setOptions": {
              result.type = "setOptions";
              if (attrs.inflationDest()) {
                result.inflationDest = accountIdtoAddress(attrs.inflationDest());
              }
              result.clearFlags = attrs.clearFlags();
              result.setFlags = attrs.setFlags();
              result.masterWeight = attrs.masterWeight();
              result.lowThreshold = attrs.lowThreshold();
              result.medThreshold = attrs.medThreshold();
              result.highThreshold = attrs.highThreshold();
              result.homeDomain = attrs.homeDomain() !== void 0 ? attrs.homeDomain().toString("ascii") : void 0;
              if (attrs.signer()) {
                var signer = {};
                var arm = attrs.signer().key().arm();
                if (arm === "ed25519") {
                  signer.ed25519PublicKey = accountIdtoAddress(attrs.signer().key());
                } else if (arm === "preAuthTx") {
                  signer.preAuthTx = attrs.signer().key().preAuthTx();
                } else if (arm === "hashX") {
                  signer.sha256Hash = attrs.signer().key().hashX();
                } else if (arm === "ed25519SignedPayload") {
                  var signedPayload = attrs.signer().key().ed25519SignedPayload();
                  signer.ed25519SignedPayload = _strkey.StrKey.encodeSignedPayload(signedPayload.toXDR());
                }
                signer.weight = attrs.signer().weight();
                result.signer = signer;
              }
              break;
            }
            case "manageOffer":
            case "manageSellOffer": {
              result.type = "manageSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "manageBuyOffer": {
              result.type = "manageBuyOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.buyAmount = this._fromXDRAmount(attrs.buyAmount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "createPassiveOffer":
            case "createPassiveSellOffer": {
              result.type = "createPassiveSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              break;
            }
            case "accountMerge": {
              result.type = "accountMerge";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs);
              break;
            }
            case "manageData": {
              result.type = "manageData";
              result.name = attrs.dataName().toString("ascii");
              result.value = attrs.dataValue();
              break;
            }
            case "inflation": {
              result.type = "inflation";
              break;
            }
            case "bumpSequence": {
              result.type = "bumpSequence";
              result.bumpTo = attrs.bumpTo().toString();
              break;
            }
            case "createClaimableBalance": {
              result.type = "createClaimableBalance";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.claimants = [];
              attrs.claimants().forEach(function(claimant) {
                result.claimants.push(_claimant.Claimant.fromXDR(claimant));
              });
              break;
            }
            case "claimClaimableBalance": {
              result.type = "claimClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "beginSponsoringFutureReserves": {
              result.type = "beginSponsoringFutureReserves";
              result.sponsoredId = accountIdtoAddress(attrs.sponsoredId());
              break;
            }
            case "endSponsoringFutureReserves": {
              result.type = "endSponsoringFutureReserves";
              break;
            }
            case "revokeSponsorship": {
              extractRevokeSponshipDetails(attrs, result);
              break;
            }
            case "clawback": {
              result.type = "clawback";
              result.amount = this._fromXDRAmount(attrs.amount());
              result.from = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.from());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              break;
            }
            case "clawbackClaimableBalance": {
              result.type = "clawbackClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "setTrustLineFlags": {
              result.type = "setTrustLineFlags";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.trustor = accountIdtoAddress(attrs.trustor());
              var clears = attrs.clearFlags();
              var sets = attrs.setFlags();
              var mapping = {
                authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
                authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
              };
              var getFlagValue = function getFlagValue2(key) {
                var bit = mapping[key].value;
                if (sets & bit) {
                  return true;
                }
                if (clears & bit) {
                  return false;
                }
                return void 0;
              };
              result.flags = {};
              Object.keys(mapping).forEach(function(flagName) {
                result.flags[flagName] = getFlagValue(flagName);
              });
              break;
            }
            case "liquidityPoolDeposit": {
              result.type = "liquidityPoolDeposit";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.maxAmountA = this._fromXDRAmount(attrs.maxAmountA());
              result.maxAmountB = this._fromXDRAmount(attrs.maxAmountB());
              result.minPrice = this._fromXDRPrice(attrs.minPrice());
              result.maxPrice = this._fromXDRPrice(attrs.maxPrice());
              break;
            }
            case "liquidityPoolWithdraw": {
              result.type = "liquidityPoolWithdraw";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.amount = this._fromXDRAmount(attrs.amount());
              result.minAmountA = this._fromXDRAmount(attrs.minAmountA());
              result.minAmountB = this._fromXDRAmount(attrs.minAmountB());
              break;
            }
            case "invokeHostFunction": {
              var _attrs$auth;
              result.type = "invokeHostFunction";
              result.func = attrs.hostFunction();
              result.auth = (_attrs$auth = attrs.auth()) !== null && _attrs$auth !== void 0 ? _attrs$auth : [];
              break;
            }
            case "extendFootprintTtl": {
              result.type = "extendFootprintTtl";
              result.extendTo = attrs.extendTo();
              break;
            }
            case "restoreFootprint": {
              result.type = "restoreFootprint";
              break;
            }
            default: {
              throw new Error("Unknown operation: ".concat(operationName));
            }
          }
          return result;
        }
        /**
         * Validates that a given amount is possible for a Stellar asset.
         *
         * Specifically, this means that the amount is well, a valid number, but also
         * that it is within the int64 range and has no more than 7 decimal levels of
         * precision.
         *
         * Note that while smart contracts allow larger amounts, this is oriented
         * towards validating the standard Stellar operations.
         *
         * @param {string}  value       the amount to validate
         * @param {boolean} allowZero   optionally, whether or not zero is valid (default: no)
         *
         * @returns {boolean}
         */
      }, {
        key: "isValidAmount",
        value: function isValidAmount(value) {
          var allowZero = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (typeof value !== "string") {
            return false;
          }
          var amount;
          try {
            amount = new _bignumber["default"](value);
          } catch (e) {
            return false;
          }
          if (
            // == 0
            !allowZero && amount.isZero() || // < 0
            amount.isNegative() || // > Max value
            amount.times(ONE).gt(new _bignumber["default"](MAX_INT64).toString()) || // Decimal places (max 7)
            amount.decimalPlaces() > 7 || // NaN or Infinity
            amount.isNaN() || !amount.isFinite()
          ) {
            return false;
          }
          return true;
        }
      }, {
        key: "constructAmountRequirementsError",
        value: function constructAmountRequirementsError(arg) {
          return "".concat(arg, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
        }
        /**
         * Returns value converted to uint32 value or undefined.
         * If `value` is not `Number`, `String` or `Undefined` then throws an error.
         * Used in {@link Operation.setOptions}.
         * @private
         * @param {string} name Name of the property (used in error message only)
         * @param {*} value Value to check
         * @param {function(value, name)} isValidFunction Function to check other constraints (the argument will be a `Number`)
         * @returns {undefined|Number}
         */
      }, {
        key: "_checkUnsignedIntValue",
        value: function _checkUnsignedIntValue(name, value) {
          var isValidFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (typeof value === "undefined") {
            return void 0;
          }
          if (typeof value === "string") {
            value = parseFloat(value);
          }
          switch (true) {
            case (typeof value !== "number" || !Number.isFinite(value) || value % 1 !== 0):
              throw new Error("".concat(name, " value is invalid"));
            case value < 0:
              throw new Error("".concat(name, " value must be unsigned"));
            case (!isValidFunction || isValidFunction && isValidFunction(value, name)):
              return value;
            default:
              throw new Error("".concat(name, " value is invalid"));
          }
        }
        /**
         * @private
         * @param {string|BigNumber} value Value
         * @returns {Hyper} XDR amount
         */
      }, {
        key: "_toXDRAmount",
        value: function _toXDRAmount(value) {
          var amount = new _bignumber["default"](value).times(ONE);
          return _jsXdr.Hyper.fromString(amount.toString());
        }
        /**
         * @private
         * @param {string|BigNumber} value XDR amount
         * @returns {BigNumber} Number
         */
      }, {
        key: "_fromXDRAmount",
        value: function _fromXDRAmount(value) {
          return new _bignumber["default"](value).div(ONE).toFixed(7);
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {BigNumber} Big string
         */
      }, {
        key: "_fromXDRPrice",
        value: function _fromXDRPrice(price) {
          var n = new _bignumber["default"](price.n());
          return n.div(new _bignumber["default"](price.d())).toString();
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {object} XDR price object
         */
      }, {
        key: "_toXDRPrice",
        value: function _toXDRPrice(price) {
          var xdrObject;
          if (price.n && price.d) {
            xdrObject = new _xdr["default"].Price(price);
          } else {
            var approx = (0, _continued_fraction.best_r)(price);
            xdrObject = new _xdr["default"].Price({
              n: parseInt(approx[0], 10),
              d: parseInt(approx[1], 10)
            });
          }
          if (xdrObject.n() < 0 || xdrObject.d() < 0) {
            throw new Error("price must be positive");
          }
          return xdrObject;
        }
      }]);
    }();
    function extractRevokeSponshipDetails(attrs, result) {
      switch (attrs["switch"]().name) {
        case "revokeSponsorshipLedgerEntry": {
          var ledgerKey = attrs.ledgerKey();
          switch (ledgerKey["switch"]().name) {
            case _xdr["default"].LedgerEntryType.account().name: {
              result.type = "revokeAccountSponsorship";
              result.account = accountIdtoAddress(ledgerKey.account().accountId());
              break;
            }
            case _xdr["default"].LedgerEntryType.trustline().name: {
              result.type = "revokeTrustlineSponsorship";
              result.account = accountIdtoAddress(ledgerKey.trustLine().accountId());
              var xdrAsset = ledgerKey.trustLine().asset();
              switch (xdrAsset["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.asset = _liquidity_pool_id.LiquidityPoolId.fromOperation(xdrAsset);
                  break;
                default:
                  result.asset = _asset.Asset.fromOperation(xdrAsset);
                  break;
              }
              break;
            }
            case _xdr["default"].LedgerEntryType.offer().name: {
              result.type = "revokeOfferSponsorship";
              result.seller = accountIdtoAddress(ledgerKey.offer().sellerId());
              result.offerId = ledgerKey.offer().offerId().toString();
              break;
            }
            case _xdr["default"].LedgerEntryType.data().name: {
              result.type = "revokeDataSponsorship";
              result.account = accountIdtoAddress(ledgerKey.data().accountId());
              result.name = ledgerKey.data().dataName().toString("ascii");
              break;
            }
            case _xdr["default"].LedgerEntryType.claimableBalance().name: {
              result.type = "revokeClaimableBalanceSponsorship";
              result.balanceId = ledgerKey.claimableBalance().balanceId().toXDR("hex");
              break;
            }
            case _xdr["default"].LedgerEntryType.liquidityPool().name: {
              result.type = "revokeLiquidityPoolSponsorship";
              result.liquidityPoolId = ledgerKey.liquidityPool().liquidityPoolId().toString("hex");
              break;
            }
            default: {
              throw new Error("Unknown ledgerKey: ".concat(attrs["switch"]().name));
            }
          }
          break;
        }
        case "revokeSponsorshipSigner": {
          result.type = "revokeSignerSponsorship";
          result.account = accountIdtoAddress(attrs.signer().accountId());
          result.signer = convertXDRSignerKeyToObject(attrs.signer().signerKey());
          break;
        }
        default: {
          throw new Error("Unknown revokeSponsorship: ".concat(attrs["switch"]().name));
        }
      }
    }
    function convertXDRSignerKeyToObject(signerKey) {
      var attrs = {};
      switch (signerKey["switch"]().name) {
        case _xdr["default"].SignerKeyType.signerKeyTypeEd25519().name: {
          attrs.ed25519PublicKey = _strkey.StrKey.encodeEd25519PublicKey(signerKey.ed25519());
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx().name: {
          attrs.preAuthTx = signerKey.preAuthTx().toString("hex");
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypeHashX().name: {
          attrs.sha256Hash = signerKey.hashX().toString("hex");
          break;
        }
        default: {
          throw new Error("Unknown signerKey: ".concat(signerKey["switch"]().name));
        }
      }
      return attrs;
    }
    function accountIdtoAddress(accountId) {
      return _strkey.StrKey.encodeEd25519PublicKey(accountId.ed25519());
    }
    Operation2.accountMerge = ops.accountMerge;
    Operation2.allowTrust = ops.allowTrust;
    Operation2.bumpSequence = ops.bumpSequence;
    Operation2.changeTrust = ops.changeTrust;
    Operation2.createAccount = ops.createAccount;
    Operation2.createClaimableBalance = ops.createClaimableBalance;
    Operation2.claimClaimableBalance = ops.claimClaimableBalance;
    Operation2.clawbackClaimableBalance = ops.clawbackClaimableBalance;
    Operation2.createPassiveSellOffer = ops.createPassiveSellOffer;
    Operation2.inflation = ops.inflation;
    Operation2.manageData = ops.manageData;
    Operation2.manageSellOffer = ops.manageSellOffer;
    Operation2.manageBuyOffer = ops.manageBuyOffer;
    Operation2.pathPaymentStrictReceive = ops.pathPaymentStrictReceive;
    Operation2.pathPaymentStrictSend = ops.pathPaymentStrictSend;
    Operation2.payment = ops.payment;
    Operation2.setOptions = ops.setOptions;
    Operation2.beginSponsoringFutureReserves = ops.beginSponsoringFutureReserves;
    Operation2.endSponsoringFutureReserves = ops.endSponsoringFutureReserves;
    Operation2.revokeAccountSponsorship = ops.revokeAccountSponsorship;
    Operation2.revokeTrustlineSponsorship = ops.revokeTrustlineSponsorship;
    Operation2.revokeOfferSponsorship = ops.revokeOfferSponsorship;
    Operation2.revokeDataSponsorship = ops.revokeDataSponsorship;
    Operation2.revokeClaimableBalanceSponsorship = ops.revokeClaimableBalanceSponsorship;
    Operation2.revokeLiquidityPoolSponsorship = ops.revokeLiquidityPoolSponsorship;
    Operation2.revokeSignerSponsorship = ops.revokeSignerSponsorship;
    Operation2.clawback = ops.clawback;
    Operation2.setTrustLineFlags = ops.setTrustLineFlags;
    Operation2.liquidityPoolDeposit = ops.liquidityPoolDeposit;
    Operation2.liquidityPoolWithdraw = ops.liquidityPoolWithdraw;
    Operation2.invokeHostFunction = ops.invokeHostFunction;
    Operation2.extendFootprintTtl = ops.extendFootprintTtl;
    Operation2.restoreFootprint = ops.restoreFootprint;
    Operation2.createStellarAssetContract = ops.createStellarAssetContract;
    Operation2.invokeContractFunction = ops.invokeContractFunction;
    Operation2.createCustomContract = ops.createCustomContract;
    Operation2.uploadContractWasm = ops.uploadContractWasm;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/memo.js
var require_memo2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/memo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MemoText = exports.MemoReturn = exports.MemoNone = exports.MemoID = exports.MemoHash = exports.Memo = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber3());
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MemoNone = exports.MemoNone = "none";
    var MemoID = exports.MemoID = "id";
    var MemoText = exports.MemoText = "text";
    var MemoHash = exports.MemoHash = "hash";
    var MemoReturn = exports.MemoReturn = "return";
    var Memo = exports.Memo = function() {
      function Memo2(type) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Memo2);
        this._type = type;
        this._value = value;
        switch (this._type) {
          case MemoNone:
            break;
          case MemoID:
            Memo2._validateIdValue(value);
            break;
          case MemoText:
            Memo2._validateTextValue(value);
            break;
          case MemoHash:
          case MemoReturn:
            Memo2._validateHashValue(value);
            if (typeof value === "string") {
              this._value = Buffer.from(value, "hex");
            }
            break;
          default:
            throw new Error("Invalid memo type");
        }
      }
      return _createClass(Memo2, [{
        key: "type",
        get: function get() {
          return this._type;
        },
        set: function set(type) {
          throw new Error("Memo is immutable");
        }
        /**
         * Contains memo value:
         * * `null` for `MemoNone`,
         * * `string` for `MemoID`,
         * * `Buffer` for `MemoText` after decoding using `fromXDRObject`, original value otherwise,
         * * `Buffer` for `MemoHash`, `MemoReturn`.
         */
      }, {
        key: "value",
        get: function get() {
          switch (this._type) {
            case MemoNone:
              return null;
            case MemoID:
            case MemoText:
              return this._value;
            case MemoHash:
            case MemoReturn:
              return Buffer.from(this._value);
            default:
              throw new Error("Invalid memo type");
          }
        },
        set: function set(value) {
          throw new Error("Memo is immutable");
        }
      }, {
        key: "toXDRObject",
        value: (
          /**
           * Returns XDR memo object.
           * @returns {xdr.Memo}
           */
          function toXDRObject() {
            switch (this._type) {
              case MemoNone:
                return _xdr["default"].Memo.memoNone();
              case MemoID:
                return _xdr["default"].Memo.memoId(_jsXdr.UnsignedHyper.fromString(this._value));
              case MemoText:
                return _xdr["default"].Memo.memoText(this._value);
              case MemoHash:
                return _xdr["default"].Memo.memoHash(this._value);
              case MemoReturn:
                return _xdr["default"].Memo.memoReturn(this._value);
              default:
                return null;
            }
          }
        )
        /**
         * Returns {@link Memo} from XDR memo object.
         * @param {xdr.Memo} object XDR memo object
         * @returns {Memo}
         */
      }], [{
        key: "_validateIdValue",
        value: function _validateIdValue(value) {
          var error = new Error("Expects a int64 as a string. Got ".concat(value));
          if (typeof value !== "string") {
            throw error;
          }
          var number;
          try {
            number = new _bignumber["default"](value);
          } catch (e) {
            throw error;
          }
          if (!number.isFinite()) {
            throw error;
          }
          if (number.isNaN()) {
            throw error;
          }
        }
      }, {
        key: "_validateTextValue",
        value: function _validateTextValue(value) {
          if (!_xdr["default"].Memo.armTypeForArm("text").isValid(value)) {
            throw new Error("Expects string, array or buffer, max 28 bytes");
          }
        }
      }, {
        key: "_validateHashValue",
        value: function _validateHashValue(value) {
          var error = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(value));
          if (value === null || typeof value === "undefined") {
            throw error;
          }
          var valueBuffer;
          if (typeof value === "string") {
            if (!/^[0-9A-Fa-f]{64}$/g.test(value)) {
              throw error;
            }
            valueBuffer = Buffer.from(value, "hex");
          } else if (Buffer.isBuffer(value)) {
            valueBuffer = Buffer.from(value);
          } else {
            throw error;
          }
          if (!valueBuffer.length || valueBuffer.length !== 32) {
            throw error;
          }
        }
        /**
         * Returns an empty memo (`MemoNone`).
         * @returns {Memo}
         */
      }, {
        key: "none",
        value: function none() {
          return new Memo2(MemoNone);
        }
        /**
         * Creates and returns a `MemoText` memo.
         * @param {string} text - memo text
         * @returns {Memo}
         */
      }, {
        key: "text",
        value: function text(_text) {
          return new Memo2(MemoText, _text);
        }
        /**
         * Creates and returns a `MemoID` memo.
         * @param {string} id - 64-bit number represented as a string
         * @returns {Memo}
         */
      }, {
        key: "id",
        value: function id(_id) {
          return new Memo2(MemoID, _id);
        }
        /**
         * Creates and returns a `MemoHash` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "hash",
        value: function hash2(_hash) {
          return new Memo2(MemoHash, _hash);
        }
        /**
         * Creates and returns a `MemoReturn` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "return",
        value: function _return(hash2) {
          return new Memo2(MemoReturn, hash2);
        }
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(object) {
          switch (object.arm()) {
            case "id":
              return Memo2.id(object.value().toString());
            case "text":
              return Memo2.text(object.value());
            case "hash":
              return Memo2.hash(object.value());
            case "retHash":
              return Memo2["return"](object.value());
            default:
              break;
          }
          if (typeof object.value() === "undefined") {
            return Memo2.none();
          }
          throw new Error("Unknown type");
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/transaction.js
var require_transaction3 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/transaction.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _hashing = require_hashing2();
    var _strkey = require_strkey2();
    var _operation = require_operation2();
    var _memo = require_memo2();
    var _transaction_base = require_transaction_base2();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Transaction = exports.Transaction = function(_TransactionBase) {
      function Transaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, Transaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (!(envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0() || envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTx())) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, Transaction2, [tx, signatures, fee, networkPassphrase]);
        _this._envelopeType = envelopeType;
        _this._memo = tx.memo();
        _this._sequence = tx.seqNum().toString();
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            _this._source = _strkey.StrKey.encodeEd25519PublicKey(_this.tx.sourceAccountEd25519());
            break;
          default:
            _this._source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.sourceAccount());
            break;
        }
        var cond = null;
        var timeBounds = null;
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            timeBounds = tx.timeBounds();
            break;
          case _xdr["default"].EnvelopeType.envelopeTypeTx():
            switch (tx.cond()["switch"]()) {
              case _xdr["default"].PreconditionType.precondTime():
                timeBounds = tx.cond().timeBounds();
                break;
              case _xdr["default"].PreconditionType.precondV2():
                cond = tx.cond().v2();
                timeBounds = cond.timeBounds();
                break;
              default:
                break;
            }
            break;
          default:
            break;
        }
        if (timeBounds) {
          _this._timeBounds = {
            minTime: timeBounds.minTime().toString(),
            maxTime: timeBounds.maxTime().toString()
          };
        }
        if (cond) {
          var ledgerBounds = cond.ledgerBounds();
          if (ledgerBounds) {
            _this._ledgerBounds = {
              minLedger: ledgerBounds.minLedger(),
              maxLedger: ledgerBounds.maxLedger()
            };
          }
          var minSeq = cond.minSeqNum();
          if (minSeq) {
            _this._minAccountSequence = minSeq.toString();
          }
          _this._minAccountSequenceAge = cond.minSeqAge();
          _this._minAccountSequenceLedgerGap = cond.minSeqLedgerGap();
          _this._extraSigners = cond.extraSigners();
        }
        var operations = tx.operations() || [];
        _this._operations = operations.map(function(op) {
          return _operation.Operation.fromXDRObject(op);
        });
        return _this;
      }
      _inherits(Transaction2, _TransactionBase);
      return _createClass(Transaction2, [{
        key: "timeBounds",
        get: function get() {
          return this._timeBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {object}
         * @property {number} minLedger - smallest ledger bound (uint32)
         * @property {number} maxLedger - largest ledger bound (or 0 for inf)
         * @readonly
         */
      }, {
        key: "ledgerBounds",
        get: function get() {
          return this._ledgerBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit account sequence
         * @readonly
         * @type {string}
         */
      }, {
        key: "minAccountSequence",
        get: function get() {
          return this._minAccountSequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit number of seconds
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceAge",
        get: function get() {
          return this._minAccountSequenceAge;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 32 bit number of ledgers
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceLedgerGap",
        get: function get() {
          return this._minAccountSequenceLedgerGap;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * array of extra signers ({@link StrKey}s)
         * @type {string[]}
         * @readonly
         */
      }, {
        key: "extraSigners",
        get: function get() {
          return this._extraSigners;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "sequence",
        get: function get() {
          return this._sequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "source",
        get: function get() {
          return this._source;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {Array.<xdr.Operation>}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._operations;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "memo",
        get: function get() {
          return _memo.Memo.fromXDRObject(this._memo);
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var tx = this.tx;
          if (this._envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            tx = _xdr["default"].Transaction.fromXDR(Buffer.concat([
              // TransactionV0 is a transaction with the AccountID discriminant
              // stripped off, we need to put it back to build a valid transaction
              // which we can use to build a TransactionSignaturePayloadTaggedTransaction
              _xdr["default"].PublicKeyType.publicKeyTypeEd25519().toXDR(),
              tx.toXDR()
            ]));
          }
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var rawTx = this.tx.toXDR();
          var signatures = this.signatures.slice();
          var envelope;
          switch (this._envelopeType) {
            case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxV0(new _xdr["default"].TransactionV0Envelope({
                tx: _xdr["default"].TransactionV0.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            case _xdr["default"].EnvelopeType.envelopeTypeTx():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                tx: _xdr["default"].Transaction.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            default:
              throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
          }
          return envelope;
        }
        /**
         * Calculate the claimable balance ID for an operation within the transaction.
         *
         * @param   {integer}  opIndex   the index of the CreateClaimableBalance op
         * @returns {string}   a hex string representing the claimable balance ID
         *
         * @throws {RangeError}   for invalid `opIndex` value
         * @throws {TypeError}    if op at `opIndex` is not `CreateClaimableBalance`
         * @throws for general XDR un/marshalling failures
         *
         * @see https://github.com/stellar/go/blob/d712346e61e288d450b0c08038c158f8848cc3e4/txnbuild/transaction.go#L392-L435
         *
         */
      }, {
        key: "getClaimableBalanceId",
        value: function getClaimableBalanceId(opIndex) {
          if (!Number.isInteger(opIndex) || opIndex < 0 || opIndex >= this.operations.length) {
            throw new RangeError("invalid operation index");
          }
          var op = this.operations[opIndex];
          try {
            op = _operation.Operation.createClaimableBalance(op);
          } catch (err) {
            throw new TypeError("expected createClaimableBalance, got ".concat(op.type, ": ").concat(err));
          }
          var account = _strkey.StrKey.decodeEd25519PublicKey((0, _decode_encode_muxed_account.extractBaseAddress)(this.source));
          var operationId = _xdr["default"].HashIdPreimage.envelopeTypeOpId(new _xdr["default"].HashIdPreimageOperationId({
            sourceAccount: _xdr["default"].AccountId.publicKeyTypeEd25519(account),
            seqNum: _xdr["default"].SequenceNumber.fromString(this.sequence),
            opNum: opIndex
          }));
          var opIdHash = (0, _hashing.hash)(operationId.toXDR("raw"));
          var balanceId = _xdr["default"].ClaimableBalanceId.claimableBalanceIdTypeV0(opIdHash);
          return balanceId.toXDR("hex");
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js
var require_fee_bump_transaction2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FeeBumpTransaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _hashing = require_hashing2();
    var _transaction = require_transaction3();
    var _transaction_base = require_transaction_base2();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var FeeBumpTransaction = exports.FeeBumpTransaction = function(_TransactionBase) {
      function FeeBumpTransaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, FeeBumpTransaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (envelopeType !== _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, FeeBumpTransaction2, [tx, signatures, fee, networkPassphrase]);
        var innerTxEnvelope = _xdr["default"].TransactionEnvelope.envelopeTypeTx(tx.innerTx().v1());
        _this._feeSource = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.feeSource());
        _this._innerTransaction = new _transaction.Transaction(innerTxEnvelope, networkPassphrase);
        return _this;
      }
      _inherits(FeeBumpTransaction2, _TransactionBase);
      return _createClass(FeeBumpTransaction2, [{
        key: "innerTransaction",
        get: function get() {
          return this._innerTransaction;
        }
        /**
         * @type {Operation[]}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._innerTransaction.operations;
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "feeSource",
        get: function get() {
          return this._feeSource;
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var envelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx: _xdr["default"].FeeBumpTransaction.fromXDR(this.tx.toXDR()),
            // make a copy of the tx
            signatures: this.signatures.slice()
            // make a copy of the signatures
          });
          return new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(envelope);
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/account.js
var require_account2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Account = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber3());
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Account = exports.Account = function() {
      function Account2(accountId, sequence) {
        _classCallCheck(this, Account2);
        if (_strkey.StrKey.isValidMed25519PublicKey(accountId)) {
          throw new Error("accountId is an M-address; use MuxedAccount instead");
        }
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        if (!(typeof sequence === "string")) {
          throw new Error("sequence must be of type string");
        }
        this._accountId = accountId;
        this.sequence = new _bignumber["default"](sequence);
      }
      return _createClass(Account2, [{
        key: "accountId",
        value: function accountId() {
          return this._accountId;
        }
        /**
         * @returns {string}  sequence number for the account as a string
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.sequence.toString();
        }
        /**
         * Increments sequence number in this object by one.
         * @returns {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          this.sequence = this.sequence.plus(1);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/muxed_account.js
var require_muxed_account2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/muxed_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MuxedAccount = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _account = require_account2();
    var _strkey = require_strkey2();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MuxedAccount = exports.MuxedAccount = function() {
      function MuxedAccount2(baseAccount, id) {
        _classCallCheck(this, MuxedAccount2);
        var accountId = baseAccount.accountId();
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        this.account = baseAccount;
        this._muxedXdr = (0, _decode_encode_muxed_account.encodeMuxedAccount)(accountId, id);
        this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
        this._id = id;
      }
      return _createClass(MuxedAccount2, [{
        key: "baseAccount",
        value: (
          /**
           * @return {Account} the underlying account object shared among all muxed
           *     accounts with this Stellar address
           */
          function baseAccount() {
            return this.account;
          }
        )
        /**
         * @return {string} the M-address representing this account's (G-address, ID)
         */
      }, {
        key: "accountId",
        value: function accountId() {
          return this._mAddress;
        }
      }, {
        key: "id",
        value: function id() {
          return this._id;
        }
      }, {
        key: "setId",
        value: function setId(id) {
          if (typeof id !== "string") {
            throw new Error("id should be a string representing a number (uint64)");
          }
          this._muxedXdr.med25519().id(_xdr["default"].Uint64.fromString(id));
          this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
          this._id = id;
          return this;
        }
        /**
         * Accesses the underlying account's sequence number.
         * @return {string}  strigified sequence number for the underlying account
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.account.sequenceNumber();
        }
        /**
         * Increments the underlying account's sequence number by one.
         * @return {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          return this.account.incrementSequenceNumber();
        }
        /**
         * @return {xdr.MuxedAccount} the XDR object representing this muxed account's
         *     G-address and uint64 ID
         */
      }, {
        key: "toXDRObject",
        value: function toXDRObject() {
          return this._muxedXdr;
        }
      }, {
        key: "equals",
        value: function equals(otherMuxedAccount) {
          return this.accountId() === otherMuxedAccount.accountId();
        }
      }], [{
        key: "fromAddress",
        value: function fromAddress(mAddress, sequenceNum) {
          var muxedAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(mAddress);
          var gAddress = (0, _decode_encode_muxed_account.extractBaseAddress)(mAddress);
          var id = muxedAccount.med25519().id().toString();
          return new MuxedAccount2(new _account.Account(gAddress, sequenceNum), id);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js
var require_sorobandata_builder2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SorobanDataBuilder = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SorobanDataBuilder = exports.SorobanDataBuilder = function() {
      function SorobanDataBuilder2(sorobanData) {
        _classCallCheck(this, SorobanDataBuilder2);
        _defineProperty(this, "_data", void 0);
        var data;
        if (!sorobanData) {
          data = new _xdr["default"].SorobanTransactionData({
            resources: new _xdr["default"].SorobanResources({
              footprint: new _xdr["default"].LedgerFootprint({
                readOnly: [],
                readWrite: []
              }),
              instructions: 0,
              readBytes: 0,
              writeBytes: 0
            }),
            ext: new _xdr["default"].ExtensionPoint(0),
            resourceFee: new _xdr["default"].Int64(0)
          });
        } else if (typeof sorobanData === "string" || ArrayBuffer.isView(sorobanData)) {
          data = SorobanDataBuilder2.fromXDR(sorobanData);
        } else {
          data = SorobanDataBuilder2.fromXDR(sorobanData.toXDR());
        }
        this._data = data;
      }
      return _createClass(SorobanDataBuilder2, [{
        key: "setResourceFee",
        value: (
          /**
           * Sets the resource fee portion of the Soroban data.
           * @param {number | bigint | string} fee  the resource fee to set (int64)
           * @returns {SorobanDataBuilder}
           */
          function setResourceFee(fee) {
            this._data.resourceFee(new _xdr["default"].Int64(fee));
            return this;
          }
        )
        /**
         * Sets up the resource metrics.
         *
         * You should almost NEVER need this, as its often generated / provided to you
         * by transaction simulation/preflight from a Soroban RPC server.
         *
         * @param {number} cpuInstrs      number of CPU instructions
         * @param {number} readBytes      number of bytes being read
         * @param {number} writeBytes     number of bytes being written
         *
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setResources",
        value: function setResources(cpuInstrs, readBytes, writeBytes) {
          this._data.resources().instructions(cpuInstrs);
          this._data.resources().readBytes(readBytes);
          this._data.resources().writeBytes(writeBytes);
          return this;
        }
        /**
         * Appends the given ledger keys to the existing storage access footprint.
         * @param {xdr.LedgerKey[]} readOnly   read-only keys to add
         * @param {xdr.LedgerKey[]} readWrite  read-write keys to add
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "appendFootprint",
        value: function appendFootprint(readOnly, readWrite) {
          return this.setFootprint(this.getReadOnly().concat(readOnly), this.getReadWrite().concat(readWrite));
        }
        /**
         * Sets the storage access footprint to be a certain set of ledger keys.
         *
         * You can also set each field explicitly via
         * {@link SorobanDataBuilder.setReadOnly} and
         * {@link SorobanDataBuilder.setReadWrite} or add to the existing footprint
         * via {@link SorobanDataBuilder.appendFootprint}.
         *
         * Passing `null|undefined` to either parameter will IGNORE the existing
         * values. If you want to clear them, pass `[]`, instead.
         *
         * @param {xdr.LedgerKey[]|null} [readOnly]   the set of ledger keys to set in
         *    the read-only portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @param {xdr.LedgerKey[]|null} [readWrite]  the set of ledger keys to set in
         *    the read-write portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "setFootprint",
        value: function setFootprint(readOnly, readWrite) {
          if (readOnly !== null) {
            this.setReadOnly(readOnly);
          }
          if (readWrite !== null) {
            this.setReadWrite(readWrite);
          }
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readOnly  read-only keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadOnly",
        value: function setReadOnly(readOnly) {
          this._data.resources().footprint().readOnly(readOnly !== null && readOnly !== void 0 ? readOnly : []);
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readWrite  read-write keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadWrite",
        value: function setReadWrite(readWrite) {
          this._data.resources().footprint().readWrite(readWrite !== null && readWrite !== void 0 ? readWrite : []);
          return this;
        }
        /**
         * @returns {xdr.SorobanTransactionData} a copy of the final data structure
         */
      }, {
        key: "build",
        value: function build() {
          return _xdr["default"].SorobanTransactionData.fromXDR(this._data.toXDR());
        }
        //
        // getters follow
        //
        /** @returns {xdr.LedgerKey[]} the read-only storage access pattern */
      }, {
        key: "getReadOnly",
        value: function getReadOnly() {
          return this.getFootprint().readOnly();
        }
        /** @returns {xdr.LedgerKey[]} the read-write storage access pattern */
      }, {
        key: "getReadWrite",
        value: function getReadWrite() {
          return this.getFootprint().readWrite();
        }
        /** @returns {xdr.LedgerFootprint} the storage access pattern */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return this._data.resources().footprint();
        }
      }], [{
        key: "fromXDR",
        value: function fromXDR(data) {
          return _xdr["default"].SorobanTransactionData.fromXDR(data, typeof data === "string" ? "base64" : "raw");
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/signerkey.js
var require_signerkey2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/signerkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SignerKey = void 0;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SignerKey2 = exports.SignerKey = function() {
      function SignerKey3() {
        _classCallCheck(this, SignerKey3);
      }
      return _createClass(SignerKey3, null, [{
        key: "decodeAddress",
        value: (
          /**
           * Decodes a StrKey address into an xdr.SignerKey instance.
           *
           * Only ED25519 public keys (G...), pre-auth transactions (T...), hashes
           * (H...), and signed payloads (P...) can be signer keys.
           *
           * @param   {string} address  a StrKey-encoded signer address
           * @returns {xdr.SignerKey}
           */
          function decodeAddress(address) {
            var signerKeyMap = {
              ed25519PublicKey: _xdr["default"].SignerKey.signerKeyTypeEd25519,
              preAuthTx: _xdr["default"].SignerKey.signerKeyTypePreAuthTx,
              sha256Hash: _xdr["default"].SignerKey.signerKeyTypeHashX,
              signedPayload: _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload
            };
            var vb = _strkey.StrKey.getVersionByteForPrefix(address);
            var encoder = signerKeyMap[vb];
            if (!encoder) {
              throw new Error("invalid signer key type (".concat(vb, ")"));
            }
            var raw = (0, _strkey.decodeCheck)(vb, address);
            switch (vb) {
              case "signedPayload":
                return encoder(new _xdr["default"].SignerKeyEd25519SignedPayload({
                  ed25519: raw.slice(0, 32),
                  payload: raw.slice(32 + 4)
                }));
              case "ed25519PublicKey":
              case "preAuthTx":
              case "sha256Hash":
              default:
                return encoder(raw);
            }
          }
        )
        /**
         * Encodes a signer key into its StrKey equivalent.
         *
         * @param   {xdr.SignerKey} signerKey   the signer
         * @returns {string} the StrKey representation of the signer
         */
      }, {
        key: "encodeSignerKey",
        value: function encodeSignerKey(signerKey) {
          var strkeyType;
          var raw;
          switch (signerKey["switch"]()) {
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519():
              strkeyType = "ed25519PublicKey";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx():
              strkeyType = "preAuthTx";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeHashX():
              strkeyType = "sha256Hash";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519SignedPayload():
              strkeyType = "signedPayload";
              raw = signerKey.ed25519SignedPayload().toXDR("raw");
              break;
            default:
              throw new Error("invalid SignerKey (type: ".concat(signerKey["switch"](), ")"));
          }
          return (0, _strkey.encodeCheck)(strkeyType, raw);
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/transaction_builder.js
var require_transaction_builder2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/transaction_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = void 0;
    exports.isValidDate = isValidDate;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber3());
    var _xdr = _interopRequireDefault(require_xdr3());
    var _account = require_account2();
    var _muxed_account = require_muxed_account2();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    var _transaction = require_transaction3();
    var _fee_bump_transaction = require_fee_bump_transaction2();
    var _sorobandata_builder = require_sorobandata_builder2();
    var _strkey = require_strkey2();
    var _signerkey = require_signerkey2();
    var _memo = require_memo2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var BASE_FEE = exports.BASE_FEE = "100";
    var TimeoutInfinite = exports.TimeoutInfinite = 0;
    var TransactionBuilder2 = exports.TransactionBuilder = function() {
      function TransactionBuilder3(sourceAccount) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, TransactionBuilder3);
        if (!sourceAccount) {
          throw new Error("must specify source account for the transaction");
        }
        if (opts.fee === void 0) {
          throw new Error("must specify fee for the transaction (in stroops)");
        }
        this.source = sourceAccount;
        this.operations = [];
        this.baseFee = opts.fee;
        this.timebounds = opts.timebounds ? _objectSpread({}, opts.timebounds) : null;
        this.ledgerbounds = opts.ledgerbounds ? _objectSpread({}, opts.ledgerbounds) : null;
        this.minAccountSequence = opts.minAccountSequence || null;
        this.minAccountSequenceAge = opts.minAccountSequenceAge || null;
        this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;
        this.extraSigners = opts.extraSigners ? _toConsumableArray(opts.extraSigners) : null;
        this.memo = opts.memo || _memo.Memo.none();
        this.networkPassphrase = opts.networkPassphrase || null;
        this.sorobanData = opts.sorobanData ? new _sorobandata_builder.SorobanDataBuilder(opts.sorobanData).build() : null;
      }
      return _createClass(TransactionBuilder3, [{
        key: "addOperation",
        value: (
          /**
           * Adds an operation to the transaction.
           *
           * @param {xdr.Operation} operation   The xdr operation object, use {@link
           *     Operation} static methods.
           *
           * @returns {TransactionBuilder}
           */
          function addOperation(operation) {
            this.operations.push(operation);
            return this;
          }
        )
        /**
         * Adds an operation to the transaction at a specific index.
         *
         * @param {xdr.Operation} operation - The xdr operation object to add, use {@link Operation} static methods.
         * @param {number} index - The index at which to insert the operation.
         *
         * @returns {TransactionBuilder} - The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "addOperationAt",
        value: function addOperationAt(operation, index) {
          this.operations.splice(index, 0, operation);
          return this;
        }
        /**
         * Removes the operations from the builder (useful when cloning).
         * @returns {TransactionBuilder} this builder instance
         */
      }, {
        key: "clearOperations",
        value: function clearOperations() {
          this.operations = [];
          return this;
        }
        /**
         * Removes the operation at the specified index from the transaction.
         *
         * @param {number} index - The index of the operation to remove.
         *
         * @returns {TransactionBuilder} The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "clearOperationAt",
        value: function clearOperationAt(index) {
          this.operations.splice(index, 1);
          return this;
        }
        /**
         * Adds a memo to the transaction.
         * @param {Memo} memo {@link Memo} object
         * @returns {TransactionBuilder}
         */
      }, {
        key: "addMemo",
        value: function addMemo(memo) {
          this.memo = memo;
          return this;
        }
        /**
         * Sets a timeout precondition on the transaction.
         *
         *  Because of the distributed nature of the Stellar network it is possible
         *  that the status of your transaction will be determined after a long time
         *  if the network is highly congested. If you want to be sure to receive the
         *  status of the transaction within a given period you should set the {@link
         *  TimeBounds} with `maxTime` on the transaction (this is what `setTimeout`
         *  does internally; if there's `minTime` set but no `maxTime` it will be
         *  added).
         *
         *  A call to `TransactionBuilder.setTimeout` is **required** if Transaction
         *  does not have `max_time` set. If you don't want to set timeout, use
         *  `{@link TimeoutInfinite}`. In general you should set `{@link
         *  TimeoutInfinite}` only in smart contracts.
         *
         *  Please note that Horizon may still return <code>504 Gateway Timeout</code>
         *  error, even for short timeouts. In such case you need to resubmit the same
         *  transaction again without making any changes to receive a status. This
         *  method is using the machine system time (UTC), make sure it is set
         *  correctly.
         *
         * @param {number} timeoutSeconds   Number of seconds the transaction is good.
         *     Can't be negative. If the value is {@link TimeoutInfinite}, the
         *     transaction is good indefinitely.
         *
         * @returns {TransactionBuilder}
         *
         * @see {@link TimeoutInfinite}
         * @see https://developers.stellar.org/docs/tutorials/handling-errors/
         */
      }, {
        key: "setTimeout",
        value: function setTimeout2(timeoutSeconds) {
          if (this.timebounds !== null && this.timebounds.maxTime > 0) {
            throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
          }
          if (timeoutSeconds < 0) {
            throw new Error("timeout cannot be negative");
          }
          if (timeoutSeconds > 0) {
            var timeoutTimestamp = Math.floor(Date.now() / 1e3) + timeoutSeconds;
            if (this.timebounds === null) {
              this.timebounds = {
                minTime: 0,
                maxTime: timeoutTimestamp
              };
            } else {
              this.timebounds = {
                minTime: this.timebounds.minTime,
                maxTime: timeoutTimestamp
              };
            }
          } else {
            this.timebounds = {
              minTime: 0,
              maxTime: 0
            };
          }
          return this;
        }
        /**
         * If you want to prepare a transaction which will become valid at some point
         * in the future, or be invalid after some time, you can set a timebounds
         * precondition. Internally this will set the `minTime`, and `maxTime`
         * preconditions. Conflicts with `setTimeout`, so use one or the other.
         *
         * @param {Date|number} minEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid after this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     immediately.
         * @param {Date|number} maxEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid until this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setTimebounds",
        value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {
          if (typeof minEpochOrDate === "number") {
            minEpochOrDate = new Date(minEpochOrDate * 1e3);
          }
          if (typeof maxEpochOrDate === "number") {
            maxEpochOrDate = new Date(maxEpochOrDate * 1e3);
          }
          if (this.timebounds !== null) {
            throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
          }
          var minTime = Math.floor(minEpochOrDate.valueOf() / 1e3);
          var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1e3);
          if (minTime < 0) {
            throw new Error("min_time cannot be negative");
          }
          if (maxTime < 0) {
            throw new Error("max_time cannot be negative");
          }
          if (maxTime > 0 && minTime > maxTime) {
            throw new Error("min_time cannot be greater than max_time");
          }
          this.timebounds = {
            minTime,
            maxTime
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will only be valid within some
         * range of ledgers, you can set a ledgerbounds precondition.
         * Internally this will set the `minLedger` and `maxLedger` preconditions.
         *
         * @param {number} minLedger  The minimum ledger this transaction is valid at
         *     or after. Cannot be negative. If the value is `0` (the default), the
         *     transaction is valid immediately.
         *
         * @param {number} maxLedger  The maximum ledger this transaction is valid
         *     before. Cannot be negative. If the value is `0`, the transaction is
         *     valid indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setLedgerbounds",
        value: function setLedgerbounds(minLedger, maxLedger) {
          if (this.ledgerbounds !== null) {
            throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
          }
          if (minLedger < 0) {
            throw new Error("min_ledger cannot be negative");
          }
          if (maxLedger < 0) {
            throw new Error("max_ledger cannot be negative");
          }
          if (maxLedger > 0 && minLedger > maxLedger) {
            throw new Error("min_ledger cannot be greater than max_ledger");
          }
          this.ledgerbounds = {
            minLedger,
            maxLedger
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will be valid only while the
         * account sequence number is
         *
         *     minAccountSequence <= sourceAccountSequence < tx.seqNum
         *
         * Note that after execution the account's sequence number is always raised to
         * `tx.seqNum`. Internally this will set the `minAccountSequence`
         * precondition.
         *
         * @param {string} minAccountSequence   The minimum source account sequence
         *     number this transaction is valid for. If the value is `0` (the
         *     default), the transaction is valid when `sourceAccount's sequence
         *     number == tx.seqNum- 1`.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequence",
        value: function setMinAccountSequence(minAccountSequence) {
          if (this.minAccountSequence !== null) {
            throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
          }
          this.minAccountSequence = minAccountSequence;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger time must be at least
         * `minAccountSequenceAge` greater than sourceAccount's `sequenceTime`.
         * Internally this will set the `minAccountSequenceAge` precondition.
         *
         * @param {number} durationInSeconds  The minimum amount of time between
         *     source account sequence time and the ledger time when this transaction
         *     will become valid. If the value is `0`, the transaction is unrestricted
         *     by the account sequence age. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceAge",
        value: function setMinAccountSequenceAge(durationInSeconds) {
          if (typeof durationInSeconds !== "number") {
            throw new Error("min_account_sequence_age must be a number");
          }
          if (this.minAccountSequenceAge !== null) {
            throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
          }
          if (durationInSeconds < 0) {
            throw new Error("min_account_sequence_age cannot be negative");
          }
          this.minAccountSequenceAge = durationInSeconds;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger number must be at least
         * `minAccountSequenceLedgerGap` greater than sourceAccount's ledger sequence.
         * Internally this will set the `minAccountSequenceLedgerGap` precondition.
         *
         * @param {number} gap  The minimum number of ledgers between source account
         *     sequence and the ledger number when this transaction will become valid.
         *     If the value is `0`, the transaction is unrestricted by the account
         *     sequence ledger. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceLedgerGap",
        value: function setMinAccountSequenceLedgerGap(gap) {
          if (this.minAccountSequenceLedgerGap !== null) {
            throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
          }
          if (gap < 0) {
            throw new Error("min_account_sequence_ledger_gap cannot be negative");
          }
          this.minAccountSequenceLedgerGap = gap;
          return this;
        }
        /**
         * For the transaction to be valid, there must be a signature corresponding to
         * every Signer in this array, even if the signature is not otherwise required
         * by the sourceAccount or operations. Internally this will set the
         * `extraSigners` precondition.
         *
         * @param {string[]} extraSigners   required extra signers (as {@link StrKey}s)
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setExtraSigners",
        value: function setExtraSigners(extraSigners) {
          if (!Array.isArray(extraSigners)) {
            throw new Error("extra_signers must be an array of strings.");
          }
          if (this.extraSigners !== null) {
            throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
          }
          if (extraSigners.length > 2) {
            throw new Error("extra_signers cannot be longer than 2 elements.");
          }
          this.extraSigners = _toConsumableArray(extraSigners);
          return this;
        }
        /**
         * Set network nassphrase for the Transaction that will be built.
         *
         * @param {string} networkPassphrase    passphrase of the target Stellar
         *     network (e.g. "Public Global Stellar Network ; September 2015").
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setNetworkPassphrase",
        value: function setNetworkPassphrase(networkPassphrase) {
          this.networkPassphrase = networkPassphrase;
          return this;
        }
        /**
         * Sets the transaction's internal Soroban transaction data (resources,
         * footprint, etc.).
         *
         * For non-contract(non-Soroban) transactions, this setting has no effect. In
         * the case of Soroban transactions, this is either an instance of
         * {@link xdr.SorobanTransactionData} or a base64-encoded string of said
         * structure. This is usually obtained from the simulation response based on a
         * transaction with a Soroban operation (e.g.
         * {@link Operation.invokeHostFunction}, providing necessary resource
         * and storage footprint estimations for contract invocation.
         *
         * @param {xdr.SorobanTransactionData | string} sorobanData    the
         *    {@link xdr.SorobanTransactionData} as a raw xdr object or a base64
         *    string to be decoded
         *
         * @returns {TransactionBuilder}
         * @see {SorobanDataBuilder}
         */
      }, {
        key: "setSorobanData",
        value: function setSorobanData(sorobanData) {
          this.sorobanData = new _sorobandata_builder.SorobanDataBuilder(sorobanData).build();
          return this;
        }
        /**
         * This will build the transaction.
         * It will also increment the source account's sequence number by 1.
         * @returns {Transaction} This method will return the built {@link Transaction}.
         */
      }, {
        key: "build",
        value: function build() {
          var sequenceNumber = new _bignumber["default"](this.source.sequenceNumber()).plus(1);
          var fee = new _bignumber["default"](this.baseFee).times(this.operations.length).toNumber();
          var attrs = {
            fee,
            seqNum: _xdr["default"].SequenceNumber.fromString(sequenceNumber.toString()),
            memo: this.memo ? this.memo.toXDRObject() : null
          };
          if (this.timebounds === null || typeof this.timebounds.minTime === "undefined" || typeof this.timebounds.maxTime === "undefined") {
            throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
          }
          if (isValidDate(this.timebounds.minTime)) {
            this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3;
          }
          if (isValidDate(this.timebounds.maxTime)) {
            this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3;
          }
          this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());
          this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
          var timeBounds = new _xdr["default"].TimeBounds(this.timebounds);
          if (this.hasV2Preconditions()) {
            var ledgerBounds = null;
            if (this.ledgerbounds !== null) {
              ledgerBounds = new _xdr["default"].LedgerBounds(this.ledgerbounds);
            }
            var minSeqNum = this.minAccountSequence || "0";
            minSeqNum = _xdr["default"].SequenceNumber.fromString(minSeqNum);
            var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0");
            var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;
            var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];
            attrs.cond = _xdr["default"].Preconditions.precondV2(new _xdr["default"].PreconditionsV2({
              timeBounds,
              ledgerBounds,
              minSeqNum,
              minSeqAge,
              minSeqLedgerGap,
              extraSigners
            }));
          } else {
            attrs.cond = _xdr["default"].Preconditions.precondTime(timeBounds);
          }
          attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());
          if (this.sorobanData) {
            attrs.ext = new _xdr["default"].TransactionExt(1, this.sorobanData);
          } else {
            attrs.ext = new _xdr["default"].TransactionExt(0, _xdr["default"].Void);
          }
          var xtx = new _xdr["default"].Transaction(attrs);
          xtx.operations(this.operations);
          var txEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
            tx: xtx
          }));
          var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);
          this.source.incrementSequenceNumber();
          return tx;
        }
      }, {
        key: "hasV2Preconditions",
        value: function hasV2Preconditions() {
          return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
        }
        /**
         * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing
         * transaction with a higher fee.
         *
         * @param {Keypair|string}  feeSource - account paying for the transaction,
         *     in the form of either a Keypair (only the public key is used) or
         *     an account ID (in G... or M... form, but refer to `withMuxing`)
         * @param {string}          baseFee   - max fee willing to pay per operation
         *     in inner transaction (**in stroops**)
         * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by
         *     the fee bump transaction
         * @param {string}          networkPassphrase - passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September 2015",
         *     see {@link Networks})
         *
         * @todo Alongside the next major version bump, this type signature can be
         *       changed to be less awkward: accept a MuxedAccount as the `feeSource`
         *       rather than a keypair or string.
         *
         * @note Your fee-bump amount should be >= 10x the original fee.
         * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee
         *
         * @returns {FeeBumpTransaction}
         */
      }], [{
        key: "cloneFrom",
        value: function cloneFrom(tx) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!(tx instanceof _transaction.Transaction)) {
            throw new TypeError("expected a 'Transaction', got: ".concat(tx));
          }
          var sequenceNum = (BigInt(tx.sequence) - 1n).toString();
          var source;
          if (_strkey.StrKey.isValidMed25519PublicKey(tx.source)) {
            source = _muxed_account.MuxedAccount.fromAddress(tx.source, sequenceNum);
          } else if (_strkey.StrKey.isValidEd25519PublicKey(tx.source)) {
            source = new _account.Account(tx.source, sequenceNum);
          } else {
            throw new TypeError("unsupported tx source account: ".concat(tx.source));
          }
          var unscaledFee = parseInt(tx.fee, 10) / tx.operations.length;
          var builder = new TransactionBuilder3(source, _objectSpread({
            fee: (unscaledFee || BASE_FEE).toString(),
            memo: tx.memo,
            networkPassphrase: tx.networkPassphrase,
            timebounds: tx.timeBounds,
            ledgerbounds: tx.ledgerBounds,
            minAccountSequence: tx.minAccountSequence,
            minAccountSequenceAge: tx.minAccountSequenceAge,
            minAccountSequenceLedgerGap: tx.minAccountSequenceLedgerGap,
            extraSigners: tx.extraSigners
          }, opts));
          tx._tx.operations().forEach(function(op) {
            return builder.addOperation(op);
          });
          return builder;
        }
      }, {
        key: "buildFeeBumpTransaction",
        value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {
          var innerOps = innerTx.operations.length;
          var innerBaseFeeRate = new _bignumber["default"](innerTx.fee).div(innerOps);
          var base = new _bignumber["default"](baseFee);
          if (base.lt(innerBaseFeeRate)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(innerBaseFeeRate, " stroops."));
          }
          var minBaseFee = new _bignumber["default"](BASE_FEE);
          if (base.lt(minBaseFee)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(minBaseFee, " stroops."));
          }
          var innerTxEnvelope = innerTx.toEnvelope();
          if (innerTxEnvelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            var v0Tx = innerTxEnvelope.v0().tx();
            var v1Tx = new _xdr["default"].Transaction({
              sourceAccount: new _xdr["default"].MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),
              fee: v0Tx.fee(),
              seqNum: v0Tx.seqNum(),
              cond: _xdr["default"].Preconditions.precondTime(v0Tx.timeBounds()),
              memo: v0Tx.memo(),
              operations: v0Tx.operations(),
              ext: new _xdr["default"].TransactionExt(0)
            });
            innerTxEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
              tx: v1Tx,
              signatures: innerTxEnvelope.v0().signatures()
            }));
          }
          var feeSourceAccount;
          if (typeof feeSource === "string") {
            feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);
          } else {
            feeSourceAccount = feeSource.xdrMuxedAccount();
          }
          var tx = new _xdr["default"].FeeBumpTransaction({
            feeSource: feeSourceAccount,
            fee: _xdr["default"].Int64.fromString(base.times(innerOps + 1).toString()),
            innerTx: _xdr["default"].FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),
            ext: new _xdr["default"].FeeBumpTransactionExt(0)
          });
          var feeBumpTxEnvelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx,
            signatures: []
          });
          var envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);
          return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
        }
        /**
         * Build a {@link Transaction} or {@link FeeBumpTransaction} from an
         * xdr.TransactionEnvelope.
         *
         * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope
         *     object or base64 encoded string.
         * @param {string} networkPassphrase - The network passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September
         *     2015"), see {@link Networks}.
         *
         * @returns {Transaction|FeeBumpTransaction}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(envelope, networkPassphrase) {
          if (typeof envelope === "string") {
            envelope = _xdr["default"].TransactionEnvelope.fromXDR(envelope, "base64");
          }
          if (envelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
            return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
          }
          return new _transaction.Transaction(envelope, networkPassphrase);
        }
      }]);
    }();
    function isValidDate(d) {
      return d instanceof Date && !isNaN(d);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/network.js
var require_network2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Networks = void 0;
    var Networks = exports.Networks = {
      PUBLIC: "Public Global Stellar Network ; September 2015",
      TESTNET: "Test SDF Network ; September 2015",
      FUTURENET: "Test SDF Future Network ; October 2022",
      SANDBOX: "Local Sandbox Stellar Network ; September 2022",
      STANDALONE: "Standalone Network ; February 2017"
    };
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/soroban.js
var require_soroban2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/soroban.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Soroban = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toArray(r) {
      return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Soroban = exports.Soroban = function() {
      function Soroban2() {
        _classCallCheck(this, Soroban2);
      }
      return _createClass(Soroban2, null, [{
        key: "formatTokenAmount",
        value: (
          /**
           * Given a whole number smart contract amount of a token and an amount of
           * decimal places (if the token has any), it returns a "display" value.
           *
           * All arithmetic inside the contract is performed on integers to avoid
           * potential precision and consistency issues of floating-point.
           *
           * @param {string} amount   the token amount you want to display
           * @param {number} decimals specify how many decimal places a token has
           *
           * @returns {string} the display value
           * @throws {TypeError} if the given amount has a decimal point already
           * @example
           * formatTokenAmount("123000", 4) === "12.3";
           */
          function formatTokenAmount(amount, decimals) {
            if (amount.includes(".")) {
              throw new TypeError("No decimals are allowed");
            }
            var formatted = amount;
            if (decimals > 0) {
              if (decimals > formatted.length) {
                formatted = ["0", formatted.toString().padStart(decimals, "0")].join(".");
              } else {
                formatted = [formatted.slice(0, -decimals), formatted.slice(-decimals)].join(".");
              }
            }
            return formatted.replace(/(\.\d*?)0+$/, "$1");
          }
        )
        /**
         * Parse a token amount to use it on smart contract
         *
         * This function takes the display value and its decimals (if the token has
         * any) and returns a string that'll be used within the smart contract.
         *
         * @param {string} value      the token amount you want to use it on smart
         *    contract which you've been displaying in a UI
         * @param {number} decimals   the number of decimal places expected in the
         *    display value (different than the "actual" number, because suffix zeroes
         *    might not be present)
         *
         * @returns {string}  the whole number token amount represented by the display
         *    value with the decimal places shifted over
         *
         * @example
         * const displayValueAmount = "123.4560"
         * const parsedAmtForSmartContract = parseTokenAmount(displayValueAmount, 5);
         * parsedAmtForSmartContract === "12345600"
         */
      }, {
        key: "parseTokenAmount",
        value: function parseTokenAmount(value, decimals) {
          var _fraction$padEnd;
          var _value$split$slice = value.split(".").slice(), _value$split$slice2 = _toArray(_value$split$slice), whole = _value$split$slice2[0], fraction = _value$split$slice2[1], rest = _value$split$slice2.slice(2);
          if (rest.length) {
            throw new Error("Invalid decimal value: ".concat(value));
          }
          var shifted = BigInt(whole + ((_fraction$padEnd = fraction === null || fraction === void 0 ? void 0 : fraction.padEnd(decimals, "0")) !== null && _fraction$padEnd !== void 0 ? _fraction$padEnd : "0".repeat(decimals)));
          return shifted.toString();
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/contract.js
var require_contract3 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Contract = void 0;
    var _address = require_address2();
    var _operation = require_operation2();
    var _xdr = _interopRequireDefault(require_xdr3());
    var _strkey = require_strkey2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Contract = exports.Contract = function() {
      function Contract2(contractId) {
        _classCallCheck(this, Contract2);
        try {
          this._id = _strkey.StrKey.decodeContract(contractId);
        } catch (_) {
          throw new Error("Invalid contract ID: ".concat(contractId));
        }
      }
      return _createClass(Contract2, [{
        key: "contractId",
        value: function contractId() {
          return _strkey.StrKey.encodeContract(this._id);
        }
        /** @returns {string} the ID as a strkey (C...) */
      }, {
        key: "toString",
        value: function toString() {
          return this.contractId();
        }
        /** @returns {Address} the wrapped address of this contract */
      }, {
        key: "address",
        value: function address() {
          return _address.Address.contract(this._id);
        }
        /**
         * Returns an operation that will invoke this contract call.
         *
         * @param {string}        method   name of the method to call
         * @param {...xdr.ScVal}  params   arguments to pass to the function call
         *
         * @returns {xdr.Operation}   an InvokeHostFunctionOp operation to call the
         *    contract with the given method and parameters
         *
         * @see Operation.invokeHostFunction
         * @see Operation.invokeContractFunction
         * @see Operation.createCustomContract
         * @see Operation.createStellarAssetContract
         * @see Operation.uploadContractWasm
         */
      }, {
        key: "call",
        value: function call(method) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          return _operation.Operation.invokeContractFunction({
            contract: this.address().toString(),
            "function": method,
            args: params
          });
        }
        /**
         * Returns the read-only footprint entries necessary for any invocations to
         * this contract, for convenience when manually adding it to your
         * transaction's overall footprint or doing bump/restore operations.
         *
         * @returns {xdr.LedgerKey} the ledger key for the deployed contract instance
         */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
            contract: this.address().toScAddress(),
            key: _xdr["default"].ScVal.scvLedgerKeyContractInstance(),
            durability: _xdr["default"].ContractDataDurability.persistent()
          }));
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/uint128.js
var require_uint1282 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/uint128.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint128 = exports.Uint128 = function(_LargeInt) {
      function Uint1282() {
        _classCallCheck(this, Uint1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint1282, [args]);
      }
      _inherits(Uint1282, _LargeInt);
      return _createClass(Uint1282, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint128.defineIntBoundaries();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/uint256.js
var require_uint2562 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/uint256.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint256 = exports.Uint256 = function(_LargeInt) {
      function Uint2562() {
        _classCallCheck(this, Uint2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint2562, [args]);
      }
      _inherits(Uint2562, _LargeInt);
      return _createClass(Uint2562, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint256.defineIntBoundaries();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/int128.js
var require_int1282 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/int128.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int128 = exports.Int128 = function(_LargeInt) {
      function Int1282() {
        _classCallCheck(this, Int1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int1282, [args]);
      }
      _inherits(Int1282, _LargeInt);
      return _createClass(Int1282, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int128.defineIntBoundaries();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/int256.js
var require_int2562 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/int256.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int256 = exports.Int256 = function(_LargeInt) {
      function Int2562() {
        _classCallCheck(this, Int2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int2562, [args]);
      }
      _inherits(Int2562, _LargeInt);
      return _createClass(Int2562, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int256.defineIntBoundaries();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js
var require_xdr_large_int2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.XdrLargeInt = void 0;
    var _jsXdr = require_xdr();
    var _uint = require_uint1282();
    var _uint2 = require_uint2562();
    var _int = require_int1282();
    var _int2 = require_int2562();
    var _xdr = _interopRequireDefault(require_xdr3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var XdrLargeInt = exports.XdrLargeInt = function() {
      function XdrLargeInt2(type, values) {
        _classCallCheck(this, XdrLargeInt2);
        _defineProperty(this, "int", void 0);
        _defineProperty(this, "type", void 0);
        if (!(values instanceof Array)) {
          values = [values];
        }
        values = values.map(function(i) {
          if (typeof i === "bigint") {
            return i;
          }
          if (i instanceof XdrLargeInt2) {
            return i.toBigInt();
          }
          return BigInt(i);
        });
        switch (type) {
          case "i64":
            this["int"] = new _jsXdr.Hyper(values);
            break;
          case "i128":
            this["int"] = new _int.Int128(values);
            break;
          case "i256":
            this["int"] = new _int2.Int256(values);
            break;
          case "u64":
            this["int"] = new _jsXdr.UnsignedHyper(values);
            break;
          case "u128":
            this["int"] = new _uint.Uint128(values);
            break;
          case "u256":
            this["int"] = new _uint2.Uint256(values);
            break;
          default:
            throw TypeError("invalid type: ".concat(type));
        }
        this.type = type;
      }
      return _createClass(XdrLargeInt2, [{
        key: "toNumber",
        value: function toNumber() {
          var bi = this["int"].toBigInt();
          if (bi > Number.MAX_SAFE_INTEGER || bi < Number.MIN_SAFE_INTEGER) {
            throw RangeError("value ".concat(bi, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
          }
          return Number(bi);
        }
        /** @returns {bigint} */
      }, {
        key: "toBigInt",
        value: function toBigInt() {
          return this["int"].toBigInt();
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I64` */
      }, {
        key: "toI64",
        value: function toI64() {
          this._sizeCheck(64);
          var v = this.toBigInt();
          if (BigInt.asIntN(64, v) !== v) {
            throw RangeError("value too large for i64: ".concat(v));
          }
          return _xdr["default"].ScVal.scvI64(new _xdr["default"].Int64(v));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U64` */
      }, {
        key: "toU64",
        value: function toU64() {
          this._sizeCheck(64);
          return _xdr["default"].ScVal.scvU64(
            new _xdr["default"].Uint64(BigInt.asUintN(64, this.toBigInt()))
            // reiterpret as unsigned
          );
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = I128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toI128",
        value: function toI128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          var hi64 = BigInt.asIntN(64, v >> 64n);
          var lo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI128(new _xdr["default"].Int128Parts({
            hi: new _xdr["default"].Int64(hi64),
            lo: new _xdr["default"].Uint64(lo64)
          }));
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = U128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toU128",
        value: function toU128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          return _xdr["default"].ScVal.scvU128(new _xdr["default"].UInt128Parts({
            hi: new _xdr["default"].Uint64(BigInt.asUintN(64, v >> 64n)),
            lo: new _xdr["default"].Uint64(BigInt.asUintN(64, v))
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I256` */
      }, {
        key: "toI256",
        value: function toI256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asIntN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI256(new _xdr["default"].Int256Parts({
            hiHi: new _xdr["default"].Int64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U256` */
      }, {
        key: "toU256",
        value: function toU256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asUintN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvU256(new _xdr["default"].UInt256Parts({
            hiHi: new _xdr["default"].Uint64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the smallest interpretation of the stored value */
      }, {
        key: "toScVal",
        value: function toScVal() {
          switch (this.type) {
            case "i64":
              return this.toI64();
            case "i128":
              return this.toI128();
            case "i256":
              return this.toI256();
            case "u64":
              return this.toU64();
            case "u128":
              return this.toU128();
            case "u256":
              return this.toU256();
            default:
              throw TypeError("invalid type: ".concat(this.type));
          }
        }
      }, {
        key: "valueOf",
        value: function valueOf() {
          return this["int"].valueOf();
        }
      }, {
        key: "toString",
        value: function toString() {
          return this["int"].toString();
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            value: this.toBigInt().toString(),
            type: this.type
          };
        }
      }, {
        key: "_sizeCheck",
        value: function _sizeCheck(bits) {
          if (this["int"].size > bits) {
            throw RangeError("value too large for ".concat(bits, " bits (").concat(this.type, ")"));
          }
        }
      }], [{
        key: "isType",
        value: function isType(type) {
          switch (type) {
            case "i64":
            case "i128":
            case "i256":
            case "u64":
            case "u128":
            case "u256":
              return true;
            default:
              return false;
          }
        }
        /**
         * Convert the raw `ScValType` string (e.g. 'scvI128', generated by the XDR)
         * to a type description for {@link XdrLargeInt} construction (e.g. 'i128')
         *
         * @param {string} scvType  the `xdr.ScValType` as a string
         * @returns {string} a suitable equivalent type to construct this object
         */
      }, {
        key: "getType",
        value: function getType(scvType) {
          return scvType.slice(3).toLowerCase();
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js
var require_sc_int2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScInt = void 0;
    var _xdr_large_int = require_xdr_large_int2();
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var ScInt = exports.ScInt = function(_XdrLargeInt) {
      function ScInt2(value, opts) {
        var _opts$type;
        _classCallCheck(this, ScInt2);
        var signed = value < 0;
        var type = (_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "";
        if (type.startsWith("u") && signed) {
          throw TypeError("specified type ".concat(opts.type, " yet negative (").concat(value, ")"));
        }
        if (type === "") {
          type = signed ? "i" : "u";
          var bitlen = nearestBigIntSize(value);
          switch (bitlen) {
            case 64:
            case 128:
            case 256:
              type += bitlen.toString();
              break;
            default:
              throw RangeError("expected 64/128/256 bits for input (".concat(value, "), got ").concat(bitlen));
          }
        }
        return _callSuper(this, ScInt2, [type, value]);
      }
      _inherits(ScInt2, _XdrLargeInt);
      return _createClass(ScInt2);
    }(_xdr_large_int.XdrLargeInt);
    function nearestBigIntSize(bigI) {
      var _find;
      var bitlen = bigI.toString(2).length;
      return (_find = [64, 128, 256].find(function(len) {
        return bitlen <= len;
      })) !== null && _find !== void 0 ? _find : bitlen;
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/index.js
var require_numbers2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/numbers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Int128", {
      enumerable: true,
      get: function get() {
        return _int.Int128;
      }
    });
    Object.defineProperty(exports, "Int256", {
      enumerable: true,
      get: function get() {
        return _int2.Int256;
      }
    });
    Object.defineProperty(exports, "ScInt", {
      enumerable: true,
      get: function get() {
        return _sc_int.ScInt;
      }
    });
    Object.defineProperty(exports, "Uint128", {
      enumerable: true,
      get: function get() {
        return _uint.Uint128;
      }
    });
    Object.defineProperty(exports, "Uint256", {
      enumerable: true,
      get: function get() {
        return _uint2.Uint256;
      }
    });
    Object.defineProperty(exports, "XdrLargeInt", {
      enumerable: true,
      get: function get() {
        return _xdr_large_int.XdrLargeInt;
      }
    });
    exports.scValToBigInt = scValToBigInt;
    var _xdr_large_int = require_xdr_large_int2();
    var _uint = require_uint1282();
    var _uint2 = require_uint2562();
    var _int = require_int1282();
    var _int2 = require_int2562();
    var _sc_int = require_sc_int2();
    function scValToBigInt(scv) {
      var scIntType = _xdr_large_int.XdrLargeInt.getType(scv["switch"]().name);
      switch (scv["switch"]().name) {
        case "scvU32":
        case "scvI32":
          return BigInt(scv.value());
        case "scvU64":
        case "scvI64":
          return new _xdr_large_int.XdrLargeInt(scIntType, scv.value()).toBigInt();
        case "scvU128":
        case "scvI128":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().lo(), scv.value().hi()]).toBigInt();
        case "scvU256":
        case "scvI256":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().loLo(), scv.value().loHi(), scv.value().hiLo(), scv.value().hiHi()]).toBigInt();
        default:
          throw TypeError("expected integer type, got ".concat(scv["switch"]()));
      }
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/scval.js
var require_scval2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/scval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nativeToScVal = nativeToScVal;
    exports.scValToNative = scValToNative;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _address = require_address2();
    var _contract = require_contract3();
    var _index = require_numbers2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function nativeToScVal(val) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      switch (_typeof(val)) {
        case "object": {
          var _val$constructor$name, _val$constructor;
          if (val === null) {
            return _xdr["default"].ScVal.scvVoid();
          }
          if (val instanceof _xdr["default"].ScVal) {
            return val;
          }
          if (val instanceof _address.Address) {
            return val.toScVal();
          }
          if (val instanceof _keypair.Keypair) {
            return nativeToScVal(val.publicKey(), {
              type: "address"
            });
          }
          if (val instanceof _contract.Contract) {
            return val.address().toScVal();
          }
          if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
            var _opts$type;
            var copy = Uint8Array.from(val);
            switch ((_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "bytes") {
              case "bytes":
                return _xdr["default"].ScVal.scvBytes(copy);
              case "symbol":
                return _xdr["default"].ScVal.scvSymbol(copy);
              case "string":
                return _xdr["default"].ScVal.scvString(copy);
              default:
                throw new TypeError("invalid type (".concat(opts.type, ") specified for bytes-like value"));
            }
          }
          if (Array.isArray(val)) {
            return _xdr["default"].ScVal.scvVec(val.map(function(v) {
              return nativeToScVal(v, opts);
            }));
          }
          if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
            var _val$constructor2;
            throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
          }
          return _xdr["default"].ScVal.scvMap(Object.entries(val).sort(function(_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
            var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
            return key1.localeCompare(key2);
          }).map(function(_ref5) {
            var _k, _opts$type2;
            var _ref6 = _slicedToArray(_ref5, 2), k = _ref6[0], v = _ref6[1];
            var _ref7 = (_k = ((_opts$type2 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type2 !== void 0 ? _opts$type2 : {})[k]) !== null && _k !== void 0 ? _k : [null, null], _ref8 = _slicedToArray(_ref7, 2), keyType = _ref8[0], valType = _ref8[1];
            var keyOpts = keyType ? {
              type: keyType
            } : {};
            var valOpts = valType ? {
              type: valType
            } : {};
            return new _xdr["default"].ScMapEntry({
              key: nativeToScVal(k, keyOpts),
              val: nativeToScVal(v, valOpts)
            });
          }));
        }
        case "number":
        case "bigint":
          switch (opts === null || opts === void 0 ? void 0 : opts.type) {
            case "u32":
              return _xdr["default"].ScVal.scvU32(val);
            case "i32":
              return _xdr["default"].ScVal.scvI32(val);
            default:
              break;
          }
          return new _index.ScInt(val, {
            type: opts === null || opts === void 0 ? void 0 : opts.type
          }).toScVal();
        case "string": {
          var _opts$type3;
          var optType = (_opts$type3 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type3 !== void 0 ? _opts$type3 : "string";
          switch (optType) {
            case "string":
              return _xdr["default"].ScVal.scvString(val);
            case "symbol":
              return _xdr["default"].ScVal.scvSymbol(val);
            case "address":
              return new _address.Address(val).toScVal();
            case "u32":
              return _xdr["default"].ScVal.scvU32(parseInt(val, 10));
            case "i32":
              return _xdr["default"].ScVal.scvI32(parseInt(val, 10));
            default:
              if (_index.XdrLargeInt.isType(optType)) {
                return new _index.XdrLargeInt(optType, val).toScVal();
              }
              throw new TypeError("invalid type (".concat(opts.type, ") specified for string value"));
          }
        }
        case "boolean":
          return _xdr["default"].ScVal.scvBool(val);
        case "undefined":
          return _xdr["default"].ScVal.scvVoid();
        case "function":
          return nativeToScVal(val());
        default:
          throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
      }
    }
    function scValToNative(scv) {
      var _scv$vec, _scv$map;
      switch (scv["switch"]().value) {
        case _xdr["default"].ScValType.scvVoid().value:
          return null;
        case _xdr["default"].ScValType.scvU64().value:
        case _xdr["default"].ScValType.scvI64().value:
          return scv.value().toBigInt();
        case _xdr["default"].ScValType.scvU128().value:
        case _xdr["default"].ScValType.scvI128().value:
        case _xdr["default"].ScValType.scvU256().value:
        case _xdr["default"].ScValType.scvI256().value:
          return (0, _index.scValToBigInt)(scv);
        case _xdr["default"].ScValType.scvVec().value:
          return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(scValToNative);
        case _xdr["default"].ScValType.scvAddress().value:
          return _address.Address.fromScVal(scv).toString();
        case _xdr["default"].ScValType.scvMap().value:
          return Object.fromEntries(((_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : []).map(function(entry) {
            return [scValToNative(entry.key()), scValToNative(entry.val())];
          }));
        case _xdr["default"].ScValType.scvBool().value:
        case _xdr["default"].ScValType.scvU32().value:
        case _xdr["default"].ScValType.scvI32().value:
        case _xdr["default"].ScValType.scvBytes().value:
          return scv.value();
        case _xdr["default"].ScValType.scvSymbol().value:
        case _xdr["default"].ScValType.scvString().value: {
          var v = scv.value();
          if (Buffer.isBuffer(v) || ArrayBuffer.isView(v)) {
            try {
              return new TextDecoder().decode(v);
            } catch (e) {
              return new Uint8Array(v.buffer);
            }
          }
          return v;
        }
        case _xdr["default"].ScValType.scvTimepoint().value:
        case _xdr["default"].ScValType.scvDuration().value:
          return new _xdr["default"].Uint64(scv.value()).toBigInt();
        case _xdr["default"].ScValType.scvError().value:
          switch (scv.error()["switch"]().value) {
            case _xdr["default"].ScErrorType.sceContract().value:
              return {
                type: "contract",
                code: scv.error().contractCode()
              };
            default: {
              var err = scv.error();
              return {
                type: "system",
                code: err.code().value,
                value: err.code().name
              };
            }
          }
        default:
          return scv.value();
      }
    }
    _xdr["default"].scvSortedMap = function(items) {
      var sorted = Array.from(items).sort(function(a, b) {
        var nativeA = scValToNative(a.key());
        var nativeB = scValToNative(b.key());
        switch (_typeof(nativeA)) {
          case "number":
          case "bigint":
            return nativeA < nativeB ? -1 : 1;
          default:
            return nativeA.toString().localeCompare(nativeB.toString());
        }
      });
      return _xdr["default"].ScVal.scvMap(sorted);
    };
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/events.js
var require_events2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.humanizeEvents = humanizeEvents;
    var _strkey = require_strkey2();
    var _scval = require_scval2();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function humanizeEvents(events) {
      return events.map(function(e) {
        if (e.inSuccessfulContractCall) {
          return extractEvent(e.event());
        }
        return extractEvent(e);
      });
    }
    function extractEvent(event) {
      return _objectSpread(_objectSpread({}, typeof event.contractId === "function" && event.contractId() != null && {
        contractId: _strkey.StrKey.encodeContract(event.contractId())
      }), {}, {
        type: event.type().name,
        topics: event.body().value().topics().map(function(t) {
          return (0, _scval.scValToNative)(t);
        }),
        data: (0, _scval.scValToNative)(event.body().value().data())
      });
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/auth.js
var require_auth2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.authorizeEntry = authorizeEntry;
    exports.authorizeInvocation = authorizeInvocation;
    var _xdr = _interopRequireDefault(require_xdr3());
    var _keypair = require_keypair2();
    var _strkey = require_strkey2();
    var _network = require_network2();
    var _hashing = require_hashing2();
    var _address = require_address2();
    var _scval = require_scval2();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, "catch": function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function authorizeEntry(_x, _x2, _x3) {
      return _authorizeEntry.apply(this, arguments);
    }
    function _authorizeEntry() {
      _authorizeEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(entry, signer, validUntilLedgerSeq) {
        var networkPassphrase, clone, addrAuth, networkId, preimage, payload, signature, publicKey, sigResult, sigScVal, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              networkPassphrase = _args.length > 3 && _args[3] !== void 0 ? _args[3] : _network.Networks.FUTURENET;
              if (!(entry.credentials()["switch"]().value !== _xdr["default"].SorobanCredentialsType.sorobanCredentialsAddress().value)) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", entry);
            case 3:
              clone = _xdr["default"].SorobanAuthorizationEntry.fromXDR(entry.toXDR());
              addrAuth = clone.credentials().address();
              addrAuth.signatureExpirationLedger(validUntilLedgerSeq);
              networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
              preimage = _xdr["default"].HashIdPreimage.envelopeTypeSorobanAuthorization(new _xdr["default"].HashIdPreimageSorobanAuthorization({
                networkId,
                nonce: addrAuth.nonce(),
                invocation: clone.rootInvocation(),
                signatureExpirationLedger: addrAuth.signatureExpirationLedger()
              }));
              payload = (0, _hashing.hash)(preimage.toXDR());
              if (!(typeof signer === "function")) {
                _context.next = 16;
                break;
              }
              _context.next = 12;
              return signer(preimage);
            case 12:
              sigResult = _context.sent;
              if (sigResult !== null && sigResult !== void 0 && sigResult.signature) {
                signature = Buffer.from(sigResult.signature);
                publicKey = sigResult.publicKey;
              } else {
                signature = Buffer.from(sigResult);
                publicKey = _address.Address.fromScAddress(addrAuth.address()).toString();
              }
              _context.next = 18;
              break;
            case 16:
              signature = Buffer.from(signer.sign(payload));
              publicKey = signer.publicKey();
            case 18:
              if (_keypair.Keypair.fromPublicKey(publicKey).verify(payload, signature)) {
                _context.next = 20;
                break;
              }
              throw new Error("signature doesn't match payload");
            case 20:
              sigScVal = (0, _scval.nativeToScVal)({
                public_key: _strkey.StrKey.decodeEd25519PublicKey(publicKey),
                signature
              }, {
                type: {
                  public_key: ["symbol", null],
                  signature: ["symbol", null]
                }
              });
              addrAuth.signature(_xdr["default"].ScVal.scvVec([sigScVal]));
              return _context.abrupt("return", clone);
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _authorizeEntry.apply(this, arguments);
    }
    function authorizeInvocation(signer, validUntilLedgerSeq, invocation) {
      var publicKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var networkPassphrase = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : _network.Networks.FUTURENET;
      var kp = _keypair.Keypair.random().rawPublicKey();
      var nonce = new _xdr["default"].Int64(bytesToInt64(kp));
      var pk = publicKey || signer.publicKey();
      if (!pk) {
        throw new Error("authorizeInvocation requires publicKey parameter");
      }
      var entry = new _xdr["default"].SorobanAuthorizationEntry({
        rootInvocation: invocation,
        credentials: _xdr["default"].SorobanCredentials.sorobanCredentialsAddress(new _xdr["default"].SorobanAddressCredentials({
          address: new _address.Address(pk).toScAddress(),
          nonce,
          signatureExpirationLedger: 0,
          // replaced
          signature: _xdr["default"].ScVal.scvVec([])
          // replaced
        }))
      });
      return authorizeEntry(entry, signer, validUntilLedgerSeq, networkPassphrase);
    }
    function bytesToInt64(bytes) {
      return bytes.subarray(0, 8).reduce(function(accum, b) {
        return accum << 8 | b;
      }, 0);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/invocation.js
var require_invocation2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/invocation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildInvocationTree = buildInvocationTree;
    exports.walkInvocationTree = walkInvocationTree;
    var _asset = require_asset2();
    var _address = require_address2();
    var _scval = require_scval2();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function buildInvocationTree(root) {
      var fn = root["function"]();
      var output = {};
      var inner = fn.value();
      switch (fn["switch"]().value) {
        case 0:
          output.type = "execute";
          output.args = {
            source: _address.Address.fromScAddress(inner.contractAddress()).toString(),
            "function": inner.functionName(),
            args: inner.args().map(function(arg) {
              return (0, _scval.scValToNative)(arg);
            })
          };
          break;
        case 1:
        case 2: {
          var createV2 = fn["switch"]().value === 2;
          output.type = "create";
          output.args = {};
          var _ref = [inner.executable(), inner.contractIdPreimage()], exec = _ref[0], preimage = _ref[1];
          if (!!exec["switch"]().value !== !!preimage["switch"]().value) {
            throw new Error("creation function appears invalid: ".concat(JSON.stringify(inner), " (should be wasm+address or token+asset)"));
          }
          switch (exec["switch"]().value) {
            case 0: {
              var details = preimage.fromAddress();
              output.args.type = "wasm";
              output.args.wasm = _objectSpread({
                salt: details.salt().toString("hex"),
                hash: exec.wasmHash().toString("hex"),
                address: _address.Address.fromScAddress(details.address()).toString()
              }, createV2 && {
                constructorArgs: inner.constructorArgs().map(function(arg) {
                  return (0, _scval.scValToNative)(arg);
                })
              });
              break;
            }
            case 1:
              output.args.type = "sac";
              output.args.asset = _asset.Asset.fromOperation(preimage.fromAsset()).toString();
              break;
            default:
              throw new Error("unknown creation type: ".concat(JSON.stringify(exec)));
          }
          break;
        }
        default:
          throw new Error("unknown invocation type (".concat(fn["switch"](), "): ").concat(JSON.stringify(fn)));
      }
      output.invocations = root.subInvocations().map(function(i) {
        return buildInvocationTree(i);
      });
      return output;
    }
    function walkInvocationTree(root, callback) {
      walkHelper(root, 1, callback);
    }
    function walkHelper(node, depth, callback, parent) {
      if (callback(node, depth, parent) === false) {
        return;
      }
      node.subInvocations().forEach(function(i) {
        return walkHelper(i, depth + 1, callback, node);
      });
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-base/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      xdr: true,
      cereal: true,
      hash: true,
      sign: true,
      verify: true,
      FastSigning: true,
      getLiquidityPoolId: true,
      LiquidityPoolFeeV18: true,
      Keypair: true,
      UnsignedHyper: true,
      Hyper: true,
      TransactionBase: true,
      Transaction: true,
      FeeBumpTransaction: true,
      TransactionBuilder: true,
      TimeoutInfinite: true,
      BASE_FEE: true,
      Asset: true,
      LiquidityPoolAsset: true,
      LiquidityPoolId: true,
      Operation: true,
      AuthRequiredFlag: true,
      AuthRevocableFlag: true,
      AuthImmutableFlag: true,
      AuthClawbackEnabledFlag: true,
      Account: true,
      MuxedAccount: true,
      Claimant: true,
      Networks: true,
      StrKey: true,
      SignerKey: true,
      Soroban: true,
      decodeAddressToMuxedAccount: true,
      encodeMuxedAccountToAddress: true,
      extractBaseAddress: true,
      encodeMuxedAccount: true,
      Contract: true,
      Address: true
    };
    Object.defineProperty(exports, "Account", {
      enumerable: true,
      get: function get() {
        return _account.Account;
      }
    });
    Object.defineProperty(exports, "Address", {
      enumerable: true,
      get: function get() {
        return _address.Address;
      }
    });
    Object.defineProperty(exports, "Asset", {
      enumerable: true,
      get: function get() {
        return _asset.Asset;
      }
    });
    Object.defineProperty(exports, "AuthClawbackEnabledFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthClawbackEnabledFlag;
      }
    });
    Object.defineProperty(exports, "AuthImmutableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthImmutableFlag;
      }
    });
    Object.defineProperty(exports, "AuthRequiredFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRequiredFlag;
      }
    });
    Object.defineProperty(exports, "AuthRevocableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRevocableFlag;
      }
    });
    Object.defineProperty(exports, "BASE_FEE", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.BASE_FEE;
      }
    });
    Object.defineProperty(exports, "Claimant", {
      enumerable: true,
      get: function get() {
        return _claimant.Claimant;
      }
    });
    Object.defineProperty(exports, "Contract", {
      enumerable: true,
      get: function get() {
        return _contract.Contract;
      }
    });
    Object.defineProperty(exports, "FastSigning", {
      enumerable: true,
      get: function get() {
        return _signing.FastSigning;
      }
    });
    Object.defineProperty(exports, "FeeBumpTransaction", {
      enumerable: true,
      get: function get() {
        return _fee_bump_transaction.FeeBumpTransaction;
      }
    });
    Object.defineProperty(exports, "Hyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.Hyper;
      }
    });
    Object.defineProperty(exports, "Keypair", {
      enumerable: true,
      get: function get() {
        return _keypair.Keypair;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolAsset", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_asset.LiquidityPoolAsset;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolFeeV18", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.LiquidityPoolFeeV18;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_id.LiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "MuxedAccount", {
      enumerable: true,
      get: function get() {
        return _muxed_account.MuxedAccount;
      }
    });
    Object.defineProperty(exports, "Networks", {
      enumerable: true,
      get: function get() {
        return _network.Networks;
      }
    });
    Object.defineProperty(exports, "Operation", {
      enumerable: true,
      get: function get() {
        return _operation.Operation;
      }
    });
    Object.defineProperty(exports, "SignerKey", {
      enumerable: true,
      get: function get() {
        return _signerkey.SignerKey;
      }
    });
    Object.defineProperty(exports, "Soroban", {
      enumerable: true,
      get: function get() {
        return _soroban.Soroban;
      }
    });
    Object.defineProperty(exports, "StrKey", {
      enumerable: true,
      get: function get() {
        return _strkey.StrKey;
      }
    });
    Object.defineProperty(exports, "TimeoutInfinite", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TimeoutInfinite;
      }
    });
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function get() {
        return _transaction.Transaction;
      }
    });
    Object.defineProperty(exports, "TransactionBase", {
      enumerable: true,
      get: function get() {
        return _transaction_base.TransactionBase;
      }
    });
    Object.defineProperty(exports, "TransactionBuilder", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TransactionBuilder;
      }
    });
    Object.defineProperty(exports, "UnsignedHyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.UnsignedHyper;
      }
    });
    Object.defineProperty(exports, "cereal", {
      enumerable: true,
      get: function get() {
        return _jsxdr["default"];
      }
    });
    Object.defineProperty(exports, "decodeAddressToMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.decodeAddressToMuxedAccount;
      }
    });
    exports["default"] = void 0;
    Object.defineProperty(exports, "encodeMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccount;
      }
    });
    Object.defineProperty(exports, "encodeMuxedAccountToAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccountToAddress;
      }
    });
    Object.defineProperty(exports, "extractBaseAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.extractBaseAddress;
      }
    });
    Object.defineProperty(exports, "getLiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.getLiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "hash", {
      enumerable: true,
      get: function get() {
        return _hashing.hash;
      }
    });
    Object.defineProperty(exports, "sign", {
      enumerable: true,
      get: function get() {
        return _signing.sign;
      }
    });
    Object.defineProperty(exports, "verify", {
      enumerable: true,
      get: function get() {
        return _signing.verify;
      }
    });
    Object.defineProperty(exports, "xdr", {
      enumerable: true,
      get: function get() {
        return _xdr["default"];
      }
    });
    var _xdr = _interopRequireDefault(require_xdr3());
    var _jsxdr = _interopRequireDefault(require_jsxdr2());
    var _hashing = require_hashing2();
    var _signing = require_signing2();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id2();
    var _keypair = require_keypair2();
    var _jsXdr = require_xdr();
    var _transaction_base = require_transaction_base2();
    var _transaction = require_transaction3();
    var _fee_bump_transaction = require_fee_bump_transaction2();
    var _transaction_builder = require_transaction_builder2();
    var _asset = require_asset2();
    var _liquidity_pool_asset = require_liquidity_pool_asset2();
    var _liquidity_pool_id = require_liquidity_pool_id2();
    var _operation = require_operation2();
    var _memo = require_memo2();
    Object.keys(_memo).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _memo[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _memo[key];
        }
      });
    });
    var _account = require_account2();
    var _muxed_account = require_muxed_account2();
    var _claimant = require_claimant2();
    var _network = require_network2();
    var _strkey = require_strkey2();
    var _signerkey = require_signerkey2();
    var _soroban = require_soroban2();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account2();
    var _contract = require_contract3();
    var _address = require_address2();
    var _numbers = require_numbers2();
    Object.keys(_numbers).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _numbers[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _numbers[key];
        }
      });
    });
    var _scval = require_scval2();
    Object.keys(_scval).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _scval[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _scval[key];
        }
      });
    });
    var _events = require_events2();
    Object.keys(_events).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _events[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _events[key];
        }
      });
    });
    var _sorobandata_builder = require_sorobandata_builder2();
    Object.keys(_sorobandata_builder).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _sorobandata_builder[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sorobandata_builder[key];
        }
      });
    });
    var _auth = require_auth2();
    Object.keys(_auth).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _auth[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _auth[key];
        }
      });
    });
    var _invocation = require_invocation2();
    Object.keys(_invocation).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _invocation[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _invocation[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = module.exports;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/types.js
var require_types3 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CancelToken = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var CancelToken = exports.CancelToken = function() {
      function CancelToken2(executor) {
        var _this = this;
        _classCallCheck(this, CancelToken2);
        var resolvePromise;
        this.promise = new Promise(function(resolve) {
          resolvePromise = resolve;
        });
        executor(function(reason) {
          _this.reason = reason;
          resolvePromise();
        });
      }
      return _createClass(CancelToken2, [{
        key: "throwIfRequested",
        value: function throwIfRequested() {
          if (this.reason) {
            throw new Error(this.reason);
          }
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/fetch-client.js
var require_fetch_client2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/fetch-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.create = createFetchClient;
    exports.fetchClient = void 0;
    var _feaxios = _interopRequireDefault(require_dist());
    var _types = require_types3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var InterceptorManager = function() {
      function InterceptorManager2() {
        _classCallCheck(this, InterceptorManager2);
        _defineProperty(this, "handlers", []);
      }
      return _createClass(InterceptorManager2, [{
        key: "use",
        value: function use(fulfilled, rejected) {
          this.handlers.push({
            fulfilled,
            rejected
          });
          return this.handlers.length - 1;
        }
      }, {
        key: "eject",
        value: function eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          this.handlers.forEach(function(h) {
            if (h !== null) {
              fn(h);
            }
          });
        }
      }]);
    }();
    function getFormConfig(config) {
      var formConfig = config || {};
      formConfig.headers = new Headers(formConfig.headers || {});
      formConfig.headers.set("Content-Type", "application/x-www-form-urlencoded");
      return formConfig;
    }
    function createFetchClient() {
      var fetchConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = _objectSpread(_objectSpread({}, fetchConfig), {}, {
        headers: fetchConfig.headers || {}
      });
      var instance = _feaxios.default.create(defaults);
      var requestInterceptors = new InterceptorManager();
      var responseInterceptors = new InterceptorManager();
      var httpClient = {
        interceptors: {
          request: requestInterceptors,
          response: responseInterceptors
        },
        defaults: _objectSpread(_objectSpread({}, defaults), {}, {
          adapter: function adapter(config) {
            return instance.request(config);
          }
        }),
        create: function create(config) {
          return createFetchClient(_objectSpread(_objectSpread({}, this.defaults), config));
        },
        makeRequest: function makeRequest(config) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var abortController = new AbortController();
            config.signal = abortController.signal;
            if (config.cancelToken) {
              config.cancelToken.promise.then(function() {
                abortController.abort();
                reject(new Error("Request canceled"));
              });
            }
            var modifiedConfig = config;
            if (requestInterceptors.handlers.length > 0) {
              var chain = requestInterceptors.handlers.filter(function(interceptor) {
                return interceptor !== null;
              }).flatMap(function(interceptor) {
                return [interceptor.fulfilled, interceptor.rejected];
              });
              for (var i = 0, len = chain.length; i < len; i += 2) {
                var onFulfilled = chain[i];
                var onRejected = chain[i + 1];
                try {
                  if (onFulfilled) modifiedConfig = onFulfilled(modifiedConfig);
                } catch (error) {
                  if (onRejected) onRejected === null || onRejected === void 0 || onRejected(error);
                  reject(error);
                  return;
                }
              }
            }
            var adapter = modifiedConfig.adapter || _this.defaults.adapter;
            if (!adapter) {
              throw new Error("No adapter available");
            }
            var responsePromise = adapter(modifiedConfig).then(function(axiosResponse) {
              var httpClientResponse = {
                data: axiosResponse.data,
                headers: axiosResponse.headers,
                config: axiosResponse.config,
                status: axiosResponse.status,
                statusText: axiosResponse.statusText
              };
              return httpClientResponse;
            });
            if (responseInterceptors.handlers.length > 0) {
              var _chain = responseInterceptors.handlers.filter(function(interceptor) {
                return interceptor !== null;
              }).flatMap(function(interceptor) {
                return [interceptor.fulfilled, interceptor.rejected];
              });
              var _loop = function _loop2(_i2) {
                responsePromise = responsePromise.then(function(response) {
                  var fulfilledInterceptor = _chain[_i2];
                  if (typeof fulfilledInterceptor === "function") {
                    return fulfilledInterceptor(response);
                  }
                  return response;
                }, function(error) {
                  var rejectedInterceptor = _chain[_i2 + 1];
                  if (typeof rejectedInterceptor === "function") {
                    return rejectedInterceptor(error);
                  }
                  throw error;
                }).then(function(interceptedResponse) {
                  return interceptedResponse;
                });
              };
              for (var _i = 0, _len = _chain.length; _i < _len; _i += 2) {
                _loop(_i);
              }
            }
            responsePromise.then(resolve).catch(reject);
          });
        },
        get: function get(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "get"
          }));
        },
        delete: function _delete(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "delete"
          }));
        },
        head: function head(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "head"
          }));
        },
        options: function options(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "options"
          }));
        },
        post: function post(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "post",
            data
          }));
        },
        put: function put(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "put",
            data
          }));
        },
        patch: function patch(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "patch",
            data
          }));
        },
        postForm: function postForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "post",
            data
          }));
        },
        putForm: function putForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "put",
            data
          }));
        },
        patchForm: function patchForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "patch",
            data
          }));
        },
        CancelToken: _types.CancelToken,
        isCancel: function isCancel(value) {
          return value instanceof Error && value.message === "Request canceled";
        }
      };
      return httpClient;
    }
    var fetchClient = exports.fetchClient = createFetchClient();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/index.js
var require_http_client2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      httpClient: true,
      create: true
    };
    exports.httpClient = exports.create = void 0;
    var _types = require_types3();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    var httpClient;
    var create;
    if (false) {
      axiosModule = null;
      exports.httpClient = httpClient = axiosModule.axiosClient;
      exports.create = create = axiosModule.create;
    } else {
      fetchModule = require_fetch_client2();
      exports.httpClient = httpClient = fetchModule.fetchClient;
      exports.create = create = fetchModule.create;
    }
    var axiosModule;
    var fetchModule;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/axios.js
var require_axios2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/axios.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.version = exports.default = exports.AxiosClient = void 0;
    var _httpClient = require_http_client2();
    var version2 = exports.version = "13.3.0";
    var AxiosClient = exports.AxiosClient = (0, _httpClient.create)({
      headers: {
        "X-Client-Name": "js-soroban-client",
        "X-Client-Version": version2
      }
    });
    var _default = exports.default = AxiosClient;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/jsonrpc.js
var require_jsonrpc2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.postObject = postObject;
    var _axios = _interopRequireDefault(require_axios2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function hasOwnProperty(obj, prop) {
      return obj.hasOwnProperty(prop);
    }
    function postObject(_x, _x2) {
      return _postObject.apply(this, arguments);
    }
    function _postObject() {
      _postObject = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(url, method) {
        var param, response, _response$data, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              param = _args.length > 2 && _args[2] !== void 0 ? _args[2] : null;
              _context.next = 3;
              return _axios.default.post(url, {
                jsonrpc: "2.0",
                id: 1,
                method,
                params: param
              });
            case 3:
              response = _context.sent;
              if (!hasOwnProperty(response.data, "error")) {
                _context.next = 8;
                break;
              }
              throw response.data.error;
            case 8:
              return _context.abrupt("return", (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.result);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _postObject.apply(this, arguments);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/parsers.js
var require_parsers2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/parsers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseRawEvents = parseRawEvents;
    exports.parseRawLedgerEntries = parseRawLedgerEntries;
    exports.parseRawSendTransaction = parseRawSendTransaction;
    exports.parseRawSimulation = parseRawSimulation;
    exports.parseRawTransactions = parseRawTransactions;
    exports.parseTransactionInfo = parseTransactionInfo;
    var _stellarBase = require_lib2();
    var _api = require_api2();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function parseRawSendTransaction(raw) {
      var errorResultXdr = raw.errorResultXdr, diagnosticEventsXdr = raw.diagnosticEventsXdr;
      delete raw.errorResultXdr;
      delete raw.diagnosticEventsXdr;
      if (errorResultXdr) {
        return _objectSpread(_objectSpread(_objectSpread({}, raw), diagnosticEventsXdr !== void 0 && diagnosticEventsXdr.length > 0 && {
          diagnosticEvents: diagnosticEventsXdr.map(function(evt) {
            return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
          })
        }), {}, {
          errorResult: _stellarBase.xdr.TransactionResult.fromXDR(errorResultXdr, "base64")
        });
      }
      return _objectSpread({}, raw);
    }
    function parseTransactionInfo(raw) {
      var meta = _stellarBase.xdr.TransactionMeta.fromXDR(raw.resultMetaXdr, "base64");
      var info = {
        ledger: raw.ledger,
        createdAt: raw.createdAt,
        applicationOrder: raw.applicationOrder,
        feeBump: raw.feeBump,
        envelopeXdr: _stellarBase.xdr.TransactionEnvelope.fromXDR(raw.envelopeXdr, "base64"),
        resultXdr: _stellarBase.xdr.TransactionResult.fromXDR(raw.resultXdr, "base64"),
        resultMetaXdr: meta
      };
      if (meta.switch() === 3 && meta.v3().sorobanMeta() !== null) {
        var _meta$v3$sorobanMeta;
        info.returnValue = (_meta$v3$sorobanMeta = meta.v3().sorobanMeta()) === null || _meta$v3$sorobanMeta === void 0 ? void 0 : _meta$v3$sorobanMeta.returnValue();
      }
      if ("diagnosticEventsXdr" in raw && raw.diagnosticEventsXdr) {
        info.diagnosticEventsXdr = raw.diagnosticEventsXdr.map(function(diagnosticEvent) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(diagnosticEvent, "base64");
        });
      }
      return info;
    }
    function parseRawTransactions(r) {
      return _objectSpread({
        status: r.status,
        txHash: r.txHash
      }, parseTransactionInfo(r));
    }
    function parseRawEvents(raw) {
      var _raw$events;
      return {
        latestLedger: raw.latestLedger,
        cursor: raw.cursor,
        events: ((_raw$events = raw.events) !== null && _raw$events !== void 0 ? _raw$events : []).map(function(evt) {
          var clone = _objectSpread({}, evt);
          delete clone.contractId;
          return _objectSpread(_objectSpread(_objectSpread({}, clone), evt.contractId !== "" && {
            contractId: new _stellarBase.Contract(evt.contractId)
          }), {}, {
            topic: evt.topic.map(function(topic) {
              return _stellarBase.xdr.ScVal.fromXDR(topic, "base64");
            }),
            value: _stellarBase.xdr.ScVal.fromXDR(evt.value, "base64")
          });
        })
      };
    }
    function parseRawLedgerEntries(raw) {
      var _raw$entries;
      return {
        latestLedger: raw.latestLedger,
        entries: ((_raw$entries = raw.entries) !== null && _raw$entries !== void 0 ? _raw$entries : []).map(function(rawEntry) {
          if (!rawEntry.key || !rawEntry.xdr) {
            throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(rawEntry)));
          }
          return _objectSpread({
            lastModifiedLedgerSeq: rawEntry.lastModifiedLedgerSeq,
            key: _stellarBase.xdr.LedgerKey.fromXDR(rawEntry.key, "base64"),
            val: _stellarBase.xdr.LedgerEntryData.fromXDR(rawEntry.xdr, "base64")
          }, rawEntry.liveUntilLedgerSeq !== void 0 && {
            liveUntilLedgerSeq: rawEntry.liveUntilLedgerSeq
          });
        })
      };
    }
    function parseSuccessful(sim, partial) {
      var _sim$results$length, _sim$results, _sim$stateChanges$len, _sim$stateChanges, _sim$stateChanges2;
      var success = _objectSpread(_objectSpread(_objectSpread({}, partial), {}, {
        transactionData: new _stellarBase.SorobanDataBuilder(sim.transactionData),
        minResourceFee: sim.minResourceFee
      }, ((_sim$results$length = (_sim$results = sim.results) === null || _sim$results === void 0 ? void 0 : _sim$results.length) !== null && _sim$results$length !== void 0 ? _sim$results$length : 0 > 0) && {
        result: sim.results.map(function(row) {
          var _row$auth;
          return {
            auth: ((_row$auth = row.auth) !== null && _row$auth !== void 0 ? _row$auth : []).map(function(entry) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(entry, "base64");
            }),
            retval: row.xdr ? _stellarBase.xdr.ScVal.fromXDR(row.xdr, "base64") : _stellarBase.xdr.ScVal.scvVoid()
          };
        })[0]
      }), ((_sim$stateChanges$len = (_sim$stateChanges = sim.stateChanges) === null || _sim$stateChanges === void 0 ? void 0 : _sim$stateChanges.length) !== null && _sim$stateChanges$len !== void 0 ? _sim$stateChanges$len : 0 > 0) && {
        stateChanges: (_sim$stateChanges2 = sim.stateChanges) === null || _sim$stateChanges2 === void 0 ? void 0 : _sim$stateChanges2.map(function(entryChange) {
          return {
            type: entryChange.type,
            key: _stellarBase.xdr.LedgerKey.fromXDR(entryChange.key, "base64"),
            before: entryChange.before ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.before, "base64") : null,
            after: entryChange.after ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.after, "base64") : null
          };
        })
      });
      if (!sim.restorePreamble || sim.restorePreamble.transactionData === "") {
        return success;
      }
      return _objectSpread(_objectSpread({}, success), {}, {
        restorePreamble: {
          minResourceFee: sim.restorePreamble.minResourceFee,
          transactionData: new _stellarBase.SorobanDataBuilder(sim.restorePreamble.transactionData)
        }
      });
    }
    function parseRawSimulation(sim) {
      var _sim$events$map, _sim$events;
      var looksRaw = _api.Api.isSimulationRaw(sim);
      if (!looksRaw) {
        return sim;
      }
      var base = {
        _parsed: true,
        id: sim.id,
        latestLedger: sim.latestLedger,
        events: (_sim$events$map = (_sim$events = sim.events) === null || _sim$events === void 0 ? void 0 : _sim$events.map(function(evt) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
        })) !== null && _sim$events$map !== void 0 ? _sim$events$map : []
      };
      if (typeof sim.error === "string") {
        return _objectSpread(_objectSpread({}, base), {}, {
          error: sim.error
        });
      }
      return parseSuccessful(sim, base);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/transaction.js
var require_transaction4 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assembleTransaction = assembleTransaction;
    var _stellarBase = require_lib2();
    var _api = require_api2();
    var _parsers = require_parsers2();
    function isSorobanTransaction(tx) {
      if (tx.operations.length !== 1) {
        return false;
      }
      switch (tx.operations[0].type) {
        case "invokeHostFunction":
        case "extendFootprintTtl":
        case "restoreFootprint":
          return true;
        default:
          return false;
      }
    }
    function assembleTransaction(raw, simulation) {
      if ("innerTransaction" in raw) {
        return assembleTransaction(raw.innerTransaction, simulation);
      }
      if (!isSorobanTransaction(raw)) {
        throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
      }
      var success = (0, _parsers.parseRawSimulation)(simulation);
      if (!_api.Api.isSimulationSuccess(success)) {
        throw new Error("simulation incorrect: ".concat(JSON.stringify(success)));
      }
      var classicFeeNum = parseInt(raw.fee) || 0;
      var minResourceFeeNum = parseInt(success.minResourceFee) || 0;
      var txnBuilder = _stellarBase.TransactionBuilder.cloneFrom(raw, {
        fee: (classicFeeNum + minResourceFeeNum).toString(),
        sorobanData: success.transactionData.build(),
        networkPassphrase: raw.networkPassphrase
      });
      if (raw.operations[0].type === "invokeHostFunction") {
        var _invokeOp$auth;
        txnBuilder.clearOperations();
        var invokeOp = raw.operations[0];
        var existingAuth = (_invokeOp$auth = invokeOp.auth) !== null && _invokeOp$auth !== void 0 ? _invokeOp$auth : [];
        txnBuilder.addOperation(_stellarBase.Operation.invokeHostFunction({
          source: invokeOp.source,
          func: invokeOp.func,
          auth: existingAuth.length > 0 ? existingAuth : success.result.auth
        }));
      }
      return txnBuilder;
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/utils.js
var require_utils3 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Utils = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Utils = exports.Utils = function() {
      function Utils2() {
        _classCallCheck(this, Utils2);
      }
      return _createClass(Utils2, null, [{
        key: "validateTimebounds",
        value: function validateTimebounds(transaction) {
          var gracePeriod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          if (!transaction.timeBounds) {
            return false;
          }
          var now = Math.floor(Date.now() / 1e3);
          var _transaction$timeBoun = transaction.timeBounds, minTime = _transaction$timeBoun.minTime, maxTime = _transaction$timeBoun.maxTime;
          return now >= Number.parseInt(minTime, 10) - gracePeriod && now <= Number.parseInt(maxTime, 10) + gracePeriod;
        }
      }, {
        key: "sleep",
        value: function sleep(ms) {
          return new Promise(function(resolve) {
            return setTimeout(resolve, ms);
          });
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/server.js
var require_server2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SUBMIT_TRANSACTION_TIMEOUT = exports.RpcServer = exports.LinearSleepStrategy = exports.Durability = exports.BasicSleepStrategy = void 0;
    var _urijs = _interopRequireDefault(require_URI());
    var _stellarBase = require_lib2();
    var _axios = _interopRequireDefault(require_axios2());
    var jsonrpc = _interopRequireWildcard(require_jsonrpc2());
    var _api = require_api2();
    var _transaction = require_transaction4();
    var _parsers = require_parsers2();
    var _utils = require_utils3();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SUBMIT_TRANSACTION_TIMEOUT = exports.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
    var Durability2 = exports.Durability = function(Durability3) {
      Durability3["Temporary"] = "temporary";
      Durability3["Persistent"] = "persistent";
      return Durability3;
    }({});
    var DEFAULT_GET_TRANSACTION_TIMEOUT = 30;
    var BasicSleepStrategy = exports.BasicSleepStrategy = function BasicSleepStrategy2(_iter) {
      return 1e3;
    };
    var LinearSleepStrategy = exports.LinearSleepStrategy = function LinearSleepStrategy2(iter) {
      return 1e3 * iter;
    };
    function findCreatedAccountSequenceInTransactionMeta(meta) {
      var _operations$flatMap$f;
      var operations = [];
      switch (meta.switch()) {
        case 0:
          operations = meta.operations();
          break;
        case 1:
        case 2:
        case 3:
          operations = meta.value().operations();
          break;
        default:
          throw new Error("Unexpected transaction meta switch value");
      }
      var sequenceNumber = (_operations$flatMap$f = operations.flatMap(function(op) {
        return op.changes();
      }).find(function(c) {
        return c.switch() === _stellarBase.xdr.LedgerEntryChangeType.ledgerEntryCreated() && c.created().data().switch() === _stellarBase.xdr.LedgerEntryType.account();
      })) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.created()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.data()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.account()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.seqNum()) === null || _operations$flatMap$f === void 0 ? void 0 : _operations$flatMap$f.toString();
      if (sequenceNumber) {
        return sequenceNumber;
      }
      throw new Error("No account created in transaction");
    }
    var RpcServer = exports.RpcServer = function() {
      function RpcServer2(serverURL) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, RpcServer2);
        this.serverURL = (0, _urijs.default)(serverURL);
        if (opts.headers && Object.keys(opts.headers).length !== 0) {
          _axios.default.interceptors.request.use(function(config) {
            config.headers = Object.assign(config.headers, opts.headers);
            return config;
          });
        }
        if (this.serverURL.protocol() !== "https" && !opts.allowHttp) {
          throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
        }
      }
      return _createClass(RpcServer2, [{
        key: "getAccount",
        value: function() {
          var _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(address) {
            var ledgerKey, resp, accountEntry;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  ledgerKey = _stellarBase.xdr.LedgerKey.account(new _stellarBase.xdr.LedgerKeyAccount({
                    accountId: _stellarBase.Keypair.fromPublicKey(address).xdrPublicKey()
                  }));
                  _context.next = 3;
                  return this.getLedgerEntries(ledgerKey);
                case 3:
                  resp = _context.sent;
                  if (!(resp.entries.length === 0)) {
                    _context.next = 6;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Account not found: ".concat(address)
                  }));
                case 6:
                  accountEntry = resp.entries[0].val.account();
                  return _context.abrupt("return", new _stellarBase.Account(address, accountEntry.seqNum().toString()));
                case 8:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function getAccount(_x) {
            return _getAccount.apply(this, arguments);
          }
          return getAccount;
        }()
      }, {
        key: "getHealth",
        value: function() {
          var _getHealth = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getHealth"));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function getHealth() {
            return _getHealth.apply(this, arguments);
          }
          return getHealth;
        }()
      }, {
        key: "getContractData",
        value: function() {
          var _getContractData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(contract, key) {
            var durability, scAddress, xdrDurability, contractKey, _args3 = arguments;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  durability = _args3.length > 2 && _args3[2] !== void 0 ? _args3[2] : Durability2.Persistent;
                  if (!(typeof contract === "string")) {
                    _context3.next = 5;
                    break;
                  }
                  scAddress = new _stellarBase.Contract(contract).address().toScAddress();
                  _context3.next = 14;
                  break;
                case 5:
                  if (!(contract instanceof _stellarBase.Address)) {
                    _context3.next = 9;
                    break;
                  }
                  scAddress = contract.toScAddress();
                  _context3.next = 14;
                  break;
                case 9:
                  if (!(contract instanceof _stellarBase.Contract)) {
                    _context3.next = 13;
                    break;
                  }
                  scAddress = contract.address().toScAddress();
                  _context3.next = 14;
                  break;
                case 13:
                  throw new TypeError("unknown contract type: ".concat(contract));
                case 14:
                  _context3.t0 = durability;
                  _context3.next = _context3.t0 === Durability2.Temporary ? 17 : _context3.t0 === Durability2.Persistent ? 19 : 21;
                  break;
                case 17:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.temporary();
                  return _context3.abrupt("break", 22);
                case 19:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.persistent();
                  return _context3.abrupt("break", 22);
                case 21:
                  throw new TypeError("invalid durability: ".concat(durability));
                case 22:
                  contractKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    key,
                    contract: scAddress,
                    durability: xdrDurability
                  }));
                  return _context3.abrupt("return", this.getLedgerEntries(contractKey).then(function(r) {
                    if (r.entries.length === 0) {
                      return Promise.reject({
                        code: 404,
                        message: "Contract data not found. Contract: ".concat(_stellarBase.Address.fromScAddress(scAddress).toString(), ", Key: ").concat(key.toXDR("base64"), ", Durability: ").concat(durability)
                      });
                    }
                    return r.entries[0];
                  }));
                case 24:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this);
          }));
          function getContractData(_x2, _x3) {
            return _getContractData.apply(this, arguments);
          }
          return getContractData;
        }()
      }, {
        key: "getContractWasmByContractId",
        value: function() {
          var _getContractWasmByContractId = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(contractId) {
            var _response$entries$;
            var contractLedgerKey, response, wasmHash;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  contractLedgerKey = new _stellarBase.Contract(contractId).getFootprint();
                  _context4.next = 3;
                  return this.getLedgerEntries(contractLedgerKey);
                case 3:
                  response = _context4.sent;
                  if (!(!response.entries.length || !((_response$entries$ = response.entries[0]) !== null && _response$entries$ !== void 0 && _response$entries$.val))) {
                    _context4.next = 6;
                    break;
                  }
                  return _context4.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract hash from server"
                  }));
                case 6:
                  wasmHash = response.entries[0].val.contractData().val().instance().executable().wasmHash();
                  return _context4.abrupt("return", this.getContractWasmByHash(wasmHash));
                case 8:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));
          function getContractWasmByContractId(_x4) {
            return _getContractWasmByContractId.apply(this, arguments);
          }
          return getContractWasmByContractId;
        }()
      }, {
        key: "getContractWasmByHash",
        value: function() {
          var _getContractWasmByHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasmHash) {
            var _responseWasm$entries;
            var format, wasmHashBuffer, ledgerKeyWasmHash, responseWasm, wasmBuffer, _args5 = arguments;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  format = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : void 0;
                  wasmHashBuffer = typeof wasmHash === "string" ? Buffer.from(wasmHash, format) : wasmHash;
                  ledgerKeyWasmHash = _stellarBase.xdr.LedgerKey.contractCode(new _stellarBase.xdr.LedgerKeyContractCode({
                    hash: wasmHashBuffer
                  }));
                  _context5.next = 5;
                  return this.getLedgerEntries(ledgerKeyWasmHash);
                case 5:
                  responseWasm = _context5.sent;
                  if (!(!responseWasm.entries.length || !((_responseWasm$entries = responseWasm.entries[0]) !== null && _responseWasm$entries !== void 0 && _responseWasm$entries.val))) {
                    _context5.next = 8;
                    break;
                  }
                  return _context5.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract wasm from server"
                  }));
                case 8:
                  wasmBuffer = responseWasm.entries[0].val.contractCode().code();
                  return _context5.abrupt("return", wasmBuffer);
                case 10:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function getContractWasmByHash(_x5) {
            return _getContractWasmByHash.apply(this, arguments);
          }
          return getContractWasmByHash;
        }()
      }, {
        key: "getLedgerEntries",
        value: function() {
          var _getLedgerEntries2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
            var _args6 = arguments;
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  return _context6.abrupt("return", this._getLedgerEntries.apply(this, _args6).then(_parsers.parseRawLedgerEntries));
                case 1:
                case "end":
                  return _context6.stop();
              }
            }, _callee6, this);
          }));
          function getLedgerEntries() {
            return _getLedgerEntries2.apply(this, arguments);
          }
          return getLedgerEntries;
        }()
      }, {
        key: "_getLedgerEntries",
        value: function() {
          var _getLedgerEntries3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var _len, keys, _key, _args7 = arguments;
            return _regeneratorRuntime().wrap(function _callee7$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  for (_len = _args7.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
                    keys[_key] = _args7[_key];
                  }
                  return _context7.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLedgerEntries", {
                    keys: keys.map(function(k) {
                      return k.toXDR("base64");
                    })
                  }));
                case 2:
                case "end":
                  return _context7.stop();
              }
            }, _callee7, this);
          }));
          function _getLedgerEntries() {
            return _getLedgerEntries3.apply(this, arguments);
          }
          return _getLedgerEntries;
        }()
      }, {
        key: "pollTransaction",
        value: function() {
          var _pollTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(hash2, opts) {
            var _opts$attempts, _opts$attempts2;
            var maxAttempts, foundInfo, attempt, _opts$sleepStrategy;
            return _regeneratorRuntime().wrap(function _callee8$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  maxAttempts = ((_opts$attempts = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts !== void 0 ? _opts$attempts : 0) < 1 ? DEFAULT_GET_TRANSACTION_TIMEOUT : (_opts$attempts2 = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts2 !== void 0 ? _opts$attempts2 : DEFAULT_GET_TRANSACTION_TIMEOUT;
                  attempt = 1;
                case 2:
                  if (!(attempt < maxAttempts)) {
                    _context8.next = 13;
                    break;
                  }
                  _context8.next = 5;
                  return this.getTransaction(hash2);
                case 5:
                  foundInfo = _context8.sent;
                  if (!(foundInfo.status !== _api.Api.GetTransactionStatus.NOT_FOUND)) {
                    _context8.next = 8;
                    break;
                  }
                  return _context8.abrupt("return", foundInfo);
                case 8:
                  _context8.next = 10;
                  return _utils.Utils.sleep(((_opts$sleepStrategy = opts === null || opts === void 0 ? void 0 : opts.sleepStrategy) !== null && _opts$sleepStrategy !== void 0 ? _opts$sleepStrategy : BasicSleepStrategy)(attempt));
                case 10:
                  attempt++;
                  _context8.next = 2;
                  break;
                case 13:
                  return _context8.abrupt("return", foundInfo);
                case 14:
                case "end":
                  return _context8.stop();
              }
            }, _callee8, this);
          }));
          function pollTransaction(_x6, _x7) {
            return _pollTransaction.apply(this, arguments);
          }
          return pollTransaction;
        }()
      }, {
        key: "getTransaction",
        value: function() {
          var _getTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(hash2) {
            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  return _context9.abrupt("return", this._getTransaction(hash2).then(function(raw) {
                    var foundInfo = {};
                    if (raw.status !== _api.Api.GetTransactionStatus.NOT_FOUND) {
                      Object.assign(foundInfo, (0, _parsers.parseTransactionInfo)(raw));
                    }
                    var result = _objectSpread({
                      status: raw.status,
                      txHash: hash2,
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTime: raw.latestLedgerCloseTime,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTime: raw.oldestLedgerCloseTime
                    }, foundInfo);
                    return result;
                  }));
                case 1:
                case "end":
                  return _context9.stop();
              }
            }, _callee9, this);
          }));
          function getTransaction(_x8) {
            return _getTransaction2.apply(this, arguments);
          }
          return getTransaction;
        }()
      }, {
        key: "_getTransaction",
        value: function() {
          var _getTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(hash2) {
            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  return _context10.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransaction", {
                    hash: hash2
                  }));
                case 1:
                case "end":
                  return _context10.stop();
              }
            }, _callee10, this);
          }));
          function _getTransaction(_x9) {
            return _getTransaction3.apply(this, arguments);
          }
          return _getTransaction;
        }()
      }, {
        key: "getTransactions",
        value: function() {
          var _getTransactions2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(request) {
            return _regeneratorRuntime().wrap(function _callee11$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  return _context11.abrupt("return", this._getTransactions(request).then(function(raw) {
                    var result = {
                      transactions: (raw.transactions || []).map(_parsers.parseRawTransactions),
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTimestamp: raw.latestLedgerCloseTimestamp,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTimestamp: raw.oldestLedgerCloseTimestamp,
                      cursor: raw.cursor
                    };
                    return result;
                  }));
                case 1:
                case "end":
                  return _context11.stop();
              }
            }, _callee11, this);
          }));
          function getTransactions(_x10) {
            return _getTransactions2.apply(this, arguments);
          }
          return getTransactions;
        }()
      }, {
        key: "_getTransactions",
        value: function() {
          var _getTransactions3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee12(request) {
            return _regeneratorRuntime().wrap(function _callee12$(_context12) {
              while (1) switch (_context12.prev = _context12.next) {
                case 0:
                  return _context12.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransactions", request));
                case 1:
                case "end":
                  return _context12.stop();
              }
            }, _callee12, this);
          }));
          function _getTransactions(_x11) {
            return _getTransactions3.apply(this, arguments);
          }
          return _getTransactions;
        }()
      }, {
        key: "getEvents",
        value: function() {
          var _getEvents2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee13(request) {
            return _regeneratorRuntime().wrap(function _callee13$(_context13) {
              while (1) switch (_context13.prev = _context13.next) {
                case 0:
                  return _context13.abrupt("return", this._getEvents(request).then(_parsers.parseRawEvents));
                case 1:
                case "end":
                  return _context13.stop();
              }
            }, _callee13, this);
          }));
          function getEvents(_x12) {
            return _getEvents2.apply(this, arguments);
          }
          return getEvents;
        }()
      }, {
        key: "_getEvents",
        value: function() {
          var _getEvents3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee14(request) {
            var _request$filters;
            return _regeneratorRuntime().wrap(function _callee14$(_context14) {
              while (1) switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getEvents", _objectSpread(_objectSpread({
                    filters: (_request$filters = request.filters) !== null && _request$filters !== void 0 ? _request$filters : [],
                    pagination: _objectSpread(_objectSpread({}, request.cursor && {
                      cursor: request.cursor
                    }), request.limit && {
                      limit: request.limit
                    })
                  }, request.startLedger && {
                    startLedger: request.startLedger
                  }), request.endLedger && {
                    endLedger: request.endLedger
                  })));
                case 1:
                case "end":
                  return _context14.stop();
              }
            }, _callee14, this);
          }));
          function _getEvents(_x13) {
            return _getEvents3.apply(this, arguments);
          }
          return _getEvents;
        }()
      }, {
        key: "getNetwork",
        value: function() {
          var _getNetwork = _asyncToGenerator(_regeneratorRuntime().mark(function _callee15() {
            return _regeneratorRuntime().wrap(function _callee15$(_context15) {
              while (1) switch (_context15.prev = _context15.next) {
                case 0:
                  return _context15.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getNetwork"));
                case 1:
                case "end":
                  return _context15.stop();
              }
            }, _callee15, this);
          }));
          function getNetwork() {
            return _getNetwork.apply(this, arguments);
          }
          return getNetwork;
        }()
      }, {
        key: "getLatestLedger",
        value: function() {
          var _getLatestLedger = _asyncToGenerator(_regeneratorRuntime().mark(function _callee16() {
            return _regeneratorRuntime().wrap(function _callee16$(_context16) {
              while (1) switch (_context16.prev = _context16.next) {
                case 0:
                  return _context16.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLatestLedger"));
                case 1:
                case "end":
                  return _context16.stop();
              }
            }, _callee16, this);
          }));
          function getLatestLedger() {
            return _getLatestLedger.apply(this, arguments);
          }
          return getLatestLedger;
        }()
      }, {
        key: "simulateTransaction",
        value: function() {
          var _simulateTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee17(tx, addlResources) {
            return _regeneratorRuntime().wrap(function _callee17$(_context17) {
              while (1) switch (_context17.prev = _context17.next) {
                case 0:
                  return _context17.abrupt("return", this._simulateTransaction(tx, addlResources).then(_parsers.parseRawSimulation));
                case 1:
                case "end":
                  return _context17.stop();
              }
            }, _callee17, this);
          }));
          function simulateTransaction(_x14, _x15) {
            return _simulateTransaction2.apply(this, arguments);
          }
          return simulateTransaction;
        }()
      }, {
        key: "_simulateTransaction",
        value: function() {
          var _simulateTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee18(transaction, addlResources) {
            return _regeneratorRuntime().wrap(function _callee18$(_context18) {
              while (1) switch (_context18.prev = _context18.next) {
                case 0:
                  return _context18.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "simulateTransaction", _objectSpread({
                    transaction: transaction.toXDR()
                  }, addlResources !== void 0 && {
                    resourceConfig: {
                      instructionLeeway: addlResources.cpuInstructions
                    }
                  })));
                case 1:
                case "end":
                  return _context18.stop();
              }
            }, _callee18, this);
          }));
          function _simulateTransaction(_x16, _x17) {
            return _simulateTransaction3.apply(this, arguments);
          }
          return _simulateTransaction;
        }()
      }, {
        key: "prepareTransaction",
        value: function() {
          var _prepareTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee19(tx) {
            var simResponse;
            return _regeneratorRuntime().wrap(function _callee19$(_context19) {
              while (1) switch (_context19.prev = _context19.next) {
                case 0:
                  _context19.next = 2;
                  return this.simulateTransaction(tx);
                case 2:
                  simResponse = _context19.sent;
                  if (!_api.Api.isSimulationError(simResponse)) {
                    _context19.next = 5;
                    break;
                  }
                  throw new Error(simResponse.error);
                case 5:
                  return _context19.abrupt("return", (0, _transaction.assembleTransaction)(tx, simResponse).build());
                case 6:
                case "end":
                  return _context19.stop();
              }
            }, _callee19, this);
          }));
          function prepareTransaction(_x18) {
            return _prepareTransaction.apply(this, arguments);
          }
          return prepareTransaction;
        }()
      }, {
        key: "sendTransaction",
        value: function() {
          var _sendTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee20(transaction) {
            return _regeneratorRuntime().wrap(function _callee20$(_context20) {
              while (1) switch (_context20.prev = _context20.next) {
                case 0:
                  return _context20.abrupt("return", this._sendTransaction(transaction).then(_parsers.parseRawSendTransaction));
                case 1:
                case "end":
                  return _context20.stop();
              }
            }, _callee20, this);
          }));
          function sendTransaction(_x19) {
            return _sendTransaction2.apply(this, arguments);
          }
          return sendTransaction;
        }()
      }, {
        key: "_sendTransaction",
        value: function() {
          var _sendTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee21(transaction) {
            return _regeneratorRuntime().wrap(function _callee21$(_context21) {
              while (1) switch (_context21.prev = _context21.next) {
                case 0:
                  return _context21.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "sendTransaction", {
                    transaction: transaction.toXDR()
                  }));
                case 1:
                case "end":
                  return _context21.stop();
              }
            }, _callee21, this);
          }));
          function _sendTransaction(_x20) {
            return _sendTransaction3.apply(this, arguments);
          }
          return _sendTransaction;
        }()
      }, {
        key: "requestAirdrop",
        value: function() {
          var _requestAirdrop = _asyncToGenerator(_regeneratorRuntime().mark(function _callee22(address, friendbotUrl) {
            var account, response, meta, txMeta, sequence, _error$response, _error$response$detai;
            return _regeneratorRuntime().wrap(function _callee22$(_context22) {
              while (1) switch (_context22.prev = _context22.next) {
                case 0:
                  account = typeof address === "string" ? address : address.accountId();
                  _context22.t0 = friendbotUrl;
                  if (_context22.t0) {
                    _context22.next = 6;
                    break;
                  }
                  _context22.next = 5;
                  return this.getNetwork();
                case 5:
                  _context22.t0 = _context22.sent.friendbotUrl;
                case 6:
                  friendbotUrl = _context22.t0;
                  if (friendbotUrl) {
                    _context22.next = 9;
                    break;
                  }
                  throw new Error("No friendbot URL configured for current network");
                case 9:
                  _context22.prev = 9;
                  _context22.next = 12;
                  return _axios.default.post("".concat(friendbotUrl, "?addr=").concat(encodeURIComponent(account)));
                case 12:
                  response = _context22.sent;
                  if (response.data.result_meta_xdr) {
                    _context22.next = 22;
                    break;
                  }
                  _context22.next = 16;
                  return this.getTransaction(response.data.hash);
                case 16:
                  txMeta = _context22.sent;
                  if (!(txMeta.status !== _api.Api.GetTransactionStatus.SUCCESS)) {
                    _context22.next = 19;
                    break;
                  }
                  throw new Error("Funding account ".concat(address, " failed"));
                case 19:
                  meta = txMeta.resultMetaXdr;
                  _context22.next = 23;
                  break;
                case 22:
                  meta = _stellarBase.xdr.TransactionMeta.fromXDR(response.data.result_meta_xdr, "base64");
                case 23:
                  sequence = findCreatedAccountSequenceInTransactionMeta(meta);
                  return _context22.abrupt("return", new _stellarBase.Account(account, sequence));
                case 27:
                  _context22.prev = 27;
                  _context22.t1 = _context22["catch"](9);
                  if (!(((_error$response = _context22.t1.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 400)) {
                    _context22.next = 32;
                    break;
                  }
                  if (!((_error$response$detai = _context22.t1.response.detail) !== null && _error$response$detai !== void 0 && _error$response$detai.includes("createAccountAlreadyExist"))) {
                    _context22.next = 32;
                    break;
                  }
                  return _context22.abrupt("return", this.getAccount(account));
                case 32:
                  throw _context22.t1;
                case 33:
                case "end":
                  return _context22.stop();
              }
            }, _callee22, this, [[9, 27]]);
          }));
          function requestAirdrop(_x21, _x22) {
            return _requestAirdrop.apply(this, arguments);
          }
          return requestAirdrop;
        }()
      }, {
        key: "getFeeStats",
        value: function() {
          var _getFeeStats = _asyncToGenerator(_regeneratorRuntime().mark(function _callee23() {
            return _regeneratorRuntime().wrap(function _callee23$(_context23) {
              while (1) switch (_context23.prev = _context23.next) {
                case 0:
                  return _context23.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getFeeStats"));
                case 1:
                case "end":
                  return _context23.stop();
              }
            }, _callee23, this);
          }));
          function getFeeStats() {
            return _getFeeStats.apply(this, arguments);
          }
          return getFeeStats;
        }()
      }, {
        key: "getVersionInfo",
        value: function() {
          var _getVersionInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee24() {
            return _regeneratorRuntime().wrap(function _callee24$(_context24) {
              while (1) switch (_context24.prev = _context24.next) {
                case 0:
                  return _context24.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getVersionInfo"));
                case 1:
                case "end":
                  return _context24.stop();
              }
            }, _callee24, this);
          }));
          function getVersionInfo() {
            return _getVersionInfo.apply(this, arguments);
          }
          return getVersionInfo;
        }()
      }, {
        key: "getSACBalance",
        value: function() {
          var _getSACBalance = _asyncToGenerator(_regeneratorRuntime().mark(function _callee25(contractId, sac, networkPassphrase) {
            var passphrase, sacId, key, ledgerKey, response, _response$entries$2, lastModifiedLedgerSeq, liveUntilLedgerSeq, val, entry;
            return _regeneratorRuntime().wrap(function _callee25$(_context25) {
              while (1) switch (_context25.prev = _context25.next) {
                case 0:
                  if (_stellarBase.StrKey.isValidContract(contractId)) {
                    _context25.next = 2;
                    break;
                  }
                  throw new TypeError("expected contract ID, got ".concat(contractId));
                case 2:
                  if (!(networkPassphrase !== null && networkPassphrase !== void 0)) {
                    _context25.next = 6;
                    break;
                  }
                  _context25.t0 = networkPassphrase;
                  _context25.next = 9;
                  break;
                case 6:
                  _context25.next = 8;
                  return this.getNetwork().then(function(n) {
                    return n.passphrase;
                  });
                case 8:
                  _context25.t0 = _context25.sent;
                case 9:
                  passphrase = _context25.t0;
                  sacId = sac.contractId(passphrase);
                  key = _stellarBase.xdr.ScVal.scvVec([(0, _stellarBase.nativeToScVal)("Balance", {
                    type: "symbol"
                  }), (0, _stellarBase.nativeToScVal)(contractId, {
                    type: "address"
                  })]);
                  ledgerKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    contract: new _stellarBase.Address(sacId).toScAddress(),
                    durability: _stellarBase.xdr.ContractDataDurability.persistent(),
                    key
                  }));
                  _context25.next = 15;
                  return this.getLedgerEntries(ledgerKey);
                case 15:
                  response = _context25.sent;
                  if (!(response.entries.length === 0)) {
                    _context25.next = 18;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 18:
                  _response$entries$2 = response.entries[0], lastModifiedLedgerSeq = _response$entries$2.lastModifiedLedgerSeq, liveUntilLedgerSeq = _response$entries$2.liveUntilLedgerSeq, val = _response$entries$2.val;
                  if (!(val.switch().value !== _stellarBase.xdr.LedgerEntryType.contractData().value)) {
                    _context25.next = 21;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 21:
                  entry = (0, _stellarBase.scValToNative)(val.contractData().val());
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger,
                    balanceEntry: {
                      liveUntilLedgerSeq,
                      lastModifiedLedgerSeq,
                      amount: entry.amount.toString(),
                      authorized: entry.authorized,
                      clawback: entry.clawback
                    }
                  });
                case 23:
                case "end":
                  return _context25.stop();
              }
            }, _callee25, this);
          }));
          function getSACBalance(_x23, _x24, _x25) {
            return _getSACBalance.apply(this, arguments);
          }
          return getSACBalance;
        }()
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/index.js
var require_rpc2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      Server: true,
      BasicSleepStrategy: true,
      LinearSleepStrategy: true,
      Durability: true,
      AxiosClient: true,
      parseRawSimulation: true,
      parseRawEvents: true
    };
    Object.defineProperty(exports, "AxiosClient", {
      enumerable: true,
      get: function get() {
        return _axios.default;
      }
    });
    Object.defineProperty(exports, "BasicSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.BasicSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Durability", {
      enumerable: true,
      get: function get() {
        return _server.Durability;
      }
    });
    Object.defineProperty(exports, "LinearSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.LinearSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Server", {
      enumerable: true,
      get: function get() {
        return _server.RpcServer;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "parseRawEvents", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawEvents;
      }
    });
    Object.defineProperty(exports, "parseRawSimulation", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawSimulation;
      }
    });
    var _api = require_api2();
    Object.keys(_api).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _api[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _api[key];
        }
      });
    });
    var _server = require_server2();
    var _axios = _interopRequireDefault(require_axios2());
    var _parsers = require_parsers2();
    var _transaction = require_transaction4();
    Object.keys(_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _transaction[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var _default = exports.default = module.exports;
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/rust_result.js
var require_rust_result2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/rust_result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Ok = exports.Err = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Ok = exports.Ok = function() {
      function Ok2(value) {
        _classCallCheck(this, Ok2);
        this.value = value;
      }
      return _createClass(Ok2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          throw new Error("No error");
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          return this.value;
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return true;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return false;
        }
      }]);
    }();
    var Err = exports.Err = function() {
      function Err2(error) {
        _classCallCheck(this, Err2);
        this.error = error;
      }
      return _createClass(Err2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          return this.error;
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          throw new Error(this.error.message);
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return false;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return true;
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/types.js
var require_types4 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NULL_ACCOUNT = exports.DEFAULT_TIMEOUT = void 0;
    var _stellarBase = require_lib2();
    var DEFAULT_TIMEOUT = exports.DEFAULT_TIMEOUT = 5 * 60;
    var NULL_ACCOUNT = exports.NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/utils.js
var require_utils4 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contractErrorPattern = void 0;
    exports.getAccount = getAccount;
    exports.implementsToString = implementsToString;
    exports.processSpecEntryStream = processSpecEntryStream;
    exports.withExponentialBackoff = withExponentialBackoff;
    var _stellarBase = require_lib2();
    var _types = require_types4();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function withExponentialBackoff(_x, _x2, _x3) {
      return _withExponentialBackoff.apply(this, arguments);
    }
    function _withExponentialBackoff() {
      _withExponentialBackoff = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(fn, keepWaitingIf, timeoutInSeconds) {
        var exponentialFactor, verbose, attempts, count, waitUntil, waitTime, totalWaitTime, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              exponentialFactor = _args.length > 3 && _args[3] !== void 0 ? _args[3] : 1.5;
              verbose = _args.length > 4 && _args[4] !== void 0 ? _args[4] : false;
              attempts = [];
              count = 0;
              _context.t0 = attempts;
              _context.next = 7;
              return fn();
            case 7:
              _context.t1 = _context.sent;
              _context.t0.push.call(_context.t0, _context.t1);
              if (keepWaitingIf(attempts[attempts.length - 1])) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", attempts);
            case 11:
              waitUntil = new Date(Date.now() + timeoutInSeconds * 1e3).valueOf();
              waitTime = 1e3;
              totalWaitTime = waitTime;
            case 14:
              if (!(Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1]))) {
                _context.next = 30;
                break;
              }
              count += 1;
              if (verbose) {
                console.info("Waiting ".concat(waitTime, "ms before trying again (bringing the total wait time to ").concat(totalWaitTime, "ms so far, of total ").concat(timeoutInSeconds * 1e3, "ms)"));
              }
              _context.next = 19;
              return new Promise(function(res) {
                return setTimeout(res, waitTime);
              });
            case 19:
              waitTime *= exponentialFactor;
              if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
                waitTime = waitUntil - Date.now();
                if (verbose) {
                  console.info("was gonna wait too long; new waitTime: ".concat(waitTime, "ms"));
                }
              }
              totalWaitTime = waitTime + totalWaitTime;
              _context.t2 = attempts;
              _context.next = 25;
              return fn(attempts[attempts.length - 1]);
            case 25:
              _context.t3 = _context.sent;
              _context.t2.push.call(_context.t2, _context.t3);
              if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {
                console.info("".concat(count, ". Called ").concat(fn, "; ").concat(attempts.length, " prev attempts. Most recent: ").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));
              }
              _context.next = 14;
              break;
            case 30:
              return _context.abrupt("return", attempts);
            case 31:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _withExponentialBackoff.apply(this, arguments);
    }
    var contractErrorPattern = exports.contractErrorPattern = /Error\(Contract, #(\d+)\)/;
    function implementsToString(obj) {
      return _typeof(obj) === "object" && obj !== null && "toString" in obj;
    }
    function processSpecEntryStream(buffer) {
      var reader = new _stellarBase.cereal.XdrReader(buffer);
      var res = [];
      while (!reader.eof) {
        res.push(_stellarBase.xdr.ScSpecEntry.read(reader));
      }
      return res;
    }
    function getAccount(_x4, _x5) {
      return _getAccount.apply(this, arguments);
    }
    function _getAccount() {
      _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(options, server) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", options.publicKey ? server.getAccount(options.publicKey) : new _stellarBase.Account(_types.NULL_ACCOUNT, "0"));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _getAccount.apply(this, arguments);
    }
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/sent_transaction.js
var require_sent_transaction2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/sent_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SentTransaction = void 0;
    var _rpc = require_rpc2();
    var _api = require_api2();
    var _utils = require_utils4();
    var _types = require_types4();
    var _SentTransaction;
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SentTransaction = exports.SentTransaction = function() {
      function SentTransaction2(assembled) {
        var _this = this, _this$assembled$optio2;
        _classCallCheck(this, SentTransaction2);
        _defineProperty(this, "send", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _this$assembled$optio;
          var hash2, timeoutInSeconds;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.server.sendTransaction(_this.assembled.signed);
              case 2:
                _this.sendTransactionResponse = _context.sent;
                if (!(_this.sendTransactionResponse.status !== "PENDING")) {
                  _context.next = 5;
                  break;
                }
                throw new SentTransaction2.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(_this.sendTransactionResponse, null, 2)));
              case 5:
                hash2 = _this.sendTransactionResponse.hash;
                timeoutInSeconds = (_this$assembled$optio = _this.assembled.options.timeoutInSeconds) !== null && _this$assembled$optio !== void 0 ? _this$assembled$optio : _types.DEFAULT_TIMEOUT;
                _context.next = 9;
                return (0, _utils.withExponentialBackoff)(function() {
                  return _this.server.getTransaction(hash2);
                }, function(resp) {
                  return resp.status === _api.Api.GetTransactionStatus.NOT_FOUND;
                }, timeoutInSeconds);
              case 9:
                _this.getTransactionResponseAll = _context.sent;
                _this.getTransactionResponse = _this.getTransactionResponseAll[_this.getTransactionResponseAll.length - 1];
                if (!(_this.getTransactionResponse.status === _api.Api.GetTransactionStatus.NOT_FOUND)) {
                  _context.next = 13;
                  break;
                }
                throw new SentTransaction2.Errors.TransactionStillPending("Waited ".concat(timeoutInSeconds, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(_this.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(_this.getTransactionResponseAll, null, 2)));
              case 13:
                return _context.abrupt("return", _this);
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        this.assembled = assembled;
        this.server = new _rpc.Server(this.assembled.options.rpcUrl, {
          allowHttp: (_this$assembled$optio2 = this.assembled.options.allowHttp) !== null && _this$assembled$optio2 !== void 0 ? _this$assembled$optio2 : false
        });
      }
      return _createClass(SentTransaction2, [{
        key: "result",
        get: function get() {
          if ("getTransactionResponse" in this && this.getTransactionResponse) {
            if ("returnValue" in this.getTransactionResponse) {
              return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
            }
            throw new Error("Transaction failed! Cannot parse result.");
          }
          if (this.sendTransactionResponse) {
            var _this$sendTransaction;
            var errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();
            if (errorResult) {
              throw new SentTransaction2.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(errorResult));
            }
            throw new SentTransaction2.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
          }
          throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
        }
      }]);
    }();
    _SentTransaction = SentTransaction;
    _defineProperty(SentTransaction, "Errors", {
      SendFailed: function(_Error) {
        function SendFailedError() {
          _classCallCheck(this, SendFailedError);
          return _callSuper(this, SendFailedError, arguments);
        }
        _inherits(SendFailedError, _Error);
        return _createClass(SendFailedError);
      }(_wrapNativeSuper(Error)),
      SendResultOnly: function(_Error2) {
        function SendResultOnlyError() {
          _classCallCheck(this, SendResultOnlyError);
          return _callSuper(this, SendResultOnlyError, arguments);
        }
        _inherits(SendResultOnlyError, _Error2);
        return _createClass(SendResultOnlyError);
      }(_wrapNativeSuper(Error)),
      TransactionStillPending: function(_Error3) {
        function TransactionStillPendingError() {
          _classCallCheck(this, TransactionStillPendingError);
          return _callSuper(this, TransactionStillPendingError, arguments);
        }
        _inherits(TransactionStillPendingError, _Error3);
        return _createClass(TransactionStillPendingError);
      }(_wrapNativeSuper(Error))
    });
    _defineProperty(SentTransaction, "init", function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(assembled) {
        var tx, sent;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              tx = new _SentTransaction(assembled);
              _context2.next = 3;
              return tx.send();
            case 3:
              sent = _context2.sent;
              return _context2.abrupt("return", sent);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/assembled_transaction.js
var require_assembled_transaction2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/assembled_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AssembledTransaction = void 0;
    var _stellarBase = require_lib2();
    var _rpc = require_rpc2();
    var _api = require_api2();
    var _transaction = require_transaction4();
    var _rust_result = require_rust_result2();
    var _utils = require_utils4();
    var _types = require_types4();
    var _sent_transaction = require_sent_transaction2();
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var AssembledTransaction5 = exports.AssembledTransaction = function() {
      function AssembledTransaction6(options) {
        var _this = this, _this$options$simulat, _this$options$allowHt;
        _classCallCheck(this, AssembledTransaction6);
        _defineProperty(this, "simulate", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _ref2, restore, account, result, _this$options$fee, _this$options$args, _this$options$timeout, contract, _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, restore = _ref2.restore;
                if (_this.built) {
                  _context.next = 5;
                  break;
                }
                if (_this.raw) {
                  _context.next = 4;
                  break;
                }
                throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
              case 4:
                _this.built = _this.raw.build();
              case 5:
                restore = restore !== null && restore !== void 0 ? restore : _this.options.restore;
                delete _this.simulationResult;
                delete _this.simulationTransactionData;
                _context.next = 10;
                return _this.server.simulateTransaction(_this.built);
              case 10:
                _this.simulation = _context.sent;
                if (!(restore && _api.Api.isSimulationRestore(_this.simulation))) {
                  _context.next = 25;
                  break;
                }
                _context.next = 14;
                return (0, _utils.getAccount)(_this.options, _this.server);
              case 14:
                account = _context.sent;
                _context.next = 17;
                return _this.restoreFootprint(_this.simulation.restorePreamble, account);
              case 17:
                result = _context.sent;
                if (!(result.status === _api.Api.GetTransactionStatus.SUCCESS)) {
                  _context.next = 24;
                  break;
                }
                contract = new _stellarBase.Contract(_this.options.contractId);
                _this.raw = new _stellarBase.TransactionBuilder(account, {
                  fee: (_this$options$fee = _this.options.fee) !== null && _this$options$fee !== void 0 ? _this$options$fee : _stellarBase.BASE_FEE,
                  networkPassphrase: _this.options.networkPassphrase
                }).addOperation(contract.call.apply(contract, [_this.options.method].concat(_toConsumableArray((_this$options$args = _this.options.args) !== null && _this$options$args !== void 0 ? _this$options$args : [])))).setTimeout((_this$options$timeout = _this.options.timeoutInSeconds) !== null && _this$options$timeout !== void 0 ? _this$options$timeout : _types.DEFAULT_TIMEOUT);
                _context.next = 23;
                return _this.simulate();
              case 23:
                return _context.abrupt("return", _this);
              case 24:
                throw new AssembledTransaction6.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(result)));
              case 25:
                if (_api.Api.isSimulationSuccess(_this.simulation)) {
                  _this.built = (0, _transaction.assembleTransaction)(_this.built, _this.simulation).build();
                }
                return _context.abrupt("return", _this);
              case 27:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        _defineProperty(this, "sign", _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
          var _this$options$timeout2;
          var _ref4, _ref4$force, force, _ref4$signTransaction, signTransaction, sigsNeeded, timeoutInSeconds, signOpts, _yield$signTransactio, signature, error, _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _ref4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref4$force = _ref4.force, force = _ref4$force === void 0 ? false : _ref4$force, _ref4$signTransaction = _ref4.signTransaction, signTransaction = _ref4$signTransaction === void 0 ? _this.options.signTransaction : _ref4$signTransaction;
                if (_this.built) {
                  _context2.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been simulated");
              case 3:
                if (!(!force && _this.isReadCall)) {
                  _context2.next = 5;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
              case 5:
                if (signTransaction) {
                  _context2.next = 7;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
              case 7:
                sigsNeeded = _this.needsNonInvokerSigningBy().filter(function(id) {
                  return !id.startsWith("C");
                });
                if (!sigsNeeded.length) {
                  _context2.next = 10;
                  break;
                }
                throw new AssembledTransaction6.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(sigsNeeded, ". ") + "See `needsNonInvokerSigningBy` for details.");
              case 10:
                timeoutInSeconds = (_this$options$timeout2 = _this.options.timeoutInSeconds) !== null && _this$options$timeout2 !== void 0 ? _this$options$timeout2 : _types.DEFAULT_TIMEOUT;
                _this.built = _stellarBase.TransactionBuilder.cloneFrom(_this.built, {
                  fee: _this.built.fee,
                  timebounds: void 0,
                  sorobanData: _this.simulationData.transactionData
                }).setTimeout(timeoutInSeconds).build();
                signOpts = {
                  networkPassphrase: _this.options.networkPassphrase
                };
                if (_this.options.address) signOpts.address = _this.options.address;
                if (_this.options.submit !== void 0) signOpts.submit = _this.options.submit;
                if (_this.options.submitUrl) signOpts.submitUrl = _this.options.submitUrl;
                _context2.next = 18;
                return signTransaction(_this.built.toXDR(), signOpts);
              case 18:
                _yield$signTransactio = _context2.sent;
                signature = _yield$signTransactio.signedTxXdr;
                error = _yield$signTransactio.error;
                _this.handleWalletError(error);
                _this.signed = _stellarBase.TransactionBuilder.fromXDR(signature, _this.options.networkPassphrase);
              case 23:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        })));
        _defineProperty(this, "signAndSend", _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
          var _ref6, _ref6$force, force, _ref6$signTransaction, signTransaction, originalSubmit, _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _ref6 = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {}, _ref6$force = _ref6.force, force = _ref6$force === void 0 ? false : _ref6$force, _ref6$signTransaction = _ref6.signTransaction, signTransaction = _ref6$signTransaction === void 0 ? _this.options.signTransaction : _ref6$signTransaction;
                if (_this.signed) {
                  _context3.next = 10;
                  break;
                }
                originalSubmit = _this.options.submit;
                if (_this.options.submit) {
                  _this.options.submit = false;
                }
                _context3.prev = 4;
                _context3.next = 7;
                return _this.sign({
                  force,
                  signTransaction
                });
              case 7:
                _context3.prev = 7;
                _this.options.submit = originalSubmit;
                return _context3.finish(7);
              case 10:
                return _context3.abrupt("return", _this.send());
              case 11:
              case "end":
                return _context3.stop();
            }
          }, _callee3, null, [[4, , 7, 10]]);
        })));
        _defineProperty(this, "needsNonInvokerSigningBy", function() {
          var _rawInvokeHostFunctio;
          var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$includeAlreadyS = _ref7.includeAlreadySigned, includeAlreadySigned = _ref7$includeAlreadyS === void 0 ? false : _ref7$includeAlreadyS;
          if (!_this.built) {
            throw new Error("Transaction has not yet been simulated");
          }
          if (!("operations" in _this.built)) {
            throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(_this.built)));
          }
          var rawInvokeHostFunctionOp = _this.built.operations[0];
          return _toConsumableArray(new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(function(entry) {
            return entry.credentials().switch() === _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === "scvVoid");
          }).map(function(entry) {
            return _stellarBase.Address.fromScAddress(entry.credentials().address().address()).toString();
          })));
        });
        _defineProperty(this, "signAuthEntries", _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
          var _rawInvokeHostFunctio2;
          var _ref9, _ref9$expiration, expiration, _ref9$signAuthEntry, signAuthEntry, _ref9$address, address, _ref9$authorizeEntry, authorizeEntry, needsNonInvokerSigningBy, rawInvokeHostFunctionOp, authEntries, _iterator, _step, _loop, _ret, _args7 = arguments;
          return _regeneratorRuntime().wrap(function _callee6$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _ref9 = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {}, _ref9$expiration = _ref9.expiration, expiration = _ref9$expiration === void 0 ? _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _this.server.getLatestLedger();
                      case 2:
                        _context4.t0 = _context4.sent.sequence;
                        return _context4.abrupt("return", _context4.t0 + 100);
                      case 4:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }))() : _ref9$expiration, _ref9$signAuthEntry = _ref9.signAuthEntry, signAuthEntry = _ref9$signAuthEntry === void 0 ? _this.options.signAuthEntry : _ref9$signAuthEntry, _ref9$address = _ref9.address, address = _ref9$address === void 0 ? _this.options.publicKey : _ref9$address, _ref9$authorizeEntry = _ref9.authorizeEntry, authorizeEntry = _ref9$authorizeEntry === void 0 ? _stellarBase.authorizeEntry : _ref9$authorizeEntry;
                if (_this.built) {
                  _context7.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been assembled or simulated");
              case 3:
                if (!(authorizeEntry === _stellarBase.authorizeEntry)) {
                  _context7.next = 11;
                  break;
                }
                needsNonInvokerSigningBy = _this.needsNonInvokerSigningBy();
                if (!(needsNonInvokerSigningBy.length === 0)) {
                  _context7.next = 7;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
              case 7:
                if (!(needsNonInvokerSigningBy.indexOf(address !== null && address !== void 0 ? address : "") === -1)) {
                  _context7.next = 9;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(address, '"'));
              case 9:
                if (signAuthEntry) {
                  _context7.next = 11;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
              case 11:
                rawInvokeHostFunctionOp = _this.built.operations[0];
                authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];
                _iterator = _createForOfIteratorHelper(authEntries.entries());
                _context7.prev = 14;
                _loop = _regeneratorRuntime().mark(function _loop2() {
                  var _step$value, i, entry, credentials, authEntryAddress, sign;
                  return _regeneratorRuntime().wrap(function _loop$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _step$value = _slicedToArray(_step.value, 2), i = _step$value[0], entry = _step$value[1];
                        credentials = _stellarBase.xdr.SorobanCredentials.fromXDR(entry.credentials().toXDR());
                        if (!(credentials.switch() !== _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress())) {
                          _context6.next = 4;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 4:
                        authEntryAddress = _stellarBase.Address.fromScAddress(credentials.address().address()).toString();
                        if (!(authEntryAddress !== address)) {
                          _context6.next = 7;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 7:
                        sign = signAuthEntry !== null && signAuthEntry !== void 0 ? signAuthEntry : Promise.resolve;
                        _context6.t0 = authorizeEntry;
                        _context6.t1 = entry;
                        _context6.t2 = function() {
                          var _ref11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(preimage) {
                            var _yield$sign, signedAuthEntry, error;
                            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                              while (1) switch (_context5.prev = _context5.next) {
                                case 0:
                                  _context5.next = 2;
                                  return sign(preimage.toXDR("base64"), {
                                    address
                                  });
                                case 2:
                                  _yield$sign = _context5.sent;
                                  signedAuthEntry = _yield$sign.signedAuthEntry;
                                  error = _yield$sign.error;
                                  _this.handleWalletError(error);
                                  return _context5.abrupt("return", Buffer.from(signedAuthEntry, "base64"));
                                case 7:
                                case "end":
                                  return _context5.stop();
                              }
                            }, _callee5);
                          }));
                          return function(_x) {
                            return _ref11.apply(this, arguments);
                          };
                        }();
                        _context6.next = 13;
                        return expiration;
                      case 13:
                        _context6.t3 = _context6.sent;
                        _context6.t4 = _this.options.networkPassphrase;
                        _context6.next = 17;
                        return (0, _context6.t0)(_context6.t1, _context6.t2, _context6.t3, _context6.t4);
                      case 17:
                        authEntries[i] = _context6.sent;
                      case 18:
                      case "end":
                        return _context6.stop();
                    }
                  }, _loop2);
                });
                _iterator.s();
              case 17:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 24;
                  break;
                }
                return _context7.delegateYield(_loop(), "t0", 19);
              case 19:
                _ret = _context7.t0;
                if (!(_ret === 0)) {
                  _context7.next = 22;
                  break;
                }
                return _context7.abrupt("continue", 22);
              case 22:
                _context7.next = 17;
                break;
              case 24:
                _context7.next = 29;
                break;
              case 26:
                _context7.prev = 26;
                _context7.t1 = _context7["catch"](14);
                _iterator.e(_context7.t1);
              case 29:
                _context7.prev = 29;
                _iterator.f();
                return _context7.finish(29);
              case 32:
              case "end":
                return _context7.stop();
            }
          }, _callee6, null, [[14, 26, 29, 32]]);
        })));
        this.options = options;
        this.options.simulate = (_this$options$simulat = this.options.simulate) !== null && _this$options$simulat !== void 0 ? _this$options$simulat : true;
        this.server = new _rpc.Server(this.options.rpcUrl, {
          allowHttp: (_this$options$allowHt = this.options.allowHttp) !== null && _this$options$allowHt !== void 0 ? _this$options$allowHt : false
        });
      }
      return _createClass(AssembledTransaction6, [{
        key: "toJSON",
        value: function toJSON() {
          var _this$built;
          return JSON.stringify({
            method: this.options.method,
            tx: (_this$built = this.built) === null || _this$built === void 0 ? void 0 : _this$built.toXDR(),
            simulationResult: {
              auth: this.simulationData.result.auth.map(function(a) {
                return a.toXDR("base64");
              }),
              retval: this.simulationData.result.retval.toXDR("base64")
            },
            simulationTransactionData: this.simulationData.transactionData.toXDR("base64")
          });
        }
      }, {
        key: "toXDR",
        value: function toXDR() {
          var _this$built2;
          if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
          return (_this$built2 = this.built) === null || _this$built2 === void 0 ? void 0 : _this$built2.toEnvelope().toXDR("base64");
        }
      }, {
        key: "handleWalletError",
        value: function handleWalletError(error) {
          if (!error) return;
          var message = error.message, code = error.code;
          var fullMessage = "".concat(message).concat(error.ext ? " (".concat(error.ext.join(", "), ")") : "");
          switch (code) {
            case -1:
              throw new AssembledTransaction6.Errors.InternalWalletError(fullMessage);
            case -2:
              throw new AssembledTransaction6.Errors.ExternalServiceError(fullMessage);
            case -3:
              throw new AssembledTransaction6.Errors.InvalidClientRequest(fullMessage);
            case -4:
              throw new AssembledTransaction6.Errors.UserRejected(fullMessage);
            default:
              throw new Error("Unhandled error: ".concat(fullMessage));
          }
        }
      }, {
        key: "simulationData",
        get: function get() {
          var _simulation$result;
          if (this.simulationResult && this.simulationTransactionData) {
            return {
              result: this.simulationResult,
              transactionData: this.simulationTransactionData
            };
          }
          var simulation = this.simulation;
          if (!simulation) {
            throw new AssembledTransaction6.Errors.NotYetSimulated("Transaction has not yet been simulated");
          }
          if (_api.Api.isSimulationError(simulation)) {
            throw new AssembledTransaction6.Errors.SimulationFailed('Transaction simulation failed: "'.concat(simulation.error, '"'));
          }
          if (_api.Api.isSimulationRestore(simulation)) {
            throw new AssembledTransaction6.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
          }
          this.simulationResult = (_simulation$result = simulation.result) !== null && _simulation$result !== void 0 ? _simulation$result : {
            auth: [],
            retval: _stellarBase.xdr.ScVal.scvVoid()
          };
          this.simulationTransactionData = simulation.transactionData.build();
          return {
            result: this.simulationResult,
            transactionData: this.simulationTransactionData
          };
        }
      }, {
        key: "result",
        get: function get() {
          try {
            if (!this.simulationData.result) {
              throw new Error("No simulation result!");
            }
            return this.options.parseResultXdr(this.simulationData.result.retval);
          } catch (e) {
            if (!(0, _utils.implementsToString)(e)) throw e;
            var err = this.parseError(e.toString());
            if (err) return err;
            throw e;
          }
        }
      }, {
        key: "parseError",
        value: function parseError(errorMessage) {
          if (!this.options.errorTypes) return void 0;
          var match = errorMessage.match(_utils.contractErrorPattern);
          if (!match) return void 0;
          var i = parseInt(match[1], 10);
          var err = this.options.errorTypes[i];
          if (!err) return void 0;
          return new _rust_result.Err(err);
        }
      }, {
        key: "send",
        value: function() {
          var _send = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var sent;
            return _regeneratorRuntime().wrap(function _callee7$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  if (this.signed) {
                    _context8.next = 2;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 2:
                  _context8.next = 4;
                  return _sent_transaction.SentTransaction.init(this);
                case 4:
                  sent = _context8.sent;
                  return _context8.abrupt("return", sent);
                case 6:
                case "end":
                  return _context8.stop();
              }
            }, _callee7, this);
          }));
          function send() {
            return _send.apply(this, arguments);
          }
          return send;
        }()
      }, {
        key: "isReadCall",
        get: function get() {
          var authsCount = this.simulationData.result.auth.length;
          var writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;
          return authsCount === 0 && writeLength === 0;
        }
      }, {
        key: "restoreFootprint",
        value: function() {
          var _restoreFootprint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(restorePreamble, account) {
            var restoreTx, sentTransaction;
            return _regeneratorRuntime().wrap(function _callee8$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  if (this.options.signTransaction) {
                    _context9.next = 2;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 2:
                  if (!(account !== null && account !== void 0)) {
                    _context9.next = 6;
                    break;
                  }
                  _context9.t0 = account;
                  _context9.next = 9;
                  break;
                case 6:
                  _context9.next = 8;
                  return (0, _utils.getAccount)(this.options, this.server);
                case 8:
                  _context9.t0 = _context9.sent;
                case 9:
                  account = _context9.t0;
                  _context9.next = 12;
                  return AssembledTransaction6.buildFootprintRestoreTransaction(_objectSpread({}, this.options), restorePreamble.transactionData, account, restorePreamble.minResourceFee);
                case 12:
                  restoreTx = _context9.sent;
                  _context9.next = 15;
                  return restoreTx.signAndSend();
                case 15:
                  sentTransaction = _context9.sent;
                  if (sentTransaction.getTransactionResponse) {
                    _context9.next = 18;
                    break;
                  }
                  throw new AssembledTransaction6.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(sentTransaction)));
                case 18:
                  return _context9.abrupt("return", sentTransaction.getTransactionResponse);
                case 19:
                case "end":
                  return _context9.stop();
              }
            }, _callee8, this);
          }));
          function restoreFootprint(_x2, _x3) {
            return _restoreFootprint.apply(this, arguments);
          }
          return restoreFootprint;
        }()
      }], [{
        key: "fromJSON",
        value: function fromJSON(options, _ref12) {
          var tx = _ref12.tx, simulationResult = _ref12.simulationResult, simulationTransactionData = _ref12.simulationTransactionData;
          var txn = new AssembledTransaction6(options);
          txn.built = _stellarBase.TransactionBuilder.fromXDR(tx, options.networkPassphrase);
          txn.simulationResult = {
            auth: simulationResult.auth.map(function(a) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
            }),
            retval: _stellarBase.xdr.ScVal.fromXDR(simulationResult.retval, "base64")
          };
          txn.simulationTransactionData = _stellarBase.xdr.SorobanTransactionData.fromXDR(simulationTransactionData, "base64");
          return txn;
        }
      }, {
        key: "fromXDR",
        value: function fromXDR(options, encodedXDR, spec) {
          var _operation$func;
          var envelope = _stellarBase.xdr.TransactionEnvelope.fromXDR(encodedXDR, "base64");
          var built = _stellarBase.TransactionBuilder.fromXDR(envelope, options.networkPassphrase);
          var operation = built.operations[0];
          if (!(operation !== null && operation !== void 0 && (_operation$func = operation.func) !== null && _operation$func !== void 0 && _operation$func.value) || typeof operation.func.value !== "function") {
            throw new Error("Could not extract the method from the transaction envelope.");
          }
          var invokeContractArgs = operation.func.value();
          if (!(invokeContractArgs !== null && invokeContractArgs !== void 0 && invokeContractArgs.functionName)) {
            throw new Error("Could not extract the method name from the transaction envelope.");
          }
          var method = invokeContractArgs.functionName().toString("utf-8");
          var txn = new AssembledTransaction6(_objectSpread(_objectSpread({}, options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return spec.funcResToNative(method, result);
            }
          }));
          txn.built = built;
          return txn;
        }
      }, {
        key: "build",
        value: function build(options) {
          var _options$args;
          var contract = new _stellarBase.Contract(options.contractId);
          return AssembledTransaction6.buildWithOp(contract.call.apply(contract, [options.method].concat(_toConsumableArray((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))), options);
        }
      }, {
        key: "buildWithOp",
        value: function() {
          var _buildWithOp = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(operation, options) {
            var _options$fee, _options$timeoutInSec;
            var tx, account;
            return _regeneratorRuntime().wrap(function _callee9$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  tx = new AssembledTransaction6(options);
                  _context10.next = 3;
                  return (0, _utils.getAccount)(options, tx.server);
                case 3:
                  account = _context10.sent;
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee: (_options$fee = options.fee) !== null && _options$fee !== void 0 ? _options$fee : _stellarBase.BASE_FEE,
                    networkPassphrase: options.networkPassphrase
                  }).setTimeout((_options$timeoutInSec = options.timeoutInSeconds) !== null && _options$timeoutInSec !== void 0 ? _options$timeoutInSec : _types.DEFAULT_TIMEOUT).addOperation(operation);
                  if (!options.simulate) {
                    _context10.next = 8;
                    break;
                  }
                  _context10.next = 8;
                  return tx.simulate();
                case 8:
                  return _context10.abrupt("return", tx);
                case 9:
                case "end":
                  return _context10.stop();
              }
            }, _callee9);
          }));
          function buildWithOp(_x4, _x5) {
            return _buildWithOp.apply(this, arguments);
          }
          return buildWithOp;
        }()
      }, {
        key: "buildFootprintRestoreTransaction",
        value: function() {
          var _buildFootprintRestoreTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(options, sorobanData, account, fee) {
            var _options$timeoutInSec2;
            var tx;
            return _regeneratorRuntime().wrap(function _callee10$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  tx = new AssembledTransaction6(options);
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee,
                    networkPassphrase: options.networkPassphrase
                  }).setSorobanData(sorobanData instanceof _stellarBase.SorobanDataBuilder ? sorobanData.build() : sorobanData).addOperation(_stellarBase.Operation.restoreFootprint({})).setTimeout((_options$timeoutInSec2 = options.timeoutInSeconds) !== null && _options$timeoutInSec2 !== void 0 ? _options$timeoutInSec2 : _types.DEFAULT_TIMEOUT);
                  _context11.next = 4;
                  return tx.simulate({
                    restore: false
                  });
                case 4:
                  return _context11.abrupt("return", tx);
                case 5:
                case "end":
                  return _context11.stop();
              }
            }, _callee10);
          }));
          function buildFootprintRestoreTransaction(_x6, _x7, _x8, _x9) {
            return _buildFootprintRestoreTransaction.apply(this, arguments);
          }
          return buildFootprintRestoreTransaction;
        }()
      }]);
    }();
    _defineProperty(AssembledTransaction5, "Errors", {
      ExpiredState: function(_Error) {
        function ExpiredStateError() {
          _classCallCheck(this, ExpiredStateError);
          return _callSuper(this, ExpiredStateError, arguments);
        }
        _inherits(ExpiredStateError, _Error);
        return _createClass(ExpiredStateError);
      }(_wrapNativeSuper(Error)),
      RestorationFailure: function(_Error2) {
        function RestoreFailureError() {
          _classCallCheck(this, RestoreFailureError);
          return _callSuper(this, RestoreFailureError, arguments);
        }
        _inherits(RestoreFailureError, _Error2);
        return _createClass(RestoreFailureError);
      }(_wrapNativeSuper(Error)),
      NeedsMoreSignatures: function(_Error3) {
        function NeedsMoreSignaturesError() {
          _classCallCheck(this, NeedsMoreSignaturesError);
          return _callSuper(this, NeedsMoreSignaturesError, arguments);
        }
        _inherits(NeedsMoreSignaturesError, _Error3);
        return _createClass(NeedsMoreSignaturesError);
      }(_wrapNativeSuper(Error)),
      NoSignatureNeeded: function(_Error4) {
        function NoSignatureNeededError() {
          _classCallCheck(this, NoSignatureNeededError);
          return _callSuper(this, NoSignatureNeededError, arguments);
        }
        _inherits(NoSignatureNeededError, _Error4);
        return _createClass(NoSignatureNeededError);
      }(_wrapNativeSuper(Error)),
      NoUnsignedNonInvokerAuthEntries: function(_Error5) {
        function NoUnsignedNonInvokerAuthEntriesError() {
          _classCallCheck(this, NoUnsignedNonInvokerAuthEntriesError);
          return _callSuper(this, NoUnsignedNonInvokerAuthEntriesError, arguments);
        }
        _inherits(NoUnsignedNonInvokerAuthEntriesError, _Error5);
        return _createClass(NoUnsignedNonInvokerAuthEntriesError);
      }(_wrapNativeSuper(Error)),
      NoSigner: function(_Error6) {
        function NoSignerError() {
          _classCallCheck(this, NoSignerError);
          return _callSuper(this, NoSignerError, arguments);
        }
        _inherits(NoSignerError, _Error6);
        return _createClass(NoSignerError);
      }(_wrapNativeSuper(Error)),
      NotYetSimulated: function(_Error7) {
        function NotYetSimulatedError() {
          _classCallCheck(this, NotYetSimulatedError);
          return _callSuper(this, NotYetSimulatedError, arguments);
        }
        _inherits(NotYetSimulatedError, _Error7);
        return _createClass(NotYetSimulatedError);
      }(_wrapNativeSuper(Error)),
      FakeAccount: function(_Error8) {
        function FakeAccountError() {
          _classCallCheck(this, FakeAccountError);
          return _callSuper(this, FakeAccountError, arguments);
        }
        _inherits(FakeAccountError, _Error8);
        return _createClass(FakeAccountError);
      }(_wrapNativeSuper(Error)),
      SimulationFailed: function(_Error9) {
        function SimulationFailedError() {
          _classCallCheck(this, SimulationFailedError);
          return _callSuper(this, SimulationFailedError, arguments);
        }
        _inherits(SimulationFailedError, _Error9);
        return _createClass(SimulationFailedError);
      }(_wrapNativeSuper(Error)),
      InternalWalletError: function(_Error10) {
        function InternalWalletError() {
          _classCallCheck(this, InternalWalletError);
          return _callSuper(this, InternalWalletError, arguments);
        }
        _inherits(InternalWalletError, _Error10);
        return _createClass(InternalWalletError);
      }(_wrapNativeSuper(Error)),
      ExternalServiceError: function(_Error11) {
        function ExternalServiceError() {
          _classCallCheck(this, ExternalServiceError);
          return _callSuper(this, ExternalServiceError, arguments);
        }
        _inherits(ExternalServiceError, _Error11);
        return _createClass(ExternalServiceError);
      }(_wrapNativeSuper(Error)),
      InvalidClientRequest: function(_Error12) {
        function InvalidClientRequestError() {
          _classCallCheck(this, InvalidClientRequestError);
          return _callSuper(this, InvalidClientRequestError, arguments);
        }
        _inherits(InvalidClientRequestError, _Error12);
        return _createClass(InvalidClientRequestError);
      }(_wrapNativeSuper(Error)),
      UserRejected: function(_Error13) {
        function UserRejectedError() {
          _classCallCheck(this, UserRejectedError);
          return _callSuper(this, UserRejectedError, arguments);
        }
        _inherits(UserRejectedError, _Error13);
        return _createClass(UserRejectedError);
      }(_wrapNativeSuper(Error))
    });
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/basic_node_signer.js
var require_basic_node_signer2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/basic_node_signer.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.basicNodeSigner = void 0;
    var _stellarBase = require_lib2();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var basicNodeSigner2 = exports.basicNodeSigner = function basicNodeSigner3(keypair, networkPassphrase) {
      return {
        signTransaction: function() {
          var _signTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(xdr3, opts) {
            var t;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  t = _stellarBase.TransactionBuilder.fromXDR(xdr3, (opts === null || opts === void 0 ? void 0 : opts.networkPassphrase) || networkPassphrase);
                  t.sign(keypair);
                  return _context.abrupt("return", {
                    signedTxXdr: t.toXDR(),
                    signerAddress: keypair.publicKey()
                  });
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function signTransaction(_x, _x2) {
            return _signTransaction.apply(this, arguments);
          }
          return signTransaction;
        }(),
        signAuthEntry: function() {
          var _signAuthEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(authEntry) {
            var signedAuthEntry;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  signedAuthEntry = keypair.sign((0, _stellarBase.hash)(Buffer.from(authEntry, "base64"))).toString("base64");
                  return _context2.abrupt("return", {
                    signedAuthEntry,
                    signerAddress: keypair.publicKey()
                  });
                case 2:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function signAuthEntry(_x3) {
            return _signAuthEntry.apply(this, arguments);
          }
          return signAuthEntry;
        }()
      };
    };
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/spec.js
var require_spec2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/spec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Spec = void 0;
    var _stellarBase = require_lib2();
    var _rust_result = require_rust_result2();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function enumToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        var title = aCase.name().toString();
        var desc = aCase.doc().toString();
        oneOf.push({
          description: desc,
          title,
          enum: [aCase.value()],
          type: "number"
        });
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    function isNumeric(field) {
      return /^\d+$/.test(field.name().toString());
    }
    function readObj(args, input) {
      var inputName = input.name().toString();
      var entry = Object.entries(args).find(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), name = _ref2[0];
        return name === inputName;
      });
      if (!entry) {
        throw new Error("Missing field ".concat(inputName));
      }
      return entry[1];
    }
    function findCase(name) {
      return function matches(entry) {
        switch (entry.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var tuple = entry.tupleCase();
            return tuple.name().toString() === name;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var voidCase = entry.voidCase();
            return voidCase.name().toString() === name;
          }
          default:
            return false;
        }
      };
    }
    function stringToScVal(str, ty) {
      switch (ty.value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value:
          return _stellarBase.xdr.ScVal.scvString(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value:
          return _stellarBase.xdr.ScVal.scvSymbol(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value:
          return _stellarBase.Address.fromString(str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
          return new _stellarBase.XdrLargeInt("u64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
          return new _stellarBase.XdrLargeInt("i64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
          return new _stellarBase.XdrLargeInt("u128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
          return new _stellarBase.XdrLargeInt("i128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
          return new _stellarBase.XdrLargeInt("u256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
          return new _stellarBase.XdrLargeInt("i256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value:
          return _stellarBase.xdr.ScVal.scvBytes(Buffer.from(str, "base64"));
        default:
          throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
      }
    }
    var PRIMITIVE_DEFINITONS = {
      U32: {
        type: "integer",
        minimum: 0,
        maximum: 4294967295
      },
      I32: {
        type: "integer",
        minimum: -2147483648,
        maximum: 2147483647
      },
      U64: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      I64: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 21
      },
      U128: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 39
      },
      I128: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 40
      },
      U256: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 78
      },
      I256: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 79
      },
      Address: {
        type: "string",
        format: "address",
        description: "Address can be a public key or contract id"
      },
      ScString: {
        type: "string",
        description: "ScString is a string"
      },
      ScSymbol: {
        type: "string",
        description: "ScSymbol is a string"
      },
      DataUrl: {
        type: "string",
        pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$"
      }
    };
    function typeRef(typeDef) {
      var t = typeDef.switch();
      var value = t.value;
      var ref;
      switch (value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal().value: {
          ref = "Val";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool().value: {
          return {
            type: "boolean"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value: {
          return {
            type: "null"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeError().value: {
          ref = "Error";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value: {
          ref = "U32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value: {
          ref = "I32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value: {
          ref = "U64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value: {
          ref = "I64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value: {
          throw new Error("Timepoint type not supported");
          ref = "Timepoint";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
          throw new Error("Duration not supported");
          ref = "Duration";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value: {
          ref = "U128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value: {
          ref = "I128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value: {
          ref = "U256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
          ref = "I256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value: {
          ref = "DataUrl";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value: {
          ref = "ScString";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value: {
          ref = "ScSymbol";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value: {
          ref = "Address";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value: {
          var opt = typeDef.option();
          return typeRef(opt.valueType());
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult().value: {
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
          var arr = typeDef.vec();
          var reference = typeRef(arr.elementType());
          return {
            type: "array",
            items: reference
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
          var map = typeDef.map();
          var items = [typeRef(map.keyType()), typeRef(map.valueType())];
          return {
            type: "array",
            items: {
              type: "array",
              items,
              minItems: 2,
              maxItems: 2
            }
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
          var tuple = typeDef.tuple();
          var minItems = tuple.valueTypes().length;
          var maxItems = minItems;
          var _items = tuple.valueTypes().map(typeRef);
          return {
            type: "array",
            items: _items,
            minItems,
            maxItems
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
          var _arr = typeDef.bytesN();
          return {
            $ref: "#/definitions/DataUrl",
            maxLength: _arr.n()
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value: {
          var udt = typeDef.udt();
          ref = udt.name().toString();
          break;
        }
      }
      return {
        $ref: "#/definitions/".concat(ref)
      };
    }
    function isRequired(typeDef) {
      return typeDef.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeOption().value;
    }
    function argsAndRequired(input) {
      var properties = {};
      var required = [];
      input.forEach(function(arg) {
        var aType = arg.type();
        var name = arg.name().toString();
        properties[name] = typeRef(aType);
        if (isRequired(aType)) {
          required.push(name);
        }
      });
      var res = {
        properties
      };
      if (required.length > 0) {
        res.required = required;
      }
      return res;
    }
    function structToJsonSchema(udt) {
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error("mixed numeric and non-numeric field names are not allowed");
        }
        var items = fields.map(function(_, i) {
          return typeRef(fields[i].type());
        });
        return {
          type: "array",
          items,
          minItems: fields.length,
          maxItems: fields.length
        };
      }
      var description = udt.doc().toString();
      var _argsAndRequired = argsAndRequired(fields), properties = _argsAndRequired.properties, required = _argsAndRequired.required;
      properties.additionalProperties = false;
      return {
        description,
        properties,
        required,
        type: "object"
      };
    }
    function functionToJsonSchema(func) {
      var _argsAndRequired2 = argsAndRequired(func.inputs()), properties = _argsAndRequired2.properties, required = _argsAndRequired2.required;
      var args = {
        additionalProperties: false,
        properties,
        type: "object"
      };
      if ((required === null || required === void 0 ? void 0 : required.length) > 0) {
        args.required = required;
      }
      var input = {
        properties: {
          args
        }
      };
      var outputs = func.outputs();
      var output = outputs.length > 0 ? typeRef(outputs[0]) : typeRef(_stellarBase.xdr.ScSpecTypeDef.scSpecTypeVoid());
      var description = func.doc().toString();
      if (description.length > 0) {
        input.description = description;
      }
      input.additionalProperties = false;
      output.additionalProperties = false;
      return {
        input,
        output
      };
    }
    function unionToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        switch (aCase.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var c = aCase.voidCase();
            var title = c.name().toString();
            oneOf.push({
              type: "object",
              title,
              properties: {
                tag: title
              },
              additionalProperties: false,
              required: ["tag"]
            });
            break;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var _c = aCase.tupleCase();
            var _title = _c.name().toString();
            oneOf.push({
              type: "object",
              title: _title,
              properties: {
                tag: _title,
                values: {
                  type: "array",
                  items: _c.type().map(typeRef)
                }
              },
              required: ["tag", "values"],
              additionalProperties: false
            });
          }
        }
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    var Spec = exports.Spec = function() {
      function Spec2(entries) {
        _classCallCheck(this, Spec2);
        _defineProperty(this, "entries", []);
        if (entries.length === 0) {
          throw new Error("Contract spec must have at least one entry");
        }
        var entry = entries[0];
        if (typeof entry === "string") {
          this.entries = entries.map(function(s) {
            return _stellarBase.xdr.ScSpecEntry.fromXDR(s, "base64");
          });
        } else {
          this.entries = entries;
        }
      }
      return _createClass(Spec2, [{
        key: "funcs",
        value: function funcs() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(entry) {
            return entry.functionV0();
          });
        }
      }, {
        key: "getFunc",
        value: function getFunc(name) {
          var entry = this.findEntry(name);
          if (entry.switch().value !== _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
            throw new Error("".concat(name, " is not a function"));
          }
          return entry.functionV0();
        }
      }, {
        key: "funcArgsToScVals",
        value: function funcArgsToScVals(name, args) {
          var _this = this;
          var fn = this.getFunc(name);
          return fn.inputs().map(function(input) {
            return _this.nativeToScVal(readObj(args, input), input.type());
          });
        }
      }, {
        key: "funcResToNative",
        value: function funcResToNative(name, val_or_base64) {
          var val = typeof val_or_base64 === "string" ? _stellarBase.xdr.ScVal.fromXDR(val_or_base64, "base64") : val_or_base64;
          var func = this.getFunc(name);
          var outputs = func.outputs();
          if (outputs.length === 0) {
            var type = val.switch();
            if (type.value !== _stellarBase.xdr.ScValType.scvVoid().value) {
              throw new Error("Expected void, got ".concat(type.name));
            }
            return null;
          }
          if (outputs.length > 1) {
            throw new Error("Multiple outputs not supported");
          }
          var output = outputs[0];
          if (output.switch().value === _stellarBase.xdr.ScSpecType.scSpecTypeResult().value) {
            return new _rust_result.Ok(this.scValToNative(val, output.result().okType()));
          }
          return this.scValToNative(val, output);
        }
      }, {
        key: "findEntry",
        value: function findEntry(name) {
          var entry = this.entries.find(function(e) {
            return e.value().name().toString() === name;
          });
          if (!entry) {
            throw new Error("no such entry: ".concat(name));
          }
          return entry;
        }
      }, {
        key: "nativeToScVal",
        value: function nativeToScVal(val, ty) {
          var _this2 = this;
          var t = ty.switch();
          var value = t.value;
          if (t.value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            var udt = ty.udt();
            return this.nativeToUdt(val, udt.name().toString());
          }
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
            var opt = ty.option();
            if (val === void 0) {
              return _stellarBase.xdr.ScVal.scvVoid();
            }
            return this.nativeToScVal(val, opt.valueType());
          }
          switch (_typeof(val)) {
            case "object": {
              var _val$constructor$name, _val$constructor;
              if (val === null) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                    return _stellarBase.xdr.ScVal.scvVoid();
                  default:
                    throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
                }
              }
              if (val instanceof _stellarBase.xdr.ScVal) {
                return val;
              }
              if (val instanceof _stellarBase.Address) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.toScVal();
              }
              if (val instanceof _stellarBase.Contract) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.address().toScVal();
              }
              if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
                var copy = Uint8Array.from(val);
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
                    var bytesN = ty.bytesN();
                    if (copy.length !== bytesN.n()) {
                      throw new TypeError("expected ".concat(bytesN.n(), " bytes, but got ").concat(copy.length));
                    }
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  default:
                    throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(val)) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
                    var vec = ty.vec();
                    var elementType = vec.elementType();
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2) {
                      return _this2.nativeToScVal(v2, elementType);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
                    var tup = ty.tuple();
                    var valTypes = tup.valueTypes();
                    if (val.length !== valTypes.length) {
                      throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                    }
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2, i) {
                      return _this2.nativeToScVal(v2, valTypes[i]);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
                    var map = ty.map();
                    var keyType = map.keyType();
                    var valueType = map.valueType();
                    return _stellarBase.xdr.ScVal.scvMap(val.map(function(entry) {
                      var key2 = _this2.nativeToScVal(entry[0], keyType);
                      var mapVal = _this2.nativeToScVal(entry[1], valueType);
                      return new _stellarBase.xdr.ScMapEntry({
                        key: key2,
                        val: mapVal
                      });
                    }));
                  }
                  default:
                    throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
                }
              }
              if (val.constructor === Map) {
                if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                  throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
                }
                var scMap = ty.map();
                var _map = val;
                var entries = [];
                var values = _map.entries();
                var res = values.next();
                while (!res.done) {
                  var _res$value = _slicedToArray(res.value, 2), k = _res$value[0], v = _res$value[1];
                  var key = this.nativeToScVal(k, scMap.keyType());
                  var mapval = this.nativeToScVal(v, scMap.valueType());
                  entries.push(new _stellarBase.xdr.ScMapEntry({
                    key,
                    val: mapval
                  }));
                  res = values.next();
                }
                return _stellarBase.xdr.ScVal.scvMap(entries);
              }
              if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
                var _val$constructor2;
                throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
              }
              throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
            }
            case "number":
            case "bigint": {
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value:
                  return _stellarBase.xdr.ScVal.scvU32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value:
                  return _stellarBase.xdr.ScVal.scvI32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
                  var intType = t.name.substring(10).toLowerCase();
                  return new _stellarBase.XdrLargeInt(intType, val).toScVal();
                }
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
              }
            }
            case "string":
              return stringToScVal(val, t);
            case "boolean": {
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeBool().value) {
                throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
              }
              return _stellarBase.xdr.ScVal.scvBool(val);
            }
            case "undefined": {
              if (!ty) {
                return _stellarBase.xdr.ScVal.scvVoid();
              }
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value:
                  return _stellarBase.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
              }
            }
            case "function":
              return this.nativeToScVal(val(), ty);
            default:
              throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
          }
        }
      }, {
        key: "nativeToUdt",
        value: function nativeToUdt(val, name) {
          var entry = this.findEntry(name);
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if (typeof val !== "number") {
                throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(_typeof(val)));
              }
              return this.nativeToEnum(val, entry.udtEnumV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(val, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(val, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(name));
          }
        }
      }, {
        key: "nativeToUnion",
        value: function nativeToUnion(val, union_) {
          var _this3 = this;
          var entryName = val.tag;
          var caseFound = union_.cases().find(function(entry) {
            var caseN = entry.value().name().toString();
            return caseN === entryName;
          });
          if (!caseFound) {
            throw new TypeError("no such enum entry: ".concat(entryName, " in ").concat(union_));
          }
          var key = _stellarBase.xdr.ScVal.scvSymbol(entryName);
          switch (caseFound.switch()) {
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0(): {
              return _stellarBase.xdr.ScVal.scvVec([key]);
            }
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0(): {
              var types = caseFound.tupleCase().type();
              if (Array.isArray(val.values)) {
                if (val.values.length !== types.length) {
                  throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
                }
                var scvals = val.values.map(function(v, i) {
                  return _this3.nativeToScVal(v, types[i]);
                });
                scvals.unshift(key);
                return _stellarBase.xdr.ScVal.scvVec(scvals);
              }
              throw new Error("failed to parse union case ".concat(caseFound, " with ").concat(val));
            }
            default:
              throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
          }
        }
      }, {
        key: "nativeToStruct",
        value: function nativeToStruct(val, struct) {
          var _this4 = this;
          var fields = struct.fields();
          if (fields.some(isNumeric)) {
            if (!fields.every(isNumeric)) {
              throw new Error("mixed numeric and non-numeric field names are not allowed");
            }
            return _stellarBase.xdr.ScVal.scvVec(fields.map(function(_, i) {
              return _this4.nativeToScVal(val[i], fields[i].type());
            }));
          }
          return _stellarBase.xdr.ScVal.scvMap(fields.map(function(field) {
            var name = field.name().toString();
            return new _stellarBase.xdr.ScMapEntry({
              key: _this4.nativeToScVal(name, _stellarBase.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
              val: _this4.nativeToScVal(val[name], field.type())
            });
          }));
        }
      }, {
        key: "nativeToEnum",
        value: function nativeToEnum(val, enum_) {
          if (enum_.cases().some(function(entry) {
            return entry.value() === val;
          })) {
            return _stellarBase.xdr.ScVal.scvU32(val);
          }
          throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
        }
      }, {
        key: "scValStrToNative",
        value: function scValStrToNative(scv, typeDef) {
          return this.scValToNative(_stellarBase.xdr.ScVal.fromXDR(scv, "base64"), typeDef);
        }
      }, {
        key: "scValToNative",
        value: function scValToNative(scv, typeDef) {
          var _this5 = this;
          var t = typeDef.switch();
          var value = t.value;
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            return this.scValUdtToNative(scv, typeDef.udt());
          }
          switch (scv.switch().value) {
            case _stellarBase.xdr.ScValType.scvVoid().value:
              return void 0;
            case _stellarBase.xdr.ScValType.scvU64().value:
            case _stellarBase.xdr.ScValType.scvI64().value:
            case _stellarBase.xdr.ScValType.scvU128().value:
            case _stellarBase.xdr.ScValType.scvI128().value:
            case _stellarBase.xdr.ScValType.scvU256().value:
            case _stellarBase.xdr.ScValType.scvI256().value:
              return (0, _stellarBase.scValToBigInt)(scv);
            case _stellarBase.xdr.ScValType.scvVec().value: {
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeVec().value) {
                var _scv$vec;
                var vec = typeDef.vec();
                return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function(elm) {
                  return _this5.scValToNative(elm, vec.elementType());
                });
              }
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value) {
                var _scv$vec2;
                var tuple = typeDef.tuple();
                var valTypes = tuple.valueTypes();
                return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function(elm, i) {
                  return _this5.scValToNative(elm, valTypes[i]);
                });
              }
              throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
            }
            case _stellarBase.xdr.ScValType.scvAddress().value:
              return _stellarBase.Address.fromScVal(scv).toString();
            case _stellarBase.xdr.ScValType.scvMap().value: {
              var _scv$map;
              var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                var typed = typeDef.map();
                var keyType = typed.keyType();
                var valueType = typed.valueType();
                var res = map.map(function(entry) {
                  return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
                });
                return res;
              }
              throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            case _stellarBase.xdr.ScValType.scvBool().value:
            case _stellarBase.xdr.ScValType.scvU32().value:
            case _stellarBase.xdr.ScValType.scvI32().value:
            case _stellarBase.xdr.ScValType.scvBytes().value:
              return scv.value();
            case _stellarBase.xdr.ScValType.scvString().value:
            case _stellarBase.xdr.ScValType.scvSymbol().value: {
              var _scv$value;
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeString().value && value !== _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value) {
                throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
              }
              return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
            }
            case _stellarBase.xdr.ScValType.scvTimepoint().value:
            case _stellarBase.xdr.ScValType.scvDuration().value:
              return (0, _stellarBase.scValToBigInt)(_stellarBase.xdr.ScVal.scvU64(scv.u64()));
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
          }
        }
      }, {
        key: "scValUdtToNative",
        value: function scValUdtToNative(scv, udt) {
          var entry = this.findEntry(udt.name().toString());
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(scv);
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(scv, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(scv, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
          }
        }
      }, {
        key: "unionToNative",
        value: function unionToNative(val, udt) {
          var _this6 = this;
          var vec = val.vec();
          if (!vec) {
            throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
          }
          if (vec.length === 0 && udt.cases.length !== 0) {
            throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
          }
          var name = vec[0].sym().toString();
          if (vec[0].switch().value !== _stellarBase.xdr.ScValType.scvSymbol().value) {
            throw new Error("{vec[0]} is not a symbol");
          }
          var entry = udt.cases().find(findCase(name));
          if (!entry) {
            throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
          }
          var res = {
            tag: name
          };
          if (entry.switch().value === _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var tuple = entry.tupleCase();
            var ty = tuple.type();
            var values = ty.map(function(e, i) {
              return _this6.scValToNative(vec[i + 1], e);
            });
            res.values = values;
          }
          return res;
        }
      }, {
        key: "structToNative",
        value: function structToNative(val, udt) {
          var _this7 = this, _val$map;
          var res = {};
          var fields = udt.fields();
          if (fields.some(isNumeric)) {
            var _val$vec;
            var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function(entry, i) {
              return _this7.scValToNative(entry, fields[i].type());
            });
            return r;
          }
          (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function(entry, i) {
            var field = fields[i];
            res[field.name().toString()] = _this7.scValToNative(entry.val(), field.type());
          });
          return res;
        }
      }, {
        key: "enumToNative",
        value: function enumToNative(scv) {
          if (scv.switch().value !== _stellarBase.xdr.ScValType.scvU32().value) {
            throw new Error("Enum must have a u32 value");
          }
          var num = scv.u32();
          return num;
        }
      }, {
        key: "errorCases",
        value: function errorCases() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(entry) {
            return entry.value().cases();
          });
        }
      }, {
        key: "jsonSchema",
        value: function jsonSchema(funcName) {
          var definitions = {};
          this.entries.forEach(function(entry) {
            switch (entry.switch().value) {
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value: {
                var udt = entry.udtEnumV0();
                definitions[udt.name().toString()] = enumToJsonSchema(udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value: {
                var _udt = entry.udtStructV0();
                definitions[_udt.name().toString()] = structToJsonSchema(_udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value: {
                var _udt2 = entry.udtUnionV0();
                definitions[_udt2.name().toString()] = unionToJsonSchema(_udt2);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value: {
                var fn = entry.functionV0();
                var fnName = fn.name().toString();
                var _functionToJsonSchema = functionToJsonSchema(fn), input = _functionToJsonSchema.input;
                definitions[fnName] = input;
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value: {
              }
            }
          });
          var res = {
            $schema: "http://json-schema.org/draft-07/schema#",
            definitions: _objectSpread(_objectSpread({}, PRIMITIVE_DEFINITONS), definitions)
          };
          if (funcName) {
            res.$ref = "#/definitions/".concat(funcName);
          }
          return res;
        }
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/client.js
var require_client2 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/client.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _stellarBase = require_lib2();
    var _spec = require_spec2();
    var _rpc = require_rpc2();
    var _assembled_transaction = require_assembled_transaction2();
    var _utils = require_utils4();
    var _excluded = ["method"];
    var _excluded2 = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o, r, i = _objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var CONSTRUCTOR_FUNC = "__constructor";
    function specFromWasm(_x) {
      return _specFromWasm.apply(this, arguments);
    }
    function _specFromWasm() {
      _specFromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasm) {
        var xdrSections, wasmModule, customData, bufferSection, specEntryArray, spec;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return WebAssembly.compile(wasm);
            case 3:
              wasmModule = _context5.sent;
              xdrSections = WebAssembly.Module.customSections(wasmModule, "contractspecv0");
              _context5.next = 11;
              break;
            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](0);
              customData = parseWasmCustomSections(wasm);
              xdrSections = customData.get("contractspecv0");
            case 11:
              if (!(!xdrSections || xdrSections.length === 0)) {
                _context5.next = 13;
                break;
              }
              throw new Error("Could not obtain contract spec from wasm");
            case 13:
              bufferSection = Buffer.from(xdrSections[0]);
              specEntryArray = (0, _utils.processSpecEntryStream)(bufferSection);
              spec = new _spec.Spec(specEntryArray);
              return _context5.abrupt("return", spec);
            case 17:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 7]]);
      }));
      return _specFromWasm.apply(this, arguments);
    }
    function parseWasmCustomSections(buffer) {
      var sections = /* @__PURE__ */ new Map();
      var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
      var offset = 0;
      var read = function read2(length) {
        if (offset + length > buffer.byteLength) throw new Error("Buffer overflow");
        var bytes = new Uint8Array(arrayBuffer, offset, length);
        offset += length;
        return bytes;
      };
      if (_toConsumableArray(read(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
      if (_toConsumableArray(read(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
      while (offset < buffer.byteLength) {
        var sectionId = read(1)[0];
        var sectionLength = readVarUint32();
        var start = offset;
        if (sectionId === 0) {
          var nameLen = readVarUint32();
          if (nameLen === 0 || offset + nameLen > start + sectionLength) continue;
          var nameBytes = read(nameLen);
          var payload = read(sectionLength - (offset - start));
          try {
            var name = new TextDecoder("utf-8", {
              fatal: true
            }).decode(nameBytes);
            if (payload.length > 0) {
              sections.set(name, (sections.get(name) || []).concat(payload));
            }
          } catch (_unused) {
          }
        } else {
          offset += sectionLength;
        }
      }
      function readVarUint32() {
        var value = 0, shift = 0;
        while (true) {
          var byte = read(1)[0];
          value |= (byte & 127) << shift;
          if ((byte & 128) === 0) break;
          if ((shift += 7) >= 32) throw new Error("Invalid WASM value");
        }
        return value >>> 0;
      }
      return sections;
    }
    function specFromWasmHash(_x2, _x3) {
      return _specFromWasmHash.apply(this, arguments);
    }
    function _specFromWasmHash() {
      _specFromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(wasmHash, options) {
        var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              format = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : "hex";
              if (!(!options || !options.rpcUrl)) {
                _context6.next = 3;
                break;
              }
              throw new TypeError("options must contain rpcUrl");
            case 3:
              rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
              serverOpts = {
                allowHttp
              };
              server = new _rpc.Server(rpcUrl, serverOpts);
              _context6.next = 8;
              return server.getContractWasmByHash(wasmHash, format);
            case 8:
              wasm = _context6.sent;
              return _context6.abrupt("return", specFromWasm(wasm));
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return _specFromWasmHash.apply(this, arguments);
    }
    var Client3 = exports.Client = function() {
      function Client4(spec, options) {
        var _this = this;
        _classCallCheck(this, Client4);
        _defineProperty(this, "txFromJSON", function(json) {
          var _JSON$parse = JSON.parse(json), method = _JSON$parse.method, tx = _objectWithoutProperties(_JSON$parse, _excluded);
          return _assembled_transaction.AssembledTransaction.fromJSON(_objectSpread(_objectSpread({}, _this.options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return _this.spec.funcResToNative(method, result);
            }
          }), tx);
        });
        _defineProperty(this, "txFromXDR", function(xdrBase64) {
          return _assembled_transaction.AssembledTransaction.fromXDR(_this.options, xdrBase64, _this.spec);
        });
        this.spec = spec;
        this.options = options;
        this.spec.funcs().forEach(function(xdrFn) {
          var method = xdrFn.name().toString();
          if (method === CONSTRUCTOR_FUNC) {
            return;
          }
          var assembleTransaction = function assembleTransaction2(args, methodOptions) {
            return _assembled_transaction.AssembledTransaction.build(_objectSpread(_objectSpread(_objectSpread({
              method,
              args: args && spec.funcArgsToScVals(method, args)
            }, options), methodOptions), {}, {
              errorTypes: spec.errorCases().reduce(function(acc, curr) {
                return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, curr.value(), {
                  message: curr.doc().toString()
                }));
              }, {}),
              parseResultXdr: function parseResultXdr(result) {
                return spec.funcResToNative(method, result);
              }
            }));
          };
          _this[method] = spec.getFunc(method).inputs().length === 0 ? function(opts) {
            return assembleTransaction(void 0, opts);
          } : assembleTransaction;
        });
      }
      return _createClass(Client4, null, [{
        key: "deploy",
        value: function() {
          var _deploy = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(args, options) {
            var wasmHash, salt, format, fee, timeoutInSeconds, simulate, clientOptions, spec, operation;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  wasmHash = options.wasmHash, salt = options.salt, format = options.format, fee = options.fee, timeoutInSeconds = options.timeoutInSeconds, simulate = options.simulate, clientOptions = _objectWithoutProperties(options, _excluded2);
                  _context.next = 3;
                  return specFromWasmHash(wasmHash, clientOptions, format);
                case 3:
                  spec = _context.sent;
                  operation = _stellarBase.Operation.createCustomContract({
                    address: new _stellarBase.Address(options.address || options.publicKey),
                    wasmHash: typeof wasmHash === "string" ? Buffer.from(wasmHash, format !== null && format !== void 0 ? format : "hex") : wasmHash,
                    salt,
                    constructorArgs: args ? spec.funcArgsToScVals(CONSTRUCTOR_FUNC, args) : []
                  });
                  return _context.abrupt("return", _assembled_transaction.AssembledTransaction.buildWithOp(operation, _objectSpread(_objectSpread({
                    fee,
                    timeoutInSeconds,
                    simulate
                  }, clientOptions), {}, {
                    contractId: "ignored",
                    method: CONSTRUCTOR_FUNC,
                    parseResultXdr: function parseResultXdr(result) {
                      return new Client4(spec, _objectSpread(_objectSpread({}, clientOptions), {}, {
                        contractId: _stellarBase.Address.fromScVal(result).toString()
                      }));
                    }
                  })));
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function deploy(_x4, _x5) {
            return _deploy.apply(this, arguments);
          }
          return deploy;
        }()
      }, {
        key: "fromWasmHash",
        value: function() {
          var _fromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(wasmHash, options) {
            var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args2 = arguments;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  format = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : "hex";
                  if (!(!options || !options.rpcUrl)) {
                    _context2.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context2.next = 8;
                  return server.getContractWasmByHash(wasmHash, format);
                case 8:
                  wasm = _context2.sent;
                  return _context2.abrupt("return", Client4.fromWasm(wasm, options));
                case 10:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function fromWasmHash(_x6, _x7) {
            return _fromWasmHash.apply(this, arguments);
          }
          return fromWasmHash;
        }()
      }, {
        key: "fromWasm",
        value: function() {
          var _fromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(wasm, options) {
            var spec;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return specFromWasm(wasm);
                case 2:
                  spec = _context3.sent;
                  return _context3.abrupt("return", new Client4(spec, options));
                case 4:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function fromWasm(_x8, _x9) {
            return _fromWasm.apply(this, arguments);
          }
          return fromWasm;
        }()
      }, {
        key: "from",
        value: function() {
          var _from = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(options) {
            var rpcUrl, contractId, allowHttp, serverOpts, server, wasm;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  if (!(!options || !options.rpcUrl || !options.contractId)) {
                    _context4.next = 2;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 2:
                  rpcUrl = options.rpcUrl, contractId = options.contractId, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context4.next = 7;
                  return server.getContractWasmByContractId(contractId);
                case 7:
                  wasm = _context4.sent;
                  return _context4.abrupt("return", Client4.fromWasm(wasm, options));
                case 9:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }));
          function from(_x10) {
            return _from.apply(this, arguments);
          }
          return from;
        }()
      }]);
    }();
  }
});

// node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/index.js
var require_contract4 = __commonJS({
  "node_modules/passkey-kit/node_modules/@stellar/stellar-sdk/lib/minimal/contract/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _assembled_transaction = require_assembled_transaction2();
    Object.keys(_assembled_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _assembled_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _assembled_transaction[key];
        }
      });
    });
    var _basic_node_signer = require_basic_node_signer2();
    Object.keys(_basic_node_signer).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _basic_node_signer[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _basic_node_signer[key];
        }
      });
    });
    var _client = require_client2();
    Object.keys(_client).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _client[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _client[key];
        }
      });
    });
    var _rust_result = require_rust_result2();
    Object.keys(_rust_result).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _rust_result[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _rust_result[key];
        }
      });
    });
    var _sent_transaction = require_sent_transaction2();
    Object.keys(_sent_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _sent_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sent_transaction[key];
        }
      });
    });
    var _spec = require_spec2();
    Object.keys(_spec).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _spec[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _spec[key];
        }
      });
    });
    var _types = require_types4();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js
var require_curr_generated3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var XDR = _interopRequireWildcard(require_xdr());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    var types = XDR.config(function(xdr3) {
      var SCSYMBOL_LIMIT = 32;
      var SC_SPEC_DOC_LIMIT = 1024;
      xdr3.typedef("Value", xdr3.varOpaque());
      xdr3.struct("ScpBallot", [["counter", xdr3.lookup("Uint32")], ["value", xdr3.lookup("Value")]]);
      xdr3["enum"]("ScpStatementType", {
        scpStPrepare: 0,
        scpStConfirm: 1,
        scpStExternalize: 2,
        scpStNominate: 3
      });
      xdr3.struct("ScpNomination", [["quorumSetHash", xdr3.lookup("Hash")], ["votes", xdr3.varArray(xdr3.lookup("Value"), 2147483647)], ["accepted", xdr3.varArray(xdr3.lookup("Value"), 2147483647)]]);
      xdr3.struct("ScpStatementPrepare", [["quorumSetHash", xdr3.lookup("Hash")], ["ballot", xdr3.lookup("ScpBallot")], ["prepared", xdr3.option(xdr3.lookup("ScpBallot"))], ["preparedPrime", xdr3.option(xdr3.lookup("ScpBallot"))], ["nC", xdr3.lookup("Uint32")], ["nH", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScpStatementConfirm", [["ballot", xdr3.lookup("ScpBallot")], ["nPrepared", xdr3.lookup("Uint32")], ["nCommit", xdr3.lookup("Uint32")], ["nH", xdr3.lookup("Uint32")], ["quorumSetHash", xdr3.lookup("Hash")]]);
      xdr3.struct("ScpStatementExternalize", [["commit", xdr3.lookup("ScpBallot")], ["nH", xdr3.lookup("Uint32")], ["commitQuorumSetHash", xdr3.lookup("Hash")]]);
      xdr3.union("ScpStatementPledges", {
        switchOn: xdr3.lookup("ScpStatementType"),
        switchName: "type",
        switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
        arms: {
          prepare: xdr3.lookup("ScpStatementPrepare"),
          confirm: xdr3.lookup("ScpStatementConfirm"),
          externalize: xdr3.lookup("ScpStatementExternalize"),
          nominate: xdr3.lookup("ScpNomination")
        }
      });
      xdr3.struct("ScpStatement", [["nodeId", xdr3.lookup("NodeId")], ["slotIndex", xdr3.lookup("Uint64")], ["pledges", xdr3.lookup("ScpStatementPledges")]]);
      xdr3.struct("ScpEnvelope", [["statement", xdr3.lookup("ScpStatement")], ["signature", xdr3.lookup("Signature")]]);
      xdr3.struct("ScpQuorumSet", [["threshold", xdr3.lookup("Uint32")], ["validators", xdr3.varArray(xdr3.lookup("NodeId"), 2147483647)], ["innerSets", xdr3.varArray(xdr3.lookup("ScpQuorumSet"), 2147483647)]]);
      xdr3.typedef("Thresholds", xdr3.opaque(4));
      xdr3.typedef("String32", xdr3.string(32));
      xdr3.typedef("String64", xdr3.string(64));
      xdr3.typedef("SequenceNumber", xdr3.lookup("Int64"));
      xdr3.typedef("DataValue", xdr3.varOpaque(64));
      xdr3.typedef("PoolId", xdr3.lookup("Hash"));
      xdr3.typedef("AssetCode4", xdr3.opaque(4));
      xdr3.typedef("AssetCode12", xdr3.opaque(12));
      xdr3["enum"]("AssetType", {
        assetTypeNative: 0,
        assetTypeCreditAlphanum4: 1,
        assetTypeCreditAlphanum12: 2,
        assetTypePoolShare: 3
      });
      xdr3.union("AssetCode", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
        arms: {
          assetCode4: xdr3.lookup("AssetCode4"),
          assetCode12: xdr3.lookup("AssetCode12")
        }
      });
      xdr3.struct("AlphaNum4", [["assetCode", xdr3.lookup("AssetCode4")], ["issuer", xdr3.lookup("AccountId")]]);
      xdr3.struct("AlphaNum12", [["assetCode", xdr3.lookup("AssetCode12")], ["issuer", xdr3.lookup("AccountId")]]);
      xdr3.union("Asset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12")
        }
      });
      xdr3.struct("Price", [["n", xdr3.lookup("Int32")], ["d", xdr3.lookup("Int32")]]);
      xdr3.struct("Liabilities", [["buying", xdr3.lookup("Int64")], ["selling", xdr3.lookup("Int64")]]);
      xdr3["enum"]("ThresholdIndices", {
        thresholdMasterWeight: 0,
        thresholdLow: 1,
        thresholdMed: 2,
        thresholdHigh: 3
      });
      xdr3["enum"]("LedgerEntryType", {
        account: 0,
        trustline: 1,
        offer: 2,
        data: 3,
        claimableBalance: 4,
        liquidityPool: 5,
        contractData: 6,
        contractCode: 7,
        configSetting: 8,
        ttl: 9
      });
      xdr3.struct("Signer", [["key", xdr3.lookup("SignerKey")], ["weight", xdr3.lookup("Uint32")]]);
      xdr3["enum"]("AccountFlags", {
        authRequiredFlag: 1,
        authRevocableFlag: 2,
        authImmutableFlag: 4,
        authClawbackEnabledFlag: 8
      });
      xdr3["const"]("MASK_ACCOUNT_FLAGS", 7);
      xdr3["const"]("MASK_ACCOUNT_FLAGS_V17", 15);
      xdr3["const"]("MAX_SIGNERS", 20);
      xdr3.typedef("SponsorshipDescriptor", xdr3.option(xdr3.lookup("AccountId")));
      xdr3.struct("AccountEntryExtensionV3", [["ext", xdr3.lookup("ExtensionPoint")], ["seqLedger", xdr3.lookup("Uint32")], ["seqTime", xdr3.lookup("TimePoint")]]);
      xdr3.union("AccountEntryExtensionV2Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [3, "v3"]],
        arms: {
          v3: xdr3.lookup("AccountEntryExtensionV3")
        }
      });
      xdr3.struct("AccountEntryExtensionV2", [["numSponsored", xdr3.lookup("Uint32")], ["numSponsoring", xdr3.lookup("Uint32")], ["signerSponsoringIDs", xdr3.varArray(xdr3.lookup("SponsorshipDescriptor"), xdr3.lookup("MAX_SIGNERS"))], ["ext", xdr3.lookup("AccountEntryExtensionV2Ext")]]);
      xdr3.union("AccountEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [2, "v2"]],
        arms: {
          v2: xdr3.lookup("AccountEntryExtensionV2")
        }
      });
      xdr3.struct("AccountEntryExtensionV1", [["liabilities", xdr3.lookup("Liabilities")], ["ext", xdr3.lookup("AccountEntryExtensionV1Ext")]]);
      xdr3.union("AccountEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("AccountEntryExtensionV1")
        }
      });
      xdr3.struct("AccountEntry", [["accountId", xdr3.lookup("AccountId")], ["balance", xdr3.lookup("Int64")], ["seqNum", xdr3.lookup("SequenceNumber")], ["numSubEntries", xdr3.lookup("Uint32")], ["inflationDest", xdr3.option(xdr3.lookup("AccountId"))], ["flags", xdr3.lookup("Uint32")], ["homeDomain", xdr3.lookup("String32")], ["thresholds", xdr3.lookup("Thresholds")], ["signers", xdr3.varArray(xdr3.lookup("Signer"), xdr3.lookup("MAX_SIGNERS"))], ["ext", xdr3.lookup("AccountEntryExt")]]);
      xdr3["enum"]("TrustLineFlags", {
        authorizedFlag: 1,
        authorizedToMaintainLiabilitiesFlag: 2,
        trustlineClawbackEnabledFlag: 4
      });
      xdr3["const"]("MASK_TRUSTLINE_FLAGS", 1);
      xdr3["const"]("MASK_TRUSTLINE_FLAGS_V13", 3);
      xdr3["const"]("MASK_TRUSTLINE_FLAGS_V17", 7);
      xdr3["enum"]("LiquidityPoolType", {
        liquidityPoolConstantProduct: 0
      });
      xdr3.union("TrustLineAsset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12"),
          liquidityPoolId: xdr3.lookup("PoolId")
        }
      });
      xdr3.union("TrustLineEntryExtensionV2Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", xdr3.lookup("Int32")], ["ext", xdr3.lookup("TrustLineEntryExtensionV2Ext")]]);
      xdr3.union("TrustLineEntryV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [2, "v2"]],
        arms: {
          v2: xdr3.lookup("TrustLineEntryExtensionV2")
        }
      });
      xdr3.struct("TrustLineEntryV1", [["liabilities", xdr3.lookup("Liabilities")], ["ext", xdr3.lookup("TrustLineEntryV1Ext")]]);
      xdr3.union("TrustLineEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("TrustLineEntryV1")
        }
      });
      xdr3.struct("TrustLineEntry", [["accountId", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("TrustLineAsset")], ["balance", xdr3.lookup("Int64")], ["limit", xdr3.lookup("Int64")], ["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("TrustLineEntryExt")]]);
      xdr3["enum"]("OfferEntryFlags", {
        passiveFlag: 1
      });
      xdr3["const"]("MASK_OFFERENTRY_FLAGS", 1);
      xdr3.union("OfferEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("OfferEntry", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")], ["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("OfferEntryExt")]]);
      xdr3.union("DataEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("DataEntry", [["accountId", xdr3.lookup("AccountId")], ["dataName", xdr3.lookup("String64")], ["dataValue", xdr3.lookup("DataValue")], ["ext", xdr3.lookup("DataEntryExt")]]);
      xdr3["enum"]("ClaimPredicateType", {
        claimPredicateUnconditional: 0,
        claimPredicateAnd: 1,
        claimPredicateOr: 2,
        claimPredicateNot: 3,
        claimPredicateBeforeAbsoluteTime: 4,
        claimPredicateBeforeRelativeTime: 5
      });
      xdr3.union("ClaimPredicate", {
        switchOn: xdr3.lookup("ClaimPredicateType"),
        switchName: "type",
        switches: [["claimPredicateUnconditional", xdr3["void"]()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
        arms: {
          andPredicates: xdr3.varArray(xdr3.lookup("ClaimPredicate"), 2),
          orPredicates: xdr3.varArray(xdr3.lookup("ClaimPredicate"), 2),
          notPredicate: xdr3.option(xdr3.lookup("ClaimPredicate")),
          absBefore: xdr3.lookup("Int64"),
          relBefore: xdr3.lookup("Int64")
        }
      });
      xdr3["enum"]("ClaimantType", {
        claimantTypeV0: 0
      });
      xdr3.struct("ClaimantV0", [["destination", xdr3.lookup("AccountId")], ["predicate", xdr3.lookup("ClaimPredicate")]]);
      xdr3.union("Claimant", {
        switchOn: xdr3.lookup("ClaimantType"),
        switchName: "type",
        switches: [["claimantTypeV0", "v0"]],
        arms: {
          v0: xdr3.lookup("ClaimantV0")
        }
      });
      xdr3["enum"]("ClaimableBalanceIdType", {
        claimableBalanceIdTypeV0: 0
      });
      xdr3.union("ClaimableBalanceId", {
        switchOn: xdr3.lookup("ClaimableBalanceIdType"),
        switchName: "type",
        switches: [["claimableBalanceIdTypeV0", "v0"]],
        arms: {
          v0: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ClaimableBalanceFlags", {
        claimableBalanceClawbackEnabledFlag: 1
      });
      xdr3["const"]("MASK_CLAIMABLE_BALANCE_FLAGS", 1);
      xdr3.union("ClaimableBalanceEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("ClaimableBalanceEntryExtensionV1", [["ext", xdr3.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", xdr3.lookup("Uint32")]]);
      xdr3.union("ClaimableBalanceEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("ClaimableBalanceEntryExtensionV1")
        }
      });
      xdr3.struct("ClaimableBalanceEntry", [["balanceId", xdr3.lookup("ClaimableBalanceId")], ["claimants", xdr3.varArray(xdr3.lookup("Claimant"), 10)], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["ext", xdr3.lookup("ClaimableBalanceEntryExt")]]);
      xdr3.struct("LiquidityPoolConstantProductParameters", [["assetA", xdr3.lookup("Asset")], ["assetB", xdr3.lookup("Asset")], ["fee", xdr3.lookup("Int32")]]);
      xdr3.struct("LiquidityPoolEntryConstantProduct", [["params", xdr3.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", xdr3.lookup("Int64")], ["reserveB", xdr3.lookup("Int64")], ["totalPoolShares", xdr3.lookup("Int64")], ["poolSharesTrustLineCount", xdr3.lookup("Int64")]]);
      xdr3.union("LiquidityPoolEntryBody", {
        switchOn: xdr3.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr3.lookup("LiquidityPoolEntryConstantProduct")
        }
      });
      xdr3.struct("LiquidityPoolEntry", [["liquidityPoolId", xdr3.lookup("PoolId")], ["body", xdr3.lookup("LiquidityPoolEntryBody")]]);
      xdr3["enum"]("ContractDataDurability", {
        temporary: 0,
        persistent: 1
      });
      xdr3.struct("ContractDataEntry", [["ext", xdr3.lookup("ExtensionPoint")], ["contract", xdr3.lookup("ScAddress")], ["key", xdr3.lookup("ScVal")], ["durability", xdr3.lookup("ContractDataDurability")], ["val", xdr3.lookup("ScVal")]]);
      xdr3.struct("ContractCodeCostInputs", [["ext", xdr3.lookup("ExtensionPoint")], ["nInstructions", xdr3.lookup("Uint32")], ["nFunctions", xdr3.lookup("Uint32")], ["nGlobals", xdr3.lookup("Uint32")], ["nTableEntries", xdr3.lookup("Uint32")], ["nTypes", xdr3.lookup("Uint32")], ["nDataSegments", xdr3.lookup("Uint32")], ["nElemSegments", xdr3.lookup("Uint32")], ["nImports", xdr3.lookup("Uint32")], ["nExports", xdr3.lookup("Uint32")], ["nDataSegmentBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("ContractCodeEntryV1", [["ext", xdr3.lookup("ExtensionPoint")], ["costInputs", xdr3.lookup("ContractCodeCostInputs")]]);
      xdr3.union("ContractCodeEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("ContractCodeEntryV1")
        }
      });
      xdr3.struct("ContractCodeEntry", [["ext", xdr3.lookup("ContractCodeEntryExt")], ["hash", xdr3.lookup("Hash")], ["code", xdr3.varOpaque()]]);
      xdr3.struct("TtlEntry", [["keyHash", xdr3.lookup("Hash")], ["liveUntilLedgerSeq", xdr3.lookup("Uint32")]]);
      xdr3.union("LedgerEntryExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerEntryExtensionV1", [["sponsoringId", xdr3.lookup("SponsorshipDescriptor")], ["ext", xdr3.lookup("LedgerEntryExtensionV1Ext")]]);
      xdr3.union("LedgerEntryData", {
        switchOn: xdr3.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr3.lookup("AccountEntry"),
          trustLine: xdr3.lookup("TrustLineEntry"),
          offer: xdr3.lookup("OfferEntry"),
          data: xdr3.lookup("DataEntry"),
          claimableBalance: xdr3.lookup("ClaimableBalanceEntry"),
          liquidityPool: xdr3.lookup("LiquidityPoolEntry"),
          contractData: xdr3.lookup("ContractDataEntry"),
          contractCode: xdr3.lookup("ContractCodeEntry"),
          configSetting: xdr3.lookup("ConfigSettingEntry"),
          ttl: xdr3.lookup("TtlEntry")
        }
      });
      xdr3.union("LedgerEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerEntryExtensionV1")
        }
      });
      xdr3.struct("LedgerEntry", [["lastModifiedLedgerSeq", xdr3.lookup("Uint32")], ["data", xdr3.lookup("LedgerEntryData")], ["ext", xdr3.lookup("LedgerEntryExt")]]);
      xdr3.struct("LedgerKeyAccount", [["accountId", xdr3.lookup("AccountId")]]);
      xdr3.struct("LedgerKeyTrustLine", [["accountId", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("TrustLineAsset")]]);
      xdr3.struct("LedgerKeyOffer", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("LedgerKeyData", [["accountId", xdr3.lookup("AccountId")], ["dataName", xdr3.lookup("String64")]]);
      xdr3.struct("LedgerKeyClaimableBalance", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", xdr3.lookup("PoolId")]]);
      xdr3.struct("LedgerKeyContractData", [["contract", xdr3.lookup("ScAddress")], ["key", xdr3.lookup("ScVal")], ["durability", xdr3.lookup("ContractDataDurability")]]);
      xdr3.struct("LedgerKeyContractCode", [["hash", xdr3.lookup("Hash")]]);
      xdr3.struct("LedgerKeyConfigSetting", [["configSettingId", xdr3.lookup("ConfigSettingId")]]);
      xdr3.struct("LedgerKeyTtl", [["keyHash", xdr3.lookup("Hash")]]);
      xdr3.union("LedgerKey", {
        switchOn: xdr3.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr3.lookup("LedgerKeyAccount"),
          trustLine: xdr3.lookup("LedgerKeyTrustLine"),
          offer: xdr3.lookup("LedgerKeyOffer"),
          data: xdr3.lookup("LedgerKeyData"),
          claimableBalance: xdr3.lookup("LedgerKeyClaimableBalance"),
          liquidityPool: xdr3.lookup("LedgerKeyLiquidityPool"),
          contractData: xdr3.lookup("LedgerKeyContractData"),
          contractCode: xdr3.lookup("LedgerKeyContractCode"),
          configSetting: xdr3.lookup("LedgerKeyConfigSetting"),
          ttl: xdr3.lookup("LedgerKeyTtl")
        }
      });
      xdr3["enum"]("EnvelopeType", {
        envelopeTypeTxV0: 0,
        envelopeTypeScp: 1,
        envelopeTypeTx: 2,
        envelopeTypeAuth: 3,
        envelopeTypeScpvalue: 4,
        envelopeTypeTxFeeBump: 5,
        envelopeTypeOpId: 6,
        envelopeTypePoolRevokeOpId: 7,
        envelopeTypeContractId: 8,
        envelopeTypeSorobanAuthorization: 9
      });
      xdr3["enum"]("BucketListType", {
        live: 0,
        hotArchive: 1,
        coldArchive: 2
      });
      xdr3["enum"]("BucketEntryType", {
        metaentry: -1,
        liveentry: 0,
        deadentry: 1,
        initentry: 2
      });
      xdr3["enum"]("HotArchiveBucketEntryType", {
        hotArchiveMetaentry: -1,
        hotArchiveArchived: 0,
        hotArchiveLive: 1,
        hotArchiveDeleted: 2
      });
      xdr3["enum"]("ColdArchiveBucketEntryType", {
        coldArchiveMetaentry: -1,
        coldArchiveArchivedLeaf: 0,
        coldArchiveDeletedLeaf: 1,
        coldArchiveBoundaryLeaf: 2,
        coldArchiveHash: 3
      });
      xdr3.union("BucketMetadataExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "bucketListType"]],
        arms: {
          bucketListType: xdr3.lookup("BucketListType")
        }
      });
      xdr3.struct("BucketMetadata", [["ledgerVersion", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("BucketMetadataExt")]]);
      xdr3.union("BucketEntry", {
        switchOn: xdr3.lookup("BucketEntryType"),
        switchName: "type",
        switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
        arms: {
          liveEntry: xdr3.lookup("LedgerEntry"),
          deadEntry: xdr3.lookup("LedgerKey"),
          metaEntry: xdr3.lookup("BucketMetadata")
        }
      });
      xdr3.union("HotArchiveBucketEntry", {
        switchOn: xdr3.lookup("HotArchiveBucketEntryType"),
        switchName: "type",
        switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]],
        arms: {
          archivedEntry: xdr3.lookup("LedgerEntry"),
          key: xdr3.lookup("LedgerKey"),
          metaEntry: xdr3.lookup("BucketMetadata")
        }
      });
      xdr3.struct("ColdArchiveArchivedLeaf", [["index", xdr3.lookup("Uint32")], ["archivedEntry", xdr3.lookup("LedgerEntry")]]);
      xdr3.struct("ColdArchiveDeletedLeaf", [["index", xdr3.lookup("Uint32")], ["deletedKey", xdr3.lookup("LedgerKey")]]);
      xdr3.struct("ColdArchiveBoundaryLeaf", [["index", xdr3.lookup("Uint32")], ["isLowerBound", xdr3.bool()]]);
      xdr3.struct("ColdArchiveHashEntry", [["index", xdr3.lookup("Uint32")], ["level", xdr3.lookup("Uint32")], ["hash", xdr3.lookup("Hash")]]);
      xdr3.union("ColdArchiveBucketEntry", {
        switchOn: xdr3.lookup("ColdArchiveBucketEntryType"),
        switchName: "type",
        switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]],
        arms: {
          metaEntry: xdr3.lookup("BucketMetadata"),
          archivedLeaf: xdr3.lookup("ColdArchiveArchivedLeaf"),
          deletedLeaf: xdr3.lookup("ColdArchiveDeletedLeaf"),
          boundaryLeaf: xdr3.lookup("ColdArchiveBoundaryLeaf"),
          hashEntry: xdr3.lookup("ColdArchiveHashEntry")
        }
      });
      xdr3.typedef("UpgradeType", xdr3.varOpaque(128));
      xdr3["enum"]("StellarValueType", {
        stellarValueBasic: 0,
        stellarValueSigned: 1
      });
      xdr3.struct("LedgerCloseValueSignature", [["nodeId", xdr3.lookup("NodeId")], ["signature", xdr3.lookup("Signature")]]);
      xdr3.union("StellarValueExt", {
        switchOn: xdr3.lookup("StellarValueType"),
        switchName: "v",
        switches: [["stellarValueBasic", xdr3["void"]()], ["stellarValueSigned", "lcValueSignature"]],
        arms: {
          lcValueSignature: xdr3.lookup("LedgerCloseValueSignature")
        }
      });
      xdr3.struct("StellarValue", [["txSetHash", xdr3.lookup("Hash")], ["closeTime", xdr3.lookup("TimePoint")], ["upgrades", xdr3.varArray(xdr3.lookup("UpgradeType"), 6)], ["ext", xdr3.lookup("StellarValueExt")]]);
      xdr3["const"]("MASK_LEDGER_HEADER_FLAGS", 7);
      xdr3["enum"]("LedgerHeaderFlags", {
        disableLiquidityPoolTradingFlag: 1,
        disableLiquidityPoolDepositFlag: 2,
        disableLiquidityPoolWithdrawalFlag: 4
      });
      xdr3.union("LedgerHeaderExtensionV1Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerHeaderExtensionV1", [["flags", xdr3.lookup("Uint32")], ["ext", xdr3.lookup("LedgerHeaderExtensionV1Ext")]]);
      xdr3.union("LedgerHeaderExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerHeaderExtensionV1")
        }
      });
      xdr3.struct("LedgerHeader", [["ledgerVersion", xdr3.lookup("Uint32")], ["previousLedgerHash", xdr3.lookup("Hash")], ["scpValue", xdr3.lookup("StellarValue")], ["txSetResultHash", xdr3.lookup("Hash")], ["bucketListHash", xdr3.lookup("Hash")], ["ledgerSeq", xdr3.lookup("Uint32")], ["totalCoins", xdr3.lookup("Int64")], ["feePool", xdr3.lookup("Int64")], ["inflationSeq", xdr3.lookup("Uint32")], ["idPool", xdr3.lookup("Uint64")], ["baseFee", xdr3.lookup("Uint32")], ["baseReserve", xdr3.lookup("Uint32")], ["maxTxSetSize", xdr3.lookup("Uint32")], ["skipList", xdr3.array(xdr3.lookup("Hash"), 4)], ["ext", xdr3.lookup("LedgerHeaderExt")]]);
      xdr3["enum"]("LedgerUpgradeType", {
        ledgerUpgradeVersion: 1,
        ledgerUpgradeBaseFee: 2,
        ledgerUpgradeMaxTxSetSize: 3,
        ledgerUpgradeBaseReserve: 4,
        ledgerUpgradeFlags: 5,
        ledgerUpgradeConfig: 6,
        ledgerUpgradeMaxSorobanTxSetSize: 7
      });
      xdr3.struct("ConfigUpgradeSetKey", [["contractId", xdr3.lookup("Hash")], ["contentHash", xdr3.lookup("Hash")]]);
      xdr3.union("LedgerUpgrade", {
        switchOn: xdr3.lookup("LedgerUpgradeType"),
        switchName: "type",
        switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]],
        arms: {
          newLedgerVersion: xdr3.lookup("Uint32"),
          newBaseFee: xdr3.lookup("Uint32"),
          newMaxTxSetSize: xdr3.lookup("Uint32"),
          newBaseReserve: xdr3.lookup("Uint32"),
          newFlags: xdr3.lookup("Uint32"),
          newConfig: xdr3.lookup("ConfigUpgradeSetKey"),
          newMaxSorobanTxSetSize: xdr3.lookup("Uint32")
        }
      });
      xdr3.struct("ConfigUpgradeSet", [["updatedEntry", xdr3.varArray(xdr3.lookup("ConfigSettingEntry"), 2147483647)]]);
      xdr3["enum"]("TxSetComponentType", {
        txsetCompTxsMaybeDiscountedFee: 0
      });
      xdr3.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", xdr3.option(xdr3.lookup("Int64"))], ["txes", xdr3.varArray(xdr3.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr3.union("TxSetComponent", {
        switchOn: xdr3.lookup("TxSetComponentType"),
        switchName: "type",
        switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]],
        arms: {
          txsMaybeDiscountedFee: xdr3.lookup("TxSetComponentTxsMaybeDiscountedFee")
        }
      });
      xdr3.union("TransactionPhase", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0Components"]],
        arms: {
          v0Components: xdr3.varArray(xdr3.lookup("TxSetComponent"), 2147483647)
        }
      });
      xdr3.struct("TransactionSet", [["previousLedgerHash", xdr3.lookup("Hash")], ["txes", xdr3.varArray(xdr3.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr3.struct("TransactionSetV1", [["previousLedgerHash", xdr3.lookup("Hash")], ["phases", xdr3.varArray(xdr3.lookup("TransactionPhase"), 2147483647)]]);
      xdr3.union("GeneralizedTransactionSet", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[1, "v1TxSet"]],
        arms: {
          v1TxSet: xdr3.lookup("TransactionSetV1")
        }
      });
      xdr3.struct("TransactionResultPair", [["transactionHash", xdr3.lookup("Hash")], ["result", xdr3.lookup("TransactionResult")]]);
      xdr3.struct("TransactionResultSet", [["results", xdr3.varArray(xdr3.lookup("TransactionResultPair"), 2147483647)]]);
      xdr3.union("TransactionHistoryEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "generalizedTxSet"]],
        arms: {
          generalizedTxSet: xdr3.lookup("GeneralizedTransactionSet")
        }
      });
      xdr3.struct("TransactionHistoryEntry", [["ledgerSeq", xdr3.lookup("Uint32")], ["txSet", xdr3.lookup("TransactionSet")], ["ext", xdr3.lookup("TransactionHistoryEntryExt")]]);
      xdr3.union("TransactionHistoryResultEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionHistoryResultEntry", [["ledgerSeq", xdr3.lookup("Uint32")], ["txResultSet", xdr3.lookup("TransactionResultSet")], ["ext", xdr3.lookup("TransactionHistoryResultEntryExt")]]);
      xdr3.union("LedgerHeaderHistoryEntryExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("LedgerHeaderHistoryEntry", [["hash", xdr3.lookup("Hash")], ["header", xdr3.lookup("LedgerHeader")], ["ext", xdr3.lookup("LedgerHeaderHistoryEntryExt")]]);
      xdr3.struct("LedgerScpMessages", [["ledgerSeq", xdr3.lookup("Uint32")], ["messages", xdr3.varArray(xdr3.lookup("ScpEnvelope"), 2147483647)]]);
      xdr3.struct("ScpHistoryEntryV0", [["quorumSets", xdr3.varArray(xdr3.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", xdr3.lookup("LedgerScpMessages")]]);
      xdr3.union("ScpHistoryEntry", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("ScpHistoryEntryV0")
        }
      });
      xdr3["enum"]("LedgerEntryChangeType", {
        ledgerEntryCreated: 0,
        ledgerEntryUpdated: 1,
        ledgerEntryRemoved: 2,
        ledgerEntryState: 3
      });
      xdr3.union("LedgerEntryChange", {
        switchOn: xdr3.lookup("LedgerEntryChangeType"),
        switchName: "type",
        switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
        arms: {
          created: xdr3.lookup("LedgerEntry"),
          updated: xdr3.lookup("LedgerEntry"),
          removed: xdr3.lookup("LedgerKey"),
          state: xdr3.lookup("LedgerEntry")
        }
      });
      xdr3.typedef("LedgerEntryChanges", xdr3.varArray(xdr3.lookup("LedgerEntryChange"), 2147483647));
      xdr3.struct("OperationMeta", [["changes", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3.struct("TransactionMetaV1", [["txChanges", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)]]);
      xdr3.struct("TransactionMetaV2", [["txChangesBefore", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3["enum"]("ContractEventType", {
        system: 0,
        contract: 1,
        diagnostic: 2
      });
      xdr3.struct("ContractEventV0", [["topics", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)], ["data", xdr3.lookup("ScVal")]]);
      xdr3.union("ContractEventBody", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("ContractEventV0")
        }
      });
      xdr3.struct("ContractEvent", [["ext", xdr3.lookup("ExtensionPoint")], ["contractId", xdr3.option(xdr3.lookup("Hash"))], ["type", xdr3.lookup("ContractEventType")], ["body", xdr3.lookup("ContractEventBody")]]);
      xdr3.struct("DiagnosticEvent", [["inSuccessfulContractCall", xdr3.bool()], ["event", xdr3.lookup("ContractEvent")]]);
      xdr3.typedef("DiagnosticEvents", xdr3.varArray(xdr3.lookup("DiagnosticEvent"), 2147483647));
      xdr3.struct("SorobanTransactionMetaExtV1", [["ext", xdr3.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", xdr3.lookup("Int64")], ["totalRefundableResourceFeeCharged", xdr3.lookup("Int64")], ["rentFeeCharged", xdr3.lookup("Int64")]]);
      xdr3.union("SorobanTransactionMetaExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("SorobanTransactionMetaExtV1")
        }
      });
      xdr3.struct("SorobanTransactionMeta", [["ext", xdr3.lookup("SorobanTransactionMetaExt")], ["events", xdr3.varArray(xdr3.lookup("ContractEvent"), 2147483647)], ["returnValue", xdr3.lookup("ScVal")], ["diagnosticEvents", xdr3.varArray(xdr3.lookup("DiagnosticEvent"), 2147483647)]]);
      xdr3.struct("TransactionMetaV3", [["ext", xdr3.lookup("ExtensionPoint")], ["txChangesBefore", xdr3.lookup("LedgerEntryChanges")], ["operations", xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr3.lookup("LedgerEntryChanges")], ["sorobanMeta", xdr3.option(xdr3.lookup("SorobanTransactionMeta"))]]);
      xdr3.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", xdr3.lookup("ScVal")], ["events", xdr3.varArray(xdr3.lookup("ContractEvent"), 2147483647)]]);
      xdr3.union("TransactionMeta", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]],
        arms: {
          operations: xdr3.varArray(xdr3.lookup("OperationMeta"), 2147483647),
          v1: xdr3.lookup("TransactionMetaV1"),
          v2: xdr3.lookup("TransactionMetaV2"),
          v3: xdr3.lookup("TransactionMetaV3")
        }
      });
      xdr3.struct("TransactionResultMeta", [["result", xdr3.lookup("TransactionResultPair")], ["feeProcessing", xdr3.lookup("LedgerEntryChanges")], ["txApplyProcessing", xdr3.lookup("TransactionMeta")]]);
      xdr3.struct("UpgradeEntryMeta", [["upgrade", xdr3.lookup("LedgerUpgrade")], ["changes", xdr3.lookup("LedgerEntryChanges")]]);
      xdr3.struct("LedgerCloseMetaV0", [["ledgerHeader", xdr3.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr3.lookup("TransactionSet")], ["txProcessing", xdr3.varArray(xdr3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr3.varArray(xdr3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr3.varArray(xdr3.lookup("ScpHistoryEntry"), 2147483647)]]);
      xdr3.struct("LedgerCloseMetaExtV1", [["ext", xdr3.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", xdr3.lookup("Int64")]]);
      xdr3.union("LedgerCloseMetaExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "v1"]],
        arms: {
          v1: xdr3.lookup("LedgerCloseMetaExtV1")
        }
      });
      xdr3.struct("LedgerCloseMetaV1", [["ext", xdr3.lookup("LedgerCloseMetaExt")], ["ledgerHeader", xdr3.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr3.lookup("GeneralizedTransactionSet")], ["txProcessing", xdr3.varArray(xdr3.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr3.varArray(xdr3.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr3.varArray(xdr3.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", xdr3.lookup("Uint64")], ["evictedTemporaryLedgerKeys", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", xdr3.varArray(xdr3.lookup("LedgerEntry"), 2147483647)]]);
      xdr3.union("LedgerCloseMeta", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, "v0"], [1, "v1"]],
        arms: {
          v0: xdr3.lookup("LedgerCloseMetaV0"),
          v1: xdr3.lookup("LedgerCloseMetaV1")
        }
      });
      xdr3["enum"]("ErrorCode", {
        errMisc: 0,
        errData: 1,
        errConf: 2,
        errAuth: 3,
        errLoad: 4
      });
      xdr3.struct("Error", [["code", xdr3.lookup("ErrorCode")], ["msg", xdr3.string(100)]]);
      xdr3.struct("SendMore", [["numMessages", xdr3.lookup("Uint32")]]);
      xdr3.struct("SendMoreExtended", [["numMessages", xdr3.lookup("Uint32")], ["numBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("AuthCert", [["pubkey", xdr3.lookup("Curve25519Public")], ["expiration", xdr3.lookup("Uint64")], ["sig", xdr3.lookup("Signature")]]);
      xdr3.struct("Hello", [["ledgerVersion", xdr3.lookup("Uint32")], ["overlayVersion", xdr3.lookup("Uint32")], ["overlayMinVersion", xdr3.lookup("Uint32")], ["networkId", xdr3.lookup("Hash")], ["versionStr", xdr3.string(100)], ["listeningPort", xdr3["int"]()], ["peerId", xdr3.lookup("NodeId")], ["cert", xdr3.lookup("AuthCert")], ["nonce", xdr3.lookup("Uint256")]]);
      xdr3["const"]("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200);
      xdr3.struct("Auth", [["flags", xdr3["int"]()]]);
      xdr3["enum"]("IpAddrType", {
        iPv4: 0,
        iPv6: 1
      });
      xdr3.union("PeerAddressIp", {
        switchOn: xdr3.lookup("IpAddrType"),
        switchName: "type",
        switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
        arms: {
          ipv4: xdr3.opaque(4),
          ipv6: xdr3.opaque(16)
        }
      });
      xdr3.struct("PeerAddress", [["ip", xdr3.lookup("PeerAddressIp")], ["port", xdr3.lookup("Uint32")], ["numFailures", xdr3.lookup("Uint32")]]);
      xdr3["enum"]("MessageType", {
        errorMsg: 0,
        auth: 2,
        dontHave: 3,
        getPeers: 4,
        peers: 5,
        getTxSet: 6,
        txSet: 7,
        generalizedTxSet: 17,
        transaction: 8,
        getScpQuorumset: 9,
        scpQuorumset: 10,
        scpMessage: 11,
        getScpState: 12,
        hello: 13,
        surveyRequest: 14,
        surveyResponse: 15,
        sendMore: 16,
        sendMoreExtended: 20,
        floodAdvert: 18,
        floodDemand: 19,
        timeSlicedSurveyRequest: 21,
        timeSlicedSurveyResponse: 22,
        timeSlicedSurveyStartCollecting: 23,
        timeSlicedSurveyStopCollecting: 24
      });
      xdr3.struct("DontHave", [["type", xdr3.lookup("MessageType")], ["reqHash", xdr3.lookup("Uint256")]]);
      xdr3["enum"]("SurveyMessageCommandType", {
        surveyTopology: 0,
        timeSlicedSurveyTopology: 1
      });
      xdr3["enum"]("SurveyMessageResponseType", {
        surveyTopologyResponseV0: 0,
        surveyTopologyResponseV1: 1,
        surveyTopologyResponseV2: 2
      });
      xdr3.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", xdr3.lookup("NodeId")], ["nonce", xdr3.lookup("Uint32")], ["ledgerNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", xdr3.lookup("Signature")], ["startCollecting", xdr3.lookup("TimeSlicedSurveyStartCollectingMessage")]]);
      xdr3.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", xdr3.lookup("NodeId")], ["nonce", xdr3.lookup("Uint32")], ["ledgerNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", xdr3.lookup("Signature")], ["stopCollecting", xdr3.lookup("TimeSlicedSurveyStopCollectingMessage")]]);
      xdr3.struct("SurveyRequestMessage", [["surveyorPeerId", xdr3.lookup("NodeId")], ["surveyedPeerId", xdr3.lookup("NodeId")], ["ledgerNum", xdr3.lookup("Uint32")], ["encryptionKey", xdr3.lookup("Curve25519Public")], ["commandType", xdr3.lookup("SurveyMessageCommandType")]]);
      xdr3.struct("TimeSlicedSurveyRequestMessage", [["request", xdr3.lookup("SurveyRequestMessage")], ["nonce", xdr3.lookup("Uint32")], ["inboundPeersIndex", xdr3.lookup("Uint32")], ["outboundPeersIndex", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedSurveyRequestMessage", [["requestSignature", xdr3.lookup("Signature")], ["request", xdr3.lookup("SurveyRequestMessage")]]);
      xdr3.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", xdr3.lookup("Signature")], ["request", xdr3.lookup("TimeSlicedSurveyRequestMessage")]]);
      xdr3.typedef("EncryptedBody", xdr3.varOpaque(64e3));
      xdr3.struct("SurveyResponseMessage", [["surveyorPeerId", xdr3.lookup("NodeId")], ["surveyedPeerId", xdr3.lookup("NodeId")], ["ledgerNum", xdr3.lookup("Uint32")], ["commandType", xdr3.lookup("SurveyMessageCommandType")], ["encryptedBody", xdr3.lookup("EncryptedBody")]]);
      xdr3.struct("TimeSlicedSurveyResponseMessage", [["response", xdr3.lookup("SurveyResponseMessage")], ["nonce", xdr3.lookup("Uint32")]]);
      xdr3.struct("SignedSurveyResponseMessage", [["responseSignature", xdr3.lookup("Signature")], ["response", xdr3.lookup("SurveyResponseMessage")]]);
      xdr3.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", xdr3.lookup("Signature")], ["response", xdr3.lookup("TimeSlicedSurveyResponseMessage")]]);
      xdr3.struct("PeerStats", [["id", xdr3.lookup("NodeId")], ["versionStr", xdr3.string(100)], ["messagesRead", xdr3.lookup("Uint64")], ["messagesWritten", xdr3.lookup("Uint64")], ["bytesRead", xdr3.lookup("Uint64")], ["bytesWritten", xdr3.lookup("Uint64")], ["secondsConnected", xdr3.lookup("Uint64")], ["uniqueFloodBytesRecv", xdr3.lookup("Uint64")], ["duplicateFloodBytesRecv", xdr3.lookup("Uint64")], ["uniqueFetchBytesRecv", xdr3.lookup("Uint64")], ["duplicateFetchBytesRecv", xdr3.lookup("Uint64")], ["uniqueFloodMessageRecv", xdr3.lookup("Uint64")], ["duplicateFloodMessageRecv", xdr3.lookup("Uint64")], ["uniqueFetchMessageRecv", xdr3.lookup("Uint64")], ["duplicateFetchMessageRecv", xdr3.lookup("Uint64")]]);
      xdr3.typedef("PeerStatList", xdr3.varArray(xdr3.lookup("PeerStats"), 25));
      xdr3.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", xdr3.lookup("Uint32")], ["droppedAuthenticatedPeers", xdr3.lookup("Uint32")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", xdr3.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", xdr3.lookup("Uint32")], ["lostSyncCount", xdr3.lookup("Uint32")], ["isValidator", xdr3.bool()], ["maxInboundPeerCount", xdr3.lookup("Uint32")], ["maxOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TimeSlicedPeerData", [["peerStats", xdr3.lookup("PeerStats")], ["averageLatencyMs", xdr3.lookup("Uint32")]]);
      xdr3.typedef("TimeSlicedPeerDataList", xdr3.varArray(xdr3.lookup("TimeSlicedPeerData"), 25));
      xdr3.struct("TopologyResponseBodyV0", [["inboundPeers", xdr3.lookup("PeerStatList")], ["outboundPeers", xdr3.lookup("PeerStatList")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TopologyResponseBodyV1", [["inboundPeers", xdr3.lookup("PeerStatList")], ["outboundPeers", xdr3.lookup("PeerStatList")], ["totalInboundPeerCount", xdr3.lookup("Uint32")], ["totalOutboundPeerCount", xdr3.lookup("Uint32")], ["maxInboundPeerCount", xdr3.lookup("Uint32")], ["maxOutboundPeerCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("TopologyResponseBodyV2", [["inboundPeers", xdr3.lookup("TimeSlicedPeerDataList")], ["outboundPeers", xdr3.lookup("TimeSlicedPeerDataList")], ["nodeData", xdr3.lookup("TimeSlicedNodeData")]]);
      xdr3.union("SurveyResponseBody", {
        switchOn: xdr3.lookup("SurveyMessageResponseType"),
        switchName: "type",
        switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]],
        arms: {
          topologyResponseBodyV0: xdr3.lookup("TopologyResponseBodyV0"),
          topologyResponseBodyV1: xdr3.lookup("TopologyResponseBodyV1"),
          topologyResponseBodyV2: xdr3.lookup("TopologyResponseBodyV2")
        }
      });
      xdr3["const"]("TX_ADVERT_VECTOR_MAX_SIZE", 1e3);
      xdr3.typedef("TxAdvertVector", xdr3.varArray(xdr3.lookup("Hash"), xdr3.lookup("TX_ADVERT_VECTOR_MAX_SIZE")));
      xdr3.struct("FloodAdvert", [["txHashes", xdr3.lookup("TxAdvertVector")]]);
      xdr3["const"]("TX_DEMAND_VECTOR_MAX_SIZE", 1e3);
      xdr3.typedef("TxDemandVector", xdr3.varArray(xdr3.lookup("Hash"), xdr3.lookup("TX_DEMAND_VECTOR_MAX_SIZE")));
      xdr3.struct("FloodDemand", [["txHashes", xdr3.lookup("TxDemandVector")]]);
      xdr3.union("StellarMessage", {
        switchOn: xdr3.lookup("MessageType"),
        switchName: "type",
        switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", xdr3["void"]()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]],
        arms: {
          error: xdr3.lookup("Error"),
          hello: xdr3.lookup("Hello"),
          auth: xdr3.lookup("Auth"),
          dontHave: xdr3.lookup("DontHave"),
          peers: xdr3.varArray(xdr3.lookup("PeerAddress"), 100),
          txSetHash: xdr3.lookup("Uint256"),
          txSet: xdr3.lookup("TransactionSet"),
          generalizedTxSet: xdr3.lookup("GeneralizedTransactionSet"),
          transaction: xdr3.lookup("TransactionEnvelope"),
          signedSurveyRequestMessage: xdr3.lookup("SignedSurveyRequestMessage"),
          signedSurveyResponseMessage: xdr3.lookup("SignedSurveyResponseMessage"),
          signedTimeSlicedSurveyRequestMessage: xdr3.lookup("SignedTimeSlicedSurveyRequestMessage"),
          signedTimeSlicedSurveyResponseMessage: xdr3.lookup("SignedTimeSlicedSurveyResponseMessage"),
          signedTimeSlicedSurveyStartCollectingMessage: xdr3.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),
          signedTimeSlicedSurveyStopCollectingMessage: xdr3.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),
          qSetHash: xdr3.lookup("Uint256"),
          qSet: xdr3.lookup("ScpQuorumSet"),
          envelope: xdr3.lookup("ScpEnvelope"),
          getScpLedgerSeq: xdr3.lookup("Uint32"),
          sendMoreMessage: xdr3.lookup("SendMore"),
          sendMoreExtendedMessage: xdr3.lookup("SendMoreExtended"),
          floodAdvert: xdr3.lookup("FloodAdvert"),
          floodDemand: xdr3.lookup("FloodDemand")
        }
      });
      xdr3.struct("AuthenticatedMessageV0", [["sequence", xdr3.lookup("Uint64")], ["message", xdr3.lookup("StellarMessage")], ["mac", xdr3.lookup("HmacSha256Mac")]]);
      xdr3.union("AuthenticatedMessage", {
        switchOn: xdr3.lookup("Uint32"),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr3.lookup("AuthenticatedMessageV0")
        }
      });
      xdr3["const"]("MAX_OPS_PER_TX", 100);
      xdr3.union("LiquidityPoolParameters", {
        switchOn: xdr3.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr3.lookup("LiquidityPoolConstantProductParameters")
        }
      });
      xdr3.struct("MuxedAccountMed25519", [["id", xdr3.lookup("Uint64")], ["ed25519", xdr3.lookup("Uint256")]]);
      xdr3.union("MuxedAccount", {
        switchOn: xdr3.lookup("CryptoKeyType"),
        switchName: "type",
        switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
        arms: {
          ed25519: xdr3.lookup("Uint256"),
          med25519: xdr3.lookup("MuxedAccountMed25519")
        }
      });
      xdr3.struct("DecoratedSignature", [["hint", xdr3.lookup("SignatureHint")], ["signature", xdr3.lookup("Signature")]]);
      xdr3["enum"]("OperationType", {
        createAccount: 0,
        payment: 1,
        pathPaymentStrictReceive: 2,
        manageSellOffer: 3,
        createPassiveSellOffer: 4,
        setOptions: 5,
        changeTrust: 6,
        allowTrust: 7,
        accountMerge: 8,
        inflation: 9,
        manageData: 10,
        bumpSequence: 11,
        manageBuyOffer: 12,
        pathPaymentStrictSend: 13,
        createClaimableBalance: 14,
        claimClaimableBalance: 15,
        beginSponsoringFutureReserves: 16,
        endSponsoringFutureReserves: 17,
        revokeSponsorship: 18,
        clawback: 19,
        clawbackClaimableBalance: 20,
        setTrustLineFlags: 21,
        liquidityPoolDeposit: 22,
        liquidityPoolWithdraw: 23,
        invokeHostFunction: 24,
        extendFootprintTtl: 25,
        restoreFootprint: 26
      });
      xdr3.struct("CreateAccountOp", [["destination", xdr3.lookup("AccountId")], ["startingBalance", xdr3.lookup("Int64")]]);
      xdr3.struct("PaymentOp", [["destination", xdr3.lookup("MuxedAccount")], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("PathPaymentStrictReceiveOp", [["sendAsset", xdr3.lookup("Asset")], ["sendMax", xdr3.lookup("Int64")], ["destination", xdr3.lookup("MuxedAccount")], ["destAsset", xdr3.lookup("Asset")], ["destAmount", xdr3.lookup("Int64")], ["path", xdr3.varArray(xdr3.lookup("Asset"), 5)]]);
      xdr3.struct("PathPaymentStrictSendOp", [["sendAsset", xdr3.lookup("Asset")], ["sendAmount", xdr3.lookup("Int64")], ["destination", xdr3.lookup("MuxedAccount")], ["destAsset", xdr3.lookup("Asset")], ["destMin", xdr3.lookup("Int64")], ["path", xdr3.varArray(xdr3.lookup("Asset"), 5)]]);
      xdr3.struct("ManageSellOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("ManageBuyOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["buyAmount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")], ["offerId", xdr3.lookup("Int64")]]);
      xdr3.struct("CreatePassiveSellOfferOp", [["selling", xdr3.lookup("Asset")], ["buying", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["price", xdr3.lookup("Price")]]);
      xdr3.struct("SetOptionsOp", [["inflationDest", xdr3.option(xdr3.lookup("AccountId"))], ["clearFlags", xdr3.option(xdr3.lookup("Uint32"))], ["setFlags", xdr3.option(xdr3.lookup("Uint32"))], ["masterWeight", xdr3.option(xdr3.lookup("Uint32"))], ["lowThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["medThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["highThreshold", xdr3.option(xdr3.lookup("Uint32"))], ["homeDomain", xdr3.option(xdr3.lookup("String32"))], ["signer", xdr3.option(xdr3.lookup("Signer"))]]);
      xdr3.union("ChangeTrustAsset", {
        switchOn: xdr3.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr3["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
        arms: {
          alphaNum4: xdr3.lookup("AlphaNum4"),
          alphaNum12: xdr3.lookup("AlphaNum12"),
          liquidityPool: xdr3.lookup("LiquidityPoolParameters")
        }
      });
      xdr3.struct("ChangeTrustOp", [["line", xdr3.lookup("ChangeTrustAsset")], ["limit", xdr3.lookup("Int64")]]);
      xdr3.struct("AllowTrustOp", [["trustor", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("AssetCode")], ["authorize", xdr3.lookup("Uint32")]]);
      xdr3.struct("ManageDataOp", [["dataName", xdr3.lookup("String64")], ["dataValue", xdr3.option(xdr3.lookup("DataValue"))]]);
      xdr3.struct("BumpSequenceOp", [["bumpTo", xdr3.lookup("SequenceNumber")]]);
      xdr3.struct("CreateClaimableBalanceOp", [["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")], ["claimants", xdr3.varArray(xdr3.lookup("Claimant"), 10)]]);
      xdr3.struct("ClaimClaimableBalanceOp", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", xdr3.lookup("AccountId")]]);
      xdr3["enum"]("RevokeSponsorshipType", {
        revokeSponsorshipLedgerEntry: 0,
        revokeSponsorshipSigner: 1
      });
      xdr3.struct("RevokeSponsorshipOpSigner", [["accountId", xdr3.lookup("AccountId")], ["signerKey", xdr3.lookup("SignerKey")]]);
      xdr3.union("RevokeSponsorshipOp", {
        switchOn: xdr3.lookup("RevokeSponsorshipType"),
        switchName: "type",
        switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
        arms: {
          ledgerKey: xdr3.lookup("LedgerKey"),
          signer: xdr3.lookup("RevokeSponsorshipOpSigner")
        }
      });
      xdr3.struct("ClawbackOp", [["asset", xdr3.lookup("Asset")], ["from", xdr3.lookup("MuxedAccount")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("ClawbackClaimableBalanceOp", [["balanceId", xdr3.lookup("ClaimableBalanceId")]]);
      xdr3.struct("SetTrustLineFlagsOp", [["trustor", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("Asset")], ["clearFlags", xdr3.lookup("Uint32")], ["setFlags", xdr3.lookup("Uint32")]]);
      xdr3["const"]("LIQUIDITY_POOL_FEE_V18", 30);
      xdr3.struct("LiquidityPoolDepositOp", [["liquidityPoolId", xdr3.lookup("PoolId")], ["maxAmountA", xdr3.lookup("Int64")], ["maxAmountB", xdr3.lookup("Int64")], ["minPrice", xdr3.lookup("Price")], ["maxPrice", xdr3.lookup("Price")]]);
      xdr3.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", xdr3.lookup("PoolId")], ["amount", xdr3.lookup("Int64")], ["minAmountA", xdr3.lookup("Int64")], ["minAmountB", xdr3.lookup("Int64")]]);
      xdr3["enum"]("HostFunctionType", {
        hostFunctionTypeInvokeContract: 0,
        hostFunctionTypeCreateContract: 1,
        hostFunctionTypeUploadContractWasm: 2,
        hostFunctionTypeCreateContractV2: 3
      });
      xdr3["enum"]("ContractIdPreimageType", {
        contractIdPreimageFromAddress: 0,
        contractIdPreimageFromAsset: 1
      });
      xdr3.struct("ContractIdPreimageFromAddress", [["address", xdr3.lookup("ScAddress")], ["salt", xdr3.lookup("Uint256")]]);
      xdr3.union("ContractIdPreimage", {
        switchOn: xdr3.lookup("ContractIdPreimageType"),
        switchName: "type",
        switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]],
        arms: {
          fromAddress: xdr3.lookup("ContractIdPreimageFromAddress"),
          fromAsset: xdr3.lookup("Asset")
        }
      });
      xdr3.struct("CreateContractArgs", [["contractIdPreimage", xdr3.lookup("ContractIdPreimage")], ["executable", xdr3.lookup("ContractExecutable")]]);
      xdr3.struct("CreateContractArgsV2", [["contractIdPreimage", xdr3.lookup("ContractIdPreimage")], ["executable", xdr3.lookup("ContractExecutable")], ["constructorArgs", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)]]);
      xdr3.struct("InvokeContractArgs", [["contractAddress", xdr3.lookup("ScAddress")], ["functionName", xdr3.lookup("ScSymbol")], ["args", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647)]]);
      xdr3.union("HostFunction", {
        switchOn: xdr3.lookup("HostFunctionType"),
        switchName: "type",
        switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]],
        arms: {
          invokeContract: xdr3.lookup("InvokeContractArgs"),
          createContract: xdr3.lookup("CreateContractArgs"),
          wasm: xdr3.varOpaque(),
          createContractV2: xdr3.lookup("CreateContractArgsV2")
        }
      });
      xdr3["enum"]("SorobanAuthorizedFunctionType", {
        sorobanAuthorizedFunctionTypeContractFn: 0,
        sorobanAuthorizedFunctionTypeCreateContractHostFn: 1,
        sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2
      });
      xdr3.union("SorobanAuthorizedFunction", {
        switchOn: xdr3.lookup("SorobanAuthorizedFunctionType"),
        switchName: "type",
        switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]],
        arms: {
          contractFn: xdr3.lookup("InvokeContractArgs"),
          createContractHostFn: xdr3.lookup("CreateContractArgs"),
          createContractV2HostFn: xdr3.lookup("CreateContractArgsV2")
        }
      });
      xdr3.struct("SorobanAuthorizedInvocation", [["function", xdr3.lookup("SorobanAuthorizedFunction")], ["subInvocations", xdr3.varArray(xdr3.lookup("SorobanAuthorizedInvocation"), 2147483647)]]);
      xdr3.struct("SorobanAddressCredentials", [["address", xdr3.lookup("ScAddress")], ["nonce", xdr3.lookup("Int64")], ["signatureExpirationLedger", xdr3.lookup("Uint32")], ["signature", xdr3.lookup("ScVal")]]);
      xdr3["enum"]("SorobanCredentialsType", {
        sorobanCredentialsSourceAccount: 0,
        sorobanCredentialsAddress: 1
      });
      xdr3.union("SorobanCredentials", {
        switchOn: xdr3.lookup("SorobanCredentialsType"),
        switchName: "type",
        switches: [["sorobanCredentialsSourceAccount", xdr3["void"]()], ["sorobanCredentialsAddress", "address"]],
        arms: {
          address: xdr3.lookup("SorobanAddressCredentials")
        }
      });
      xdr3.struct("SorobanAuthorizationEntry", [["credentials", xdr3.lookup("SorobanCredentials")], ["rootInvocation", xdr3.lookup("SorobanAuthorizedInvocation")]]);
      xdr3.struct("InvokeHostFunctionOp", [["hostFunction", xdr3.lookup("HostFunction")], ["auth", xdr3.varArray(xdr3.lookup("SorobanAuthorizationEntry"), 2147483647)]]);
      xdr3.struct("ExtendFootprintTtlOp", [["ext", xdr3.lookup("ExtensionPoint")], ["extendTo", xdr3.lookup("Uint32")]]);
      xdr3.struct("RestoreFootprintOp", [["ext", xdr3.lookup("ExtensionPoint")]]);
      xdr3.union("OperationBody", {
        switchOn: xdr3.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", xdr3["void"]()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", xdr3["void"]()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]],
        arms: {
          createAccountOp: xdr3.lookup("CreateAccountOp"),
          paymentOp: xdr3.lookup("PaymentOp"),
          pathPaymentStrictReceiveOp: xdr3.lookup("PathPaymentStrictReceiveOp"),
          manageSellOfferOp: xdr3.lookup("ManageSellOfferOp"),
          createPassiveSellOfferOp: xdr3.lookup("CreatePassiveSellOfferOp"),
          setOptionsOp: xdr3.lookup("SetOptionsOp"),
          changeTrustOp: xdr3.lookup("ChangeTrustOp"),
          allowTrustOp: xdr3.lookup("AllowTrustOp"),
          destination: xdr3.lookup("MuxedAccount"),
          manageDataOp: xdr3.lookup("ManageDataOp"),
          bumpSequenceOp: xdr3.lookup("BumpSequenceOp"),
          manageBuyOfferOp: xdr3.lookup("ManageBuyOfferOp"),
          pathPaymentStrictSendOp: xdr3.lookup("PathPaymentStrictSendOp"),
          createClaimableBalanceOp: xdr3.lookup("CreateClaimableBalanceOp"),
          claimClaimableBalanceOp: xdr3.lookup("ClaimClaimableBalanceOp"),
          beginSponsoringFutureReservesOp: xdr3.lookup("BeginSponsoringFutureReservesOp"),
          revokeSponsorshipOp: xdr3.lookup("RevokeSponsorshipOp"),
          clawbackOp: xdr3.lookup("ClawbackOp"),
          clawbackClaimableBalanceOp: xdr3.lookup("ClawbackClaimableBalanceOp"),
          setTrustLineFlagsOp: xdr3.lookup("SetTrustLineFlagsOp"),
          liquidityPoolDepositOp: xdr3.lookup("LiquidityPoolDepositOp"),
          liquidityPoolWithdrawOp: xdr3.lookup("LiquidityPoolWithdrawOp"),
          invokeHostFunctionOp: xdr3.lookup("InvokeHostFunctionOp"),
          extendFootprintTtlOp: xdr3.lookup("ExtendFootprintTtlOp"),
          restoreFootprintOp: xdr3.lookup("RestoreFootprintOp")
        }
      });
      xdr3.struct("Operation", [["sourceAccount", xdr3.option(xdr3.lookup("MuxedAccount"))], ["body", xdr3.lookup("OperationBody")]]);
      xdr3.struct("HashIdPreimageOperationId", [["sourceAccount", xdr3.lookup("AccountId")], ["seqNum", xdr3.lookup("SequenceNumber")], ["opNum", xdr3.lookup("Uint32")]]);
      xdr3.struct("HashIdPreimageRevokeId", [["sourceAccount", xdr3.lookup("AccountId")], ["seqNum", xdr3.lookup("SequenceNumber")], ["opNum", xdr3.lookup("Uint32")], ["liquidityPoolId", xdr3.lookup("PoolId")], ["asset", xdr3.lookup("Asset")]]);
      xdr3.struct("HashIdPreimageContractId", [["networkId", xdr3.lookup("Hash")], ["contractIdPreimage", xdr3.lookup("ContractIdPreimage")]]);
      xdr3.struct("HashIdPreimageSorobanAuthorization", [["networkId", xdr3.lookup("Hash")], ["nonce", xdr3.lookup("Int64")], ["signatureExpirationLedger", xdr3.lookup("Uint32")], ["invocation", xdr3.lookup("SorobanAuthorizedInvocation")]]);
      xdr3.union("HashIdPreimage", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]],
        arms: {
          operationId: xdr3.lookup("HashIdPreimageOperationId"),
          revokeId: xdr3.lookup("HashIdPreimageRevokeId"),
          contractId: xdr3.lookup("HashIdPreimageContractId"),
          sorobanAuthorization: xdr3.lookup("HashIdPreimageSorobanAuthorization")
        }
      });
      xdr3["enum"]("MemoType", {
        memoNone: 0,
        memoText: 1,
        memoId: 2,
        memoHash: 3,
        memoReturn: 4
      });
      xdr3.union("Memo", {
        switchOn: xdr3.lookup("MemoType"),
        switchName: "type",
        switches: [["memoNone", xdr3["void"]()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
        arms: {
          text: xdr3.string(28),
          id: xdr3.lookup("Uint64"),
          hash: xdr3.lookup("Hash"),
          retHash: xdr3.lookup("Hash")
        }
      });
      xdr3.struct("TimeBounds", [["minTime", xdr3.lookup("TimePoint")], ["maxTime", xdr3.lookup("TimePoint")]]);
      xdr3.struct("LedgerBounds", [["minLedger", xdr3.lookup("Uint32")], ["maxLedger", xdr3.lookup("Uint32")]]);
      xdr3.struct("PreconditionsV2", [["timeBounds", xdr3.option(xdr3.lookup("TimeBounds"))], ["ledgerBounds", xdr3.option(xdr3.lookup("LedgerBounds"))], ["minSeqNum", xdr3.option(xdr3.lookup("SequenceNumber"))], ["minSeqAge", xdr3.lookup("Duration")], ["minSeqLedgerGap", xdr3.lookup("Uint32")], ["extraSigners", xdr3.varArray(xdr3.lookup("SignerKey"), 2)]]);
      xdr3["enum"]("PreconditionType", {
        precondNone: 0,
        precondTime: 1,
        precondV2: 2
      });
      xdr3.union("Preconditions", {
        switchOn: xdr3.lookup("PreconditionType"),
        switchName: "type",
        switches: [["precondNone", xdr3["void"]()], ["precondTime", "timeBounds"], ["precondV2", "v2"]],
        arms: {
          timeBounds: xdr3.lookup("TimeBounds"),
          v2: xdr3.lookup("PreconditionsV2")
        }
      });
      xdr3.struct("LedgerFootprint", [["readOnly", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["readWrite", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)]]);
      xdr3["enum"]("ArchivalProofType", {
        existence: 0,
        nonexistence: 1
      });
      xdr3.struct("ArchivalProofNode", [["index", xdr3.lookup("Uint32")], ["hash", xdr3.lookup("Hash")]]);
      xdr3.typedef("ProofLevel", xdr3.varArray(xdr3.lookup("ArchivalProofNode"), 2147483647));
      xdr3.struct("NonexistenceProofBody", [["entriesToProve", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr3.varArray(xdr3.lookup("ProofLevel"), 2147483647)]]);
      xdr3.struct("ExistenceProofBody", [["keysToProve", xdr3.varArray(xdr3.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", xdr3.varArray(xdr3.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr3.varArray(xdr3.lookup("ProofLevel"), 2147483647)]]);
      xdr3.union("ArchivalProofBody", {
        switchOn: xdr3.lookup("ArchivalProofType"),
        switchName: "t",
        switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]],
        arms: {
          nonexistenceProof: xdr3.lookup("NonexistenceProofBody"),
          existenceProof: xdr3.lookup("ExistenceProofBody")
        }
      });
      xdr3.struct("ArchivalProof", [["epoch", xdr3.lookup("Uint32")], ["body", xdr3.lookup("ArchivalProofBody")]]);
      xdr3.struct("SorobanResources", [["footprint", xdr3.lookup("LedgerFootprint")], ["instructions", xdr3.lookup("Uint32")], ["readBytes", xdr3.lookup("Uint32")], ["writeBytes", xdr3.lookup("Uint32")]]);
      xdr3.struct("SorobanTransactionData", [["ext", xdr3.lookup("ExtensionPoint")], ["resources", xdr3.lookup("SorobanResources")], ["resourceFee", xdr3.lookup("Int64")]]);
      xdr3.union("TransactionV0Ext", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionV0", [["sourceAccountEd25519", xdr3.lookup("Uint256")], ["fee", xdr3.lookup("Uint32")], ["seqNum", xdr3.lookup("SequenceNumber")], ["timeBounds", xdr3.option(xdr3.lookup("TimeBounds"))], ["memo", xdr3.lookup("Memo")], ["operations", xdr3.varArray(xdr3.lookup("Operation"), xdr3.lookup("MAX_OPS_PER_TX"))], ["ext", xdr3.lookup("TransactionV0Ext")]]);
      xdr3.struct("TransactionV0Envelope", [["tx", xdr3.lookup("TransactionV0")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("TransactionExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()], [1, "sorobanData"]],
        arms: {
          sorobanData: xdr3.lookup("SorobanTransactionData")
        }
      });
      xdr3.struct("Transaction", [["sourceAccount", xdr3.lookup("MuxedAccount")], ["fee", xdr3.lookup("Uint32")], ["seqNum", xdr3.lookup("SequenceNumber")], ["cond", xdr3.lookup("Preconditions")], ["memo", xdr3.lookup("Memo")], ["operations", xdr3.varArray(xdr3.lookup("Operation"), xdr3.lookup("MAX_OPS_PER_TX"))], ["ext", xdr3.lookup("TransactionExt")]]);
      xdr3.struct("TransactionV1Envelope", [["tx", xdr3.lookup("Transaction")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("FeeBumpTransactionInnerTx", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "v1"]],
        arms: {
          v1: xdr3.lookup("TransactionV1Envelope")
        }
      });
      xdr3.union("FeeBumpTransactionExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("FeeBumpTransaction", [["feeSource", xdr3.lookup("MuxedAccount")], ["fee", xdr3.lookup("Int64")], ["innerTx", xdr3.lookup("FeeBumpTransactionInnerTx")], ["ext", xdr3.lookup("FeeBumpTransactionExt")]]);
      xdr3.struct("FeeBumpTransactionEnvelope", [["tx", xdr3.lookup("FeeBumpTransaction")], ["signatures", xdr3.varArray(xdr3.lookup("DecoratedSignature"), 20)]]);
      xdr3.union("TransactionEnvelope", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          v0: xdr3.lookup("TransactionV0Envelope"),
          v1: xdr3.lookup("TransactionV1Envelope"),
          feeBump: xdr3.lookup("FeeBumpTransactionEnvelope")
        }
      });
      xdr3.union("TransactionSignaturePayloadTaggedTransaction", {
        switchOn: xdr3.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          tx: xdr3.lookup("Transaction"),
          feeBump: xdr3.lookup("FeeBumpTransaction")
        }
      });
      xdr3.struct("TransactionSignaturePayload", [["networkId", xdr3.lookup("Hash")], ["taggedTransaction", xdr3.lookup("TransactionSignaturePayloadTaggedTransaction")]]);
      xdr3["enum"]("ClaimAtomType", {
        claimAtomTypeV0: 0,
        claimAtomTypeOrderBook: 1,
        claimAtomTypeLiquidityPool: 2
      });
      xdr3.struct("ClaimOfferAtomV0", [["sellerEd25519", xdr3.lookup("Uint256")], ["offerId", xdr3.lookup("Int64")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.struct("ClaimOfferAtom", [["sellerId", xdr3.lookup("AccountId")], ["offerId", xdr3.lookup("Int64")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.struct("ClaimLiquidityAtom", [["liquidityPoolId", xdr3.lookup("PoolId")], ["assetSold", xdr3.lookup("Asset")], ["amountSold", xdr3.lookup("Int64")], ["assetBought", xdr3.lookup("Asset")], ["amountBought", xdr3.lookup("Int64")]]);
      xdr3.union("ClaimAtom", {
        switchOn: xdr3.lookup("ClaimAtomType"),
        switchName: "type",
        switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
        arms: {
          v0: xdr3.lookup("ClaimOfferAtomV0"),
          orderBook: xdr3.lookup("ClaimOfferAtom"),
          liquidityPool: xdr3.lookup("ClaimLiquidityAtom")
        }
      });
      xdr3["enum"]("CreateAccountResultCode", {
        createAccountSuccess: 0,
        createAccountMalformed: -1,
        createAccountUnderfunded: -2,
        createAccountLowReserve: -3,
        createAccountAlreadyExist: -4
      });
      xdr3.union("CreateAccountResult", {
        switchOn: xdr3.lookup("CreateAccountResultCode"),
        switchName: "code",
        switches: [["createAccountSuccess", xdr3["void"]()], ["createAccountMalformed", xdr3["void"]()], ["createAccountUnderfunded", xdr3["void"]()], ["createAccountLowReserve", xdr3["void"]()], ["createAccountAlreadyExist", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("PaymentResultCode", {
        paymentSuccess: 0,
        paymentMalformed: -1,
        paymentUnderfunded: -2,
        paymentSrcNoTrust: -3,
        paymentSrcNotAuthorized: -4,
        paymentNoDestination: -5,
        paymentNoTrust: -6,
        paymentNotAuthorized: -7,
        paymentLineFull: -8,
        paymentNoIssuer: -9
      });
      xdr3.union("PaymentResult", {
        switchOn: xdr3.lookup("PaymentResultCode"),
        switchName: "code",
        switches: [["paymentSuccess", xdr3["void"]()], ["paymentMalformed", xdr3["void"]()], ["paymentUnderfunded", xdr3["void"]()], ["paymentSrcNoTrust", xdr3["void"]()], ["paymentSrcNotAuthorized", xdr3["void"]()], ["paymentNoDestination", xdr3["void"]()], ["paymentNoTrust", xdr3["void"]()], ["paymentNotAuthorized", xdr3["void"]()], ["paymentLineFull", xdr3["void"]()], ["paymentNoIssuer", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("PathPaymentStrictReceiveResultCode", {
        pathPaymentStrictReceiveSuccess: 0,
        pathPaymentStrictReceiveMalformed: -1,
        pathPaymentStrictReceiveUnderfunded: -2,
        pathPaymentStrictReceiveSrcNoTrust: -3,
        pathPaymentStrictReceiveSrcNotAuthorized: -4,
        pathPaymentStrictReceiveNoDestination: -5,
        pathPaymentStrictReceiveNoTrust: -6,
        pathPaymentStrictReceiveNotAuthorized: -7,
        pathPaymentStrictReceiveLineFull: -8,
        pathPaymentStrictReceiveNoIssuer: -9,
        pathPaymentStrictReceiveTooFewOffers: -10,
        pathPaymentStrictReceiveOfferCrossSelf: -11,
        pathPaymentStrictReceiveOverSendmax: -12
      });
      xdr3.struct("SimplePaymentResult", [["destination", xdr3.lookup("AccountId")], ["asset", xdr3.lookup("Asset")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.struct("PathPaymentStrictReceiveResultSuccess", [["offers", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["last", xdr3.lookup("SimplePaymentResult")]]);
      xdr3.union("PathPaymentStrictReceiveResult", {
        switchOn: xdr3.lookup("PathPaymentStrictReceiveResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", xdr3["void"]()], ["pathPaymentStrictReceiveUnderfunded", xdr3["void"]()], ["pathPaymentStrictReceiveSrcNoTrust", xdr3["void"]()], ["pathPaymentStrictReceiveSrcNotAuthorized", xdr3["void"]()], ["pathPaymentStrictReceiveNoDestination", xdr3["void"]()], ["pathPaymentStrictReceiveNoTrust", xdr3["void"]()], ["pathPaymentStrictReceiveNotAuthorized", xdr3["void"]()], ["pathPaymentStrictReceiveLineFull", xdr3["void"]()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", xdr3["void"]()], ["pathPaymentStrictReceiveOfferCrossSelf", xdr3["void"]()], ["pathPaymentStrictReceiveOverSendmax", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("PathPaymentStrictReceiveResultSuccess"),
          noIssuer: xdr3.lookup("Asset")
        }
      });
      xdr3["enum"]("PathPaymentStrictSendResultCode", {
        pathPaymentStrictSendSuccess: 0,
        pathPaymentStrictSendMalformed: -1,
        pathPaymentStrictSendUnderfunded: -2,
        pathPaymentStrictSendSrcNoTrust: -3,
        pathPaymentStrictSendSrcNotAuthorized: -4,
        pathPaymentStrictSendNoDestination: -5,
        pathPaymentStrictSendNoTrust: -6,
        pathPaymentStrictSendNotAuthorized: -7,
        pathPaymentStrictSendLineFull: -8,
        pathPaymentStrictSendNoIssuer: -9,
        pathPaymentStrictSendTooFewOffers: -10,
        pathPaymentStrictSendOfferCrossSelf: -11,
        pathPaymentStrictSendUnderDestmin: -12
      });
      xdr3.struct("PathPaymentStrictSendResultSuccess", [["offers", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["last", xdr3.lookup("SimplePaymentResult")]]);
      xdr3.union("PathPaymentStrictSendResult", {
        switchOn: xdr3.lookup("PathPaymentStrictSendResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", xdr3["void"]()], ["pathPaymentStrictSendUnderfunded", xdr3["void"]()], ["pathPaymentStrictSendSrcNoTrust", xdr3["void"]()], ["pathPaymentStrictSendSrcNotAuthorized", xdr3["void"]()], ["pathPaymentStrictSendNoDestination", xdr3["void"]()], ["pathPaymentStrictSendNoTrust", xdr3["void"]()], ["pathPaymentStrictSendNotAuthorized", xdr3["void"]()], ["pathPaymentStrictSendLineFull", xdr3["void"]()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", xdr3["void"]()], ["pathPaymentStrictSendOfferCrossSelf", xdr3["void"]()], ["pathPaymentStrictSendUnderDestmin", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("PathPaymentStrictSendResultSuccess"),
          noIssuer: xdr3.lookup("Asset")
        }
      });
      xdr3["enum"]("ManageSellOfferResultCode", {
        manageSellOfferSuccess: 0,
        manageSellOfferMalformed: -1,
        manageSellOfferSellNoTrust: -2,
        manageSellOfferBuyNoTrust: -3,
        manageSellOfferSellNotAuthorized: -4,
        manageSellOfferBuyNotAuthorized: -5,
        manageSellOfferLineFull: -6,
        manageSellOfferUnderfunded: -7,
        manageSellOfferCrossSelf: -8,
        manageSellOfferSellNoIssuer: -9,
        manageSellOfferBuyNoIssuer: -10,
        manageSellOfferNotFound: -11,
        manageSellOfferLowReserve: -12
      });
      xdr3["enum"]("ManageOfferEffect", {
        manageOfferCreated: 0,
        manageOfferUpdated: 1,
        manageOfferDeleted: 2
      });
      xdr3.union("ManageOfferSuccessResultOffer", {
        switchOn: xdr3.lookup("ManageOfferEffect"),
        switchName: "effect",
        switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", xdr3["void"]()]],
        arms: {
          offer: xdr3.lookup("OfferEntry")
        }
      });
      xdr3.struct("ManageOfferSuccessResult", [["offersClaimed", xdr3.varArray(xdr3.lookup("ClaimAtom"), 2147483647)], ["offer", xdr3.lookup("ManageOfferSuccessResultOffer")]]);
      xdr3.union("ManageSellOfferResult", {
        switchOn: xdr3.lookup("ManageSellOfferResultCode"),
        switchName: "code",
        switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", xdr3["void"]()], ["manageSellOfferSellNoTrust", xdr3["void"]()], ["manageSellOfferBuyNoTrust", xdr3["void"]()], ["manageSellOfferSellNotAuthorized", xdr3["void"]()], ["manageSellOfferBuyNotAuthorized", xdr3["void"]()], ["manageSellOfferLineFull", xdr3["void"]()], ["manageSellOfferUnderfunded", xdr3["void"]()], ["manageSellOfferCrossSelf", xdr3["void"]()], ["manageSellOfferSellNoIssuer", xdr3["void"]()], ["manageSellOfferBuyNoIssuer", xdr3["void"]()], ["manageSellOfferNotFound", xdr3["void"]()], ["manageSellOfferLowReserve", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("ManageOfferSuccessResult")
        }
      });
      xdr3["enum"]("ManageBuyOfferResultCode", {
        manageBuyOfferSuccess: 0,
        manageBuyOfferMalformed: -1,
        manageBuyOfferSellNoTrust: -2,
        manageBuyOfferBuyNoTrust: -3,
        manageBuyOfferSellNotAuthorized: -4,
        manageBuyOfferBuyNotAuthorized: -5,
        manageBuyOfferLineFull: -6,
        manageBuyOfferUnderfunded: -7,
        manageBuyOfferCrossSelf: -8,
        manageBuyOfferSellNoIssuer: -9,
        manageBuyOfferBuyNoIssuer: -10,
        manageBuyOfferNotFound: -11,
        manageBuyOfferLowReserve: -12
      });
      xdr3.union("ManageBuyOfferResult", {
        switchOn: xdr3.lookup("ManageBuyOfferResultCode"),
        switchName: "code",
        switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", xdr3["void"]()], ["manageBuyOfferSellNoTrust", xdr3["void"]()], ["manageBuyOfferBuyNoTrust", xdr3["void"]()], ["manageBuyOfferSellNotAuthorized", xdr3["void"]()], ["manageBuyOfferBuyNotAuthorized", xdr3["void"]()], ["manageBuyOfferLineFull", xdr3["void"]()], ["manageBuyOfferUnderfunded", xdr3["void"]()], ["manageBuyOfferCrossSelf", xdr3["void"]()], ["manageBuyOfferSellNoIssuer", xdr3["void"]()], ["manageBuyOfferBuyNoIssuer", xdr3["void"]()], ["manageBuyOfferNotFound", xdr3["void"]()], ["manageBuyOfferLowReserve", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("ManageOfferSuccessResult")
        }
      });
      xdr3["enum"]("SetOptionsResultCode", {
        setOptionsSuccess: 0,
        setOptionsLowReserve: -1,
        setOptionsTooManySigners: -2,
        setOptionsBadFlags: -3,
        setOptionsInvalidInflation: -4,
        setOptionsCantChange: -5,
        setOptionsUnknownFlag: -6,
        setOptionsThresholdOutOfRange: -7,
        setOptionsBadSigner: -8,
        setOptionsInvalidHomeDomain: -9,
        setOptionsAuthRevocableRequired: -10
      });
      xdr3.union("SetOptionsResult", {
        switchOn: xdr3.lookup("SetOptionsResultCode"),
        switchName: "code",
        switches: [["setOptionsSuccess", xdr3["void"]()], ["setOptionsLowReserve", xdr3["void"]()], ["setOptionsTooManySigners", xdr3["void"]()], ["setOptionsBadFlags", xdr3["void"]()], ["setOptionsInvalidInflation", xdr3["void"]()], ["setOptionsCantChange", xdr3["void"]()], ["setOptionsUnknownFlag", xdr3["void"]()], ["setOptionsThresholdOutOfRange", xdr3["void"]()], ["setOptionsBadSigner", xdr3["void"]()], ["setOptionsInvalidHomeDomain", xdr3["void"]()], ["setOptionsAuthRevocableRequired", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ChangeTrustResultCode", {
        changeTrustSuccess: 0,
        changeTrustMalformed: -1,
        changeTrustNoIssuer: -2,
        changeTrustInvalidLimit: -3,
        changeTrustLowReserve: -4,
        changeTrustSelfNotAllowed: -5,
        changeTrustTrustLineMissing: -6,
        changeTrustCannotDelete: -7,
        changeTrustNotAuthMaintainLiabilities: -8
      });
      xdr3.union("ChangeTrustResult", {
        switchOn: xdr3.lookup("ChangeTrustResultCode"),
        switchName: "code",
        switches: [["changeTrustSuccess", xdr3["void"]()], ["changeTrustMalformed", xdr3["void"]()], ["changeTrustNoIssuer", xdr3["void"]()], ["changeTrustInvalidLimit", xdr3["void"]()], ["changeTrustLowReserve", xdr3["void"]()], ["changeTrustSelfNotAllowed", xdr3["void"]()], ["changeTrustTrustLineMissing", xdr3["void"]()], ["changeTrustCannotDelete", xdr3["void"]()], ["changeTrustNotAuthMaintainLiabilities", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("AllowTrustResultCode", {
        allowTrustSuccess: 0,
        allowTrustMalformed: -1,
        allowTrustNoTrustLine: -2,
        allowTrustTrustNotRequired: -3,
        allowTrustCantRevoke: -4,
        allowTrustSelfNotAllowed: -5,
        allowTrustLowReserve: -6
      });
      xdr3.union("AllowTrustResult", {
        switchOn: xdr3.lookup("AllowTrustResultCode"),
        switchName: "code",
        switches: [["allowTrustSuccess", xdr3["void"]()], ["allowTrustMalformed", xdr3["void"]()], ["allowTrustNoTrustLine", xdr3["void"]()], ["allowTrustTrustNotRequired", xdr3["void"]()], ["allowTrustCantRevoke", xdr3["void"]()], ["allowTrustSelfNotAllowed", xdr3["void"]()], ["allowTrustLowReserve", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("AccountMergeResultCode", {
        accountMergeSuccess: 0,
        accountMergeMalformed: -1,
        accountMergeNoAccount: -2,
        accountMergeImmutableSet: -3,
        accountMergeHasSubEntries: -4,
        accountMergeSeqnumTooFar: -5,
        accountMergeDestFull: -6,
        accountMergeIsSponsor: -7
      });
      xdr3.union("AccountMergeResult", {
        switchOn: xdr3.lookup("AccountMergeResultCode"),
        switchName: "code",
        switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", xdr3["void"]()], ["accountMergeNoAccount", xdr3["void"]()], ["accountMergeImmutableSet", xdr3["void"]()], ["accountMergeHasSubEntries", xdr3["void"]()], ["accountMergeSeqnumTooFar", xdr3["void"]()], ["accountMergeDestFull", xdr3["void"]()], ["accountMergeIsSponsor", xdr3["void"]()]],
        arms: {
          sourceAccountBalance: xdr3.lookup("Int64")
        }
      });
      xdr3["enum"]("InflationResultCode", {
        inflationSuccess: 0,
        inflationNotTime: -1
      });
      xdr3.struct("InflationPayout", [["destination", xdr3.lookup("AccountId")], ["amount", xdr3.lookup("Int64")]]);
      xdr3.union("InflationResult", {
        switchOn: xdr3.lookup("InflationResultCode"),
        switchName: "code",
        switches: [["inflationSuccess", "payouts"], ["inflationNotTime", xdr3["void"]()]],
        arms: {
          payouts: xdr3.varArray(xdr3.lookup("InflationPayout"), 2147483647)
        }
      });
      xdr3["enum"]("ManageDataResultCode", {
        manageDataSuccess: 0,
        manageDataNotSupportedYet: -1,
        manageDataNameNotFound: -2,
        manageDataLowReserve: -3,
        manageDataInvalidName: -4
      });
      xdr3.union("ManageDataResult", {
        switchOn: xdr3.lookup("ManageDataResultCode"),
        switchName: "code",
        switches: [["manageDataSuccess", xdr3["void"]()], ["manageDataNotSupportedYet", xdr3["void"]()], ["manageDataNameNotFound", xdr3["void"]()], ["manageDataLowReserve", xdr3["void"]()], ["manageDataInvalidName", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("BumpSequenceResultCode", {
        bumpSequenceSuccess: 0,
        bumpSequenceBadSeq: -1
      });
      xdr3.union("BumpSequenceResult", {
        switchOn: xdr3.lookup("BumpSequenceResultCode"),
        switchName: "code",
        switches: [["bumpSequenceSuccess", xdr3["void"]()], ["bumpSequenceBadSeq", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("CreateClaimableBalanceResultCode", {
        createClaimableBalanceSuccess: 0,
        createClaimableBalanceMalformed: -1,
        createClaimableBalanceLowReserve: -2,
        createClaimableBalanceNoTrust: -3,
        createClaimableBalanceNotAuthorized: -4,
        createClaimableBalanceUnderfunded: -5
      });
      xdr3.union("CreateClaimableBalanceResult", {
        switchOn: xdr3.lookup("CreateClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", xdr3["void"]()], ["createClaimableBalanceLowReserve", xdr3["void"]()], ["createClaimableBalanceNoTrust", xdr3["void"]()], ["createClaimableBalanceNotAuthorized", xdr3["void"]()], ["createClaimableBalanceUnderfunded", xdr3["void"]()]],
        arms: {
          balanceId: xdr3.lookup("ClaimableBalanceId")
        }
      });
      xdr3["enum"]("ClaimClaimableBalanceResultCode", {
        claimClaimableBalanceSuccess: 0,
        claimClaimableBalanceDoesNotExist: -1,
        claimClaimableBalanceCannotClaim: -2,
        claimClaimableBalanceLineFull: -3,
        claimClaimableBalanceNoTrust: -4,
        claimClaimableBalanceNotAuthorized: -5
      });
      xdr3.union("ClaimClaimableBalanceResult", {
        switchOn: xdr3.lookup("ClaimClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["claimClaimableBalanceSuccess", xdr3["void"]()], ["claimClaimableBalanceDoesNotExist", xdr3["void"]()], ["claimClaimableBalanceCannotClaim", xdr3["void"]()], ["claimClaimableBalanceLineFull", xdr3["void"]()], ["claimClaimableBalanceNoTrust", xdr3["void"]()], ["claimClaimableBalanceNotAuthorized", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("BeginSponsoringFutureReservesResultCode", {
        beginSponsoringFutureReservesSuccess: 0,
        beginSponsoringFutureReservesMalformed: -1,
        beginSponsoringFutureReservesAlreadySponsored: -2,
        beginSponsoringFutureReservesRecursive: -3
      });
      xdr3.union("BeginSponsoringFutureReservesResult", {
        switchOn: xdr3.lookup("BeginSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["beginSponsoringFutureReservesSuccess", xdr3["void"]()], ["beginSponsoringFutureReservesMalformed", xdr3["void"]()], ["beginSponsoringFutureReservesAlreadySponsored", xdr3["void"]()], ["beginSponsoringFutureReservesRecursive", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("EndSponsoringFutureReservesResultCode", {
        endSponsoringFutureReservesSuccess: 0,
        endSponsoringFutureReservesNotSponsored: -1
      });
      xdr3.union("EndSponsoringFutureReservesResult", {
        switchOn: xdr3.lookup("EndSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["endSponsoringFutureReservesSuccess", xdr3["void"]()], ["endSponsoringFutureReservesNotSponsored", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("RevokeSponsorshipResultCode", {
        revokeSponsorshipSuccess: 0,
        revokeSponsorshipDoesNotExist: -1,
        revokeSponsorshipNotSponsor: -2,
        revokeSponsorshipLowReserve: -3,
        revokeSponsorshipOnlyTransferable: -4,
        revokeSponsorshipMalformed: -5
      });
      xdr3.union("RevokeSponsorshipResult", {
        switchOn: xdr3.lookup("RevokeSponsorshipResultCode"),
        switchName: "code",
        switches: [["revokeSponsorshipSuccess", xdr3["void"]()], ["revokeSponsorshipDoesNotExist", xdr3["void"]()], ["revokeSponsorshipNotSponsor", xdr3["void"]()], ["revokeSponsorshipLowReserve", xdr3["void"]()], ["revokeSponsorshipOnlyTransferable", xdr3["void"]()], ["revokeSponsorshipMalformed", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ClawbackResultCode", {
        clawbackSuccess: 0,
        clawbackMalformed: -1,
        clawbackNotClawbackEnabled: -2,
        clawbackNoTrust: -3,
        clawbackUnderfunded: -4
      });
      xdr3.union("ClawbackResult", {
        switchOn: xdr3.lookup("ClawbackResultCode"),
        switchName: "code",
        switches: [["clawbackSuccess", xdr3["void"]()], ["clawbackMalformed", xdr3["void"]()], ["clawbackNotClawbackEnabled", xdr3["void"]()], ["clawbackNoTrust", xdr3["void"]()], ["clawbackUnderfunded", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("ClawbackClaimableBalanceResultCode", {
        clawbackClaimableBalanceSuccess: 0,
        clawbackClaimableBalanceDoesNotExist: -1,
        clawbackClaimableBalanceNotIssuer: -2,
        clawbackClaimableBalanceNotClawbackEnabled: -3
      });
      xdr3.union("ClawbackClaimableBalanceResult", {
        switchOn: xdr3.lookup("ClawbackClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["clawbackClaimableBalanceSuccess", xdr3["void"]()], ["clawbackClaimableBalanceDoesNotExist", xdr3["void"]()], ["clawbackClaimableBalanceNotIssuer", xdr3["void"]()], ["clawbackClaimableBalanceNotClawbackEnabled", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("SetTrustLineFlagsResultCode", {
        setTrustLineFlagsSuccess: 0,
        setTrustLineFlagsMalformed: -1,
        setTrustLineFlagsNoTrustLine: -2,
        setTrustLineFlagsCantRevoke: -3,
        setTrustLineFlagsInvalidState: -4,
        setTrustLineFlagsLowReserve: -5
      });
      xdr3.union("SetTrustLineFlagsResult", {
        switchOn: xdr3.lookup("SetTrustLineFlagsResultCode"),
        switchName: "code",
        switches: [["setTrustLineFlagsSuccess", xdr3["void"]()], ["setTrustLineFlagsMalformed", xdr3["void"]()], ["setTrustLineFlagsNoTrustLine", xdr3["void"]()], ["setTrustLineFlagsCantRevoke", xdr3["void"]()], ["setTrustLineFlagsInvalidState", xdr3["void"]()], ["setTrustLineFlagsLowReserve", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("LiquidityPoolDepositResultCode", {
        liquidityPoolDepositSuccess: 0,
        liquidityPoolDepositMalformed: -1,
        liquidityPoolDepositNoTrust: -2,
        liquidityPoolDepositNotAuthorized: -3,
        liquidityPoolDepositUnderfunded: -4,
        liquidityPoolDepositLineFull: -5,
        liquidityPoolDepositBadPrice: -6,
        liquidityPoolDepositPoolFull: -7
      });
      xdr3.union("LiquidityPoolDepositResult", {
        switchOn: xdr3.lookup("LiquidityPoolDepositResultCode"),
        switchName: "code",
        switches: [["liquidityPoolDepositSuccess", xdr3["void"]()], ["liquidityPoolDepositMalformed", xdr3["void"]()], ["liquidityPoolDepositNoTrust", xdr3["void"]()], ["liquidityPoolDepositNotAuthorized", xdr3["void"]()], ["liquidityPoolDepositUnderfunded", xdr3["void"]()], ["liquidityPoolDepositLineFull", xdr3["void"]()], ["liquidityPoolDepositBadPrice", xdr3["void"]()], ["liquidityPoolDepositPoolFull", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("LiquidityPoolWithdrawResultCode", {
        liquidityPoolWithdrawSuccess: 0,
        liquidityPoolWithdrawMalformed: -1,
        liquidityPoolWithdrawNoTrust: -2,
        liquidityPoolWithdrawUnderfunded: -3,
        liquidityPoolWithdrawLineFull: -4,
        liquidityPoolWithdrawUnderMinimum: -5
      });
      xdr3.union("LiquidityPoolWithdrawResult", {
        switchOn: xdr3.lookup("LiquidityPoolWithdrawResultCode"),
        switchName: "code",
        switches: [["liquidityPoolWithdrawSuccess", xdr3["void"]()], ["liquidityPoolWithdrawMalformed", xdr3["void"]()], ["liquidityPoolWithdrawNoTrust", xdr3["void"]()], ["liquidityPoolWithdrawUnderfunded", xdr3["void"]()], ["liquidityPoolWithdrawLineFull", xdr3["void"]()], ["liquidityPoolWithdrawUnderMinimum", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("InvokeHostFunctionResultCode", {
        invokeHostFunctionSuccess: 0,
        invokeHostFunctionMalformed: -1,
        invokeHostFunctionTrapped: -2,
        invokeHostFunctionResourceLimitExceeded: -3,
        invokeHostFunctionEntryArchived: -4,
        invokeHostFunctionInsufficientRefundableFee: -5
      });
      xdr3.union("InvokeHostFunctionResult", {
        switchOn: xdr3.lookup("InvokeHostFunctionResultCode"),
        switchName: "code",
        switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", xdr3["void"]()], ["invokeHostFunctionTrapped", xdr3["void"]()], ["invokeHostFunctionResourceLimitExceeded", xdr3["void"]()], ["invokeHostFunctionEntryArchived", xdr3["void"]()], ["invokeHostFunctionInsufficientRefundableFee", xdr3["void"]()]],
        arms: {
          success: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ExtendFootprintTtlResultCode", {
        extendFootprintTtlSuccess: 0,
        extendFootprintTtlMalformed: -1,
        extendFootprintTtlResourceLimitExceeded: -2,
        extendFootprintTtlInsufficientRefundableFee: -3
      });
      xdr3.union("ExtendFootprintTtlResult", {
        switchOn: xdr3.lookup("ExtendFootprintTtlResultCode"),
        switchName: "code",
        switches: [["extendFootprintTtlSuccess", xdr3["void"]()], ["extendFootprintTtlMalformed", xdr3["void"]()], ["extendFootprintTtlResourceLimitExceeded", xdr3["void"]()], ["extendFootprintTtlInsufficientRefundableFee", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("RestoreFootprintResultCode", {
        restoreFootprintSuccess: 0,
        restoreFootprintMalformed: -1,
        restoreFootprintResourceLimitExceeded: -2,
        restoreFootprintInsufficientRefundableFee: -3
      });
      xdr3.union("RestoreFootprintResult", {
        switchOn: xdr3.lookup("RestoreFootprintResultCode"),
        switchName: "code",
        switches: [["restoreFootprintSuccess", xdr3["void"]()], ["restoreFootprintMalformed", xdr3["void"]()], ["restoreFootprintResourceLimitExceeded", xdr3["void"]()], ["restoreFootprintInsufficientRefundableFee", xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("OperationResultCode", {
        opInner: 0,
        opBadAuth: -1,
        opNoAccount: -2,
        opNotSupported: -3,
        opTooManySubentries: -4,
        opExceededWorkLimit: -5,
        opTooManySponsoring: -6
      });
      xdr3.union("OperationResultTr", {
        switchOn: xdr3.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]],
        arms: {
          createAccountResult: xdr3.lookup("CreateAccountResult"),
          paymentResult: xdr3.lookup("PaymentResult"),
          pathPaymentStrictReceiveResult: xdr3.lookup("PathPaymentStrictReceiveResult"),
          manageSellOfferResult: xdr3.lookup("ManageSellOfferResult"),
          createPassiveSellOfferResult: xdr3.lookup("ManageSellOfferResult"),
          setOptionsResult: xdr3.lookup("SetOptionsResult"),
          changeTrustResult: xdr3.lookup("ChangeTrustResult"),
          allowTrustResult: xdr3.lookup("AllowTrustResult"),
          accountMergeResult: xdr3.lookup("AccountMergeResult"),
          inflationResult: xdr3.lookup("InflationResult"),
          manageDataResult: xdr3.lookup("ManageDataResult"),
          bumpSeqResult: xdr3.lookup("BumpSequenceResult"),
          manageBuyOfferResult: xdr3.lookup("ManageBuyOfferResult"),
          pathPaymentStrictSendResult: xdr3.lookup("PathPaymentStrictSendResult"),
          createClaimableBalanceResult: xdr3.lookup("CreateClaimableBalanceResult"),
          claimClaimableBalanceResult: xdr3.lookup("ClaimClaimableBalanceResult"),
          beginSponsoringFutureReservesResult: xdr3.lookup("BeginSponsoringFutureReservesResult"),
          endSponsoringFutureReservesResult: xdr3.lookup("EndSponsoringFutureReservesResult"),
          revokeSponsorshipResult: xdr3.lookup("RevokeSponsorshipResult"),
          clawbackResult: xdr3.lookup("ClawbackResult"),
          clawbackClaimableBalanceResult: xdr3.lookup("ClawbackClaimableBalanceResult"),
          setTrustLineFlagsResult: xdr3.lookup("SetTrustLineFlagsResult"),
          liquidityPoolDepositResult: xdr3.lookup("LiquidityPoolDepositResult"),
          liquidityPoolWithdrawResult: xdr3.lookup("LiquidityPoolWithdrawResult"),
          invokeHostFunctionResult: xdr3.lookup("InvokeHostFunctionResult"),
          extendFootprintTtlResult: xdr3.lookup("ExtendFootprintTtlResult"),
          restoreFootprintResult: xdr3.lookup("RestoreFootprintResult")
        }
      });
      xdr3.union("OperationResult", {
        switchOn: xdr3.lookup("OperationResultCode"),
        switchName: "code",
        switches: [["opInner", "tr"], ["opBadAuth", xdr3["void"]()], ["opNoAccount", xdr3["void"]()], ["opNotSupported", xdr3["void"]()], ["opTooManySubentries", xdr3["void"]()], ["opExceededWorkLimit", xdr3["void"]()], ["opTooManySponsoring", xdr3["void"]()]],
        arms: {
          tr: xdr3.lookup("OperationResultTr")
        }
      });
      xdr3["enum"]("TransactionResultCode", {
        txFeeBumpInnerSuccess: 1,
        txSuccess: 0,
        txFailed: -1,
        txTooEarly: -2,
        txTooLate: -3,
        txMissingOperation: -4,
        txBadSeq: -5,
        txBadAuth: -6,
        txInsufficientBalance: -7,
        txNoAccount: -8,
        txInsufficientFee: -9,
        txBadAuthExtra: -10,
        txInternalError: -11,
        txNotSupported: -12,
        txFeeBumpInnerFailed: -13,
        txBadSponsorship: -14,
        txBadMinSeqAgeOrGap: -15,
        txMalformed: -16,
        txSorobanInvalid: -17
      });
      xdr3.union("InnerTransactionResultResult", {
        switchOn: xdr3.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr3["void"]()], ["txTooLate", xdr3["void"]()], ["txMissingOperation", xdr3["void"]()], ["txBadSeq", xdr3["void"]()], ["txBadAuth", xdr3["void"]()], ["txInsufficientBalance", xdr3["void"]()], ["txNoAccount", xdr3["void"]()], ["txInsufficientFee", xdr3["void"]()], ["txBadAuthExtra", xdr3["void"]()], ["txInternalError", xdr3["void"]()], ["txNotSupported", xdr3["void"]()], ["txBadSponsorship", xdr3["void"]()], ["txBadMinSeqAgeOrGap", xdr3["void"]()], ["txMalformed", xdr3["void"]()], ["txSorobanInvalid", xdr3["void"]()]],
        arms: {
          results: xdr3.varArray(xdr3.lookup("OperationResult"), 2147483647)
        }
      });
      xdr3.union("InnerTransactionResultExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("InnerTransactionResult", [["feeCharged", xdr3.lookup("Int64")], ["result", xdr3.lookup("InnerTransactionResultResult")], ["ext", xdr3.lookup("InnerTransactionResultExt")]]);
      xdr3.struct("InnerTransactionResultPair", [["transactionHash", xdr3.lookup("Hash")], ["result", xdr3.lookup("InnerTransactionResult")]]);
      xdr3.union("TransactionResultResult", {
        switchOn: xdr3.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr3["void"]()], ["txTooLate", xdr3["void"]()], ["txMissingOperation", xdr3["void"]()], ["txBadSeq", xdr3["void"]()], ["txBadAuth", xdr3["void"]()], ["txInsufficientBalance", xdr3["void"]()], ["txNoAccount", xdr3["void"]()], ["txInsufficientFee", xdr3["void"]()], ["txBadAuthExtra", xdr3["void"]()], ["txInternalError", xdr3["void"]()], ["txNotSupported", xdr3["void"]()], ["txBadSponsorship", xdr3["void"]()], ["txBadMinSeqAgeOrGap", xdr3["void"]()], ["txMalformed", xdr3["void"]()], ["txSorobanInvalid", xdr3["void"]()]],
        arms: {
          innerResultPair: xdr3.lookup("InnerTransactionResultPair"),
          results: xdr3.varArray(xdr3.lookup("OperationResult"), 2147483647)
        }
      });
      xdr3.union("TransactionResultExt", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3.struct("TransactionResult", [["feeCharged", xdr3.lookup("Int64")], ["result", xdr3.lookup("TransactionResultResult")], ["ext", xdr3.lookup("TransactionResultExt")]]);
      xdr3.typedef("Hash", xdr3.opaque(32));
      xdr3.typedef("Uint256", xdr3.opaque(32));
      xdr3.typedef("Uint32", xdr3.uint());
      xdr3.typedef("Int32", xdr3["int"]());
      xdr3.typedef("Uint64", xdr3.uhyper());
      xdr3.typedef("Int64", xdr3.hyper());
      xdr3.typedef("TimePoint", xdr3.lookup("Uint64"));
      xdr3.typedef("Duration", xdr3.lookup("Uint64"));
      xdr3.union("ExtensionPoint", {
        switchOn: xdr3["int"](),
        switchName: "v",
        switches: [[0, xdr3["void"]()]],
        arms: {}
      });
      xdr3["enum"]("CryptoKeyType", {
        keyTypeEd25519: 0,
        keyTypePreAuthTx: 1,
        keyTypeHashX: 2,
        keyTypeEd25519SignedPayload: 3,
        keyTypeMuxedEd25519: 256
      });
      xdr3["enum"]("PublicKeyType", {
        publicKeyTypeEd25519: 0
      });
      xdr3["enum"]("SignerKeyType", {
        signerKeyTypeEd25519: 0,
        signerKeyTypePreAuthTx: 1,
        signerKeyTypeHashX: 2,
        signerKeyTypeEd25519SignedPayload: 3
      });
      xdr3.union("PublicKey", {
        switchOn: xdr3.lookup("PublicKeyType"),
        switchName: "type",
        switches: [["publicKeyTypeEd25519", "ed25519"]],
        arms: {
          ed25519: xdr3.lookup("Uint256")
        }
      });
      xdr3.struct("SignerKeyEd25519SignedPayload", [["ed25519", xdr3.lookup("Uint256")], ["payload", xdr3.varOpaque(64)]]);
      xdr3.union("SignerKey", {
        switchOn: xdr3.lookup("SignerKeyType"),
        switchName: "type",
        switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]],
        arms: {
          ed25519: xdr3.lookup("Uint256"),
          preAuthTx: xdr3.lookup("Uint256"),
          hashX: xdr3.lookup("Uint256"),
          ed25519SignedPayload: xdr3.lookup("SignerKeyEd25519SignedPayload")
        }
      });
      xdr3.typedef("Signature", xdr3.varOpaque(64));
      xdr3.typedef("SignatureHint", xdr3.opaque(4));
      xdr3.typedef("NodeId", xdr3.lookup("PublicKey"));
      xdr3.typedef("AccountId", xdr3.lookup("PublicKey"));
      xdr3.struct("Curve25519Secret", [["key", xdr3.opaque(32)]]);
      xdr3.struct("Curve25519Public", [["key", xdr3.opaque(32)]]);
      xdr3.struct("HmacSha256Key", [["key", xdr3.opaque(32)]]);
      xdr3.struct("HmacSha256Mac", [["mac", xdr3.opaque(32)]]);
      xdr3.struct("ShortHashSeed", [["seed", xdr3.opaque(16)]]);
      xdr3["enum"]("BinaryFuseFilterType", {
        binaryFuseFilter8Bit: 0,
        binaryFuseFilter16Bit: 1,
        binaryFuseFilter32Bit: 2
      });
      xdr3.struct("SerializedBinaryFuseFilter", [["type", xdr3.lookup("BinaryFuseFilterType")], ["inputHashSeed", xdr3.lookup("ShortHashSeed")], ["filterSeed", xdr3.lookup("ShortHashSeed")], ["segmentLength", xdr3.lookup("Uint32")], ["segementLengthMask", xdr3.lookup("Uint32")], ["segmentCount", xdr3.lookup("Uint32")], ["segmentCountLength", xdr3.lookup("Uint32")], ["fingerprintLength", xdr3.lookup("Uint32")], ["fingerprints", xdr3.varOpaque()]]);
      xdr3["enum"]("ScValType", {
        scvBool: 0,
        scvVoid: 1,
        scvError: 2,
        scvU32: 3,
        scvI32: 4,
        scvU64: 5,
        scvI64: 6,
        scvTimepoint: 7,
        scvDuration: 8,
        scvU128: 9,
        scvI128: 10,
        scvU256: 11,
        scvI256: 12,
        scvBytes: 13,
        scvString: 14,
        scvSymbol: 15,
        scvVec: 16,
        scvMap: 17,
        scvAddress: 18,
        scvContractInstance: 19,
        scvLedgerKeyContractInstance: 20,
        scvLedgerKeyNonce: 21
      });
      xdr3["enum"]("ScErrorType", {
        sceContract: 0,
        sceWasmVm: 1,
        sceContext: 2,
        sceStorage: 3,
        sceObject: 4,
        sceCrypto: 5,
        sceEvents: 6,
        sceBudget: 7,
        sceValue: 8,
        sceAuth: 9
      });
      xdr3["enum"]("ScErrorCode", {
        scecArithDomain: 0,
        scecIndexBounds: 1,
        scecInvalidInput: 2,
        scecMissingValue: 3,
        scecExistingValue: 4,
        scecExceededLimit: 5,
        scecInvalidAction: 6,
        scecInternalError: 7,
        scecUnexpectedType: 8,
        scecUnexpectedSize: 9
      });
      xdr3.union("ScError", {
        switchOn: xdr3.lookup("ScErrorType"),
        switchName: "type",
        switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]],
        arms: {
          contractCode: xdr3.lookup("Uint32"),
          code: xdr3.lookup("ScErrorCode")
        }
      });
      xdr3.struct("UInt128Parts", [["hi", xdr3.lookup("Uint64")], ["lo", xdr3.lookup("Uint64")]]);
      xdr3.struct("Int128Parts", [["hi", xdr3.lookup("Int64")], ["lo", xdr3.lookup("Uint64")]]);
      xdr3.struct("UInt256Parts", [["hiHi", xdr3.lookup("Uint64")], ["hiLo", xdr3.lookup("Uint64")], ["loHi", xdr3.lookup("Uint64")], ["loLo", xdr3.lookup("Uint64")]]);
      xdr3.struct("Int256Parts", [["hiHi", xdr3.lookup("Int64")], ["hiLo", xdr3.lookup("Uint64")], ["loHi", xdr3.lookup("Uint64")], ["loLo", xdr3.lookup("Uint64")]]);
      xdr3["enum"]("ContractExecutableType", {
        contractExecutableWasm: 0,
        contractExecutableStellarAsset: 1
      });
      xdr3.union("ContractExecutable", {
        switchOn: xdr3.lookup("ContractExecutableType"),
        switchName: "type",
        switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", xdr3["void"]()]],
        arms: {
          wasmHash: xdr3.lookup("Hash")
        }
      });
      xdr3["enum"]("ScAddressType", {
        scAddressTypeAccount: 0,
        scAddressTypeContract: 1
      });
      xdr3.union("ScAddress", {
        switchOn: xdr3.lookup("ScAddressType"),
        switchName: "type",
        switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]],
        arms: {
          accountId: xdr3.lookup("AccountId"),
          contractId: xdr3.lookup("Hash")
        }
      });
      xdr3["const"]("SCSYMBOL_LIMIT", 32);
      xdr3.typedef("ScVec", xdr3.varArray(xdr3.lookup("ScVal"), 2147483647));
      xdr3.typedef("ScMap", xdr3.varArray(xdr3.lookup("ScMapEntry"), 2147483647));
      xdr3.typedef("ScBytes", xdr3.varOpaque());
      xdr3.typedef("ScString", xdr3.string());
      xdr3.typedef("ScSymbol", xdr3.string(SCSYMBOL_LIMIT));
      xdr3.struct("ScNonceKey", [["nonce", xdr3.lookup("Int64")]]);
      xdr3.struct("ScContractInstance", [["executable", xdr3.lookup("ContractExecutable")], ["storage", xdr3.option(xdr3.lookup("ScMap"))]]);
      xdr3.union("ScVal", {
        switchOn: xdr3.lookup("ScValType"),
        switchName: "type",
        switches: [["scvBool", "b"], ["scvVoid", xdr3["void"]()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", xdr3["void"]()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]],
        arms: {
          b: xdr3.bool(),
          error: xdr3.lookup("ScError"),
          u32: xdr3.lookup("Uint32"),
          i32: xdr3.lookup("Int32"),
          u64: xdr3.lookup("Uint64"),
          i64: xdr3.lookup("Int64"),
          timepoint: xdr3.lookup("TimePoint"),
          duration: xdr3.lookup("Duration"),
          u128: xdr3.lookup("UInt128Parts"),
          i128: xdr3.lookup("Int128Parts"),
          u256: xdr3.lookup("UInt256Parts"),
          i256: xdr3.lookup("Int256Parts"),
          bytes: xdr3.lookup("ScBytes"),
          str: xdr3.lookup("ScString"),
          sym: xdr3.lookup("ScSymbol"),
          vec: xdr3.option(xdr3.lookup("ScVec")),
          map: xdr3.option(xdr3.lookup("ScMap")),
          address: xdr3.lookup("ScAddress"),
          nonceKey: xdr3.lookup("ScNonceKey"),
          instance: xdr3.lookup("ScContractInstance")
        }
      });
      xdr3.struct("ScMapEntry", [["key", xdr3.lookup("ScVal")], ["val", xdr3.lookup("ScVal")]]);
      xdr3["enum"]("ScEnvMetaKind", {
        scEnvMetaKindInterfaceVersion: 0
      });
      xdr3.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", xdr3.lookup("Uint32")], ["preRelease", xdr3.lookup("Uint32")]]);
      xdr3.union("ScEnvMetaEntry", {
        switchOn: xdr3.lookup("ScEnvMetaKind"),
        switchName: "kind",
        switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]],
        arms: {
          interfaceVersion: xdr3.lookup("ScEnvMetaEntryInterfaceVersion")
        }
      });
      xdr3.struct("ScMetaV0", [["key", xdr3.string()], ["val", xdr3.string()]]);
      xdr3["enum"]("ScMetaKind", {
        scMetaV0: 0
      });
      xdr3.union("ScMetaEntry", {
        switchOn: xdr3.lookup("ScMetaKind"),
        switchName: "kind",
        switches: [["scMetaV0", "v0"]],
        arms: {
          v0: xdr3.lookup("ScMetaV0")
        }
      });
      xdr3["const"]("SC_SPEC_DOC_LIMIT", 1024);
      xdr3["enum"]("ScSpecType", {
        scSpecTypeVal: 0,
        scSpecTypeBool: 1,
        scSpecTypeVoid: 2,
        scSpecTypeError: 3,
        scSpecTypeU32: 4,
        scSpecTypeI32: 5,
        scSpecTypeU64: 6,
        scSpecTypeI64: 7,
        scSpecTypeTimepoint: 8,
        scSpecTypeDuration: 9,
        scSpecTypeU128: 10,
        scSpecTypeI128: 11,
        scSpecTypeU256: 12,
        scSpecTypeI256: 13,
        scSpecTypeBytes: 14,
        scSpecTypeString: 16,
        scSpecTypeSymbol: 17,
        scSpecTypeAddress: 19,
        scSpecTypeOption: 1e3,
        scSpecTypeResult: 1001,
        scSpecTypeVec: 1002,
        scSpecTypeMap: 1004,
        scSpecTypeTuple: 1005,
        scSpecTypeBytesN: 1006,
        scSpecTypeUdt: 2e3
      });
      xdr3.struct("ScSpecTypeOption", [["valueType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeResult", [["okType", xdr3.lookup("ScSpecTypeDef")], ["errorType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeVec", [["elementType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeMap", [["keyType", xdr3.lookup("ScSpecTypeDef")], ["valueType", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecTypeTuple", [["valueTypes", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 12)]]);
      xdr3.struct("ScSpecTypeBytesN", [["n", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecTypeUdt", [["name", xdr3.string(60)]]);
      xdr3.union("ScSpecTypeDef", {
        switchOn: xdr3.lookup("ScSpecType"),
        switchName: "type",
        switches: [["scSpecTypeVal", xdr3["void"]()], ["scSpecTypeBool", xdr3["void"]()], ["scSpecTypeVoid", xdr3["void"]()], ["scSpecTypeError", xdr3["void"]()], ["scSpecTypeU32", xdr3["void"]()], ["scSpecTypeI32", xdr3["void"]()], ["scSpecTypeU64", xdr3["void"]()], ["scSpecTypeI64", xdr3["void"]()], ["scSpecTypeTimepoint", xdr3["void"]()], ["scSpecTypeDuration", xdr3["void"]()], ["scSpecTypeU128", xdr3["void"]()], ["scSpecTypeI128", xdr3["void"]()], ["scSpecTypeU256", xdr3["void"]()], ["scSpecTypeI256", xdr3["void"]()], ["scSpecTypeBytes", xdr3["void"]()], ["scSpecTypeString", xdr3["void"]()], ["scSpecTypeSymbol", xdr3["void"]()], ["scSpecTypeAddress", xdr3["void"]()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]],
        arms: {
          option: xdr3.lookup("ScSpecTypeOption"),
          result: xdr3.lookup("ScSpecTypeResult"),
          vec: xdr3.lookup("ScSpecTypeVec"),
          map: xdr3.lookup("ScSpecTypeMap"),
          tuple: xdr3.lookup("ScSpecTypeTuple"),
          bytesN: xdr3.lookup("ScSpecTypeBytesN"),
          udt: xdr3.lookup("ScSpecTypeUdt")
        }
      });
      xdr3.struct("ScSpecUdtStructFieldV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(30)], ["type", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecUdtStructV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["fields", xdr3.varArray(xdr3.lookup("ScSpecUdtStructFieldV0"), 40)]]);
      xdr3.struct("ScSpecUdtUnionCaseVoidV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)]]);
      xdr3.struct("ScSpecUdtUnionCaseTupleV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["type", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 12)]]);
      xdr3["enum"]("ScSpecUdtUnionCaseV0Kind", {
        scSpecUdtUnionCaseVoidV0: 0,
        scSpecUdtUnionCaseTupleV0: 1
      });
      xdr3.union("ScSpecUdtUnionCaseV0", {
        switchOn: xdr3.lookup("ScSpecUdtUnionCaseV0Kind"),
        switchName: "kind",
        switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]],
        arms: {
          voidCase: xdr3.lookup("ScSpecUdtUnionCaseVoidV0"),
          tupleCase: xdr3.lookup("ScSpecUdtUnionCaseTupleV0")
        }
      });
      xdr3.struct("ScSpecUdtUnionV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtUnionCaseV0"), 50)]]);
      xdr3.struct("ScSpecUdtEnumCaseV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["value", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecUdtEnumV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtEnumCaseV0"), 50)]]);
      xdr3.struct("ScSpecUdtErrorEnumCaseV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(60)], ["value", xdr3.lookup("Uint32")]]);
      xdr3.struct("ScSpecUdtErrorEnumV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr3.string(80)], ["name", xdr3.string(60)], ["cases", xdr3.varArray(xdr3.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]);
      xdr3.struct("ScSpecFunctionInputV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.string(30)], ["type", xdr3.lookup("ScSpecTypeDef")]]);
      xdr3.struct("ScSpecFunctionV0", [["doc", xdr3.string(SC_SPEC_DOC_LIMIT)], ["name", xdr3.lookup("ScSymbol")], ["inputs", xdr3.varArray(xdr3.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", xdr3.varArray(xdr3.lookup("ScSpecTypeDef"), 1)]]);
      xdr3["enum"]("ScSpecEntryKind", {
        scSpecEntryFunctionV0: 0,
        scSpecEntryUdtStructV0: 1,
        scSpecEntryUdtUnionV0: 2,
        scSpecEntryUdtEnumV0: 3,
        scSpecEntryUdtErrorEnumV0: 4
      });
      xdr3.union("ScSpecEntry", {
        switchOn: xdr3.lookup("ScSpecEntryKind"),
        switchName: "kind",
        switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]],
        arms: {
          functionV0: xdr3.lookup("ScSpecFunctionV0"),
          udtStructV0: xdr3.lookup("ScSpecUdtStructV0"),
          udtUnionV0: xdr3.lookup("ScSpecUdtUnionV0"),
          udtEnumV0: xdr3.lookup("ScSpecUdtEnumV0"),
          udtErrorEnumV0: xdr3.lookup("ScSpecUdtErrorEnumV0")
        }
      });
      xdr3.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", xdr3.lookup("Int64")], ["txMaxInstructions", xdr3.lookup("Int64")], ["feeRatePerInstructionsIncrement", xdr3.lookup("Int64")], ["txMemoryLimit", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", xdr3.lookup("Uint32")], ["ledgerMaxReadBytes", xdr3.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", xdr3.lookup("Uint32")], ["ledgerMaxWriteBytes", xdr3.lookup("Uint32")], ["txMaxReadLedgerEntries", xdr3.lookup("Uint32")], ["txMaxReadBytes", xdr3.lookup("Uint32")], ["txMaxWriteLedgerEntries", xdr3.lookup("Uint32")], ["txMaxWriteBytes", xdr3.lookup("Uint32")], ["feeReadLedgerEntry", xdr3.lookup("Int64")], ["feeWriteLedgerEntry", xdr3.lookup("Int64")], ["feeRead1Kb", xdr3.lookup("Int64")], ["bucketListTargetSizeBytes", xdr3.lookup("Int64")], ["writeFee1KbBucketListLow", xdr3.lookup("Int64")], ["writeFee1KbBucketListHigh", xdr3.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", xdr3.lookup("Uint32")]]);
      xdr3.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", xdr3.lookup("Int64")]]);
      xdr3.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", xdr3.lookup("Uint32")], ["feeContractEvents1Kb", xdr3.lookup("Int64")]]);
      xdr3.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", xdr3.lookup("Uint32")], ["txMaxSizeBytes", xdr3.lookup("Uint32")], ["feeTxSize1Kb", xdr3.lookup("Int64")]]);
      xdr3["enum"]("ContractCostType", {
        wasmInsnExec: 0,
        memAlloc: 1,
        memCpy: 2,
        memCmp: 3,
        dispatchHostFunction: 4,
        visitObject: 5,
        valSer: 6,
        valDeser: 7,
        computeSha256Hash: 8,
        computeEd25519PubKey: 9,
        verifyEd25519Sig: 10,
        vmInstantiation: 11,
        vmCachedInstantiation: 12,
        invokeVmFunction: 13,
        computeKeccak256Hash: 14,
        decodeEcdsaCurve256Sig: 15,
        recoverEcdsaSecp256k1Key: 16,
        int256AddSub: 17,
        int256Mul: 18,
        int256Div: 19,
        int256Pow: 20,
        int256Shift: 21,
        chaCha20DrawBytes: 22,
        parseWasmInstructions: 23,
        parseWasmFunctions: 24,
        parseWasmGlobals: 25,
        parseWasmTableEntries: 26,
        parseWasmTypes: 27,
        parseWasmDataSegments: 28,
        parseWasmElemSegments: 29,
        parseWasmImports: 30,
        parseWasmExports: 31,
        parseWasmDataSegmentBytes: 32,
        instantiateWasmInstructions: 33,
        instantiateWasmFunctions: 34,
        instantiateWasmGlobals: 35,
        instantiateWasmTableEntries: 36,
        instantiateWasmTypes: 37,
        instantiateWasmDataSegments: 38,
        instantiateWasmElemSegments: 39,
        instantiateWasmImports: 40,
        instantiateWasmExports: 41,
        instantiateWasmDataSegmentBytes: 42,
        sec1DecodePointUncompressed: 43,
        verifyEcdsaSecp256r1Sig: 44,
        bls12381EncodeFp: 45,
        bls12381DecodeFp: 46,
        bls12381G1CheckPointOnCurve: 47,
        bls12381G1CheckPointInSubgroup: 48,
        bls12381G2CheckPointOnCurve: 49,
        bls12381G2CheckPointInSubgroup: 50,
        bls12381G1ProjectiveToAffine: 51,
        bls12381G2ProjectiveToAffine: 52,
        bls12381G1Add: 53,
        bls12381G1Mul: 54,
        bls12381G1Msm: 55,
        bls12381MapFpToG1: 56,
        bls12381HashToG1: 57,
        bls12381G2Add: 58,
        bls12381G2Mul: 59,
        bls12381G2Msm: 60,
        bls12381MapFp2ToG2: 61,
        bls12381HashToG2: 62,
        bls12381Pairing: 63,
        bls12381FrFromU256: 64,
        bls12381FrToU256: 65,
        bls12381FrAddSub: 66,
        bls12381FrMul: 67,
        bls12381FrPow: 68,
        bls12381FrInv: 69
      });
      xdr3.struct("ContractCostParamEntry", [["ext", xdr3.lookup("ExtensionPoint")], ["constTerm", xdr3.lookup("Int64")], ["linearTerm", xdr3.lookup("Int64")]]);
      xdr3.struct("StateArchivalSettings", [["maxEntryTtl", xdr3.lookup("Uint32")], ["minTemporaryTtl", xdr3.lookup("Uint32")], ["minPersistentTtl", xdr3.lookup("Uint32")], ["persistentRentRateDenominator", xdr3.lookup("Int64")], ["tempRentRateDenominator", xdr3.lookup("Int64")], ["maxEntriesToArchive", xdr3.lookup("Uint32")], ["bucketListSizeWindowSampleSize", xdr3.lookup("Uint32")], ["bucketListWindowSamplePeriod", xdr3.lookup("Uint32")], ["evictionScanSize", xdr3.lookup("Uint32")], ["startingEvictionScanLevel", xdr3.lookup("Uint32")]]);
      xdr3.struct("EvictionIterator", [["bucketListLevel", xdr3.lookup("Uint32")], ["isCurrBucket", xdr3.bool()], ["bucketFileOffset", xdr3.lookup("Uint64")]]);
      xdr3["const"]("CONTRACT_COST_COUNT_LIMIT", 1024);
      xdr3.typedef("ContractCostParams", xdr3.varArray(xdr3.lookup("ContractCostParamEntry"), xdr3.lookup("CONTRACT_COST_COUNT_LIMIT")));
      xdr3["enum"]("ConfigSettingId", {
        configSettingContractMaxSizeBytes: 0,
        configSettingContractComputeV0: 1,
        configSettingContractLedgerCostV0: 2,
        configSettingContractHistoricalDataV0: 3,
        configSettingContractEventsV0: 4,
        configSettingContractBandwidthV0: 5,
        configSettingContractCostParamsCpuInstructions: 6,
        configSettingContractCostParamsMemoryBytes: 7,
        configSettingContractDataKeySizeBytes: 8,
        configSettingContractDataEntrySizeBytes: 9,
        configSettingStateArchival: 10,
        configSettingContractExecutionLanes: 11,
        configSettingBucketlistSizeWindow: 12,
        configSettingEvictionIterator: 13
      });
      xdr3.union("ConfigSettingEntry", {
        switchOn: xdr3.lookup("ConfigSettingId"),
        switchName: "configSettingId",
        switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]],
        arms: {
          contractMaxSizeBytes: xdr3.lookup("Uint32"),
          contractCompute: xdr3.lookup("ConfigSettingContractComputeV0"),
          contractLedgerCost: xdr3.lookup("ConfigSettingContractLedgerCostV0"),
          contractHistoricalData: xdr3.lookup("ConfigSettingContractHistoricalDataV0"),
          contractEvents: xdr3.lookup("ConfigSettingContractEventsV0"),
          contractBandwidth: xdr3.lookup("ConfigSettingContractBandwidthV0"),
          contractCostParamsCpuInsns: xdr3.lookup("ContractCostParams"),
          contractCostParamsMemBytes: xdr3.lookup("ContractCostParams"),
          contractDataKeySizeBytes: xdr3.lookup("Uint32"),
          contractDataEntrySizeBytes: xdr3.lookup("Uint32"),
          stateArchivalSettings: xdr3.lookup("StateArchivalSettings"),
          contractExecutionLanes: xdr3.lookup("ConfigSettingContractExecutionLanesV0"),
          bucketListSizeWindow: xdr3.varArray(xdr3.lookup("Uint64"), 2147483647),
          evictionIterator: xdr3.lookup("EvictionIterator")
        }
      });
    });
    var _default = exports["default"] = types;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/xdr.js
var require_xdr4 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/xdr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _curr_generated = _interopRequireDefault(require_curr_generated3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = _curr_generated["default"];
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/jsxdr.js
var require_jsxdr3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/jsxdr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _jsXdr = require_xdr();
    var cereal = {
      XdrWriter: _jsXdr.XdrWriter,
      XdrReader: _jsXdr.XdrReader
    };
    var _default = exports["default"] = cereal;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/hashing.js
var require_hashing3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hash = hash2;
    var _sha = require_sha2();
    function hash2(data) {
      var hasher = new _sha.sha256();
      hasher.update(data, "utf8");
      return hasher.digest();
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/signing.js
var require_signing3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FastSigning = void 0;
    exports.generate = generate;
    exports.sign = sign;
    exports.verify = verify;
    var actualMethods = {};
    var FastSigning = exports.FastSigning = checkFastSigning();
    function sign(data, secretKey) {
      return actualMethods.sign(data, secretKey);
    }
    function verify(data, signature, publicKey) {
      return actualMethods.verify(data, signature, publicKey);
    }
    function generate(secretKey) {
      return actualMethods.generate(secretKey);
    }
    function checkFastSigning() {
      return typeof window === "undefined" ? checkFastSigningNode() : checkFastSigningBrowser();
    }
    function checkFastSigningNode() {
      var sodium;
      try {
        sodium = require_sodium_native();
      } catch (err) {
        return checkFastSigningBrowser();
      }
      if (!Object.keys(sodium).length) {
        return checkFastSigningBrowser();
      }
      actualMethods.generate = function(secretKey) {
        var pk = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
        var sk = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
        sodium.crypto_sign_seed_keypair(pk, sk, secretKey);
        return pk;
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        var signature = Buffer.alloc(sodium.crypto_sign_BYTES);
        sodium.crypto_sign_detached(signature, data, secretKey);
        return signature;
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        try {
          return sodium.crypto_sign_verify_detached(signature, data, publicKey);
        } catch (e) {
          return false;
        }
      };
      return true;
    }
    function checkFastSigningBrowser() {
      var nacl = require_nacl_fast();
      actualMethods.generate = function(secretKey) {
        var secretKeyUint8 = new Uint8Array(secretKey);
        var naclKeys = nacl.sign.keyPair.fromSeed(secretKeyUint8);
        return Buffer.from(naclKeys.publicKey);
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        secretKey = new Uint8Array(secretKey.toJSON().data);
        var signature = nacl.sign.detached(data, secretKey);
        return Buffer.from(signature);
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        signature = new Uint8Array(signature.toJSON().data);
        publicKey = new Uint8Array(publicKey.toJSON().data);
        return nacl.sign.detached.verify(data, signature, publicKey);
      };
      return false;
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/util.js
var require_util3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.trimEnd = void 0;
    var trimEnd = exports.trimEnd = function trimEnd2(input, _char) {
      var isNumber = typeof input === "number";
      var str = String(input);
      while (str.endsWith(_char)) {
        str = str.slice(0, -1);
      }
      return isNumber ? Number(str) : str;
    };
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/checksum.js
var require_checksum3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/checksum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.verifyChecksum = verifyChecksum;
    function verifyChecksum(expected, actual) {
      if (expected.length !== actual.length) {
        return false;
      }
      if (expected.length === 0) {
        return true;
      }
      for (var i = 0; i < expected.length; i += 1) {
        if (expected[i] !== actual[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/strkey.js
var require_strkey3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/strkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StrKey = void 0;
    exports.decodeCheck = decodeCheck;
    exports.encodeCheck = encodeCheck;
    var _base = _interopRequireDefault(require_base32());
    var _checksum = require_checksum3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var versionBytes = {
      ed25519PublicKey: 6 << 3,
      // G (when encoded in base32)
      ed25519SecretSeed: 18 << 3,
      // S
      med25519PublicKey: 12 << 3,
      // M
      preAuthTx: 19 << 3,
      // T
      sha256Hash: 23 << 3,
      // X
      signedPayload: 15 << 3,
      // P
      contract: 2 << 3
      // C
    };
    var strkeyTypes = {
      G: "ed25519PublicKey",
      S: "ed25519SecretSeed",
      M: "med25519PublicKey",
      T: "preAuthTx",
      X: "sha256Hash",
      P: "signedPayload",
      C: "contract"
    };
    var StrKey2 = exports.StrKey = function() {
      function StrKey3() {
        _classCallCheck(this, StrKey3);
      }
      return _createClass(StrKey3, null, [{
        key: "encodeEd25519PublicKey",
        value: (
          /**
           * Encodes `data` to strkey ed25519 public key.
           *
           * @param   {Buffer} data   raw data to encode
           * @returns {string}        "G..." representation of the key
           */
          function encodeEd25519PublicKey(data) {
            return encodeCheck("ed25519PublicKey", data);
          }
        )
        /**
         * Decodes strkey ed25519 public key to raw data.
         *
         * If the parameter is a muxed account key ("M..."), this will only encode it
         * as a basic Ed25519 key (as if in "G..." format).
         *
         * @param   {string} data   "G..." (or "M...") key representation to decode
         * @returns {Buffer}        raw key
         */
      }, {
        key: "decodeEd25519PublicKey",
        value: function decodeEd25519PublicKey(data) {
          return decodeCheck("ed25519PublicKey", data);
        }
        /**
         * Returns true if the given Stellar public key is a valid ed25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519PublicKey",
        value: function isValidEd25519PublicKey(publicKey) {
          return isValid("ed25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey ed25519 seed.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeEd25519SecretSeed",
        value: function encodeEd25519SecretSeed(data) {
          return encodeCheck("ed25519SecretSeed", data);
        }
        /**
         * Decodes strkey ed25519 seed to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeEd25519SecretSeed",
        value: function decodeEd25519SecretSeed(address) {
          return decodeCheck("ed25519SecretSeed", address);
        }
        /**
         * Returns true if the given Stellar secret key is a valid ed25519 secret seed.
         * @param {string} seed seed to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519SecretSeed",
        value: function isValidEd25519SecretSeed(seed) {
          return isValid("ed25519SecretSeed", seed);
        }
        /**
         * Encodes data to strkey med25519 public key.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeMed25519PublicKey",
        value: function encodeMed25519PublicKey(data) {
          return encodeCheck("med25519PublicKey", data);
        }
        /**
         * Decodes strkey med25519 public key to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeMed25519PublicKey",
        value: function decodeMed25519PublicKey(address) {
          return decodeCheck("med25519PublicKey", address);
        }
        /**
         * Returns true if the given Stellar public key is a valid med25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidMed25519PublicKey",
        value: function isValidMed25519PublicKey(publicKey) {
          return isValid("med25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey preAuthTx.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodePreAuthTx",
        value: function encodePreAuthTx(data) {
          return encodeCheck("preAuthTx", data);
        }
        /**
         * Decodes strkey PreAuthTx to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodePreAuthTx",
        value: function decodePreAuthTx(address) {
          return decodeCheck("preAuthTx", address);
        }
        /**
         * Encodes data to strkey sha256 hash.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSha256Hash",
        value: function encodeSha256Hash(data) {
          return encodeCheck("sha256Hash", data);
        }
        /**
         * Decodes strkey sha256 hash to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSha256Hash",
        value: function decodeSha256Hash(address) {
          return decodeCheck("sha256Hash", address);
        }
        /**
         * Encodes raw data to strkey signed payload (P...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSignedPayload",
        value: function encodeSignedPayload(data) {
          return encodeCheck("signedPayload", data);
        }
        /**
         * Decodes strkey signed payload (P...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSignedPayload",
        value: function decodeSignedPayload(address) {
          return decodeCheck("signedPayload", address);
        }
        /**
         * Checks validity of alleged signed payload (P...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidSignedPayload",
        value: function isValidSignedPayload(address) {
          return isValid("signedPayload", address);
        }
        /**
         * Encodes raw data to strkey contract (C...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeContract",
        value: function encodeContract(data) {
          return encodeCheck("contract", data);
        }
        /**
         * Decodes strkey contract (C...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeContract",
        value: function decodeContract(address) {
          return decodeCheck("contract", address);
        }
        /**
         * Checks validity of alleged contract (C...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidContract",
        value: function isValidContract(address) {
          return isValid("contract", address);
        }
      }, {
        key: "getVersionByteForPrefix",
        value: function getVersionByteForPrefix(address) {
          return strkeyTypes[address[0]];
        }
      }]);
    }();
    function isValid(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
          if (encoded.length !== 56) {
            return false;
          }
          break;
        case "med25519PublicKey":
          if (encoded.length !== 69) {
            return false;
          }
          break;
        case "signedPayload":
          if (encoded.length < 56 || encoded.length > 165) {
            return false;
          }
          break;
        default:
          return false;
      }
      var decoded = "";
      try {
        decoded = decodeCheck(versionByteName, encoded);
      } catch (err) {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        case "ed25519SecretSeed":
        case "preAuthTx":
        case "sha256Hash":
        case "contract":
          return decoded.length === 32;
        case "med25519PublicKey":
          return decoded.length === 40;
        case "signedPayload":
          return (
            // 32 for the signer, +4 for the payload size, then either +4 for the
            // min or +64 for the max payload
            decoded.length >= 32 + 4 + 4 && decoded.length <= 32 + 4 + 64
          );
        default:
          return false;
      }
    }
    function decodeCheck(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        throw new TypeError("encoded argument must be of type String");
      }
      var decoded = _base["default"].decode(encoded);
      var versionByte = decoded[0];
      var payload = decoded.slice(0, -2);
      var data = payload.slice(1);
      var checksum = decoded.slice(-2);
      if (encoded !== _base["default"].encode(decoded)) {
        throw new Error("invalid encoded string");
      }
      var expectedVersion = versionBytes[versionByteName];
      if (expectedVersion === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      if (versionByte !== expectedVersion) {
        throw new Error("invalid version byte. expected ".concat(expectedVersion, ", got ").concat(versionByte));
      }
      var expectedChecksum = calculateChecksum(payload);
      if (!(0, _checksum.verifyChecksum)(expectedChecksum, checksum)) {
        throw new Error("invalid checksum");
      }
      return Buffer.from(data);
    }
    function encodeCheck(versionByteName, data) {
      if (data === null || data === void 0) {
        throw new Error("cannot encode null data");
      }
      var versionByte = versionBytes[versionByteName];
      if (versionByte === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      data = Buffer.from(data);
      var versionBuffer = Buffer.from([versionByte]);
      var payload = Buffer.concat([versionBuffer, data]);
      var checksum = Buffer.from(calculateChecksum(payload));
      var unencoded = Buffer.concat([payload, checksum]);
      return _base["default"].encode(unencoded);
    }
    function calculateChecksum(payload) {
      var crcTable = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
      var crc16 = 0;
      for (var i = 0; i < payload.length; i += 1) {
        var _byte = payload[i];
        var lookupIndex = crc16 >> 8 ^ _byte;
        crc16 = crc16 << 8 ^ crcTable[lookupIndex];
        crc16 &= 65535;
      }
      var checksum = new Uint8Array(2);
      checksum[0] = crc16 & 255;
      checksum[1] = crc16 >> 8 & 255;
      return checksum;
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/keypair.js
var require_keypair3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/keypair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Keypair = void 0;
    var _tweetnacl = _interopRequireDefault(require_nacl_fast());
    var _signing = require_signing3();
    var _strkey = require_strkey3();
    var _hashing = require_hashing3();
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Keypair2 = exports.Keypair = function() {
      function Keypair3(keys) {
        _classCallCheck(this, Keypair3);
        if (keys.type !== "ed25519") {
          throw new Error("Invalid keys type");
        }
        this.type = keys.type;
        if (keys.secretKey) {
          keys.secretKey = Buffer.from(keys.secretKey);
          if (keys.secretKey.length !== 32) {
            throw new Error("secretKey length is invalid");
          }
          this._secretSeed = keys.secretKey;
          this._publicKey = (0, _signing.generate)(keys.secretKey);
          this._secretKey = Buffer.concat([keys.secretKey, this._publicKey]);
          if (keys.publicKey && !this._publicKey.equals(Buffer.from(keys.publicKey))) {
            throw new Error("secretKey does not match publicKey");
          }
        } else {
          this._publicKey = Buffer.from(keys.publicKey);
          if (this._publicKey.length !== 32) {
            throw new Error("publicKey length is invalid");
          }
        }
      }
      return _createClass(Keypair3, [{
        key: "xdrAccountId",
        value: function xdrAccountId() {
          return new _xdr["default"].AccountId.publicKeyTypeEd25519(this._publicKey);
        }
      }, {
        key: "xdrPublicKey",
        value: function xdrPublicKey() {
          return new _xdr["default"].PublicKey.publicKeyTypeEd25519(this._publicKey);
        }
        /**
         * Creates a {@link xdr.MuxedAccount} object from the public key.
         *
         * You will get a different type of muxed account depending on whether or not
         * you pass an ID.
         *
         * @param  {string} [id] - stringified integer indicating the underlying muxed
         *     ID of the new account object
         *
         * @return {xdr.MuxedAccount}
         */
      }, {
        key: "xdrMuxedAccount",
        value: function xdrMuxedAccount(id) {
          if (typeof id !== "undefined") {
            if (typeof id !== "string") {
              throw new TypeError("expected string for ID, got ".concat(_typeof(id)));
            }
            return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
              id: _xdr["default"].Uint64.fromString(id),
              ed25519: this._publicKey
            }));
          }
          return new _xdr["default"].MuxedAccount.keyTypeEd25519(this._publicKey);
        }
        /**
         * Returns raw public key
         * @returns {Buffer}
         */
      }, {
        key: "rawPublicKey",
        value: function rawPublicKey() {
          return this._publicKey;
        }
      }, {
        key: "signatureHint",
        value: function signatureHint() {
          var a = this.xdrAccountId().toXDR();
          return a.slice(a.length - 4);
        }
        /**
         * Returns public key associated with this `Keypair` object.
         * @returns {string}
         */
      }, {
        key: "publicKey",
        value: function publicKey() {
          return _strkey.StrKey.encodeEd25519PublicKey(this._publicKey);
        }
        /**
         * Returns secret key associated with this `Keypair` object
         * @returns {string}
         */
      }, {
        key: "secret",
        value: function secret() {
          if (!this._secretSeed) {
            throw new Error("no secret key available");
          }
          if (this.type === "ed25519") {
            return _strkey.StrKey.encodeEd25519SecretSeed(this._secretSeed);
          }
          throw new Error("Invalid Keypair type");
        }
        /**
         * Returns raw secret key.
         * @returns {Buffer}
         */
      }, {
        key: "rawSecretKey",
        value: function rawSecretKey() {
          return this._secretSeed;
        }
        /**
         * Returns `true` if this `Keypair` object contains secret key and can sign.
         * @returns {boolean}
         */
      }, {
        key: "canSign",
        value: function canSign() {
          return !!this._secretKey;
        }
        /**
         * Signs data.
         * @param {Buffer} data Data to sign
         * @returns {Buffer}
         */
      }, {
        key: "sign",
        value: function sign(data) {
          if (!this.canSign()) {
            throw new Error("cannot sign: no secret key available");
          }
          return (0, _signing.sign)(data, this._secretKey);
        }
        /**
         * Verifies if `signature` for `data` is valid.
         * @param {Buffer} data Signed data
         * @param {Buffer} signature Signature
         * @returns {boolean}
         */
      }, {
        key: "verify",
        value: function verify(data, signature) {
          return (0, _signing.verify)(data, signature, this._publicKey);
        }
        /**
         * Returns the decorated signature (hint+sig) for arbitrary data.
         *
         * @param  {Buffer} data  arbitrary data to sign
         * @return {xdr.DecoratedSignature}   the raw signature structure which can be
         *     added directly to a transaction envelope
         *
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signDecorated",
        value: function signDecorated(data) {
          var signature = this.sign(data);
          var hint = this.signatureHint();
          return new _xdr["default"].DecoratedSignature({
            hint,
            signature
          });
        }
        /**
         * Returns the raw decorated signature (hint+sig) for a signed payload signer.
         *
         *  The hint is defined as the last 4 bytes of the signer key XORed with last
         *  4 bytes of the payload (zero-left-padded if necessary).
         *
         * @param  {Buffer} data    data to both sign and treat as the payload
         * @return {xdr.DecoratedSignature}
         *
         * @see https://github.com/stellar/stellar-protocol/blob/master/core/cap-0040.md#signature-hint
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signPayloadDecorated",
        value: function signPayloadDecorated(data) {
          var signature = this.sign(data);
          var keyHint = this.signatureHint();
          var hint = Buffer.from(data.slice(-4));
          if (hint.length < 4) {
            hint = Buffer.concat([hint, Buffer.alloc(4 - data.length, 0)]);
          }
          return new _xdr["default"].DecoratedSignature({
            hint: hint.map(function(_byte, i) {
              return _byte ^ keyHint[i];
            }),
            signature
          });
        }
      }], [{
        key: "fromSecret",
        value: function fromSecret(secret) {
          var rawSecret = _strkey.StrKey.decodeEd25519SecretSeed(secret);
          return this.fromRawEd25519Seed(rawSecret);
        }
        /**
         * Creates a new `Keypair` object from ed25519 secret key seed raw bytes.
         *
         * @param {Buffer} rawSeed Raw 32-byte ed25519 secret key seed
         * @returns {Keypair}
         */
      }, {
        key: "fromRawEd25519Seed",
        value: function fromRawEd25519Seed(rawSeed) {
          return new this({
            type: "ed25519",
            secretKey: rawSeed
          });
        }
        /**
         * Returns `Keypair` object representing network master key.
         * @param {string} networkPassphrase passphrase of the target stellar network (e.g. "Public Global Stellar Network ; September 2015").
         * @returns {Keypair}
         */
      }, {
        key: "master",
        value: function master(networkPassphrase) {
          if (!networkPassphrase) {
            throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
          }
          return this.fromRawEd25519Seed((0, _hashing.hash)(networkPassphrase));
        }
        /**
         * Creates a new `Keypair` object from public key.
         * @param {string} publicKey public key (ex. `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`)
         * @returns {Keypair}
         */
      }, {
        key: "fromPublicKey",
        value: function fromPublicKey(publicKey) {
          publicKey = _strkey.StrKey.decodeEd25519PublicKey(publicKey);
          if (publicKey.length !== 32) {
            throw new Error("Invalid Stellar public key");
          }
          return new this({
            type: "ed25519",
            publicKey
          });
        }
        /**
         * Create a random `Keypair` object.
         * @returns {Keypair}
         */
      }, {
        key: "random",
        value: function random() {
          var secret = _tweetnacl["default"].randomBytes(32);
          return this.fromRawEd25519Seed(secret);
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/asset.js
var require_asset3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Asset = void 0;
    var _util = require_util3();
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _strkey = require_strkey3();
    var _hashing = require_hashing3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Asset = exports.Asset = function() {
      function Asset2(code, issuer) {
        _classCallCheck(this, Asset2);
        if (!/^[a-zA-Z0-9]{1,12}$/.test(code)) {
          throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
        }
        if (String(code).toLowerCase() !== "xlm" && !issuer) {
          throw new Error("Issuer cannot be null");
        }
        if (issuer && !_strkey.StrKey.isValidEd25519PublicKey(issuer)) {
          throw new Error("Issuer is invalid");
        }
        if (String(code).toLowerCase() === "xlm") {
          this.code = "XLM";
        } else {
          this.code = code;
        }
        this.issuer = issuer;
      }
      return _createClass(Asset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr.Asset object for this asset.
           * @returns {xdr.Asset} XDR asset object
           */
          function toXDRObject() {
            return this._toXDRObject(_xdr["default"].Asset);
          }
        )
        /**
         * Returns the xdr.ChangeTrustAsset object for this asset.
         * @returns {xdr.ChangeTrustAsset} XDR asset object
         */
      }, {
        key: "toChangeTrustXDRObject",
        value: function toChangeTrustXDRObject() {
          return this._toXDRObject(_xdr["default"].ChangeTrustAsset);
        }
        /**
         * Returns the xdr.TrustLineAsset object for this asset.
         * @returns {xdr.TrustLineAsset} XDR asset object
         */
      }, {
        key: "toTrustLineXDRObject",
        value: function toTrustLineXDRObject() {
          return this._toXDRObject(_xdr["default"].TrustLineAsset);
        }
        /**
         * Returns the would-be contract ID (`C...` format) for this asset on a given
         * network.
         *
         * @param {string}    networkPassphrase   indicates which network the contract
         *    ID should refer to, since every network will have a unique ID for the
         *    same contract (see {@link Networks} for options)
         *
         * @returns {string}  the strkey-encoded (`C...`) contract ID for this asset
         *
         * @warning This makes no guarantee that this contract actually *exists*.
         */
      }, {
        key: "contractId",
        value: function contractId(networkPassphrase) {
          var networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
          var preimage = _xdr["default"].HashIdPreimage.envelopeTypeContractId(new _xdr["default"].HashIdPreimageContractId({
            networkId,
            contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())
          }));
          return _strkey.StrKey.encodeContract((0, _hashing.hash)(preimage.toXDR()));
        }
        /**
         * Returns the xdr object for this asset.
         * @param {xdr.Asset | xdr.ChangeTrustAsset} xdrAsset - The asset xdr object.
         * @returns {xdr.Asset | xdr.ChangeTrustAsset | xdr.TrustLineAsset} XDR Asset object
         */
      }, {
        key: "_toXDRObject",
        value: function _toXDRObject() {
          var xdrAsset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _xdr["default"].Asset;
          if (this.isNative()) {
            return xdrAsset.assetTypeNative();
          }
          var xdrType;
          var xdrTypeString;
          if (this.code.length <= 4) {
            xdrType = _xdr["default"].AlphaNum4;
            xdrTypeString = "assetTypeCreditAlphanum4";
          } else {
            xdrType = _xdr["default"].AlphaNum12;
            xdrTypeString = "assetTypeCreditAlphanum12";
          }
          var padLength = this.code.length <= 4 ? 4 : 12;
          var paddedCode = this.code.padEnd(padLength, "\0");
          var assetType = new xdrType({
            assetCode: paddedCode,
            issuer: _keypair.Keypair.fromPublicKey(this.issuer).xdrAccountId()
          });
          return new xdrAsset(xdrTypeString, assetType);
        }
        /**
         * @returns {string} Asset code
         */
      }, {
        key: "getCode",
        value: function getCode() {
          if (this.code === void 0) {
            return void 0;
          }
          return String(this.code);
        }
        /**
         * @returns {string} Asset issuer
         */
      }, {
        key: "getIssuer",
        value: function getIssuer() {
          if (this.issuer === void 0) {
            return void 0;
          }
          return String(this.issuer);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {string} Asset type. Can be one of following types:
         *
         *  - `native`,
         *  - `credit_alphanum4`,
         *  - `credit_alphanum12`, or
         *  - `unknown` as the error case (which should never occur)
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          switch (this.getRawAssetType().value) {
            case _xdr["default"].AssetType.assetTypeNative().value:
              return "native";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4().value:
              return "credit_alphanum4";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12().value:
              return "credit_alphanum12";
            default:
              return "unknown";
          }
        }
        /**
         * @returns {xdr.AssetType}  the raw XDR representation of the asset type
         */
      }, {
        key: "getRawAssetType",
        value: function getRawAssetType() {
          if (this.isNative()) {
            return _xdr["default"].AssetType.assetTypeNative();
          }
          if (this.code.length <= 4) {
            return _xdr["default"].AssetType.assetTypeCreditAlphanum4();
          }
          return _xdr["default"].AssetType.assetTypeCreditAlphanum12();
        }
        /**
         * @returns {boolean}  true if this asset object is the native asset.
         */
      }, {
        key: "isNative",
        value: function isNative() {
          return !this.issuer;
        }
        /**
         * @param {Asset} asset Asset to compare
         * @returns {boolean} true if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.code === asset.getCode() && this.issuer === asset.getIssuer();
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.isNative()) {
            return "native";
          }
          return "".concat(this.getCode(), ":").concat(this.getIssuer());
        }
        /**
         * Compares two assets according to the criteria:
         *
         *  1. First compare the type (native < alphanum4 < alphanum12).
         *  2. If the types are equal, compare the assets codes.
         *  3. If the asset codes are equal, compare the issuers.
         *
         * @param   {Asset} assetA - the first asset
         * @param   {Asset} assetB - the second asset
         * @returns {number} `-1` if assetA < assetB, `0` if assetA == assetB, `1` if assetA > assetB.
         *
         * @static
         * @memberof Asset
         */
      }], [{
        key: "native",
        value: function _native() {
          return new Asset2("XLM");
        }
        /**
         * Returns an asset object from its XDR object representation.
         * @param {xdr.Asset} assetXdr - The asset xdr object.
         * @returns {Asset}
         */
      }, {
        key: "fromOperation",
        value: function fromOperation(assetXdr) {
          var anum;
          var code;
          var issuer;
          switch (assetXdr["switch"]()) {
            case _xdr["default"].AssetType.assetTypeNative():
              return this["native"]();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4():
              anum = assetXdr.alphaNum4();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12():
              anum = anum || assetXdr.alphaNum12();
              issuer = _strkey.StrKey.encodeEd25519PublicKey(anum.issuer().ed25519());
              code = (0, _util.trimEnd)(anum.assetCode(), "\0");
              return new this(code, issuer);
            default:
              throw new Error("Invalid asset type: ".concat(assetXdr["switch"]().name));
          }
        }
      }, {
        key: "compare",
        value: function compare(assetA, assetB) {
          if (!assetA || !(assetA instanceof Asset2)) {
            throw new Error("assetA is invalid");
          }
          if (!assetB || !(assetB instanceof Asset2)) {
            throw new Error("assetB is invalid");
          }
          if (assetA.equals(assetB)) {
            return 0;
          }
          var xdrAtype = assetA.getRawAssetType().value;
          var xdrBtype = assetB.getRawAssetType().value;
          if (xdrAtype !== xdrBtype) {
            return xdrAtype < xdrBtype ? -1 : 1;
          }
          var result = asciiCompare(assetA.getCode(), assetB.getCode());
          if (result !== 0) {
            return result;
          }
          return asciiCompare(assetA.getIssuer(), assetB.getIssuer());
        }
      }]);
    }();
    function asciiCompare(a, b) {
      return Buffer.compare(Buffer.from(a, "ascii"), Buffer.from(b, "ascii"));
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js
var require_get_liquidity_pool_id3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolFeeV18 = void 0;
    exports.getLiquidityPoolId = getLiquidityPoolId;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _asset = require_asset3();
    var _hashing = require_hashing3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var LiquidityPoolFeeV18 = exports.LiquidityPoolFeeV18 = 30;
    function getLiquidityPoolId(liquidityPoolType) {
      var liquidityPoolParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (liquidityPoolType !== "constant_product") {
        throw new Error("liquidityPoolType is invalid");
      }
      var assetA = liquidityPoolParameters.assetA, assetB = liquidityPoolParameters.assetB, fee = liquidityPoolParameters.fee;
      if (!assetA || !(assetA instanceof _asset.Asset)) {
        throw new Error("assetA is invalid");
      }
      if (!assetB || !(assetB instanceof _asset.Asset)) {
        throw new Error("assetB is invalid");
      }
      if (!fee || fee !== LiquidityPoolFeeV18) {
        throw new Error("fee is invalid");
      }
      if (_asset.Asset.compare(assetA, assetB) !== -1) {
        throw new Error("Assets are not in lexicographic order");
      }
      var lpTypeData = _xdr["default"].LiquidityPoolType.liquidityPoolConstantProduct().toXDR();
      var lpParamsData = new _xdr["default"].LiquidityPoolConstantProductParameters({
        assetA: assetA.toXDRObject(),
        assetB: assetB.toXDRObject(),
        fee
      }).toXDR();
      var payload = Buffer.concat([lpTypeData, lpParamsData]);
      return (0, _hashing.hash)(payload);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/transaction_base.js
var require_transaction_base3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/transaction_base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBase = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _hashing = require_hashing3();
    var _keypair = require_keypair3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var TransactionBase = exports.TransactionBase = function() {
      function TransactionBase2(tx, signatures, fee, networkPassphrase) {
        _classCallCheck(this, TransactionBase2);
        if (typeof networkPassphrase !== "string") {
          throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(_typeof(networkPassphrase)));
        }
        this._networkPassphrase = networkPassphrase;
        this._tx = tx;
        this._signatures = signatures;
        this._fee = fee;
      }
      return _createClass(TransactionBase2, [{
        key: "signatures",
        get: function get() {
          return this._signatures;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
      }, {
        key: "tx",
        get: function get() {
          return this._tx;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "fee",
        get: function get() {
          return this._fee;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "networkPassphrase",
        get: function get() {
          return this._networkPassphrase;
        },
        set: function set(networkPassphrase) {
          this._networkPassphrase = networkPassphrase;
        }
        /**
         * Signs the transaction with the given {@link Keypair}.
         * @param {...Keypair} keypairs Keypairs of signers
         * @returns {void}
         */
      }, {
        key: "sign",
        value: function sign() {
          var _this = this;
          var txHash = this.hash();
          for (var _len = arguments.length, keypairs = new Array(_len), _key = 0; _key < _len; _key++) {
            keypairs[_key] = arguments[_key];
          }
          keypairs.forEach(function(kp) {
            var sig = kp.signDecorated(txHash);
            _this.signatures.push(sig);
          });
        }
        /**
         * Signs a transaction with the given {@link Keypair}. Useful if someone sends
         * you a transaction XDR for you to sign and return (see
         * [addSignature](#addSignature) for more information).
         *
         * When you get a transaction XDR to sign....
         * - Instantiate a `Transaction` object with the XDR
         * - Use {@link Keypair} to generate a keypair object for your Stellar seed.
         * - Run `getKeypairSignature` with that keypair
         * - Send back the signature along with your publicKey (not your secret seed!)
         *
         * Example:
         * ```javascript
         * // `transactionXDR` is a string from the person generating the transaction
         * const transaction = new Transaction(transactionXDR, networkPassphrase);
         * const keypair = Keypair.fromSecret(myStellarSeed);
         * return transaction.getKeypairSignature(keypair);
         * ```
         *
         * @param {Keypair} keypair Keypair of signer
         * @returns {string} Signature string
         */
      }, {
        key: "getKeypairSignature",
        value: function getKeypairSignature(keypair) {
          return keypair.sign(this.hash()).toString("base64");
        }
        /**
         * Add a signature to the transaction. Useful when a party wants to pre-sign
         * a transaction but doesn't want to give access to their secret keys.
         * This will also verify whether the signature is valid.
         *
         * Here's how you would use this feature to solicit multiple signatures.
         * - Use `TransactionBuilder` to build a new transaction.
         * - Make sure to set a long enough timeout on that transaction to give your
         * signers enough time to sign!
         * - Once you build the transaction, use `transaction.toXDR()` to get the
         * base64-encoded XDR string.
         * - _Warning!_ Once you've built this transaction, don't submit any other
         * transactions onto your account! Doing so will invalidate this pre-compiled
         * transaction!
         * - Send this XDR string to your other parties. They can use the instructions
         * for [getKeypairSignature](#getKeypairSignature) to sign the transaction.
         * - They should send you back their `publicKey` and the `signature` string
         * from [getKeypairSignature](#getKeypairSignature), both of which you pass to
         * this function.
         *
         * @param {string} publicKey The public key of the signer
         * @param {string} signature The base64 value of the signature XDR
         * @returns {void}
         */
      }, {
        key: "addSignature",
        value: function addSignature() {
          var publicKey = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var signature = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          if (!signature || typeof signature !== "string") {
            throw new Error("Invalid signature");
          }
          if (!publicKey || typeof publicKey !== "string") {
            throw new Error("Invalid publicKey");
          }
          var keypair;
          var hint;
          var signatureBuffer = Buffer.from(signature, "base64");
          try {
            keypair = _keypair.Keypair.fromPublicKey(publicKey);
            hint = keypair.signatureHint();
          } catch (e) {
            throw new Error("Invalid publicKey");
          }
          if (!keypair.verify(this.hash(), signatureBuffer)) {
            throw new Error("Invalid signature");
          }
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature: signatureBuffer
          }));
        }
        /**
         * Add a decorated signature directly to the transaction envelope.
         *
         * @param {xdr.DecoratedSignature} signature    raw signature to add
         * @returns {void}
         *
         * @see Keypair.signDecorated
         * @see Keypair.signPayloadDecorated
         */
      }, {
        key: "addDecoratedSignature",
        value: function addDecoratedSignature(signature) {
          this.signatures.push(signature);
        }
        /**
         * Add `hashX` signer preimage as signature.
         * @param {Buffer|String} preimage Preimage of hash used as signer
         * @returns {void}
         */
      }, {
        key: "signHashX",
        value: function signHashX(preimage) {
          if (typeof preimage === "string") {
            preimage = Buffer.from(preimage, "hex");
          }
          if (preimage.length > 64) {
            throw new Error("preimage cannnot be longer than 64 bytes");
          }
          var signature = preimage;
          var hashX = (0, _hashing.hash)(preimage);
          var hint = hashX.slice(hashX.length - 4);
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature
          }));
        }
        /**
         * Returns a hash for this transaction, suitable for signing.
         * @returns {Buffer}
         */
      }, {
        key: "hash",
        value: function hash2() {
          return (0, _hashing.hash)(this.signatureBase());
        }
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          throw new Error("Implement in subclass");
        }
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          throw new Error("Implement in subclass");
        }
        /**
         * Get the transaction envelope as a base64-encoded string
         * @returns {string} XDR string
         */
      }, {
        key: "toXDR",
        value: function toXDR() {
          return this.toEnvelope().toXDR().toString("base64");
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/bignumber.js
var require_bignumber4 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/bignumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var BigNumber = _bignumber["default"].clone();
    BigNumber.DEBUG = true;
    var _default = exports["default"] = BigNumber;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js
var require_continued_fraction3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.best_r = best_r;
    var _bignumber = _interopRequireDefault(require_bignumber4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var MAX_INT = (1 << 31 >>> 0) - 1;
    function best_r(rawNumber) {
      var number = new _bignumber["default"](rawNumber);
      var a;
      var f;
      var fractions = [[new _bignumber["default"](0), new _bignumber["default"](1)], [new _bignumber["default"](1), new _bignumber["default"](0)]];
      var i = 2;
      while (true) {
        if (number.gt(MAX_INT)) {
          break;
        }
        a = number.integerValue(_bignumber["default"].ROUND_FLOOR);
        f = number.minus(a);
        var h = a.times(fractions[i - 1][0]).plus(fractions[i - 2][0]);
        var k = a.times(fractions[i - 1][1]).plus(fractions[i - 2][1]);
        if (h.gt(MAX_INT) || k.gt(MAX_INT)) {
          break;
        }
        fractions.push([h, k]);
        if (f.eq(0)) {
          break;
        }
        number = new _bignumber["default"](1).div(f);
        i += 1;
      }
      var _fractions = _slicedToArray(fractions[fractions.length - 1], 2), n = _fractions[0], d = _fractions[1];
      if (n.isZero() || d.isZero()) {
        throw new Error("Couldn't find approximation");
      }
      return [n.toNumber(), d.toNumber()];
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js
var require_liquidity_pool_asset3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolAsset = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _asset = require_asset3();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolAsset = exports.LiquidityPoolAsset = function() {
      function LiquidityPoolAsset2(assetA, assetB, fee) {
        _classCallCheck(this, LiquidityPoolAsset2);
        if (!assetA || !(assetA instanceof _asset.Asset)) {
          throw new Error("assetA is invalid");
        }
        if (!assetB || !(assetB instanceof _asset.Asset)) {
          throw new Error("assetB is invalid");
        }
        if (_asset.Asset.compare(assetA, assetB) !== -1) {
          throw new Error("Assets are not in lexicographic order");
        }
        if (!fee || fee !== _get_liquidity_pool_id.LiquidityPoolFeeV18) {
          throw new Error("fee is invalid");
        }
        this.assetA = assetA;
        this.assetB = assetB;
        this.fee = fee;
      }
      return _createClass(LiquidityPoolAsset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.ChangeTrustAsset` object for this liquidity pool asset.
           *
           * Note: To convert from an {@link Asset `Asset`} to `xdr.ChangeTrustAsset`
           * please refer to the
           * {@link Asset.toChangeTrustXDRObject `Asset.toChangeTrustXDRObject`} method.
           *
           * @returns {xdr.ChangeTrustAsset} XDR ChangeTrustAsset object.
           */
          function toXDRObject() {
            var lpConstantProductParamsXdr = new _xdr["default"].LiquidityPoolConstantProductParameters({
              assetA: this.assetA.toXDRObject(),
              assetB: this.assetB.toXDRObject(),
              fee: this.fee
            });
            var lpParamsXdr = new _xdr["default"].LiquidityPoolParameters("liquidityPoolConstantProduct", lpConstantProductParamsXdr);
            return new _xdr["default"].ChangeTrustAsset("assetTypePoolShare", lpParamsXdr);
          }
        )
        /**
         * @returns {LiquidityPoolParameters} Liquidity pool parameters.
         */
      }, {
        key: "getLiquidityPoolParameters",
        value: function getLiquidityPoolParameters() {
          return _objectSpread(_objectSpread({}, this), {}, {
            assetA: this.assetA,
            assetB: this.assetB,
            fee: this.fee
          });
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolAsset} other the LiquidityPoolAsset to compare
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(other) {
          return this.assetA.equals(other.assetA) && this.assetB.equals(other.assetB) && this.fee === other.fee;
        }
      }, {
        key: "toString",
        value: function toString() {
          var poolId = (0, _get_liquidity_pool_id.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
          return "liquidity_pool:".concat(poolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(ctAssetXdr) {
          var assetType = ctAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolParameters = ctAssetXdr.liquidityPool().constantProduct();
            return new this(_asset.Asset.fromOperation(liquidityPoolParameters.assetA()), _asset.Asset.fromOperation(liquidityPoolParameters.assetB()), liquidityPoolParameters.fee());
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/claimant.js
var require_claimant3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/claimant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Claimant = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Claimant = exports.Claimant = function() {
      function Claimant2(destination, predicate) {
        _classCallCheck(this, Claimant2);
        if (destination && !_strkey.StrKey.isValidEd25519PublicKey(destination)) {
          throw new Error("Destination is invalid");
        }
        this._destination = destination;
        if (!predicate) {
          this._predicate = _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        } else if (predicate instanceof _xdr["default"].ClaimPredicate) {
          this._predicate = predicate;
        } else {
          throw new Error("Predicate should be an xdr.ClaimPredicate");
        }
      }
      return _createClass(Claimant2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr object for this claimant.
           * @returns {xdr.Claimant} XDR Claimant object
           */
          function toXDRObject() {
            var claimant = new _xdr["default"].ClaimantV0({
              destination: _keypair.Keypair.fromPublicKey(this._destination).xdrAccountId(),
              predicate: this._predicate
            });
            return _xdr["default"].Claimant.claimantTypeV0(claimant);
          }
        )
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "destination",
        get: function get() {
          return this._destination;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
        /**
         * @type {xdr.ClaimPredicate}
         * @readonly
         */
      }, {
        key: "predicate",
        get: function get() {
          return this._predicate;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
      }], [{
        key: "predicateUnconditional",
        value: function predicateUnconditional() {
          return _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        }
        /**
         * Returns an `and` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateAnd",
        value: function predicateAnd(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateAnd([left, right]);
        }
        /**
         * Returns an `or` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateOr",
        value: function predicateOr(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateOr([left, right]);
        }
        /**
         * Returns a `not` claim predicate
         * @param {xdr.ClaimPredicate} predicate an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateNot",
        value: function predicateNot(predicate) {
          if (!(predicate instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateNot(predicate);
        }
        /**
         * Returns a `BeforeAbsoluteTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation is less than this (absolute)
         * Unix timestamp (expressed in seconds).
         *
         * @param {string} absBefore Unix epoch (in seconds) as a string
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeAbsoluteTime",
        value: function predicateBeforeAbsoluteTime(absBefore) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeAbsoluteTime(_xdr["default"].Int64.fromString(absBefore));
        }
        /**
         * Returns a `BeforeRelativeTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation plus this relative time delta
         * (in seconds) is less than the current time.
         *
         * @param {strings} seconds seconds since closeTime of the ledger in which the ClaimableBalanceEntry was created (as string)
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeRelativeTime",
        value: function predicateBeforeRelativeTime(seconds) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeRelativeTime(_xdr["default"].Int64.fromString(seconds));
        }
        /**
         * Returns a claimant object from its XDR object representation.
         * @param {xdr.Claimant} claimantXdr - The claimant xdr object.
         * @returns {Claimant}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(claimantXdr) {
          var value;
          switch (claimantXdr["switch"]()) {
            case _xdr["default"].ClaimantType.claimantTypeV0():
              value = claimantXdr.v0();
              return new this(_strkey.StrKey.encodeEd25519PublicKey(value.destination().ed25519()), value.predicate());
            default:
              throw new Error("Invalid claimant type: ".concat(claimantXdr["switch"]().name));
          }
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js
var require_liquidity_pool_id3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolId = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolId = exports.LiquidityPoolId = function() {
      function LiquidityPoolId2(liquidityPoolId) {
        _classCallCheck(this, LiquidityPoolId2);
        if (!liquidityPoolId) {
          throw new Error("liquidityPoolId cannot be empty");
        }
        if (!/^[a-f0-9]{64}$/.test(liquidityPoolId)) {
          throw new Error("Liquidity pool ID is not a valid hash");
        }
        this.liquidityPoolId = liquidityPoolId;
      }
      return _createClass(LiquidityPoolId2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.TrustLineAsset` object for this liquidity pool ID.
           *
           * Note: To convert from {@link Asset `Asset`} to `xdr.TrustLineAsset` please
           * refer to the
           * {@link Asset.toTrustLineXDRObject `Asset.toTrustLineXDRObject`} method.
           *
           * @returns {xdr.TrustLineAsset} XDR LiquidityPoolId object
           */
          function toXDRObject() {
            var xdrPoolId = _xdr["default"].PoolId.fromXDR(this.liquidityPoolId, "hex");
            return new _xdr["default"].TrustLineAsset("assetTypePoolShare", xdrPoolId);
          }
        )
        /**
         * @returns {string} Liquidity pool ID.
         */
      }, {
        key: "getLiquidityPoolId",
        value: function getLiquidityPoolId() {
          return String(this.liquidityPoolId);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolId} asset LiquidityPoolId to compare.
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.liquidityPoolId === asset.getLiquidityPoolId();
        }
      }, {
        key: "toString",
        value: function toString() {
          return "liquidity_pool:".concat(this.liquidityPoolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(tlAssetXdr) {
          var assetType = tlAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolId = tlAssetXdr.liquidityPoolId().toString("hex");
            return new this(liquidityPoolId);
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js
var require_manage_sell_offer3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageSellOffer = manageSellOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageSellOfferOp = new _xdr["default"].ManageSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageSellOffer(manageSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js
var require_create_passive_sell_offer3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createPassiveSellOffer = createPassiveSellOffer;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createPassiveSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      var createPassiveSellOfferOp = new _xdr["default"].CreatePassiveSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createPassiveSellOffer(createPassiveSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js
var require_decode_encode_muxed_account3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;
    exports.encodeMuxedAccount = encodeMuxedAccount;
    exports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;
    exports.extractBaseAddress = extractBaseAddress;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function decodeAddressToMuxedAccount(address) {
      if (_strkey.StrKey.isValidMed25519PublicKey(address)) {
        return _decodeAddressFullyToMuxedAccount(address);
      }
      return _xdr["default"].MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));
    }
    function encodeMuxedAccountToAddress(muxedAccount) {
      if (muxedAccount["switch"]().value === _xdr["default"].CryptoKeyType.keyTypeMuxedEd25519().value) {
        return _encodeMuxedAccountFullyToAddress(muxedAccount);
      }
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());
    }
    function encodeMuxedAccount(address, id) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {
        throw new Error("address should be a Stellar account ID (G...)");
      }
      if (typeof id !== "string") {
        throw new Error("id should be a string representing a number (uint64)");
      }
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromString(id),
        ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)
      }));
    }
    function extractBaseAddress(address) {
      if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
        return address;
      }
      if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {
        throw new TypeError("expected muxed account (M...), got ".concat(address));
      }
      var muxedAccount = decodeAddressToMuxedAccount(address);
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());
    }
    function _decodeAddressFullyToMuxedAccount(address) {
      var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromXDR(rawBytes.subarray(-8)),
        ed25519: rawBytes.subarray(0, -8)
      }));
    }
    function _encodeMuxedAccountFullyToAddress(muxedAccount) {
      if (muxedAccount["switch"]() === _xdr["default"].CryptoKeyType.keyTypeEd25519()) {
        return encodeMuxedAccountToAddress(muxedAccount);
      }
      var muxed = muxedAccount.med25519();
      return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR("raw")]));
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/account_merge.js
var require_account_merge3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/account_merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.accountMerge = accountMerge;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function accountMerge(opts) {
      var opAttributes = {};
      try {
        opAttributes.body = _xdr["default"].OperationBody.accountMerge((0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination));
      } catch (e) {
        throw new Error("destination is invalid");
      }
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js
var require_allow_trust3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.allowTrust = allowTrust;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function allowTrust(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.trustor)) {
        throw new Error("trustor is invalid");
      }
      var attributes = {};
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      if (opts.assetCode.length <= 4) {
        var code = opts.assetCode.padEnd(4, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum4(code);
      } else if (opts.assetCode.length <= 12) {
        var _code = opts.assetCode.padEnd(12, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum12(_code);
      } else {
        throw new Error("Asset code must be 12 characters at max.");
      }
      if (typeof opts.authorize === "boolean") {
        if (opts.authorize) {
          attributes.authorize = _xdr["default"].TrustLineFlags.authorizedFlag().value;
        } else {
          attributes.authorize = 0;
        }
      } else {
        attributes.authorize = opts.authorize;
      }
      var allowTrustOp = new _xdr["default"].AllowTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.allowTrust(allowTrustOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js
var require_bump_sequence3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bumpSequence = bumpSequence;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber4());
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function bumpSequence(opts) {
      var attributes = {};
      if (typeof opts.bumpTo !== "string") {
        throw new Error("bumpTo must be a string");
      }
      try {
        new _bignumber["default"](opts.bumpTo);
      } catch (e) {
        throw new Error("bumpTo must be a stringified number");
      }
      attributes.bumpTo = _jsXdr.Hyper.fromString(opts.bumpTo);
      var bumpSequenceOp = new _xdr["default"].BumpSequenceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.bumpSequence(bumpSequenceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/change_trust.js
var require_change_trust3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/change_trust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.changeTrust = changeTrust;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber4());
    var _xdr = _interopRequireDefault(require_xdr4());
    var _asset = require_asset3();
    var _liquidity_pool_asset = require_liquidity_pool_asset3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var MAX_INT64 = "9223372036854775807";
    function changeTrust(opts) {
      var attributes = {};
      if (opts.asset instanceof _asset.Asset) {
        attributes.line = opts.asset.toChangeTrustXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_asset.LiquidityPoolAsset) {
        attributes.line = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be Asset or LiquidityPoolAsset");
      }
      if (opts.limit !== void 0 && !this.isValidAmount(opts.limit, true)) {
        throw new TypeError(this.constructAmountRequirementsError("limit"));
      }
      if (opts.limit) {
        attributes.limit = this._toXDRAmount(opts.limit);
      } else {
        attributes.limit = _jsXdr.Hyper.fromString(new _bignumber["default"](MAX_INT64).toString());
      }
      if (opts.source) {
        attributes.source = opts.source.masterKeypair;
      }
      var changeTrustOP = new _xdr["default"].ChangeTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.changeTrust(changeTrustOP);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/create_account.js
var require_create_account3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/create_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createAccount = createAccount;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createAccount(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.destination)) {
        throw new Error("destination is invalid");
      }
      if (!this.isValidAmount(opts.startingBalance, true)) {
        throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
      }
      var attributes = {};
      attributes.destination = _keypair.Keypair.fromPublicKey(opts.destination).xdrAccountId();
      attributes.startingBalance = this._toXDRAmount(opts.startingBalance);
      var createAccountOp = new _xdr["default"].CreateAccountOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createAccount(createAccountOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js
var require_create_claimable_balance3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createClaimableBalance = createClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _asset = require_asset3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createClaimableBalance(opts) {
      if (!(opts.asset instanceof _asset.Asset)) {
        throw new Error("must provide an asset for create claimable balance operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      if (!Array.isArray(opts.claimants) || opts.claimants.length === 0) {
        throw new Error("must provide at least one claimant");
      }
      var attributes = {};
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.claimants = Object.values(opts.claimants).map(function(c) {
        return c.toXDRObject();
      });
      var createClaimableBalanceOp = new _xdr["default"].CreateClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createClaimableBalance(createClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js
var require_claim_claimable_balance3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.claimClaimableBalance = claimClaimableBalance;
    exports.validateClaimableBalanceId = validateClaimableBalanceId;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function claimClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      validateClaimableBalanceId(opts.balanceId);
      var attributes = {};
      attributes.balanceId = _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex");
      var claimClaimableBalanceOp = new _xdr["default"].ClaimClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.claimClaimableBalance(claimClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function validateClaimableBalanceId(balanceId) {
      if (typeof balanceId !== "string" || balanceId.length !== 8 + 64) {
        throw new Error("must provide a valid claimable balance id");
      }
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js
var require_clawback_claimable_balance3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawbackClaimableBalance = clawbackClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _claim_claimable_balance = require_claim_claimable_balance3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawbackClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _claim_claimable_balance.validateClaimableBalanceId)(opts.balanceId);
      var attributes = {
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      };
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawbackClaimableBalance(new _xdr["default"].ClawbackClaimableBalanceOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/inflation.js
var require_inflation3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/inflation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inflation = inflation;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function inflation() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.inflation();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_data.js
var require_manage_data3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageData = manageData;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageData(opts) {
      var attributes = {};
      if (!(typeof opts.name === "string" && opts.name.length <= 64)) {
        throw new Error("name must be a string, up to 64 characters");
      }
      attributes.dataName = opts.name;
      if (typeof opts.value !== "string" && !Buffer.isBuffer(opts.value) && opts.value !== null) {
        throw new Error("value must be a string, Buffer or null");
      }
      if (typeof opts.value === "string") {
        attributes.dataValue = Buffer.from(opts.value);
      } else {
        attributes.dataValue = opts.value;
      }
      if (attributes.dataValue !== null && attributes.dataValue.length > 64) {
        throw new Error("value cannot be longer that 64 bytes");
      }
      var manageDataOp = new _xdr["default"].ManageDataOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageData(manageDataOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js
var require_manage_buy_offer3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageBuyOffer = manageBuyOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageBuyOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.buyAmount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
      }
      attributes.buyAmount = this._toXDRAmount(opts.buyAmount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageBuyOfferOp = new _xdr["default"].ManageBuyOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageBuyOffer(manageBuyOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js
var require_path_payment_strict_receive3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictReceive = pathPaymentStrictReceive;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictReceive(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendMax):
          throw new TypeError(this.constructAmountRequirementsError("sendMax"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destAmount):
          throw new TypeError(this.constructAmountRequirementsError("destAmount"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendMax = this._toXDRAmount(opts.sendMax);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destAmount = this._toXDRAmount(opts.destAmount);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictReceiveOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictReceive(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js
var require_path_payment_strict_send3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictSend = pathPaymentStrictSend;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictSend(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendAmount):
          throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destMin):
          throw new TypeError(this.constructAmountRequirementsError("destMin"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendAmount = this._toXDRAmount(opts.sendAmount);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destMin = this._toXDRAmount(opts.destMin);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictSendOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictSend(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/payment.js
var require_payment3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/payment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.payment = payment;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function payment(opts) {
      if (!opts.asset) {
        throw new Error("Must provide an asset for a payment operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      var attributes = {};
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      var paymentOp = new _xdr["default"].PaymentOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.payment(paymentOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/set_options.js
var require_set_options3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/set_options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setOptions = setOptions;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function weightCheckFunction(value, name) {
      if (value >= 0 && value <= 255) {
        return true;
      }
      throw new Error("".concat(name, " value must be between 0 and 255"));
    }
    function setOptions(opts) {
      var attributes = {};
      if (opts.inflationDest) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.inflationDest)) {
          throw new Error("inflationDest is invalid");
        }
        attributes.inflationDest = _keypair.Keypair.fromPublicKey(opts.inflationDest).xdrAccountId();
      }
      attributes.clearFlags = this._checkUnsignedIntValue("clearFlags", opts.clearFlags);
      attributes.setFlags = this._checkUnsignedIntValue("setFlags", opts.setFlags);
      attributes.masterWeight = this._checkUnsignedIntValue("masterWeight", opts.masterWeight, weightCheckFunction);
      attributes.lowThreshold = this._checkUnsignedIntValue("lowThreshold", opts.lowThreshold, weightCheckFunction);
      attributes.medThreshold = this._checkUnsignedIntValue("medThreshold", opts.medThreshold, weightCheckFunction);
      attributes.highThreshold = this._checkUnsignedIntValue("highThreshold", opts.highThreshold, weightCheckFunction);
      if (opts.homeDomain !== void 0 && typeof opts.homeDomain !== "string") {
        throw new TypeError("homeDomain argument must be of type String");
      }
      attributes.homeDomain = opts.homeDomain;
      if (opts.signer) {
        var weight = this._checkUnsignedIntValue("signer.weight", opts.signer.weight, weightCheckFunction);
        var key;
        var setValues = 0;
        if (opts.signer.ed25519PublicKey) {
          if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
            throw new Error("signer.ed25519PublicKey is invalid.");
          }
          var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
          key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
          setValues += 1;
        }
        if (opts.signer.preAuthTx) {
          if (typeof opts.signer.preAuthTx === "string") {
            opts.signer.preAuthTx = Buffer.from(opts.signer.preAuthTx, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.preAuthTx) && opts.signer.preAuthTx.length === 32)) {
            throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(opts.signer.preAuthTx);
          setValues += 1;
        }
        if (opts.signer.sha256Hash) {
          if (typeof opts.signer.sha256Hash === "string") {
            opts.signer.sha256Hash = Buffer.from(opts.signer.sha256Hash, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.sha256Hash) && opts.signer.sha256Hash.length === 32)) {
            throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypeHashX(opts.signer.sha256Hash);
          setValues += 1;
        }
        if (opts.signer.ed25519SignedPayload) {
          if (!_strkey.StrKey.isValidSignedPayload(opts.signer.ed25519SignedPayload)) {
            throw new Error("signer.ed25519SignedPayload is invalid.");
          }
          var _rawKey = _strkey.StrKey.decodeSignedPayload(opts.signer.ed25519SignedPayload);
          var signedPayloadXdr = _xdr["default"].SignerKeyEd25519SignedPayload.fromXDR(_rawKey);
          key = _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload(signedPayloadXdr);
          setValues += 1;
        }
        if (setValues !== 1) {
          throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
        }
        attributes.signer = new _xdr["default"].Signer({
          key,
          weight
        });
      }
      var setOptionsOp = new _xdr["default"].SetOptionsOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.setOptions(setOptionsOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js
var require_begin_sponsoring_future_reserves3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.beginSponsoringFutureReserves = beginSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _strkey = require_strkey3();
    var _keypair = require_keypair3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function beginSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.sponsoredId)) {
        throw new Error("sponsoredId is invalid");
      }
      var op = new _xdr["default"].BeginSponsoringFutureReservesOp({
        sponsoredId: _keypair.Keypair.fromPublicKey(opts.sponsoredId).xdrAccountId()
      });
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.beginSponsoringFutureReserves(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js
var require_end_sponsoring_future_reserves3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.endSponsoringFutureReserves = endSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function endSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.endSponsoringFutureReserves();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js
var require_revoke_sponsorship3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.revokeAccountSponsorship = revokeAccountSponsorship;
    exports.revokeClaimableBalanceSponsorship = revokeClaimableBalanceSponsorship;
    exports.revokeDataSponsorship = revokeDataSponsorship;
    exports.revokeLiquidityPoolSponsorship = revokeLiquidityPoolSponsorship;
    exports.revokeOfferSponsorship = revokeOfferSponsorship;
    exports.revokeSignerSponsorship = revokeSignerSponsorship;
    exports.revokeTrustlineSponsorship = revokeTrustlineSponsorship;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _strkey = require_strkey3();
    var _keypair = require_keypair3();
    var _asset = require_asset3();
    var _liquidity_pool_id = require_liquidity_pool_id3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function revokeAccountSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.account(new _xdr["default"].LedgerKeyAccount({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId()
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeTrustlineSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var asset;
      if (opts.asset instanceof _asset.Asset) {
        asset = opts.asset.toTrustLineXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_id.LiquidityPoolId) {
        asset = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be an Asset or LiquidityPoolId");
      }
      var ledgerKey = _xdr["default"].LedgerKey.trustline(new _xdr["default"].LedgerKeyTrustLine({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        asset
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeOfferSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.seller)) {
        throw new Error("seller is invalid");
      }
      if (typeof opts.offerId !== "string") {
        throw new Error("offerId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.offer(new _xdr["default"].LedgerKeyOffer({
        sellerId: _keypair.Keypair.fromPublicKey(opts.seller).xdrAccountId(),
        offerId: _xdr["default"].Int64.fromString(opts.offerId)
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeDataSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      if (typeof opts.name !== "string" || opts.name.length > 64) {
        throw new Error("name must be a string, up to 64 characters");
      }
      var ledgerKey = _xdr["default"].LedgerKey.data(new _xdr["default"].LedgerKeyData({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        dataName: opts.name
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeClaimableBalanceSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.balanceId !== "string") {
        throw new Error("balanceId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.claimableBalance(new _xdr["default"].LedgerKeyClaimableBalance({
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeLiquidityPoolSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.liquidityPoolId !== "string") {
        throw new Error("liquidityPoolId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.liquidityPool(new _xdr["default"].LedgerKeyLiquidityPool({
        liquidityPoolId: _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {
        body: _xdr["default"].OperationBody.revokeSponsorship(op)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeSignerSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var key;
      if (opts.signer.ed25519PublicKey) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
          throw new Error("signer.ed25519PublicKey is invalid.");
        }
        var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
        key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
      } else if (opts.signer.preAuthTx) {
        var buffer;
        if (typeof opts.signer.preAuthTx === "string") {
          buffer = Buffer.from(opts.signer.preAuthTx, "hex");
        } else {
          buffer = opts.signer.preAuthTx;
        }
        if (!(Buffer.isBuffer(buffer) && buffer.length === 32)) {
          throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(buffer);
      } else if (opts.signer.sha256Hash) {
        var _buffer;
        if (typeof opts.signer.sha256Hash === "string") {
          _buffer = Buffer.from(opts.signer.sha256Hash, "hex");
        } else {
          _buffer = opts.signer.sha256Hash;
        }
        if (!(Buffer.isBuffer(_buffer) && _buffer.length === 32)) {
          throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypeHashX(_buffer);
      } else {
        throw new Error("signer is invalid");
      }
      var signer = new _xdr["default"].RevokeSponsorshipOpSigner({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        signerKey: key
      });
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipSigner(signer);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback.js
var require_clawback3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawback = clawback;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawback(opts) {
      var attributes = {};
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.asset = opts.asset.toXDRObject();
      try {
        attributes.from = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.from);
      } catch (e) {
        throw new Error("from address is invalid");
      }
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawback(new _xdr["default"].ClawbackOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js
var require_set_trustline_flags3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setTrustLineFlags = setTrustLineFlags;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function setTrustLineFlags() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (_typeof(opts.flags) !== "object" || Object.keys(opts.flags).length === 0) {
        throw new Error("opts.flags must be a map of boolean flags to modify");
      }
      var mapping = {
        authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
        authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
        clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
      };
      var clearFlag = 0;
      var setFlag = 0;
      Object.keys(opts.flags).forEach(function(flagName) {
        if (!Object.prototype.hasOwnProperty.call(mapping, flagName)) {
          throw new Error("unsupported flag name specified: ".concat(flagName));
        }
        var flagValue = opts.flags[flagName];
        var bit = mapping[flagName].value;
        if (flagValue === true) {
          setFlag |= bit;
        } else if (flagValue === false) {
          clearFlag |= bit;
        }
      });
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      attributes.asset = opts.asset.toXDRObject();
      attributes.clearFlags = clearFlag;
      attributes.setFlags = setFlag;
      var opAttributes = {
        body: _xdr["default"].OperationBody.setTrustLineFlags(new _xdr["default"].SetTrustLineFlagsOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js
var require_liquidity_pool_deposit3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolDeposit = liquidityPoolDeposit;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolDeposit() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var liquidityPoolId = opts.liquidityPoolId, maxAmountA = opts.maxAmountA, maxAmountB = opts.maxAmountB, minPrice = opts.minPrice, maxPrice = opts.maxPrice;
      var attributes = {};
      if (!liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(liquidityPoolId, "hex");
      if (!this.isValidAmount(maxAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
      }
      attributes.maxAmountA = this._toXDRAmount(maxAmountA);
      if (!this.isValidAmount(maxAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
      }
      attributes.maxAmountB = this._toXDRAmount(maxAmountB);
      if (minPrice === void 0) {
        throw new TypeError("minPrice argument is required");
      }
      attributes.minPrice = this._toXDRPrice(minPrice);
      if (maxPrice === void 0) {
        throw new TypeError("maxPrice argument is required");
      }
      attributes.maxPrice = this._toXDRPrice(maxPrice);
      var liquidityPoolDepositOp = new _xdr["default"].LiquidityPoolDepositOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolDeposit(liquidityPoolDepositOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js
var require_liquidity_pool_withdraw3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolWithdraw = liquidityPoolWithdraw;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolWithdraw() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (!opts.liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex");
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (!this.isValidAmount(opts.minAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
      }
      attributes.minAmountA = this._toXDRAmount(opts.minAmountA);
      if (!this.isValidAmount(opts.minAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
      }
      attributes.minAmountB = this._toXDRAmount(opts.minAmountB);
      var liquidityPoolWithdrawOp = new _xdr["default"].LiquidityPoolWithdrawOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolWithdraw(liquidityPoolWithdrawOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/address.js
var require_address3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Address = void 0;
    var _strkey = require_strkey3();
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Address2 = exports.Address = function() {
      function Address3(address) {
        _classCallCheck(this, Address3);
        if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
          this._type = "account";
          this._key = _strkey.StrKey.decodeEd25519PublicKey(address);
        } else if (_strkey.StrKey.isValidContract(address)) {
          this._type = "contract";
          this._key = _strkey.StrKey.decodeContract(address);
        } else {
          throw new Error("Unsupported address type: ".concat(address));
        }
      }
      return _createClass(Address3, [{
        key: "toString",
        value: (
          /**
           * Serialize an address to string.
           *
           * @returns {string}
           */
          function toString() {
            switch (this._type) {
              case "account":
                return _strkey.StrKey.encodeEd25519PublicKey(this._key);
              case "contract":
                return _strkey.StrKey.encodeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          }
        )
        /**
         * Convert this Address to an xdr.ScVal type.
         *
         * @returns {xdr.ScVal}
         */
      }, {
        key: "toScVal",
        value: function toScVal() {
          return _xdr["default"].ScVal.scvAddress(this.toScAddress());
        }
        /**
         * Convert this Address to an xdr.ScAddress type.
         *
         * @returns {xdr.ScAddress}
         */
      }, {
        key: "toScAddress",
        value: function toScAddress() {
          switch (this._type) {
            case "account":
              return _xdr["default"].ScAddress.scAddressTypeAccount(_xdr["default"].PublicKey.publicKeyTypeEd25519(this._key));
            case "contract":
              return _xdr["default"].ScAddress.scAddressTypeContract(this._key);
            default:
              throw new Error("Unsupported address type");
          }
        }
        /**
         * Return the raw public key bytes for this address.
         *
         * @returns {Buffer}
         */
      }, {
        key: "toBuffer",
        value: function toBuffer() {
          return this._key;
        }
      }], [{
        key: "fromString",
        value: function fromString(address) {
          return new Address3(address);
        }
        /**
         * Creates a new account Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "account",
        value: function account(buffer) {
          return new Address3(_strkey.StrKey.encodeEd25519PublicKey(buffer));
        }
        /**
         * Creates a new contract Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "contract",
        value: function contract(buffer) {
          return new Address3(_strkey.StrKey.encodeContract(buffer));
        }
        /**
         * Convert this from an xdr.ScVal type
         *
         * @param {xdr.ScVal} scVal - The xdr.ScVal type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScVal",
        value: function fromScVal(scVal) {
          return Address3.fromScAddress(scVal.address());
        }
        /**
         * Convert this from an xdr.ScAddress type
         *
         * @param {xdr.ScAddress} scAddress - The xdr.ScAddress type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScAddress",
        value: function fromScAddress(scAddress) {
          switch (scAddress["switch"]().value) {
            case _xdr["default"].ScAddressType.scAddressTypeAccount().value:
              return Address3.account(scAddress.accountId().ed25519());
            case _xdr["default"].ScAddressType.scAddressTypeContract().value:
              return Address3.contract(scAddress.contractId());
            default:
              throw new Error("Unsupported address type");
          }
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js
var require_invoke_host_function3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createCustomContract = createCustomContract;
    exports.createStellarAssetContract = createStellarAssetContract;
    exports.invokeContractFunction = invokeContractFunction;
    exports.invokeHostFunction = invokeHostFunction;
    exports.uploadContractWasm = uploadContractWasm;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _address = require_address3();
    var _asset = require_asset3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function invokeHostFunction(opts) {
      if (!opts.func) {
        throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(opts), ")"));
      }
      var invokeHostFunctionOp = new _xdr["default"].InvokeHostFunctionOp({
        hostFunction: opts.func,
        auth: opts.auth || []
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.invokeHostFunction(invokeHostFunctionOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function invokeContractFunction(opts) {
      var c = new _address.Address(opts.contract);
      if (c._type !== "contract") {
        throw new TypeError("expected contract strkey instance, got ".concat(c));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeInvokeContract(new _xdr["default"].InvokeContractArgs({
          contractAddress: c.toScAddress(),
          functionName: opts["function"],
          args: opts.args
        }))
      });
    }
    function createCustomContract(opts) {
      var _opts$constructorArgs;
      var salt = Buffer.from(opts.salt || getSalty());
      if (!opts.wasmHash || opts.wasmHash.length !== 32) {
        throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(opts.wasmHash));
      }
      if (salt.length !== 32) {
        throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(opts.wasmHash));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContractV2(new _xdr["default"].CreateContractArgsV2({
          executable: _xdr["default"].ContractExecutable.contractExecutableWasm(Buffer.from(opts.wasmHash)),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAddress(new _xdr["default"].ContractIdPreimageFromAddress({
            address: opts.address.toScAddress(),
            salt
          })),
          constructorArgs: (_opts$constructorArgs = opts.constructorArgs) !== null && _opts$constructorArgs !== void 0 ? _opts$constructorArgs : []
        }))
      });
    }
    function createStellarAssetContract(opts) {
      var asset = opts.asset;
      if (typeof asset === "string") {
        var _asset$split = asset.split(":"), _asset$split2 = _slicedToArray(_asset$split, 2), code = _asset$split2[0], issuer = _asset$split2[1];
        asset = new _asset.Asset(code, issuer);
      }
      if (!(asset instanceof _asset.Asset)) {
        throw new TypeError("expected Asset in 'opts.asset', got ".concat(asset));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContract(new _xdr["default"].CreateContractArgs({
          executable: _xdr["default"].ContractExecutable.contractExecutableStellarAsset(),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(asset.toXDRObject())
        }))
      });
    }
    function uploadContractWasm(opts) {
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeUploadContractWasm(
          Buffer.from(opts.wasm)
          // coalesce so we can drop `Buffer` someday
        )
      });
    }
    function getSalty() {
      return _keypair.Keypair.random().xdrPublicKey().value();
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js
var require_extend_footprint_ttl3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extendFootprintTtl = extendFootprintTtl;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function extendFootprintTtl(opts) {
      var _opts$extendTo;
      if (((_opts$extendTo = opts.extendTo) !== null && _opts$extendTo !== void 0 ? _opts$extendTo : -1) <= 0) {
        throw new RangeError("extendTo has to be positive");
      }
      var extendFootprintOp = new _xdr["default"].ExtendFootprintTtlOp({
        ext: new _xdr["default"].ExtensionPoint(0),
        extendTo: opts.extendTo
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.extendFootprintTtl(extendFootprintOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js
var require_restore_footprint3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.restoreFootprint = restoreFootprint;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function restoreFootprint() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var op = new _xdr["default"].RestoreFootprintOp({
        ext: new _xdr["default"].ExtensionPoint(0)
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.restoreFootprint(op)
      };
      this.setSourceAccount(opAttributes, opts !== null && opts !== void 0 ? opts : {});
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/index.js
var require_operations3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operations/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "accountMerge", {
      enumerable: true,
      get: function get() {
        return _account_merge.accountMerge;
      }
    });
    Object.defineProperty(exports, "allowTrust", {
      enumerable: true,
      get: function get() {
        return _allow_trust.allowTrust;
      }
    });
    Object.defineProperty(exports, "beginSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _begin_sponsoring_future_reserves.beginSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "bumpSequence", {
      enumerable: true,
      get: function get() {
        return _bump_sequence.bumpSequence;
      }
    });
    Object.defineProperty(exports, "changeTrust", {
      enumerable: true,
      get: function get() {
        return _change_trust.changeTrust;
      }
    });
    Object.defineProperty(exports, "claimClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _claim_claimable_balance.claimClaimableBalance;
      }
    });
    Object.defineProperty(exports, "clawback", {
      enumerable: true,
      get: function get() {
        return _clawback.clawback;
      }
    });
    Object.defineProperty(exports, "clawbackClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _clawback_claimable_balance.clawbackClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createAccount", {
      enumerable: true,
      get: function get() {
        return _create_account.createAccount;
      }
    });
    Object.defineProperty(exports, "createClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _create_claimable_balance.createClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createCustomContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createCustomContract;
      }
    });
    Object.defineProperty(exports, "createPassiveSellOffer", {
      enumerable: true,
      get: function get() {
        return _create_passive_sell_offer.createPassiveSellOffer;
      }
    });
    Object.defineProperty(exports, "createStellarAssetContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createStellarAssetContract;
      }
    });
    Object.defineProperty(exports, "endSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _end_sponsoring_future_reserves.endSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "extendFootprintTtl", {
      enumerable: true,
      get: function get() {
        return _extend_footprint_ttl.extendFootprintTtl;
      }
    });
    Object.defineProperty(exports, "inflation", {
      enumerable: true,
      get: function get() {
        return _inflation.inflation;
      }
    });
    Object.defineProperty(exports, "invokeContractFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeContractFunction;
      }
    });
    Object.defineProperty(exports, "invokeHostFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeHostFunction;
      }
    });
    Object.defineProperty(exports, "liquidityPoolDeposit", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_deposit.liquidityPoolDeposit;
      }
    });
    Object.defineProperty(exports, "liquidityPoolWithdraw", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_withdraw.liquidityPoolWithdraw;
      }
    });
    Object.defineProperty(exports, "manageBuyOffer", {
      enumerable: true,
      get: function get() {
        return _manage_buy_offer.manageBuyOffer;
      }
    });
    Object.defineProperty(exports, "manageData", {
      enumerable: true,
      get: function get() {
        return _manage_data.manageData;
      }
    });
    Object.defineProperty(exports, "manageSellOffer", {
      enumerable: true,
      get: function get() {
        return _manage_sell_offer.manageSellOffer;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictReceive", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_receive.pathPaymentStrictReceive;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictSend", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_send.pathPaymentStrictSend;
      }
    });
    Object.defineProperty(exports, "payment", {
      enumerable: true,
      get: function get() {
        return _payment.payment;
      }
    });
    Object.defineProperty(exports, "restoreFootprint", {
      enumerable: true,
      get: function get() {
        return _restore_footprint.restoreFootprint;
      }
    });
    Object.defineProperty(exports, "revokeAccountSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeAccountSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeClaimableBalanceSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeClaimableBalanceSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeDataSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeDataSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeLiquidityPoolSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeLiquidityPoolSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeOfferSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeOfferSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeSignerSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeSignerSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeTrustlineSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeTrustlineSponsorship;
      }
    });
    Object.defineProperty(exports, "setOptions", {
      enumerable: true,
      get: function get() {
        return _set_options.setOptions;
      }
    });
    Object.defineProperty(exports, "setTrustLineFlags", {
      enumerable: true,
      get: function get() {
        return _set_trustline_flags.setTrustLineFlags;
      }
    });
    Object.defineProperty(exports, "uploadContractWasm", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.uploadContractWasm;
      }
    });
    var _manage_sell_offer = require_manage_sell_offer3();
    var _create_passive_sell_offer = require_create_passive_sell_offer3();
    var _account_merge = require_account_merge3();
    var _allow_trust = require_allow_trust3();
    var _bump_sequence = require_bump_sequence3();
    var _change_trust = require_change_trust3();
    var _create_account = require_create_account3();
    var _create_claimable_balance = require_create_claimable_balance3();
    var _claim_claimable_balance = require_claim_claimable_balance3();
    var _clawback_claimable_balance = require_clawback_claimable_balance3();
    var _inflation = require_inflation3();
    var _manage_data = require_manage_data3();
    var _manage_buy_offer = require_manage_buy_offer3();
    var _path_payment_strict_receive = require_path_payment_strict_receive3();
    var _path_payment_strict_send = require_path_payment_strict_send3();
    var _payment = require_payment3();
    var _set_options = require_set_options3();
    var _begin_sponsoring_future_reserves = require_begin_sponsoring_future_reserves3();
    var _end_sponsoring_future_reserves = require_end_sponsoring_future_reserves3();
    var _revoke_sponsorship = require_revoke_sponsorship3();
    var _clawback = require_clawback3();
    var _set_trustline_flags = require_set_trustline_flags3();
    var _liquidity_pool_deposit = require_liquidity_pool_deposit3();
    var _liquidity_pool_withdraw = require_liquidity_pool_withdraw3();
    var _invoke_host_function = require_invoke_host_function3();
    var _extend_footprint_ttl = require_extend_footprint_ttl3();
    var _restore_footprint = require_restore_footprint3();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operation.js
var require_operation3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Operation = exports.AuthRevocableFlag = exports.AuthRequiredFlag = exports.AuthImmutableFlag = exports.AuthClawbackEnabledFlag = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber4());
    var _util = require_util3();
    var _continued_fraction = require_continued_fraction3();
    var _asset = require_asset3();
    var _liquidity_pool_asset = require_liquidity_pool_asset3();
    var _claimant = require_claimant3();
    var _strkey = require_strkey3();
    var _liquidity_pool_id = require_liquidity_pool_id3();
    var _xdr = _interopRequireDefault(require_xdr4());
    var ops = _interopRequireWildcard(require_operations3());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var ONE = 1e7;
    var MAX_INT64 = "9223372036854775807";
    var AuthRequiredFlag = exports.AuthRequiredFlag = 1 << 0;
    var AuthRevocableFlag = exports.AuthRevocableFlag = 1 << 1;
    var AuthImmutableFlag = exports.AuthImmutableFlag = 1 << 2;
    var AuthClawbackEnabledFlag = exports.AuthClawbackEnabledFlag = 1 << 3;
    var Operation2 = exports.Operation = function() {
      function Operation3() {
        _classCallCheck(this, Operation3);
      }
      return _createClass(Operation3, null, [{
        key: "setSourceAccount",
        value: function setSourceAccount(opAttributes, opts) {
          if (opts.source) {
            try {
              opAttributes.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.source);
            } catch (e) {
              throw new Error("Source address is invalid");
            }
          }
        }
        /**
         * Deconstructs the raw XDR operation object into the structured object that
         * was used to create the operation (i.e. the `opts` parameter to most ops).
         *
         * @param {xdr.Operation}   operation - An XDR Operation.
         * @return {Operation}
         */
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(operation) {
          var result = {};
          if (operation.sourceAccount()) {
            result.source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(operation.sourceAccount());
          }
          var attrs = operation.body().value();
          var operationName = operation.body()["switch"]().name;
          switch (operationName) {
            case "createAccount": {
              result.type = "createAccount";
              result.destination = accountIdtoAddress(attrs.destination());
              result.startingBalance = this._fromXDRAmount(attrs.startingBalance());
              break;
            }
            case "payment": {
              result.type = "payment";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              break;
            }
            case "pathPaymentStrictReceive": {
              result.type = "pathPaymentStrictReceive";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendMax = this._fromXDRAmount(attrs.sendMax());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destAmount = this._fromXDRAmount(attrs.destAmount());
              result.path = [];
              var path = attrs.path();
              Object.keys(path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(path[pathKey]));
              });
              break;
            }
            case "pathPaymentStrictSend": {
              result.type = "pathPaymentStrictSend";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendAmount = this._fromXDRAmount(attrs.sendAmount());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destMin = this._fromXDRAmount(attrs.destMin());
              result.path = [];
              var _path = attrs.path();
              Object.keys(_path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(_path[pathKey]));
              });
              break;
            }
            case "changeTrust": {
              result.type = "changeTrust";
              switch (attrs.line()["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.line = _liquidity_pool_asset.LiquidityPoolAsset.fromOperation(attrs.line());
                  break;
                default:
                  result.line = _asset.Asset.fromOperation(attrs.line());
                  break;
              }
              result.limit = this._fromXDRAmount(attrs.limit());
              break;
            }
            case "allowTrust": {
              result.type = "allowTrust";
              result.trustor = accountIdtoAddress(attrs.trustor());
              result.assetCode = attrs.asset().value().toString();
              result.assetCode = (0, _util.trimEnd)(result.assetCode, "\0");
              result.authorize = attrs.authorize();
              break;
            }
            case "setOptions": {
              result.type = "setOptions";
              if (attrs.inflationDest()) {
                result.inflationDest = accountIdtoAddress(attrs.inflationDest());
              }
              result.clearFlags = attrs.clearFlags();
              result.setFlags = attrs.setFlags();
              result.masterWeight = attrs.masterWeight();
              result.lowThreshold = attrs.lowThreshold();
              result.medThreshold = attrs.medThreshold();
              result.highThreshold = attrs.highThreshold();
              result.homeDomain = attrs.homeDomain() !== void 0 ? attrs.homeDomain().toString("ascii") : void 0;
              if (attrs.signer()) {
                var signer = {};
                var arm = attrs.signer().key().arm();
                if (arm === "ed25519") {
                  signer.ed25519PublicKey = accountIdtoAddress(attrs.signer().key());
                } else if (arm === "preAuthTx") {
                  signer.preAuthTx = attrs.signer().key().preAuthTx();
                } else if (arm === "hashX") {
                  signer.sha256Hash = attrs.signer().key().hashX();
                } else if (arm === "ed25519SignedPayload") {
                  var signedPayload = attrs.signer().key().ed25519SignedPayload();
                  signer.ed25519SignedPayload = _strkey.StrKey.encodeSignedPayload(signedPayload.toXDR());
                }
                signer.weight = attrs.signer().weight();
                result.signer = signer;
              }
              break;
            }
            case "manageOffer":
            case "manageSellOffer": {
              result.type = "manageSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "manageBuyOffer": {
              result.type = "manageBuyOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.buyAmount = this._fromXDRAmount(attrs.buyAmount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "createPassiveOffer":
            case "createPassiveSellOffer": {
              result.type = "createPassiveSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              break;
            }
            case "accountMerge": {
              result.type = "accountMerge";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs);
              break;
            }
            case "manageData": {
              result.type = "manageData";
              result.name = attrs.dataName().toString("ascii");
              result.value = attrs.dataValue();
              break;
            }
            case "inflation": {
              result.type = "inflation";
              break;
            }
            case "bumpSequence": {
              result.type = "bumpSequence";
              result.bumpTo = attrs.bumpTo().toString();
              break;
            }
            case "createClaimableBalance": {
              result.type = "createClaimableBalance";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.claimants = [];
              attrs.claimants().forEach(function(claimant) {
                result.claimants.push(_claimant.Claimant.fromXDR(claimant));
              });
              break;
            }
            case "claimClaimableBalance": {
              result.type = "claimClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "beginSponsoringFutureReserves": {
              result.type = "beginSponsoringFutureReserves";
              result.sponsoredId = accountIdtoAddress(attrs.sponsoredId());
              break;
            }
            case "endSponsoringFutureReserves": {
              result.type = "endSponsoringFutureReserves";
              break;
            }
            case "revokeSponsorship": {
              extractRevokeSponshipDetails(attrs, result);
              break;
            }
            case "clawback": {
              result.type = "clawback";
              result.amount = this._fromXDRAmount(attrs.amount());
              result.from = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.from());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              break;
            }
            case "clawbackClaimableBalance": {
              result.type = "clawbackClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "setTrustLineFlags": {
              result.type = "setTrustLineFlags";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.trustor = accountIdtoAddress(attrs.trustor());
              var clears = attrs.clearFlags();
              var sets = attrs.setFlags();
              var mapping = {
                authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
                authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
              };
              var getFlagValue = function getFlagValue2(key) {
                var bit = mapping[key].value;
                if (sets & bit) {
                  return true;
                }
                if (clears & bit) {
                  return false;
                }
                return void 0;
              };
              result.flags = {};
              Object.keys(mapping).forEach(function(flagName) {
                result.flags[flagName] = getFlagValue(flagName);
              });
              break;
            }
            case "liquidityPoolDeposit": {
              result.type = "liquidityPoolDeposit";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.maxAmountA = this._fromXDRAmount(attrs.maxAmountA());
              result.maxAmountB = this._fromXDRAmount(attrs.maxAmountB());
              result.minPrice = this._fromXDRPrice(attrs.minPrice());
              result.maxPrice = this._fromXDRPrice(attrs.maxPrice());
              break;
            }
            case "liquidityPoolWithdraw": {
              result.type = "liquidityPoolWithdraw";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.amount = this._fromXDRAmount(attrs.amount());
              result.minAmountA = this._fromXDRAmount(attrs.minAmountA());
              result.minAmountB = this._fromXDRAmount(attrs.minAmountB());
              break;
            }
            case "invokeHostFunction": {
              var _attrs$auth;
              result.type = "invokeHostFunction";
              result.func = attrs.hostFunction();
              result.auth = (_attrs$auth = attrs.auth()) !== null && _attrs$auth !== void 0 ? _attrs$auth : [];
              break;
            }
            case "extendFootprintTtl": {
              result.type = "extendFootprintTtl";
              result.extendTo = attrs.extendTo();
              break;
            }
            case "restoreFootprint": {
              result.type = "restoreFootprint";
              break;
            }
            default: {
              throw new Error("Unknown operation: ".concat(operationName));
            }
          }
          return result;
        }
        /**
         * Validates that a given amount is possible for a Stellar asset.
         *
         * Specifically, this means that the amount is well, a valid number, but also
         * that it is within the int64 range and has no more than 7 decimal levels of
         * precision.
         *
         * Note that while smart contracts allow larger amounts, this is oriented
         * towards validating the standard Stellar operations.
         *
         * @param {string}  value       the amount to validate
         * @param {boolean} allowZero   optionally, whether or not zero is valid (default: no)
         *
         * @returns {boolean}
         */
      }, {
        key: "isValidAmount",
        value: function isValidAmount(value) {
          var allowZero = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (typeof value !== "string") {
            return false;
          }
          var amount;
          try {
            amount = new _bignumber["default"](value);
          } catch (e) {
            return false;
          }
          if (
            // == 0
            !allowZero && amount.isZero() || // < 0
            amount.isNegative() || // > Max value
            amount.times(ONE).gt(new _bignumber["default"](MAX_INT64).toString()) || // Decimal places (max 7)
            amount.decimalPlaces() > 7 || // NaN or Infinity
            amount.isNaN() || !amount.isFinite()
          ) {
            return false;
          }
          return true;
        }
      }, {
        key: "constructAmountRequirementsError",
        value: function constructAmountRequirementsError(arg) {
          return "".concat(arg, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
        }
        /**
         * Returns value converted to uint32 value or undefined.
         * If `value` is not `Number`, `String` or `Undefined` then throws an error.
         * Used in {@link Operation.setOptions}.
         * @private
         * @param {string} name Name of the property (used in error message only)
         * @param {*} value Value to check
         * @param {function(value, name)} isValidFunction Function to check other constraints (the argument will be a `Number`)
         * @returns {undefined|Number}
         */
      }, {
        key: "_checkUnsignedIntValue",
        value: function _checkUnsignedIntValue(name, value) {
          var isValidFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (typeof value === "undefined") {
            return void 0;
          }
          if (typeof value === "string") {
            value = parseFloat(value);
          }
          switch (true) {
            case (typeof value !== "number" || !Number.isFinite(value) || value % 1 !== 0):
              throw new Error("".concat(name, " value is invalid"));
            case value < 0:
              throw new Error("".concat(name, " value must be unsigned"));
            case (!isValidFunction || isValidFunction && isValidFunction(value, name)):
              return value;
            default:
              throw new Error("".concat(name, " value is invalid"));
          }
        }
        /**
         * @private
         * @param {string|BigNumber} value Value
         * @returns {Hyper} XDR amount
         */
      }, {
        key: "_toXDRAmount",
        value: function _toXDRAmount(value) {
          var amount = new _bignumber["default"](value).times(ONE);
          return _jsXdr.Hyper.fromString(amount.toString());
        }
        /**
         * @private
         * @param {string|BigNumber} value XDR amount
         * @returns {BigNumber} Number
         */
      }, {
        key: "_fromXDRAmount",
        value: function _fromXDRAmount(value) {
          return new _bignumber["default"](value).div(ONE).toFixed(7);
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {BigNumber} Big string
         */
      }, {
        key: "_fromXDRPrice",
        value: function _fromXDRPrice(price) {
          var n = new _bignumber["default"](price.n());
          return n.div(new _bignumber["default"](price.d())).toString();
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {object} XDR price object
         */
      }, {
        key: "_toXDRPrice",
        value: function _toXDRPrice(price) {
          var xdrObject;
          if (price.n && price.d) {
            xdrObject = new _xdr["default"].Price(price);
          } else {
            var approx = (0, _continued_fraction.best_r)(price);
            xdrObject = new _xdr["default"].Price({
              n: parseInt(approx[0], 10),
              d: parseInt(approx[1], 10)
            });
          }
          if (xdrObject.n() < 0 || xdrObject.d() < 0) {
            throw new Error("price must be positive");
          }
          return xdrObject;
        }
      }]);
    }();
    function extractRevokeSponshipDetails(attrs, result) {
      switch (attrs["switch"]().name) {
        case "revokeSponsorshipLedgerEntry": {
          var ledgerKey = attrs.ledgerKey();
          switch (ledgerKey["switch"]().name) {
            case _xdr["default"].LedgerEntryType.account().name: {
              result.type = "revokeAccountSponsorship";
              result.account = accountIdtoAddress(ledgerKey.account().accountId());
              break;
            }
            case _xdr["default"].LedgerEntryType.trustline().name: {
              result.type = "revokeTrustlineSponsorship";
              result.account = accountIdtoAddress(ledgerKey.trustLine().accountId());
              var xdrAsset = ledgerKey.trustLine().asset();
              switch (xdrAsset["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.asset = _liquidity_pool_id.LiquidityPoolId.fromOperation(xdrAsset);
                  break;
                default:
                  result.asset = _asset.Asset.fromOperation(xdrAsset);
                  break;
              }
              break;
            }
            case _xdr["default"].LedgerEntryType.offer().name: {
              result.type = "revokeOfferSponsorship";
              result.seller = accountIdtoAddress(ledgerKey.offer().sellerId());
              result.offerId = ledgerKey.offer().offerId().toString();
              break;
            }
            case _xdr["default"].LedgerEntryType.data().name: {
              result.type = "revokeDataSponsorship";
              result.account = accountIdtoAddress(ledgerKey.data().accountId());
              result.name = ledgerKey.data().dataName().toString("ascii");
              break;
            }
            case _xdr["default"].LedgerEntryType.claimableBalance().name: {
              result.type = "revokeClaimableBalanceSponsorship";
              result.balanceId = ledgerKey.claimableBalance().balanceId().toXDR("hex");
              break;
            }
            case _xdr["default"].LedgerEntryType.liquidityPool().name: {
              result.type = "revokeLiquidityPoolSponsorship";
              result.liquidityPoolId = ledgerKey.liquidityPool().liquidityPoolId().toString("hex");
              break;
            }
            default: {
              throw new Error("Unknown ledgerKey: ".concat(attrs["switch"]().name));
            }
          }
          break;
        }
        case "revokeSponsorshipSigner": {
          result.type = "revokeSignerSponsorship";
          result.account = accountIdtoAddress(attrs.signer().accountId());
          result.signer = convertXDRSignerKeyToObject(attrs.signer().signerKey());
          break;
        }
        default: {
          throw new Error("Unknown revokeSponsorship: ".concat(attrs["switch"]().name));
        }
      }
    }
    function convertXDRSignerKeyToObject(signerKey) {
      var attrs = {};
      switch (signerKey["switch"]().name) {
        case _xdr["default"].SignerKeyType.signerKeyTypeEd25519().name: {
          attrs.ed25519PublicKey = _strkey.StrKey.encodeEd25519PublicKey(signerKey.ed25519());
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx().name: {
          attrs.preAuthTx = signerKey.preAuthTx().toString("hex");
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypeHashX().name: {
          attrs.sha256Hash = signerKey.hashX().toString("hex");
          break;
        }
        default: {
          throw new Error("Unknown signerKey: ".concat(signerKey["switch"]().name));
        }
      }
      return attrs;
    }
    function accountIdtoAddress(accountId) {
      return _strkey.StrKey.encodeEd25519PublicKey(accountId.ed25519());
    }
    Operation2.accountMerge = ops.accountMerge;
    Operation2.allowTrust = ops.allowTrust;
    Operation2.bumpSequence = ops.bumpSequence;
    Operation2.changeTrust = ops.changeTrust;
    Operation2.createAccount = ops.createAccount;
    Operation2.createClaimableBalance = ops.createClaimableBalance;
    Operation2.claimClaimableBalance = ops.claimClaimableBalance;
    Operation2.clawbackClaimableBalance = ops.clawbackClaimableBalance;
    Operation2.createPassiveSellOffer = ops.createPassiveSellOffer;
    Operation2.inflation = ops.inflation;
    Operation2.manageData = ops.manageData;
    Operation2.manageSellOffer = ops.manageSellOffer;
    Operation2.manageBuyOffer = ops.manageBuyOffer;
    Operation2.pathPaymentStrictReceive = ops.pathPaymentStrictReceive;
    Operation2.pathPaymentStrictSend = ops.pathPaymentStrictSend;
    Operation2.payment = ops.payment;
    Operation2.setOptions = ops.setOptions;
    Operation2.beginSponsoringFutureReserves = ops.beginSponsoringFutureReserves;
    Operation2.endSponsoringFutureReserves = ops.endSponsoringFutureReserves;
    Operation2.revokeAccountSponsorship = ops.revokeAccountSponsorship;
    Operation2.revokeTrustlineSponsorship = ops.revokeTrustlineSponsorship;
    Operation2.revokeOfferSponsorship = ops.revokeOfferSponsorship;
    Operation2.revokeDataSponsorship = ops.revokeDataSponsorship;
    Operation2.revokeClaimableBalanceSponsorship = ops.revokeClaimableBalanceSponsorship;
    Operation2.revokeLiquidityPoolSponsorship = ops.revokeLiquidityPoolSponsorship;
    Operation2.revokeSignerSponsorship = ops.revokeSignerSponsorship;
    Operation2.clawback = ops.clawback;
    Operation2.setTrustLineFlags = ops.setTrustLineFlags;
    Operation2.liquidityPoolDeposit = ops.liquidityPoolDeposit;
    Operation2.liquidityPoolWithdraw = ops.liquidityPoolWithdraw;
    Operation2.invokeHostFunction = ops.invokeHostFunction;
    Operation2.extendFootprintTtl = ops.extendFootprintTtl;
    Operation2.restoreFootprint = ops.restoreFootprint;
    Operation2.createStellarAssetContract = ops.createStellarAssetContract;
    Operation2.invokeContractFunction = ops.invokeContractFunction;
    Operation2.createCustomContract = ops.createCustomContract;
    Operation2.uploadContractWasm = ops.uploadContractWasm;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/memo.js
var require_memo3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/memo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MemoText = exports.MemoReturn = exports.MemoNone = exports.MemoID = exports.MemoHash = exports.Memo = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber4());
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MemoNone = exports.MemoNone = "none";
    var MemoID = exports.MemoID = "id";
    var MemoText = exports.MemoText = "text";
    var MemoHash = exports.MemoHash = "hash";
    var MemoReturn = exports.MemoReturn = "return";
    var Memo = exports.Memo = function() {
      function Memo2(type) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Memo2);
        this._type = type;
        this._value = value;
        switch (this._type) {
          case MemoNone:
            break;
          case MemoID:
            Memo2._validateIdValue(value);
            break;
          case MemoText:
            Memo2._validateTextValue(value);
            break;
          case MemoHash:
          case MemoReturn:
            Memo2._validateHashValue(value);
            if (typeof value === "string") {
              this._value = Buffer.from(value, "hex");
            }
            break;
          default:
            throw new Error("Invalid memo type");
        }
      }
      return _createClass(Memo2, [{
        key: "type",
        get: function get() {
          return this._type;
        },
        set: function set(type) {
          throw new Error("Memo is immutable");
        }
        /**
         * Contains memo value:
         * * `null` for `MemoNone`,
         * * `string` for `MemoID`,
         * * `Buffer` for `MemoText` after decoding using `fromXDRObject`, original value otherwise,
         * * `Buffer` for `MemoHash`, `MemoReturn`.
         */
      }, {
        key: "value",
        get: function get() {
          switch (this._type) {
            case MemoNone:
              return null;
            case MemoID:
            case MemoText:
              return this._value;
            case MemoHash:
            case MemoReturn:
              return Buffer.from(this._value);
            default:
              throw new Error("Invalid memo type");
          }
        },
        set: function set(value) {
          throw new Error("Memo is immutable");
        }
      }, {
        key: "toXDRObject",
        value: (
          /**
           * Returns XDR memo object.
           * @returns {xdr.Memo}
           */
          function toXDRObject() {
            switch (this._type) {
              case MemoNone:
                return _xdr["default"].Memo.memoNone();
              case MemoID:
                return _xdr["default"].Memo.memoId(_jsXdr.UnsignedHyper.fromString(this._value));
              case MemoText:
                return _xdr["default"].Memo.memoText(this._value);
              case MemoHash:
                return _xdr["default"].Memo.memoHash(this._value);
              case MemoReturn:
                return _xdr["default"].Memo.memoReturn(this._value);
              default:
                return null;
            }
          }
        )
        /**
         * Returns {@link Memo} from XDR memo object.
         * @param {xdr.Memo} object XDR memo object
         * @returns {Memo}
         */
      }], [{
        key: "_validateIdValue",
        value: function _validateIdValue(value) {
          var error = new Error("Expects a int64 as a string. Got ".concat(value));
          if (typeof value !== "string") {
            throw error;
          }
          var number;
          try {
            number = new _bignumber["default"](value);
          } catch (e) {
            throw error;
          }
          if (!number.isFinite()) {
            throw error;
          }
          if (number.isNaN()) {
            throw error;
          }
        }
      }, {
        key: "_validateTextValue",
        value: function _validateTextValue(value) {
          if (!_xdr["default"].Memo.armTypeForArm("text").isValid(value)) {
            throw new Error("Expects string, array or buffer, max 28 bytes");
          }
        }
      }, {
        key: "_validateHashValue",
        value: function _validateHashValue(value) {
          var error = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(value));
          if (value === null || typeof value === "undefined") {
            throw error;
          }
          var valueBuffer;
          if (typeof value === "string") {
            if (!/^[0-9A-Fa-f]{64}$/g.test(value)) {
              throw error;
            }
            valueBuffer = Buffer.from(value, "hex");
          } else if (Buffer.isBuffer(value)) {
            valueBuffer = Buffer.from(value);
          } else {
            throw error;
          }
          if (!valueBuffer.length || valueBuffer.length !== 32) {
            throw error;
          }
        }
        /**
         * Returns an empty memo (`MemoNone`).
         * @returns {Memo}
         */
      }, {
        key: "none",
        value: function none() {
          return new Memo2(MemoNone);
        }
        /**
         * Creates and returns a `MemoText` memo.
         * @param {string} text - memo text
         * @returns {Memo}
         */
      }, {
        key: "text",
        value: function text(_text) {
          return new Memo2(MemoText, _text);
        }
        /**
         * Creates and returns a `MemoID` memo.
         * @param {string} id - 64-bit number represented as a string
         * @returns {Memo}
         */
      }, {
        key: "id",
        value: function id(_id) {
          return new Memo2(MemoID, _id);
        }
        /**
         * Creates and returns a `MemoHash` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "hash",
        value: function hash2(_hash) {
          return new Memo2(MemoHash, _hash);
        }
        /**
         * Creates and returns a `MemoReturn` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "return",
        value: function _return(hash2) {
          return new Memo2(MemoReturn, hash2);
        }
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(object) {
          switch (object.arm()) {
            case "id":
              return Memo2.id(object.value().toString());
            case "text":
              return Memo2.text(object.value());
            case "hash":
              return Memo2.hash(object.value());
            case "retHash":
              return Memo2["return"](object.value());
            default:
              break;
          }
          if (typeof object.value() === "undefined") {
            return Memo2.none();
          }
          throw new Error("Unknown type");
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/transaction.js
var require_transaction5 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/transaction.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _hashing = require_hashing3();
    var _strkey = require_strkey3();
    var _operation = require_operation3();
    var _memo = require_memo3();
    var _transaction_base = require_transaction_base3();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Transaction = exports.Transaction = function(_TransactionBase) {
      function Transaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, Transaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (!(envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0() || envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTx())) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, Transaction2, [tx, signatures, fee, networkPassphrase]);
        _this._envelopeType = envelopeType;
        _this._memo = tx.memo();
        _this._sequence = tx.seqNum().toString();
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            _this._source = _strkey.StrKey.encodeEd25519PublicKey(_this.tx.sourceAccountEd25519());
            break;
          default:
            _this._source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.sourceAccount());
            break;
        }
        var cond = null;
        var timeBounds = null;
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            timeBounds = tx.timeBounds();
            break;
          case _xdr["default"].EnvelopeType.envelopeTypeTx():
            switch (tx.cond()["switch"]()) {
              case _xdr["default"].PreconditionType.precondTime():
                timeBounds = tx.cond().timeBounds();
                break;
              case _xdr["default"].PreconditionType.precondV2():
                cond = tx.cond().v2();
                timeBounds = cond.timeBounds();
                break;
              default:
                break;
            }
            break;
          default:
            break;
        }
        if (timeBounds) {
          _this._timeBounds = {
            minTime: timeBounds.minTime().toString(),
            maxTime: timeBounds.maxTime().toString()
          };
        }
        if (cond) {
          var ledgerBounds = cond.ledgerBounds();
          if (ledgerBounds) {
            _this._ledgerBounds = {
              minLedger: ledgerBounds.minLedger(),
              maxLedger: ledgerBounds.maxLedger()
            };
          }
          var minSeq = cond.minSeqNum();
          if (minSeq) {
            _this._minAccountSequence = minSeq.toString();
          }
          _this._minAccountSequenceAge = cond.minSeqAge();
          _this._minAccountSequenceLedgerGap = cond.minSeqLedgerGap();
          _this._extraSigners = cond.extraSigners();
        }
        var operations = tx.operations() || [];
        _this._operations = operations.map(function(op) {
          return _operation.Operation.fromXDRObject(op);
        });
        return _this;
      }
      _inherits(Transaction2, _TransactionBase);
      return _createClass(Transaction2, [{
        key: "timeBounds",
        get: function get() {
          return this._timeBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {object}
         * @property {number} minLedger - smallest ledger bound (uint32)
         * @property {number} maxLedger - largest ledger bound (or 0 for inf)
         * @readonly
         */
      }, {
        key: "ledgerBounds",
        get: function get() {
          return this._ledgerBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit account sequence
         * @readonly
         * @type {string}
         */
      }, {
        key: "minAccountSequence",
        get: function get() {
          return this._minAccountSequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit number of seconds
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceAge",
        get: function get() {
          return this._minAccountSequenceAge;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 32 bit number of ledgers
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceLedgerGap",
        get: function get() {
          return this._minAccountSequenceLedgerGap;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * array of extra signers ({@link StrKey}s)
         * @type {string[]}
         * @readonly
         */
      }, {
        key: "extraSigners",
        get: function get() {
          return this._extraSigners;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "sequence",
        get: function get() {
          return this._sequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "source",
        get: function get() {
          return this._source;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {Array.<xdr.Operation>}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._operations;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "memo",
        get: function get() {
          return _memo.Memo.fromXDRObject(this._memo);
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var tx = this.tx;
          if (this._envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            tx = _xdr["default"].Transaction.fromXDR(Buffer.concat([
              // TransactionV0 is a transaction with the AccountID discriminant
              // stripped off, we need to put it back to build a valid transaction
              // which we can use to build a TransactionSignaturePayloadTaggedTransaction
              _xdr["default"].PublicKeyType.publicKeyTypeEd25519().toXDR(),
              tx.toXDR()
            ]));
          }
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var rawTx = this.tx.toXDR();
          var signatures = this.signatures.slice();
          var envelope;
          switch (this._envelopeType) {
            case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxV0(new _xdr["default"].TransactionV0Envelope({
                tx: _xdr["default"].TransactionV0.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            case _xdr["default"].EnvelopeType.envelopeTypeTx():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                tx: _xdr["default"].Transaction.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            default:
              throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
          }
          return envelope;
        }
        /**
         * Calculate the claimable balance ID for an operation within the transaction.
         *
         * @param   {integer}  opIndex   the index of the CreateClaimableBalance op
         * @returns {string}   a hex string representing the claimable balance ID
         *
         * @throws {RangeError}   for invalid `opIndex` value
         * @throws {TypeError}    if op at `opIndex` is not `CreateClaimableBalance`
         * @throws for general XDR un/marshalling failures
         *
         * @see https://github.com/stellar/go/blob/d712346e61e288d450b0c08038c158f8848cc3e4/txnbuild/transaction.go#L392-L435
         *
         */
      }, {
        key: "getClaimableBalanceId",
        value: function getClaimableBalanceId(opIndex) {
          if (!Number.isInteger(opIndex) || opIndex < 0 || opIndex >= this.operations.length) {
            throw new RangeError("invalid operation index");
          }
          var op = this.operations[opIndex];
          try {
            op = _operation.Operation.createClaimableBalance(op);
          } catch (err) {
            throw new TypeError("expected createClaimableBalance, got ".concat(op.type, ": ").concat(err));
          }
          var account = _strkey.StrKey.decodeEd25519PublicKey((0, _decode_encode_muxed_account.extractBaseAddress)(this.source));
          var operationId = _xdr["default"].HashIdPreimage.envelopeTypeOpId(new _xdr["default"].HashIdPreimageOperationId({
            sourceAccount: _xdr["default"].AccountId.publicKeyTypeEd25519(account),
            seqNum: _xdr["default"].SequenceNumber.fromString(this.sequence),
            opNum: opIndex
          }));
          var opIdHash = (0, _hashing.hash)(operationId.toXDR("raw"));
          var balanceId = _xdr["default"].ClaimableBalanceId.claimableBalanceIdTypeV0(opIdHash);
          return balanceId.toXDR("hex");
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js
var require_fee_bump_transaction3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FeeBumpTransaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _hashing = require_hashing3();
    var _transaction = require_transaction5();
    var _transaction_base = require_transaction_base3();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var FeeBumpTransaction = exports.FeeBumpTransaction = function(_TransactionBase) {
      function FeeBumpTransaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, FeeBumpTransaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (envelopeType !== _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, FeeBumpTransaction2, [tx, signatures, fee, networkPassphrase]);
        var innerTxEnvelope = _xdr["default"].TransactionEnvelope.envelopeTypeTx(tx.innerTx().v1());
        _this._feeSource = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.feeSource());
        _this._innerTransaction = new _transaction.Transaction(innerTxEnvelope, networkPassphrase);
        return _this;
      }
      _inherits(FeeBumpTransaction2, _TransactionBase);
      return _createClass(FeeBumpTransaction2, [{
        key: "innerTransaction",
        get: function get() {
          return this._innerTransaction;
        }
        /**
         * @type {Operation[]}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._innerTransaction.operations;
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "feeSource",
        get: function get() {
          return this._feeSource;
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var envelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx: _xdr["default"].FeeBumpTransaction.fromXDR(this.tx.toXDR()),
            // make a copy of the tx
            signatures: this.signatures.slice()
            // make a copy of the signatures
          });
          return new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(envelope);
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/account.js
var require_account3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Account = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber4());
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Account = exports.Account = function() {
      function Account2(accountId, sequence) {
        _classCallCheck(this, Account2);
        if (_strkey.StrKey.isValidMed25519PublicKey(accountId)) {
          throw new Error("accountId is an M-address; use MuxedAccount instead");
        }
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        if (!(typeof sequence === "string")) {
          throw new Error("sequence must be of type string");
        }
        this._accountId = accountId;
        this.sequence = new _bignumber["default"](sequence);
      }
      return _createClass(Account2, [{
        key: "accountId",
        value: function accountId() {
          return this._accountId;
        }
        /**
         * @returns {string}  sequence number for the account as a string
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.sequence.toString();
        }
        /**
         * Increments sequence number in this object by one.
         * @returns {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          this.sequence = this.sequence.plus(1);
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/muxed_account.js
var require_muxed_account3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/muxed_account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MuxedAccount = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _account = require_account3();
    var _strkey = require_strkey3();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MuxedAccount = exports.MuxedAccount = function() {
      function MuxedAccount2(baseAccount, id) {
        _classCallCheck(this, MuxedAccount2);
        var accountId = baseAccount.accountId();
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        this.account = baseAccount;
        this._muxedXdr = (0, _decode_encode_muxed_account.encodeMuxedAccount)(accountId, id);
        this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
        this._id = id;
      }
      return _createClass(MuxedAccount2, [{
        key: "baseAccount",
        value: (
          /**
           * @return {Account} the underlying account object shared among all muxed
           *     accounts with this Stellar address
           */
          function baseAccount() {
            return this.account;
          }
        )
        /**
         * @return {string} the M-address representing this account's (G-address, ID)
         */
      }, {
        key: "accountId",
        value: function accountId() {
          return this._mAddress;
        }
      }, {
        key: "id",
        value: function id() {
          return this._id;
        }
      }, {
        key: "setId",
        value: function setId(id) {
          if (typeof id !== "string") {
            throw new Error("id should be a string representing a number (uint64)");
          }
          this._muxedXdr.med25519().id(_xdr["default"].Uint64.fromString(id));
          this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
          this._id = id;
          return this;
        }
        /**
         * Accesses the underlying account's sequence number.
         * @return {string}  strigified sequence number for the underlying account
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.account.sequenceNumber();
        }
        /**
         * Increments the underlying account's sequence number by one.
         * @return {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          return this.account.incrementSequenceNumber();
        }
        /**
         * @return {xdr.MuxedAccount} the XDR object representing this muxed account's
         *     G-address and uint64 ID
         */
      }, {
        key: "toXDRObject",
        value: function toXDRObject() {
          return this._muxedXdr;
        }
      }, {
        key: "equals",
        value: function equals(otherMuxedAccount) {
          return this.accountId() === otherMuxedAccount.accountId();
        }
      }], [{
        key: "fromAddress",
        value: function fromAddress(mAddress, sequenceNum) {
          var muxedAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(mAddress);
          var gAddress = (0, _decode_encode_muxed_account.extractBaseAddress)(mAddress);
          var id = muxedAccount.med25519().id().toString();
          return new MuxedAccount2(new _account.Account(gAddress, sequenceNum), id);
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js
var require_sorobandata_builder3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SorobanDataBuilder = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SorobanDataBuilder = exports.SorobanDataBuilder = function() {
      function SorobanDataBuilder2(sorobanData) {
        _classCallCheck(this, SorobanDataBuilder2);
        _defineProperty(this, "_data", void 0);
        var data;
        if (!sorobanData) {
          data = new _xdr["default"].SorobanTransactionData({
            resources: new _xdr["default"].SorobanResources({
              footprint: new _xdr["default"].LedgerFootprint({
                readOnly: [],
                readWrite: []
              }),
              instructions: 0,
              readBytes: 0,
              writeBytes: 0
            }),
            ext: new _xdr["default"].ExtensionPoint(0),
            resourceFee: new _xdr["default"].Int64(0)
          });
        } else if (typeof sorobanData === "string" || ArrayBuffer.isView(sorobanData)) {
          data = SorobanDataBuilder2.fromXDR(sorobanData);
        } else {
          data = SorobanDataBuilder2.fromXDR(sorobanData.toXDR());
        }
        this._data = data;
      }
      return _createClass(SorobanDataBuilder2, [{
        key: "setResourceFee",
        value: (
          /**
           * Sets the resource fee portion of the Soroban data.
           * @param {number | bigint | string} fee  the resource fee to set (int64)
           * @returns {SorobanDataBuilder}
           */
          function setResourceFee(fee) {
            this._data.resourceFee(new _xdr["default"].Int64(fee));
            return this;
          }
        )
        /**
         * Sets up the resource metrics.
         *
         * You should almost NEVER need this, as its often generated / provided to you
         * by transaction simulation/preflight from a Soroban RPC server.
         *
         * @param {number} cpuInstrs      number of CPU instructions
         * @param {number} readBytes      number of bytes being read
         * @param {number} writeBytes     number of bytes being written
         *
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setResources",
        value: function setResources(cpuInstrs, readBytes, writeBytes) {
          this._data.resources().instructions(cpuInstrs);
          this._data.resources().readBytes(readBytes);
          this._data.resources().writeBytes(writeBytes);
          return this;
        }
        /**
         * Appends the given ledger keys to the existing storage access footprint.
         * @param {xdr.LedgerKey[]} readOnly   read-only keys to add
         * @param {xdr.LedgerKey[]} readWrite  read-write keys to add
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "appendFootprint",
        value: function appendFootprint(readOnly, readWrite) {
          return this.setFootprint(this.getReadOnly().concat(readOnly), this.getReadWrite().concat(readWrite));
        }
        /**
         * Sets the storage access footprint to be a certain set of ledger keys.
         *
         * You can also set each field explicitly via
         * {@link SorobanDataBuilder.setReadOnly} and
         * {@link SorobanDataBuilder.setReadWrite} or add to the existing footprint
         * via {@link SorobanDataBuilder.appendFootprint}.
         *
         * Passing `null|undefined` to either parameter will IGNORE the existing
         * values. If you want to clear them, pass `[]`, instead.
         *
         * @param {xdr.LedgerKey[]|null} [readOnly]   the set of ledger keys to set in
         *    the read-only portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @param {xdr.LedgerKey[]|null} [readWrite]  the set of ledger keys to set in
         *    the read-write portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "setFootprint",
        value: function setFootprint(readOnly, readWrite) {
          if (readOnly !== null) {
            this.setReadOnly(readOnly);
          }
          if (readWrite !== null) {
            this.setReadWrite(readWrite);
          }
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readOnly  read-only keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadOnly",
        value: function setReadOnly(readOnly) {
          this._data.resources().footprint().readOnly(readOnly !== null && readOnly !== void 0 ? readOnly : []);
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readWrite  read-write keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadWrite",
        value: function setReadWrite(readWrite) {
          this._data.resources().footprint().readWrite(readWrite !== null && readWrite !== void 0 ? readWrite : []);
          return this;
        }
        /**
         * @returns {xdr.SorobanTransactionData} a copy of the final data structure
         */
      }, {
        key: "build",
        value: function build() {
          return _xdr["default"].SorobanTransactionData.fromXDR(this._data.toXDR());
        }
        //
        // getters follow
        //
        /** @returns {xdr.LedgerKey[]} the read-only storage access pattern */
      }, {
        key: "getReadOnly",
        value: function getReadOnly() {
          return this.getFootprint().readOnly();
        }
        /** @returns {xdr.LedgerKey[]} the read-write storage access pattern */
      }, {
        key: "getReadWrite",
        value: function getReadWrite() {
          return this.getFootprint().readWrite();
        }
        /** @returns {xdr.LedgerFootprint} the storage access pattern */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return this._data.resources().footprint();
        }
      }], [{
        key: "fromXDR",
        value: function fromXDR(data) {
          return _xdr["default"].SorobanTransactionData.fromXDR(data, typeof data === "string" ? "base64" : "raw");
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/signerkey.js
var require_signerkey3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/signerkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SignerKey = void 0;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SignerKey2 = exports.SignerKey = function() {
      function SignerKey3() {
        _classCallCheck(this, SignerKey3);
      }
      return _createClass(SignerKey3, null, [{
        key: "decodeAddress",
        value: (
          /**
           * Decodes a StrKey address into an xdr.SignerKey instance.
           *
           * Only ED25519 public keys (G...), pre-auth transactions (T...), hashes
           * (H...), and signed payloads (P...) can be signer keys.
           *
           * @param   {string} address  a StrKey-encoded signer address
           * @returns {xdr.SignerKey}
           */
          function decodeAddress(address) {
            var signerKeyMap = {
              ed25519PublicKey: _xdr["default"].SignerKey.signerKeyTypeEd25519,
              preAuthTx: _xdr["default"].SignerKey.signerKeyTypePreAuthTx,
              sha256Hash: _xdr["default"].SignerKey.signerKeyTypeHashX,
              signedPayload: _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload
            };
            var vb = _strkey.StrKey.getVersionByteForPrefix(address);
            var encoder = signerKeyMap[vb];
            if (!encoder) {
              throw new Error("invalid signer key type (".concat(vb, ")"));
            }
            var raw = (0, _strkey.decodeCheck)(vb, address);
            switch (vb) {
              case "signedPayload":
                return encoder(new _xdr["default"].SignerKeyEd25519SignedPayload({
                  ed25519: raw.slice(0, 32),
                  payload: raw.slice(32 + 4)
                }));
              case "ed25519PublicKey":
              case "preAuthTx":
              case "sha256Hash":
              default:
                return encoder(raw);
            }
          }
        )
        /**
         * Encodes a signer key into its StrKey equivalent.
         *
         * @param   {xdr.SignerKey} signerKey   the signer
         * @returns {string} the StrKey representation of the signer
         */
      }, {
        key: "encodeSignerKey",
        value: function encodeSignerKey(signerKey) {
          var strkeyType;
          var raw;
          switch (signerKey["switch"]()) {
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519():
              strkeyType = "ed25519PublicKey";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx():
              strkeyType = "preAuthTx";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeHashX():
              strkeyType = "sha256Hash";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519SignedPayload():
              strkeyType = "signedPayload";
              raw = signerKey.ed25519SignedPayload().toXDR("raw");
              break;
            default:
              throw new Error("invalid SignerKey (type: ".concat(signerKey["switch"](), ")"));
          }
          return (0, _strkey.encodeCheck)(strkeyType, raw);
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/transaction_builder.js
var require_transaction_builder3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/transaction_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = void 0;
    exports.isValidDate = isValidDate;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber4());
    var _xdr = _interopRequireDefault(require_xdr4());
    var _account = require_account3();
    var _muxed_account = require_muxed_account3();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    var _transaction = require_transaction5();
    var _fee_bump_transaction = require_fee_bump_transaction3();
    var _sorobandata_builder = require_sorobandata_builder3();
    var _strkey = require_strkey3();
    var _signerkey = require_signerkey3();
    var _memo = require_memo3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var BASE_FEE = exports.BASE_FEE = "100";
    var TimeoutInfinite = exports.TimeoutInfinite = 0;
    var TransactionBuilder2 = exports.TransactionBuilder = function() {
      function TransactionBuilder3(sourceAccount) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, TransactionBuilder3);
        if (!sourceAccount) {
          throw new Error("must specify source account for the transaction");
        }
        if (opts.fee === void 0) {
          throw new Error("must specify fee for the transaction (in stroops)");
        }
        this.source = sourceAccount;
        this.operations = [];
        this.baseFee = opts.fee;
        this.timebounds = opts.timebounds ? _objectSpread({}, opts.timebounds) : null;
        this.ledgerbounds = opts.ledgerbounds ? _objectSpread({}, opts.ledgerbounds) : null;
        this.minAccountSequence = opts.minAccountSequence || null;
        this.minAccountSequenceAge = opts.minAccountSequenceAge || null;
        this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;
        this.extraSigners = opts.extraSigners ? _toConsumableArray(opts.extraSigners) : null;
        this.memo = opts.memo || _memo.Memo.none();
        this.networkPassphrase = opts.networkPassphrase || null;
        this.sorobanData = opts.sorobanData ? new _sorobandata_builder.SorobanDataBuilder(opts.sorobanData).build() : null;
      }
      return _createClass(TransactionBuilder3, [{
        key: "addOperation",
        value: (
          /**
           * Adds an operation to the transaction.
           *
           * @param {xdr.Operation} operation   The xdr operation object, use {@link
           *     Operation} static methods.
           *
           * @returns {TransactionBuilder}
           */
          function addOperation(operation) {
            this.operations.push(operation);
            return this;
          }
        )
        /**
         * Adds an operation to the transaction at a specific index.
         *
         * @param {xdr.Operation} operation - The xdr operation object to add, use {@link Operation} static methods.
         * @param {number} index - The index at which to insert the operation.
         *
         * @returns {TransactionBuilder} - The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "addOperationAt",
        value: function addOperationAt(operation, index) {
          this.operations.splice(index, 0, operation);
          return this;
        }
        /**
         * Removes the operations from the builder (useful when cloning).
         * @returns {TransactionBuilder} this builder instance
         */
      }, {
        key: "clearOperations",
        value: function clearOperations() {
          this.operations = [];
          return this;
        }
        /**
         * Removes the operation at the specified index from the transaction.
         *
         * @param {number} index - The index of the operation to remove.
         *
         * @returns {TransactionBuilder} The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "clearOperationAt",
        value: function clearOperationAt(index) {
          this.operations.splice(index, 1);
          return this;
        }
        /**
         * Adds a memo to the transaction.
         * @param {Memo} memo {@link Memo} object
         * @returns {TransactionBuilder}
         */
      }, {
        key: "addMemo",
        value: function addMemo(memo) {
          this.memo = memo;
          return this;
        }
        /**
         * Sets a timeout precondition on the transaction.
         *
         *  Because of the distributed nature of the Stellar network it is possible
         *  that the status of your transaction will be determined after a long time
         *  if the network is highly congested. If you want to be sure to receive the
         *  status of the transaction within a given period you should set the {@link
         *  TimeBounds} with `maxTime` on the transaction (this is what `setTimeout`
         *  does internally; if there's `minTime` set but no `maxTime` it will be
         *  added).
         *
         *  A call to `TransactionBuilder.setTimeout` is **required** if Transaction
         *  does not have `max_time` set. If you don't want to set timeout, use
         *  `{@link TimeoutInfinite}`. In general you should set `{@link
         *  TimeoutInfinite}` only in smart contracts.
         *
         *  Please note that Horizon may still return <code>504 Gateway Timeout</code>
         *  error, even for short timeouts. In such case you need to resubmit the same
         *  transaction again without making any changes to receive a status. This
         *  method is using the machine system time (UTC), make sure it is set
         *  correctly.
         *
         * @param {number} timeoutSeconds   Number of seconds the transaction is good.
         *     Can't be negative. If the value is {@link TimeoutInfinite}, the
         *     transaction is good indefinitely.
         *
         * @returns {TransactionBuilder}
         *
         * @see {@link TimeoutInfinite}
         * @see https://developers.stellar.org/docs/tutorials/handling-errors/
         */
      }, {
        key: "setTimeout",
        value: function setTimeout2(timeoutSeconds) {
          if (this.timebounds !== null && this.timebounds.maxTime > 0) {
            throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
          }
          if (timeoutSeconds < 0) {
            throw new Error("timeout cannot be negative");
          }
          if (timeoutSeconds > 0) {
            var timeoutTimestamp = Math.floor(Date.now() / 1e3) + timeoutSeconds;
            if (this.timebounds === null) {
              this.timebounds = {
                minTime: 0,
                maxTime: timeoutTimestamp
              };
            } else {
              this.timebounds = {
                minTime: this.timebounds.minTime,
                maxTime: timeoutTimestamp
              };
            }
          } else {
            this.timebounds = {
              minTime: 0,
              maxTime: 0
            };
          }
          return this;
        }
        /**
         * If you want to prepare a transaction which will become valid at some point
         * in the future, or be invalid after some time, you can set a timebounds
         * precondition. Internally this will set the `minTime`, and `maxTime`
         * preconditions. Conflicts with `setTimeout`, so use one or the other.
         *
         * @param {Date|number} minEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid after this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     immediately.
         * @param {Date|number} maxEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid until this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setTimebounds",
        value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {
          if (typeof minEpochOrDate === "number") {
            minEpochOrDate = new Date(minEpochOrDate * 1e3);
          }
          if (typeof maxEpochOrDate === "number") {
            maxEpochOrDate = new Date(maxEpochOrDate * 1e3);
          }
          if (this.timebounds !== null) {
            throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
          }
          var minTime = Math.floor(minEpochOrDate.valueOf() / 1e3);
          var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1e3);
          if (minTime < 0) {
            throw new Error("min_time cannot be negative");
          }
          if (maxTime < 0) {
            throw new Error("max_time cannot be negative");
          }
          if (maxTime > 0 && minTime > maxTime) {
            throw new Error("min_time cannot be greater than max_time");
          }
          this.timebounds = {
            minTime,
            maxTime
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will only be valid within some
         * range of ledgers, you can set a ledgerbounds precondition.
         * Internally this will set the `minLedger` and `maxLedger` preconditions.
         *
         * @param {number} minLedger  The minimum ledger this transaction is valid at
         *     or after. Cannot be negative. If the value is `0` (the default), the
         *     transaction is valid immediately.
         *
         * @param {number} maxLedger  The maximum ledger this transaction is valid
         *     before. Cannot be negative. If the value is `0`, the transaction is
         *     valid indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setLedgerbounds",
        value: function setLedgerbounds(minLedger, maxLedger) {
          if (this.ledgerbounds !== null) {
            throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
          }
          if (minLedger < 0) {
            throw new Error("min_ledger cannot be negative");
          }
          if (maxLedger < 0) {
            throw new Error("max_ledger cannot be negative");
          }
          if (maxLedger > 0 && minLedger > maxLedger) {
            throw new Error("min_ledger cannot be greater than max_ledger");
          }
          this.ledgerbounds = {
            minLedger,
            maxLedger
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will be valid only while the
         * account sequence number is
         *
         *     minAccountSequence <= sourceAccountSequence < tx.seqNum
         *
         * Note that after execution the account's sequence number is always raised to
         * `tx.seqNum`. Internally this will set the `minAccountSequence`
         * precondition.
         *
         * @param {string} minAccountSequence   The minimum source account sequence
         *     number this transaction is valid for. If the value is `0` (the
         *     default), the transaction is valid when `sourceAccount's sequence
         *     number == tx.seqNum- 1`.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequence",
        value: function setMinAccountSequence(minAccountSequence) {
          if (this.minAccountSequence !== null) {
            throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
          }
          this.minAccountSequence = minAccountSequence;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger time must be at least
         * `minAccountSequenceAge` greater than sourceAccount's `sequenceTime`.
         * Internally this will set the `minAccountSequenceAge` precondition.
         *
         * @param {number} durationInSeconds  The minimum amount of time between
         *     source account sequence time and the ledger time when this transaction
         *     will become valid. If the value is `0`, the transaction is unrestricted
         *     by the account sequence age. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceAge",
        value: function setMinAccountSequenceAge(durationInSeconds) {
          if (typeof durationInSeconds !== "number") {
            throw new Error("min_account_sequence_age must be a number");
          }
          if (this.minAccountSequenceAge !== null) {
            throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
          }
          if (durationInSeconds < 0) {
            throw new Error("min_account_sequence_age cannot be negative");
          }
          this.minAccountSequenceAge = durationInSeconds;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger number must be at least
         * `minAccountSequenceLedgerGap` greater than sourceAccount's ledger sequence.
         * Internally this will set the `minAccountSequenceLedgerGap` precondition.
         *
         * @param {number} gap  The minimum number of ledgers between source account
         *     sequence and the ledger number when this transaction will become valid.
         *     If the value is `0`, the transaction is unrestricted by the account
         *     sequence ledger. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceLedgerGap",
        value: function setMinAccountSequenceLedgerGap(gap) {
          if (this.minAccountSequenceLedgerGap !== null) {
            throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
          }
          if (gap < 0) {
            throw new Error("min_account_sequence_ledger_gap cannot be negative");
          }
          this.minAccountSequenceLedgerGap = gap;
          return this;
        }
        /**
         * For the transaction to be valid, there must be a signature corresponding to
         * every Signer in this array, even if the signature is not otherwise required
         * by the sourceAccount or operations. Internally this will set the
         * `extraSigners` precondition.
         *
         * @param {string[]} extraSigners   required extra signers (as {@link StrKey}s)
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setExtraSigners",
        value: function setExtraSigners(extraSigners) {
          if (!Array.isArray(extraSigners)) {
            throw new Error("extra_signers must be an array of strings.");
          }
          if (this.extraSigners !== null) {
            throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
          }
          if (extraSigners.length > 2) {
            throw new Error("extra_signers cannot be longer than 2 elements.");
          }
          this.extraSigners = _toConsumableArray(extraSigners);
          return this;
        }
        /**
         * Set network nassphrase for the Transaction that will be built.
         *
         * @param {string} networkPassphrase    passphrase of the target Stellar
         *     network (e.g. "Public Global Stellar Network ; September 2015").
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setNetworkPassphrase",
        value: function setNetworkPassphrase(networkPassphrase) {
          this.networkPassphrase = networkPassphrase;
          return this;
        }
        /**
         * Sets the transaction's internal Soroban transaction data (resources,
         * footprint, etc.).
         *
         * For non-contract(non-Soroban) transactions, this setting has no effect. In
         * the case of Soroban transactions, this is either an instance of
         * {@link xdr.SorobanTransactionData} or a base64-encoded string of said
         * structure. This is usually obtained from the simulation response based on a
         * transaction with a Soroban operation (e.g.
         * {@link Operation.invokeHostFunction}, providing necessary resource
         * and storage footprint estimations for contract invocation.
         *
         * @param {xdr.SorobanTransactionData | string} sorobanData    the
         *    {@link xdr.SorobanTransactionData} as a raw xdr object or a base64
         *    string to be decoded
         *
         * @returns {TransactionBuilder}
         * @see {SorobanDataBuilder}
         */
      }, {
        key: "setSorobanData",
        value: function setSorobanData(sorobanData) {
          this.sorobanData = new _sorobandata_builder.SorobanDataBuilder(sorobanData).build();
          return this;
        }
        /**
         * This will build the transaction.
         * It will also increment the source account's sequence number by 1.
         * @returns {Transaction} This method will return the built {@link Transaction}.
         */
      }, {
        key: "build",
        value: function build() {
          var sequenceNumber = new _bignumber["default"](this.source.sequenceNumber()).plus(1);
          var fee = new _bignumber["default"](this.baseFee).times(this.operations.length).toNumber();
          var attrs = {
            fee,
            seqNum: _xdr["default"].SequenceNumber.fromString(sequenceNumber.toString()),
            memo: this.memo ? this.memo.toXDRObject() : null
          };
          if (this.timebounds === null || typeof this.timebounds.minTime === "undefined" || typeof this.timebounds.maxTime === "undefined") {
            throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
          }
          if (isValidDate(this.timebounds.minTime)) {
            this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3;
          }
          if (isValidDate(this.timebounds.maxTime)) {
            this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3;
          }
          this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());
          this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
          var timeBounds = new _xdr["default"].TimeBounds(this.timebounds);
          if (this.hasV2Preconditions()) {
            var ledgerBounds = null;
            if (this.ledgerbounds !== null) {
              ledgerBounds = new _xdr["default"].LedgerBounds(this.ledgerbounds);
            }
            var minSeqNum = this.minAccountSequence || "0";
            minSeqNum = _xdr["default"].SequenceNumber.fromString(minSeqNum);
            var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0");
            var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;
            var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];
            attrs.cond = _xdr["default"].Preconditions.precondV2(new _xdr["default"].PreconditionsV2({
              timeBounds,
              ledgerBounds,
              minSeqNum,
              minSeqAge,
              minSeqLedgerGap,
              extraSigners
            }));
          } else {
            attrs.cond = _xdr["default"].Preconditions.precondTime(timeBounds);
          }
          attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());
          if (this.sorobanData) {
            attrs.ext = new _xdr["default"].TransactionExt(1, this.sorobanData);
          } else {
            attrs.ext = new _xdr["default"].TransactionExt(0, _xdr["default"].Void);
          }
          var xtx = new _xdr["default"].Transaction(attrs);
          xtx.operations(this.operations);
          var txEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
            tx: xtx
          }));
          var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);
          this.source.incrementSequenceNumber();
          return tx;
        }
      }, {
        key: "hasV2Preconditions",
        value: function hasV2Preconditions() {
          return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
        }
        /**
         * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing
         * transaction with a higher fee.
         *
         * @param {Keypair|string}  feeSource - account paying for the transaction,
         *     in the form of either a Keypair (only the public key is used) or
         *     an account ID (in G... or M... form, but refer to `withMuxing`)
         * @param {string}          baseFee   - max fee willing to pay per operation
         *     in inner transaction (**in stroops**)
         * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by
         *     the fee bump transaction
         * @param {string}          networkPassphrase - passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September 2015",
         *     see {@link Networks})
         *
         * @todo Alongside the next major version bump, this type signature can be
         *       changed to be less awkward: accept a MuxedAccount as the `feeSource`
         *       rather than a keypair or string.
         *
         * @note Your fee-bump amount should be >= 10x the original fee.
         * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee
         *
         * @returns {FeeBumpTransaction}
         */
      }], [{
        key: "cloneFrom",
        value: function cloneFrom(tx) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!(tx instanceof _transaction.Transaction)) {
            throw new TypeError("expected a 'Transaction', got: ".concat(tx));
          }
          var sequenceNum = (BigInt(tx.sequence) - 1n).toString();
          var source;
          if (_strkey.StrKey.isValidMed25519PublicKey(tx.source)) {
            source = _muxed_account.MuxedAccount.fromAddress(tx.source, sequenceNum);
          } else if (_strkey.StrKey.isValidEd25519PublicKey(tx.source)) {
            source = new _account.Account(tx.source, sequenceNum);
          } else {
            throw new TypeError("unsupported tx source account: ".concat(tx.source));
          }
          var unscaledFee = parseInt(tx.fee, 10) / tx.operations.length;
          var builder = new TransactionBuilder3(source, _objectSpread({
            fee: (unscaledFee || BASE_FEE).toString(),
            memo: tx.memo,
            networkPassphrase: tx.networkPassphrase,
            timebounds: tx.timeBounds,
            ledgerbounds: tx.ledgerBounds,
            minAccountSequence: tx.minAccountSequence,
            minAccountSequenceAge: tx.minAccountSequenceAge,
            minAccountSequenceLedgerGap: tx.minAccountSequenceLedgerGap,
            extraSigners: tx.extraSigners
          }, opts));
          tx._tx.operations().forEach(function(op) {
            return builder.addOperation(op);
          });
          return builder;
        }
      }, {
        key: "buildFeeBumpTransaction",
        value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {
          var innerOps = innerTx.operations.length;
          var innerBaseFeeRate = new _bignumber["default"](innerTx.fee).div(innerOps);
          var base = new _bignumber["default"](baseFee);
          if (base.lt(innerBaseFeeRate)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(innerBaseFeeRate, " stroops."));
          }
          var minBaseFee = new _bignumber["default"](BASE_FEE);
          if (base.lt(minBaseFee)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(minBaseFee, " stroops."));
          }
          var innerTxEnvelope = innerTx.toEnvelope();
          if (innerTxEnvelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            var v0Tx = innerTxEnvelope.v0().tx();
            var v1Tx = new _xdr["default"].Transaction({
              sourceAccount: new _xdr["default"].MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),
              fee: v0Tx.fee(),
              seqNum: v0Tx.seqNum(),
              cond: _xdr["default"].Preconditions.precondTime(v0Tx.timeBounds()),
              memo: v0Tx.memo(),
              operations: v0Tx.operations(),
              ext: new _xdr["default"].TransactionExt(0)
            });
            innerTxEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
              tx: v1Tx,
              signatures: innerTxEnvelope.v0().signatures()
            }));
          }
          var feeSourceAccount;
          if (typeof feeSource === "string") {
            feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);
          } else {
            feeSourceAccount = feeSource.xdrMuxedAccount();
          }
          var tx = new _xdr["default"].FeeBumpTransaction({
            feeSource: feeSourceAccount,
            fee: _xdr["default"].Int64.fromString(base.times(innerOps + 1).toString()),
            innerTx: _xdr["default"].FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),
            ext: new _xdr["default"].FeeBumpTransactionExt(0)
          });
          var feeBumpTxEnvelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx,
            signatures: []
          });
          var envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);
          return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
        }
        /**
         * Build a {@link Transaction} or {@link FeeBumpTransaction} from an
         * xdr.TransactionEnvelope.
         *
         * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope
         *     object or base64 encoded string.
         * @param {string} networkPassphrase - The network passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September
         *     2015"), see {@link Networks}.
         *
         * @returns {Transaction|FeeBumpTransaction}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(envelope, networkPassphrase) {
          if (typeof envelope === "string") {
            envelope = _xdr["default"].TransactionEnvelope.fromXDR(envelope, "base64");
          }
          if (envelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
            return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
          }
          return new _transaction.Transaction(envelope, networkPassphrase);
        }
      }]);
    }();
    function isValidDate(d) {
      return d instanceof Date && !isNaN(d);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/network.js
var require_network3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Networks = void 0;
    var Networks = exports.Networks = {
      PUBLIC: "Public Global Stellar Network ; September 2015",
      TESTNET: "Test SDF Network ; September 2015",
      FUTURENET: "Test SDF Future Network ; October 2022",
      SANDBOX: "Local Sandbox Stellar Network ; September 2022",
      STANDALONE: "Standalone Network ; February 2017"
    };
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/soroban.js
var require_soroban3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/soroban.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Soroban = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toArray(r) {
      return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Soroban = exports.Soroban = function() {
      function Soroban2() {
        _classCallCheck(this, Soroban2);
      }
      return _createClass(Soroban2, null, [{
        key: "formatTokenAmount",
        value: (
          /**
           * Given a whole number smart contract amount of a token and an amount of
           * decimal places (if the token has any), it returns a "display" value.
           *
           * All arithmetic inside the contract is performed on integers to avoid
           * potential precision and consistency issues of floating-point.
           *
           * @param {string} amount   the token amount you want to display
           * @param {number} decimals specify how many decimal places a token has
           *
           * @returns {string} the display value
           * @throws {TypeError} if the given amount has a decimal point already
           * @example
           * formatTokenAmount("123000", 4) === "12.3";
           */
          function formatTokenAmount(amount, decimals) {
            if (amount.includes(".")) {
              throw new TypeError("No decimals are allowed");
            }
            var formatted = amount;
            if (decimals > 0) {
              if (decimals > formatted.length) {
                formatted = ["0", formatted.toString().padStart(decimals, "0")].join(".");
              } else {
                formatted = [formatted.slice(0, -decimals), formatted.slice(-decimals)].join(".");
              }
            }
            return formatted.replace(/(\.\d*?)0+$/, "$1");
          }
        )
        /**
         * Parse a token amount to use it on smart contract
         *
         * This function takes the display value and its decimals (if the token has
         * any) and returns a string that'll be used within the smart contract.
         *
         * @param {string} value      the token amount you want to use it on smart
         *    contract which you've been displaying in a UI
         * @param {number} decimals   the number of decimal places expected in the
         *    display value (different than the "actual" number, because suffix zeroes
         *    might not be present)
         *
         * @returns {string}  the whole number token amount represented by the display
         *    value with the decimal places shifted over
         *
         * @example
         * const displayValueAmount = "123.4560"
         * const parsedAmtForSmartContract = parseTokenAmount(displayValueAmount, 5);
         * parsedAmtForSmartContract === "12345600"
         */
      }, {
        key: "parseTokenAmount",
        value: function parseTokenAmount(value, decimals) {
          var _fraction$padEnd;
          var _value$split$slice = value.split(".").slice(), _value$split$slice2 = _toArray(_value$split$slice), whole = _value$split$slice2[0], fraction = _value$split$slice2[1], rest = _value$split$slice2.slice(2);
          if (rest.length) {
            throw new Error("Invalid decimal value: ".concat(value));
          }
          var shifted = BigInt(whole + ((_fraction$padEnd = fraction === null || fraction === void 0 ? void 0 : fraction.padEnd(decimals, "0")) !== null && _fraction$padEnd !== void 0 ? _fraction$padEnd : "0".repeat(decimals)));
          return shifted.toString();
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/contract.js
var require_contract5 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Contract = void 0;
    var _address = require_address3();
    var _operation = require_operation3();
    var _xdr = _interopRequireDefault(require_xdr4());
    var _strkey = require_strkey3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Contract = exports.Contract = function() {
      function Contract2(contractId) {
        _classCallCheck(this, Contract2);
        try {
          this._id = _strkey.StrKey.decodeContract(contractId);
        } catch (_) {
          throw new Error("Invalid contract ID: ".concat(contractId));
        }
      }
      return _createClass(Contract2, [{
        key: "contractId",
        value: function contractId() {
          return _strkey.StrKey.encodeContract(this._id);
        }
        /** @returns {string} the ID as a strkey (C...) */
      }, {
        key: "toString",
        value: function toString() {
          return this.contractId();
        }
        /** @returns {Address} the wrapped address of this contract */
      }, {
        key: "address",
        value: function address() {
          return _address.Address.contract(this._id);
        }
        /**
         * Returns an operation that will invoke this contract call.
         *
         * @param {string}        method   name of the method to call
         * @param {...xdr.ScVal}  params   arguments to pass to the function call
         *
         * @returns {xdr.Operation}   an InvokeHostFunctionOp operation to call the
         *    contract with the given method and parameters
         *
         * @see Operation.invokeHostFunction
         * @see Operation.invokeContractFunction
         * @see Operation.createCustomContract
         * @see Operation.createStellarAssetContract
         * @see Operation.uploadContractWasm
         */
      }, {
        key: "call",
        value: function call(method) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          return _operation.Operation.invokeContractFunction({
            contract: this.address().toString(),
            "function": method,
            args: params
          });
        }
        /**
         * Returns the read-only footprint entries necessary for any invocations to
         * this contract, for convenience when manually adding it to your
         * transaction's overall footprint or doing bump/restore operations.
         *
         * @returns {xdr.LedgerKey} the ledger key for the deployed contract instance
         */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
            contract: this.address().toScAddress(),
            key: _xdr["default"].ScVal.scvLedgerKeyContractInstance(),
            durability: _xdr["default"].ContractDataDurability.persistent()
          }));
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint128.js
var require_uint1283 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint128.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint128 = exports.Uint128 = function(_LargeInt) {
      function Uint1282() {
        _classCallCheck(this, Uint1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint1282, [args]);
      }
      _inherits(Uint1282, _LargeInt);
      return _createClass(Uint1282, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint128.defineIntBoundaries();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint256.js
var require_uint2563 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint256.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint256 = exports.Uint256 = function(_LargeInt) {
      function Uint2562() {
        _classCallCheck(this, Uint2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint2562, [args]);
      }
      _inherits(Uint2562, _LargeInt);
      return _createClass(Uint2562, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint256.defineIntBoundaries();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/int128.js
var require_int1283 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/int128.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int128 = exports.Int128 = function(_LargeInt) {
      function Int1282() {
        _classCallCheck(this, Int1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int1282, [args]);
      }
      _inherits(Int1282, _LargeInt);
      return _createClass(Int1282, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int128.defineIntBoundaries();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/int256.js
var require_int2563 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/int256.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int256 = exports.Int256 = function(_LargeInt) {
      function Int2562() {
        _classCallCheck(this, Int2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int2562, [args]);
      }
      _inherits(Int2562, _LargeInt);
      return _createClass(Int2562, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int256.defineIntBoundaries();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js
var require_xdr_large_int3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.XdrLargeInt = void 0;
    var _jsXdr = require_xdr();
    var _uint = require_uint1283();
    var _uint2 = require_uint2563();
    var _int = require_int1283();
    var _int2 = require_int2563();
    var _xdr = _interopRequireDefault(require_xdr4());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var XdrLargeInt = exports.XdrLargeInt = function() {
      function XdrLargeInt2(type, values) {
        _classCallCheck(this, XdrLargeInt2);
        _defineProperty(this, "int", void 0);
        _defineProperty(this, "type", void 0);
        if (!(values instanceof Array)) {
          values = [values];
        }
        values = values.map(function(i) {
          if (typeof i === "bigint") {
            return i;
          }
          if (i instanceof XdrLargeInt2) {
            return i.toBigInt();
          }
          return BigInt(i);
        });
        switch (type) {
          case "i64":
            this["int"] = new _jsXdr.Hyper(values);
            break;
          case "i128":
            this["int"] = new _int.Int128(values);
            break;
          case "i256":
            this["int"] = new _int2.Int256(values);
            break;
          case "u64":
            this["int"] = new _jsXdr.UnsignedHyper(values);
            break;
          case "u128":
            this["int"] = new _uint.Uint128(values);
            break;
          case "u256":
            this["int"] = new _uint2.Uint256(values);
            break;
          default:
            throw TypeError("invalid type: ".concat(type));
        }
        this.type = type;
      }
      return _createClass(XdrLargeInt2, [{
        key: "toNumber",
        value: function toNumber() {
          var bi = this["int"].toBigInt();
          if (bi > Number.MAX_SAFE_INTEGER || bi < Number.MIN_SAFE_INTEGER) {
            throw RangeError("value ".concat(bi, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
          }
          return Number(bi);
        }
        /** @returns {bigint} */
      }, {
        key: "toBigInt",
        value: function toBigInt() {
          return this["int"].toBigInt();
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I64` */
      }, {
        key: "toI64",
        value: function toI64() {
          this._sizeCheck(64);
          var v = this.toBigInt();
          if (BigInt.asIntN(64, v) !== v) {
            throw RangeError("value too large for i64: ".concat(v));
          }
          return _xdr["default"].ScVal.scvI64(new _xdr["default"].Int64(v));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U64` */
      }, {
        key: "toU64",
        value: function toU64() {
          this._sizeCheck(64);
          return _xdr["default"].ScVal.scvU64(
            new _xdr["default"].Uint64(BigInt.asUintN(64, this.toBigInt()))
            // reiterpret as unsigned
          );
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = I128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toI128",
        value: function toI128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          var hi64 = BigInt.asIntN(64, v >> 64n);
          var lo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI128(new _xdr["default"].Int128Parts({
            hi: new _xdr["default"].Int64(hi64),
            lo: new _xdr["default"].Uint64(lo64)
          }));
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = U128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toU128",
        value: function toU128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          return _xdr["default"].ScVal.scvU128(new _xdr["default"].UInt128Parts({
            hi: new _xdr["default"].Uint64(BigInt.asUintN(64, v >> 64n)),
            lo: new _xdr["default"].Uint64(BigInt.asUintN(64, v))
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I256` */
      }, {
        key: "toI256",
        value: function toI256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asIntN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI256(new _xdr["default"].Int256Parts({
            hiHi: new _xdr["default"].Int64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U256` */
      }, {
        key: "toU256",
        value: function toU256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asUintN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvU256(new _xdr["default"].UInt256Parts({
            hiHi: new _xdr["default"].Uint64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the smallest interpretation of the stored value */
      }, {
        key: "toScVal",
        value: function toScVal() {
          switch (this.type) {
            case "i64":
              return this.toI64();
            case "i128":
              return this.toI128();
            case "i256":
              return this.toI256();
            case "u64":
              return this.toU64();
            case "u128":
              return this.toU128();
            case "u256":
              return this.toU256();
            default:
              throw TypeError("invalid type: ".concat(this.type));
          }
        }
      }, {
        key: "valueOf",
        value: function valueOf() {
          return this["int"].valueOf();
        }
      }, {
        key: "toString",
        value: function toString() {
          return this["int"].toString();
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            value: this.toBigInt().toString(),
            type: this.type
          };
        }
      }, {
        key: "_sizeCheck",
        value: function _sizeCheck(bits) {
          if (this["int"].size > bits) {
            throw RangeError("value too large for ".concat(bits, " bits (").concat(this.type, ")"));
          }
        }
      }], [{
        key: "isType",
        value: function isType(type) {
          switch (type) {
            case "i64":
            case "i128":
            case "i256":
            case "u64":
            case "u128":
            case "u256":
              return true;
            default:
              return false;
          }
        }
        /**
         * Convert the raw `ScValType` string (e.g. 'scvI128', generated by the XDR)
         * to a type description for {@link XdrLargeInt} construction (e.g. 'i128')
         *
         * @param {string} scvType  the `xdr.ScValType` as a string
         * @returns {string} a suitable equivalent type to construct this object
         */
      }, {
        key: "getType",
        value: function getType(scvType) {
          return scvType.slice(3).toLowerCase();
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js
var require_sc_int3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScInt = void 0;
    var _xdr_large_int = require_xdr_large_int3();
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var ScInt = exports.ScInt = function(_XdrLargeInt) {
      function ScInt2(value, opts) {
        var _opts$type;
        _classCallCheck(this, ScInt2);
        var signed = value < 0;
        var type = (_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "";
        if (type.startsWith("u") && signed) {
          throw TypeError("specified type ".concat(opts.type, " yet negative (").concat(value, ")"));
        }
        if (type === "") {
          type = signed ? "i" : "u";
          var bitlen = nearestBigIntSize(value);
          switch (bitlen) {
            case 64:
            case 128:
            case 256:
              type += bitlen.toString();
              break;
            default:
              throw RangeError("expected 64/128/256 bits for input (".concat(value, "), got ").concat(bitlen));
          }
        }
        return _callSuper(this, ScInt2, [type, value]);
      }
      _inherits(ScInt2, _XdrLargeInt);
      return _createClass(ScInt2);
    }(_xdr_large_int.XdrLargeInt);
    function nearestBigIntSize(bigI) {
      var _find;
      var bitlen = bigI.toString(2).length;
      return (_find = [64, 128, 256].find(function(len) {
        return bitlen <= len;
      })) !== null && _find !== void 0 ? _find : bitlen;
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/index.js
var require_numbers3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/numbers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Int128", {
      enumerable: true,
      get: function get() {
        return _int.Int128;
      }
    });
    Object.defineProperty(exports, "Int256", {
      enumerable: true,
      get: function get() {
        return _int2.Int256;
      }
    });
    Object.defineProperty(exports, "ScInt", {
      enumerable: true,
      get: function get() {
        return _sc_int.ScInt;
      }
    });
    Object.defineProperty(exports, "Uint128", {
      enumerable: true,
      get: function get() {
        return _uint.Uint128;
      }
    });
    Object.defineProperty(exports, "Uint256", {
      enumerable: true,
      get: function get() {
        return _uint2.Uint256;
      }
    });
    Object.defineProperty(exports, "XdrLargeInt", {
      enumerable: true,
      get: function get() {
        return _xdr_large_int.XdrLargeInt;
      }
    });
    exports.scValToBigInt = scValToBigInt;
    var _xdr_large_int = require_xdr_large_int3();
    var _uint = require_uint1283();
    var _uint2 = require_uint2563();
    var _int = require_int1283();
    var _int2 = require_int2563();
    var _sc_int = require_sc_int3();
    function scValToBigInt(scv) {
      var scIntType = _xdr_large_int.XdrLargeInt.getType(scv["switch"]().name);
      switch (scv["switch"]().name) {
        case "scvU32":
        case "scvI32":
          return BigInt(scv.value());
        case "scvU64":
        case "scvI64":
          return new _xdr_large_int.XdrLargeInt(scIntType, scv.value()).toBigInt();
        case "scvU128":
        case "scvI128":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().lo(), scv.value().hi()]).toBigInt();
        case "scvU256":
        case "scvI256":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().loLo(), scv.value().loHi(), scv.value().hiLo(), scv.value().hiHi()]).toBigInt();
        default:
          throw TypeError("expected integer type, got ".concat(scv["switch"]()));
      }
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/scval.js
var require_scval3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/scval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nativeToScVal = nativeToScVal;
    exports.scValToNative = scValToNative;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _address = require_address3();
    var _contract = require_contract5();
    var _index = require_numbers3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function nativeToScVal(val) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      switch (_typeof(val)) {
        case "object": {
          var _val$constructor$name, _val$constructor;
          if (val === null) {
            return _xdr["default"].ScVal.scvVoid();
          }
          if (val instanceof _xdr["default"].ScVal) {
            return val;
          }
          if (val instanceof _address.Address) {
            return val.toScVal();
          }
          if (val instanceof _keypair.Keypair) {
            return nativeToScVal(val.publicKey(), {
              type: "address"
            });
          }
          if (val instanceof _contract.Contract) {
            return val.address().toScVal();
          }
          if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
            var _opts$type;
            var copy = Uint8Array.from(val);
            switch ((_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "bytes") {
              case "bytes":
                return _xdr["default"].ScVal.scvBytes(copy);
              case "symbol":
                return _xdr["default"].ScVal.scvSymbol(copy);
              case "string":
                return _xdr["default"].ScVal.scvString(copy);
              default:
                throw new TypeError("invalid type (".concat(opts.type, ") specified for bytes-like value"));
            }
          }
          if (Array.isArray(val)) {
            return _xdr["default"].ScVal.scvVec(val.map(function(v) {
              return nativeToScVal(v, opts);
            }));
          }
          if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
            var _val$constructor2;
            throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
          }
          return _xdr["default"].ScVal.scvMap(Object.entries(val).sort(function(_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
            var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
            return key1.localeCompare(key2);
          }).map(function(_ref5) {
            var _k, _opts$type2;
            var _ref6 = _slicedToArray(_ref5, 2), k = _ref6[0], v = _ref6[1];
            var _ref7 = (_k = ((_opts$type2 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type2 !== void 0 ? _opts$type2 : {})[k]) !== null && _k !== void 0 ? _k : [null, null], _ref8 = _slicedToArray(_ref7, 2), keyType = _ref8[0], valType = _ref8[1];
            var keyOpts = keyType ? {
              type: keyType
            } : {};
            var valOpts = valType ? {
              type: valType
            } : {};
            return new _xdr["default"].ScMapEntry({
              key: nativeToScVal(k, keyOpts),
              val: nativeToScVal(v, valOpts)
            });
          }));
        }
        case "number":
        case "bigint":
          switch (opts === null || opts === void 0 ? void 0 : opts.type) {
            case "u32":
              return _xdr["default"].ScVal.scvU32(val);
            case "i32":
              return _xdr["default"].ScVal.scvI32(val);
            default:
              break;
          }
          return new _index.ScInt(val, {
            type: opts === null || opts === void 0 ? void 0 : opts.type
          }).toScVal();
        case "string": {
          var _opts$type3;
          var optType = (_opts$type3 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type3 !== void 0 ? _opts$type3 : "string";
          switch (optType) {
            case "string":
              return _xdr["default"].ScVal.scvString(val);
            case "symbol":
              return _xdr["default"].ScVal.scvSymbol(val);
            case "address":
              return new _address.Address(val).toScVal();
            case "u32":
              return _xdr["default"].ScVal.scvU32(parseInt(val, 10));
            case "i32":
              return _xdr["default"].ScVal.scvI32(parseInt(val, 10));
            default:
              if (_index.XdrLargeInt.isType(optType)) {
                return new _index.XdrLargeInt(optType, val).toScVal();
              }
              throw new TypeError("invalid type (".concat(opts.type, ") specified for string value"));
          }
        }
        case "boolean":
          return _xdr["default"].ScVal.scvBool(val);
        case "undefined":
          return _xdr["default"].ScVal.scvVoid();
        case "function":
          return nativeToScVal(val());
        default:
          throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
      }
    }
    function scValToNative(scv) {
      var _scv$vec, _scv$map;
      switch (scv["switch"]().value) {
        case _xdr["default"].ScValType.scvVoid().value:
          return null;
        case _xdr["default"].ScValType.scvU64().value:
        case _xdr["default"].ScValType.scvI64().value:
          return scv.value().toBigInt();
        case _xdr["default"].ScValType.scvU128().value:
        case _xdr["default"].ScValType.scvI128().value:
        case _xdr["default"].ScValType.scvU256().value:
        case _xdr["default"].ScValType.scvI256().value:
          return (0, _index.scValToBigInt)(scv);
        case _xdr["default"].ScValType.scvVec().value:
          return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(scValToNative);
        case _xdr["default"].ScValType.scvAddress().value:
          return _address.Address.fromScVal(scv).toString();
        case _xdr["default"].ScValType.scvMap().value:
          return Object.fromEntries(((_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : []).map(function(entry) {
            return [scValToNative(entry.key()), scValToNative(entry.val())];
          }));
        case _xdr["default"].ScValType.scvBool().value:
        case _xdr["default"].ScValType.scvU32().value:
        case _xdr["default"].ScValType.scvI32().value:
        case _xdr["default"].ScValType.scvBytes().value:
          return scv.value();
        case _xdr["default"].ScValType.scvSymbol().value:
        case _xdr["default"].ScValType.scvString().value: {
          var v = scv.value();
          if (Buffer.isBuffer(v) || ArrayBuffer.isView(v)) {
            try {
              return new TextDecoder().decode(v);
            } catch (e) {
              return new Uint8Array(v.buffer);
            }
          }
          return v;
        }
        case _xdr["default"].ScValType.scvTimepoint().value:
        case _xdr["default"].ScValType.scvDuration().value:
          return new _xdr["default"].Uint64(scv.value()).toBigInt();
        case _xdr["default"].ScValType.scvError().value:
          switch (scv.error()["switch"]().value) {
            case _xdr["default"].ScErrorType.sceContract().value:
              return {
                type: "contract",
                code: scv.error().contractCode()
              };
            default: {
              var err = scv.error();
              return {
                type: "system",
                code: err.code().value,
                value: err.code().name
              };
            }
          }
        default:
          return scv.value();
      }
    }
    _xdr["default"].scvSortedMap = function(items) {
      var sorted = Array.from(items).sort(function(a, b) {
        var nativeA = scValToNative(a.key());
        var nativeB = scValToNative(b.key());
        switch (_typeof(nativeA)) {
          case "number":
          case "bigint":
            return nativeA < nativeB ? -1 : 1;
          default:
            return nativeA.toString().localeCompare(nativeB.toString());
        }
      });
      return _xdr["default"].ScVal.scvMap(sorted);
    };
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/events.js
var require_events3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.humanizeEvents = humanizeEvents;
    var _strkey = require_strkey3();
    var _scval = require_scval3();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function humanizeEvents(events) {
      return events.map(function(e) {
        if (e.inSuccessfulContractCall) {
          return extractEvent(e.event());
        }
        return extractEvent(e);
      });
    }
    function extractEvent(event) {
      return _objectSpread(_objectSpread({}, typeof event.contractId === "function" && event.contractId() != null && {
        contractId: _strkey.StrKey.encodeContract(event.contractId())
      }), {}, {
        type: event.type().name,
        topics: event.body().value().topics().map(function(t) {
          return (0, _scval.scValToNative)(t);
        }),
        data: (0, _scval.scValToNative)(event.body().value().data())
      });
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/auth.js
var require_auth3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.authorizeEntry = authorizeEntry;
    exports.authorizeInvocation = authorizeInvocation;
    var _xdr = _interopRequireDefault(require_xdr4());
    var _keypair = require_keypair3();
    var _strkey = require_strkey3();
    var _network = require_network3();
    var _hashing = require_hashing3();
    var _address = require_address3();
    var _scval = require_scval3();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, "catch": function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function authorizeEntry(_x, _x2, _x3) {
      return _authorizeEntry.apply(this, arguments);
    }
    function _authorizeEntry() {
      _authorizeEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(entry, signer, validUntilLedgerSeq) {
        var networkPassphrase, clone, addrAuth, networkId, preimage, payload, signature, publicKey, sigResult, sigScVal, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              networkPassphrase = _args.length > 3 && _args[3] !== void 0 ? _args[3] : _network.Networks.FUTURENET;
              if (!(entry.credentials()["switch"]().value !== _xdr["default"].SorobanCredentialsType.sorobanCredentialsAddress().value)) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", entry);
            case 3:
              clone = _xdr["default"].SorobanAuthorizationEntry.fromXDR(entry.toXDR());
              addrAuth = clone.credentials().address();
              addrAuth.signatureExpirationLedger(validUntilLedgerSeq);
              networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
              preimage = _xdr["default"].HashIdPreimage.envelopeTypeSorobanAuthorization(new _xdr["default"].HashIdPreimageSorobanAuthorization({
                networkId,
                nonce: addrAuth.nonce(),
                invocation: clone.rootInvocation(),
                signatureExpirationLedger: addrAuth.signatureExpirationLedger()
              }));
              payload = (0, _hashing.hash)(preimage.toXDR());
              if (!(typeof signer === "function")) {
                _context.next = 16;
                break;
              }
              _context.next = 12;
              return signer(preimage);
            case 12:
              sigResult = _context.sent;
              if (sigResult !== null && sigResult !== void 0 && sigResult.signature) {
                signature = Buffer.from(sigResult.signature);
                publicKey = sigResult.publicKey;
              } else {
                signature = Buffer.from(sigResult);
                publicKey = _address.Address.fromScAddress(addrAuth.address()).toString();
              }
              _context.next = 18;
              break;
            case 16:
              signature = Buffer.from(signer.sign(payload));
              publicKey = signer.publicKey();
            case 18:
              if (_keypair.Keypair.fromPublicKey(publicKey).verify(payload, signature)) {
                _context.next = 20;
                break;
              }
              throw new Error("signature doesn't match payload");
            case 20:
              sigScVal = (0, _scval.nativeToScVal)({
                public_key: _strkey.StrKey.decodeEd25519PublicKey(publicKey),
                signature
              }, {
                type: {
                  public_key: ["symbol", null],
                  signature: ["symbol", null]
                }
              });
              addrAuth.signature(_xdr["default"].ScVal.scvVec([sigScVal]));
              return _context.abrupt("return", clone);
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _authorizeEntry.apply(this, arguments);
    }
    function authorizeInvocation(signer, validUntilLedgerSeq, invocation) {
      var publicKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var networkPassphrase = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : _network.Networks.FUTURENET;
      var kp = _keypair.Keypair.random().rawPublicKey();
      var nonce = new _xdr["default"].Int64(bytesToInt64(kp));
      var pk = publicKey || signer.publicKey();
      if (!pk) {
        throw new Error("authorizeInvocation requires publicKey parameter");
      }
      var entry = new _xdr["default"].SorobanAuthorizationEntry({
        rootInvocation: invocation,
        credentials: _xdr["default"].SorobanCredentials.sorobanCredentialsAddress(new _xdr["default"].SorobanAddressCredentials({
          address: new _address.Address(pk).toScAddress(),
          nonce,
          signatureExpirationLedger: 0,
          // replaced
          signature: _xdr["default"].ScVal.scvVec([])
          // replaced
        }))
      });
      return authorizeEntry(entry, signer, validUntilLedgerSeq, networkPassphrase);
    }
    function bytesToInt64(bytes) {
      return bytes.subarray(0, 8).reduce(function(accum, b) {
        return accum << 8 | b;
      }, 0);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/invocation.js
var require_invocation3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/invocation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildInvocationTree = buildInvocationTree;
    exports.walkInvocationTree = walkInvocationTree;
    var _asset = require_asset3();
    var _address = require_address3();
    var _scval = require_scval3();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function buildInvocationTree(root) {
      var fn = root["function"]();
      var output = {};
      var inner = fn.value();
      switch (fn["switch"]().value) {
        case 0:
          output.type = "execute";
          output.args = {
            source: _address.Address.fromScAddress(inner.contractAddress()).toString(),
            "function": inner.functionName(),
            args: inner.args().map(function(arg) {
              return (0, _scval.scValToNative)(arg);
            })
          };
          break;
        case 1:
        case 2: {
          var createV2 = fn["switch"]().value === 2;
          output.type = "create";
          output.args = {};
          var _ref = [inner.executable(), inner.contractIdPreimage()], exec = _ref[0], preimage = _ref[1];
          if (!!exec["switch"]().value !== !!preimage["switch"]().value) {
            throw new Error("creation function appears invalid: ".concat(JSON.stringify(inner), " (should be wasm+address or token+asset)"));
          }
          switch (exec["switch"]().value) {
            case 0: {
              var details = preimage.fromAddress();
              output.args.type = "wasm";
              output.args.wasm = _objectSpread({
                salt: details.salt().toString("hex"),
                hash: exec.wasmHash().toString("hex"),
                address: _address.Address.fromScAddress(details.address()).toString()
              }, createV2 && {
                constructorArgs: inner.constructorArgs().map(function(arg) {
                  return (0, _scval.scValToNative)(arg);
                })
              });
              break;
            }
            case 1:
              output.args.type = "sac";
              output.args.asset = _asset.Asset.fromOperation(preimage.fromAsset()).toString();
              break;
            default:
              throw new Error("unknown creation type: ".concat(JSON.stringify(exec)));
          }
          break;
        }
        default:
          throw new Error("unknown invocation type (".concat(fn["switch"](), "): ").concat(JSON.stringify(fn)));
      }
      output.invocations = root.subInvocations().map(function(i) {
        return buildInvocationTree(i);
      });
      return output;
    }
    function walkInvocationTree(root, callback) {
      walkHelper(root, 1, callback);
    }
    function walkHelper(node, depth, callback, parent) {
      if (callback(node, depth, parent) === false) {
        return;
      }
      node.subInvocations().forEach(function(i) {
        return walkHelper(i, depth + 1, callback, node);
      });
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-base/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      xdr: true,
      cereal: true,
      hash: true,
      sign: true,
      verify: true,
      FastSigning: true,
      getLiquidityPoolId: true,
      LiquidityPoolFeeV18: true,
      Keypair: true,
      UnsignedHyper: true,
      Hyper: true,
      TransactionBase: true,
      Transaction: true,
      FeeBumpTransaction: true,
      TransactionBuilder: true,
      TimeoutInfinite: true,
      BASE_FEE: true,
      Asset: true,
      LiquidityPoolAsset: true,
      LiquidityPoolId: true,
      Operation: true,
      AuthRequiredFlag: true,
      AuthRevocableFlag: true,
      AuthImmutableFlag: true,
      AuthClawbackEnabledFlag: true,
      Account: true,
      MuxedAccount: true,
      Claimant: true,
      Networks: true,
      StrKey: true,
      SignerKey: true,
      Soroban: true,
      decodeAddressToMuxedAccount: true,
      encodeMuxedAccountToAddress: true,
      extractBaseAddress: true,
      encodeMuxedAccount: true,
      Contract: true,
      Address: true
    };
    Object.defineProperty(exports, "Account", {
      enumerable: true,
      get: function get() {
        return _account.Account;
      }
    });
    Object.defineProperty(exports, "Address", {
      enumerable: true,
      get: function get() {
        return _address.Address;
      }
    });
    Object.defineProperty(exports, "Asset", {
      enumerable: true,
      get: function get() {
        return _asset.Asset;
      }
    });
    Object.defineProperty(exports, "AuthClawbackEnabledFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthClawbackEnabledFlag;
      }
    });
    Object.defineProperty(exports, "AuthImmutableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthImmutableFlag;
      }
    });
    Object.defineProperty(exports, "AuthRequiredFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRequiredFlag;
      }
    });
    Object.defineProperty(exports, "AuthRevocableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRevocableFlag;
      }
    });
    Object.defineProperty(exports, "BASE_FEE", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.BASE_FEE;
      }
    });
    Object.defineProperty(exports, "Claimant", {
      enumerable: true,
      get: function get() {
        return _claimant.Claimant;
      }
    });
    Object.defineProperty(exports, "Contract", {
      enumerable: true,
      get: function get() {
        return _contract.Contract;
      }
    });
    Object.defineProperty(exports, "FastSigning", {
      enumerable: true,
      get: function get() {
        return _signing.FastSigning;
      }
    });
    Object.defineProperty(exports, "FeeBumpTransaction", {
      enumerable: true,
      get: function get() {
        return _fee_bump_transaction.FeeBumpTransaction;
      }
    });
    Object.defineProperty(exports, "Hyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.Hyper;
      }
    });
    Object.defineProperty(exports, "Keypair", {
      enumerable: true,
      get: function get() {
        return _keypair.Keypair;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolAsset", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_asset.LiquidityPoolAsset;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolFeeV18", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.LiquidityPoolFeeV18;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_id.LiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "MuxedAccount", {
      enumerable: true,
      get: function get() {
        return _muxed_account.MuxedAccount;
      }
    });
    Object.defineProperty(exports, "Networks", {
      enumerable: true,
      get: function get() {
        return _network.Networks;
      }
    });
    Object.defineProperty(exports, "Operation", {
      enumerable: true,
      get: function get() {
        return _operation.Operation;
      }
    });
    Object.defineProperty(exports, "SignerKey", {
      enumerable: true,
      get: function get() {
        return _signerkey.SignerKey;
      }
    });
    Object.defineProperty(exports, "Soroban", {
      enumerable: true,
      get: function get() {
        return _soroban.Soroban;
      }
    });
    Object.defineProperty(exports, "StrKey", {
      enumerable: true,
      get: function get() {
        return _strkey.StrKey;
      }
    });
    Object.defineProperty(exports, "TimeoutInfinite", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TimeoutInfinite;
      }
    });
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function get() {
        return _transaction.Transaction;
      }
    });
    Object.defineProperty(exports, "TransactionBase", {
      enumerable: true,
      get: function get() {
        return _transaction_base.TransactionBase;
      }
    });
    Object.defineProperty(exports, "TransactionBuilder", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TransactionBuilder;
      }
    });
    Object.defineProperty(exports, "UnsignedHyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.UnsignedHyper;
      }
    });
    Object.defineProperty(exports, "cereal", {
      enumerable: true,
      get: function get() {
        return _jsxdr["default"];
      }
    });
    Object.defineProperty(exports, "decodeAddressToMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.decodeAddressToMuxedAccount;
      }
    });
    exports["default"] = void 0;
    Object.defineProperty(exports, "encodeMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccount;
      }
    });
    Object.defineProperty(exports, "encodeMuxedAccountToAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccountToAddress;
      }
    });
    Object.defineProperty(exports, "extractBaseAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.extractBaseAddress;
      }
    });
    Object.defineProperty(exports, "getLiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.getLiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "hash", {
      enumerable: true,
      get: function get() {
        return _hashing.hash;
      }
    });
    Object.defineProperty(exports, "sign", {
      enumerable: true,
      get: function get() {
        return _signing.sign;
      }
    });
    Object.defineProperty(exports, "verify", {
      enumerable: true,
      get: function get() {
        return _signing.verify;
      }
    });
    Object.defineProperty(exports, "xdr", {
      enumerable: true,
      get: function get() {
        return _xdr["default"];
      }
    });
    var _xdr = _interopRequireDefault(require_xdr4());
    var _jsxdr = _interopRequireDefault(require_jsxdr3());
    var _hashing = require_hashing3();
    var _signing = require_signing3();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id3();
    var _keypair = require_keypair3();
    var _jsXdr = require_xdr();
    var _transaction_base = require_transaction_base3();
    var _transaction = require_transaction5();
    var _fee_bump_transaction = require_fee_bump_transaction3();
    var _transaction_builder = require_transaction_builder3();
    var _asset = require_asset3();
    var _liquidity_pool_asset = require_liquidity_pool_asset3();
    var _liquidity_pool_id = require_liquidity_pool_id3();
    var _operation = require_operation3();
    var _memo = require_memo3();
    Object.keys(_memo).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _memo[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _memo[key];
        }
      });
    });
    var _account = require_account3();
    var _muxed_account = require_muxed_account3();
    var _claimant = require_claimant3();
    var _network = require_network3();
    var _strkey = require_strkey3();
    var _signerkey = require_signerkey3();
    var _soroban = require_soroban3();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account3();
    var _contract = require_contract5();
    var _address = require_address3();
    var _numbers = require_numbers3();
    Object.keys(_numbers).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _numbers[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _numbers[key];
        }
      });
    });
    var _scval = require_scval3();
    Object.keys(_scval).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _scval[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _scval[key];
        }
      });
    });
    var _events = require_events3();
    Object.keys(_events).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _events[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _events[key];
        }
      });
    });
    var _sorobandata_builder = require_sorobandata_builder3();
    Object.keys(_sorobandata_builder).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _sorobandata_builder[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sorobandata_builder[key];
        }
      });
    });
    var _auth = require_auth3();
    Object.keys(_auth).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _auth[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _auth[key];
        }
      });
    });
    var _invocation = require_invocation3();
    Object.keys(_invocation).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _invocation[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _invocation[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = module.exports;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/api.js
var require_api3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Api = void 0;
    var Api;
    (function(_Api) {
      var GetTransactionStatus = function(GetTransactionStatus2) {
        GetTransactionStatus2["SUCCESS"] = "SUCCESS";
        GetTransactionStatus2["NOT_FOUND"] = "NOT_FOUND";
        GetTransactionStatus2["FAILED"] = "FAILED";
        return GetTransactionStatus2;
      }({});
      _Api.GetTransactionStatus = GetTransactionStatus;
      function isSimulationError(sim) {
        return "error" in sim;
      }
      _Api.isSimulationError = isSimulationError;
      function isSimulationSuccess(sim) {
        return "transactionData" in sim;
      }
      _Api.isSimulationSuccess = isSimulationSuccess;
      function isSimulationRestore(sim) {
        return isSimulationSuccess(sim) && "restorePreamble" in sim && !!sim.restorePreamble.transactionData;
      }
      _Api.isSimulationRestore = isSimulationRestore;
      function isSimulationRaw(sim) {
        return !sim._parsed;
      }
      _Api.isSimulationRaw = isSimulationRaw;
    })(Api || (exports.Api = Api = {}));
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/types.js
var require_types5 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CancelToken = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var CancelToken = exports.CancelToken = function() {
      function CancelToken2(executor) {
        var _this = this;
        _classCallCheck(this, CancelToken2);
        var resolvePromise;
        this.promise = new Promise(function(resolve) {
          resolvePromise = resolve;
        });
        executor(function(reason) {
          _this.reason = reason;
          resolvePromise();
        });
      }
      return _createClass(CancelToken2, [{
        key: "throwIfRequested",
        value: function throwIfRequested() {
          if (this.reason) {
            throw new Error(this.reason);
          }
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/fetch-client.js
var require_fetch_client3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/fetch-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.create = createFetchClient;
    exports.fetchClient = void 0;
    var _feaxios = _interopRequireDefault(require_dist());
    var _types = require_types5();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var InterceptorManager = function() {
      function InterceptorManager2() {
        _classCallCheck(this, InterceptorManager2);
        _defineProperty(this, "handlers", []);
      }
      return _createClass(InterceptorManager2, [{
        key: "use",
        value: function use(fulfilled, rejected) {
          this.handlers.push({
            fulfilled,
            rejected
          });
          return this.handlers.length - 1;
        }
      }, {
        key: "eject",
        value: function eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          this.handlers.forEach(function(h) {
            if (h !== null) {
              fn(h);
            }
          });
        }
      }]);
    }();
    function getFormConfig(config) {
      var formConfig = config || {};
      formConfig.headers = new Headers(formConfig.headers || {});
      formConfig.headers.set("Content-Type", "application/x-www-form-urlencoded");
      return formConfig;
    }
    function createFetchClient() {
      var fetchConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = _objectSpread(_objectSpread({}, fetchConfig), {}, {
        headers: fetchConfig.headers || {}
      });
      var instance = _feaxios.default.create(defaults);
      var requestInterceptors = new InterceptorManager();
      var responseInterceptors = new InterceptorManager();
      var httpClient = {
        interceptors: {
          request: requestInterceptors,
          response: responseInterceptors
        },
        defaults: _objectSpread(_objectSpread({}, defaults), {}, {
          adapter: function adapter(config) {
            return instance.request(config);
          }
        }),
        create: function create(config) {
          return createFetchClient(_objectSpread(_objectSpread({}, this.defaults), config));
        },
        makeRequest: function makeRequest(config) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var abortController = new AbortController();
            config.signal = abortController.signal;
            if (config.cancelToken) {
              config.cancelToken.promise.then(function() {
                abortController.abort();
                reject(new Error("Request canceled"));
              });
            }
            var modifiedConfig = config;
            if (requestInterceptors.handlers.length > 0) {
              var chain = requestInterceptors.handlers.filter(function(interceptor) {
                return interceptor !== null;
              }).flatMap(function(interceptor) {
                return [interceptor.fulfilled, interceptor.rejected];
              });
              for (var i = 0, len = chain.length; i < len; i += 2) {
                var onFulfilled = chain[i];
                var onRejected = chain[i + 1];
                try {
                  if (onFulfilled) modifiedConfig = onFulfilled(modifiedConfig);
                } catch (error) {
                  if (onRejected) onRejected === null || onRejected === void 0 || onRejected(error);
                  reject(error);
                  return;
                }
              }
            }
            var adapter = modifiedConfig.adapter || _this.defaults.adapter;
            if (!adapter) {
              throw new Error("No adapter available");
            }
            var responsePromise = adapter(modifiedConfig).then(function(axiosResponse) {
              var httpClientResponse = {
                data: axiosResponse.data,
                headers: axiosResponse.headers,
                config: axiosResponse.config,
                status: axiosResponse.status,
                statusText: axiosResponse.statusText
              };
              return httpClientResponse;
            });
            if (responseInterceptors.handlers.length > 0) {
              var _chain = responseInterceptors.handlers.filter(function(interceptor) {
                return interceptor !== null;
              }).flatMap(function(interceptor) {
                return [interceptor.fulfilled, interceptor.rejected];
              });
              var _loop = function _loop2(_i2) {
                responsePromise = responsePromise.then(function(response) {
                  var fulfilledInterceptor = _chain[_i2];
                  if (typeof fulfilledInterceptor === "function") {
                    return fulfilledInterceptor(response);
                  }
                  return response;
                }, function(error) {
                  var rejectedInterceptor = _chain[_i2 + 1];
                  if (typeof rejectedInterceptor === "function") {
                    return rejectedInterceptor(error);
                  }
                  throw error;
                }).then(function(interceptedResponse) {
                  return interceptedResponse;
                });
              };
              for (var _i = 0, _len = _chain.length; _i < _len; _i += 2) {
                _loop(_i);
              }
            }
            responsePromise.then(resolve).catch(reject);
          });
        },
        get: function get(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "get"
          }));
        },
        delete: function _delete(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "delete"
          }));
        },
        head: function head(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "head"
          }));
        },
        options: function options(url, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "options"
          }));
        },
        post: function post(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "post",
            data
          }));
        },
        put: function put(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "put",
            data
          }));
        },
        patch: function patch(url, data, config) {
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), config), {}, {
            url,
            method: "patch",
            data
          }));
        },
        postForm: function postForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "post",
            data
          }));
        },
        putForm: function putForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "put",
            data
          }));
        },
        patchForm: function patchForm(url, data, config) {
          var formConfig = getFormConfig(config);
          return this.makeRequest(_objectSpread(_objectSpread(_objectSpread({}, this.defaults), formConfig), {}, {
            url,
            method: "patch",
            data
          }));
        },
        CancelToken: _types.CancelToken,
        isCancel: function isCancel(value) {
          return value instanceof Error && value.message === "Request canceled";
        }
      };
      return httpClient;
    }
    var fetchClient = exports.fetchClient = createFetchClient();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/index.js
var require_http_client3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/http-client/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      httpClient: true,
      create: true
    };
    exports.httpClient = exports.create = void 0;
    var _types = require_types5();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    var httpClient;
    var create;
    if (false) {
      axiosModule = null;
      exports.httpClient = httpClient = axiosModule.axiosClient;
      exports.create = create = axiosModule.create;
    } else {
      fetchModule = require_fetch_client3();
      exports.httpClient = httpClient = fetchModule.fetchClient;
      exports.create = create = fetchModule.create;
    }
    var axiosModule;
    var fetchModule;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/axios.js
var require_axios3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/axios.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.version = exports.default = exports.AxiosClient = void 0;
    var _httpClient = require_http_client3();
    var version2 = exports.version = "13.3.0";
    var AxiosClient = exports.AxiosClient = (0, _httpClient.create)({
      headers: {
        "X-Client-Name": "js-soroban-client",
        "X-Client-Version": version2
      }
    });
    var _default = exports.default = AxiosClient;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/jsonrpc.js
var require_jsonrpc3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.postObject = postObject;
    var _axios = _interopRequireDefault(require_axios3());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function hasOwnProperty(obj, prop) {
      return obj.hasOwnProperty(prop);
    }
    function postObject(_x, _x2) {
      return _postObject.apply(this, arguments);
    }
    function _postObject() {
      _postObject = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(url, method) {
        var param, response, _response$data, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              param = _args.length > 2 && _args[2] !== void 0 ? _args[2] : null;
              _context.next = 3;
              return _axios.default.post(url, {
                jsonrpc: "2.0",
                id: 1,
                method,
                params: param
              });
            case 3:
              response = _context.sent;
              if (!hasOwnProperty(response.data, "error")) {
                _context.next = 8;
                break;
              }
              throw response.data.error;
            case 8:
              return _context.abrupt("return", (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.result);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _postObject.apply(this, arguments);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/parsers.js
var require_parsers3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/parsers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseRawEvents = parseRawEvents;
    exports.parseRawLedgerEntries = parseRawLedgerEntries;
    exports.parseRawSendTransaction = parseRawSendTransaction;
    exports.parseRawSimulation = parseRawSimulation;
    exports.parseRawTransactions = parseRawTransactions;
    exports.parseTransactionInfo = parseTransactionInfo;
    var _stellarBase = require_lib3();
    var _api = require_api3();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function parseRawSendTransaction(raw) {
      var errorResultXdr = raw.errorResultXdr, diagnosticEventsXdr = raw.diagnosticEventsXdr;
      delete raw.errorResultXdr;
      delete raw.diagnosticEventsXdr;
      if (errorResultXdr) {
        return _objectSpread(_objectSpread(_objectSpread({}, raw), diagnosticEventsXdr !== void 0 && diagnosticEventsXdr.length > 0 && {
          diagnosticEvents: diagnosticEventsXdr.map(function(evt) {
            return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
          })
        }), {}, {
          errorResult: _stellarBase.xdr.TransactionResult.fromXDR(errorResultXdr, "base64")
        });
      }
      return _objectSpread({}, raw);
    }
    function parseTransactionInfo(raw) {
      var meta = _stellarBase.xdr.TransactionMeta.fromXDR(raw.resultMetaXdr, "base64");
      var info = {
        ledger: raw.ledger,
        createdAt: raw.createdAt,
        applicationOrder: raw.applicationOrder,
        feeBump: raw.feeBump,
        envelopeXdr: _stellarBase.xdr.TransactionEnvelope.fromXDR(raw.envelopeXdr, "base64"),
        resultXdr: _stellarBase.xdr.TransactionResult.fromXDR(raw.resultXdr, "base64"),
        resultMetaXdr: meta
      };
      if (meta.switch() === 3 && meta.v3().sorobanMeta() !== null) {
        var _meta$v3$sorobanMeta;
        info.returnValue = (_meta$v3$sorobanMeta = meta.v3().sorobanMeta()) === null || _meta$v3$sorobanMeta === void 0 ? void 0 : _meta$v3$sorobanMeta.returnValue();
      }
      if ("diagnosticEventsXdr" in raw && raw.diagnosticEventsXdr) {
        info.diagnosticEventsXdr = raw.diagnosticEventsXdr.map(function(diagnosticEvent) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(diagnosticEvent, "base64");
        });
      }
      return info;
    }
    function parseRawTransactions(r) {
      return _objectSpread({
        status: r.status,
        txHash: r.txHash
      }, parseTransactionInfo(r));
    }
    function parseRawEvents(raw) {
      var _raw$events;
      return {
        latestLedger: raw.latestLedger,
        cursor: raw.cursor,
        events: ((_raw$events = raw.events) !== null && _raw$events !== void 0 ? _raw$events : []).map(function(evt) {
          var clone = _objectSpread({}, evt);
          delete clone.contractId;
          return _objectSpread(_objectSpread(_objectSpread({}, clone), evt.contractId !== "" && {
            contractId: new _stellarBase.Contract(evt.contractId)
          }), {}, {
            topic: evt.topic.map(function(topic) {
              return _stellarBase.xdr.ScVal.fromXDR(topic, "base64");
            }),
            value: _stellarBase.xdr.ScVal.fromXDR(evt.value, "base64")
          });
        })
      };
    }
    function parseRawLedgerEntries(raw) {
      var _raw$entries;
      return {
        latestLedger: raw.latestLedger,
        entries: ((_raw$entries = raw.entries) !== null && _raw$entries !== void 0 ? _raw$entries : []).map(function(rawEntry) {
          if (!rawEntry.key || !rawEntry.xdr) {
            throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(rawEntry)));
          }
          return _objectSpread({
            lastModifiedLedgerSeq: rawEntry.lastModifiedLedgerSeq,
            key: _stellarBase.xdr.LedgerKey.fromXDR(rawEntry.key, "base64"),
            val: _stellarBase.xdr.LedgerEntryData.fromXDR(rawEntry.xdr, "base64")
          }, rawEntry.liveUntilLedgerSeq !== void 0 && {
            liveUntilLedgerSeq: rawEntry.liveUntilLedgerSeq
          });
        })
      };
    }
    function parseSuccessful(sim, partial) {
      var _sim$results$length, _sim$results, _sim$stateChanges$len, _sim$stateChanges, _sim$stateChanges2;
      var success = _objectSpread(_objectSpread(_objectSpread({}, partial), {}, {
        transactionData: new _stellarBase.SorobanDataBuilder(sim.transactionData),
        minResourceFee: sim.minResourceFee
      }, ((_sim$results$length = (_sim$results = sim.results) === null || _sim$results === void 0 ? void 0 : _sim$results.length) !== null && _sim$results$length !== void 0 ? _sim$results$length : 0 > 0) && {
        result: sim.results.map(function(row) {
          var _row$auth;
          return {
            auth: ((_row$auth = row.auth) !== null && _row$auth !== void 0 ? _row$auth : []).map(function(entry) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(entry, "base64");
            }),
            retval: row.xdr ? _stellarBase.xdr.ScVal.fromXDR(row.xdr, "base64") : _stellarBase.xdr.ScVal.scvVoid()
          };
        })[0]
      }), ((_sim$stateChanges$len = (_sim$stateChanges = sim.stateChanges) === null || _sim$stateChanges === void 0 ? void 0 : _sim$stateChanges.length) !== null && _sim$stateChanges$len !== void 0 ? _sim$stateChanges$len : 0 > 0) && {
        stateChanges: (_sim$stateChanges2 = sim.stateChanges) === null || _sim$stateChanges2 === void 0 ? void 0 : _sim$stateChanges2.map(function(entryChange) {
          return {
            type: entryChange.type,
            key: _stellarBase.xdr.LedgerKey.fromXDR(entryChange.key, "base64"),
            before: entryChange.before ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.before, "base64") : null,
            after: entryChange.after ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.after, "base64") : null
          };
        })
      });
      if (!sim.restorePreamble || sim.restorePreamble.transactionData === "") {
        return success;
      }
      return _objectSpread(_objectSpread({}, success), {}, {
        restorePreamble: {
          minResourceFee: sim.restorePreamble.minResourceFee,
          transactionData: new _stellarBase.SorobanDataBuilder(sim.restorePreamble.transactionData)
        }
      });
    }
    function parseRawSimulation(sim) {
      var _sim$events$map, _sim$events;
      var looksRaw = _api.Api.isSimulationRaw(sim);
      if (!looksRaw) {
        return sim;
      }
      var base = {
        _parsed: true,
        id: sim.id,
        latestLedger: sim.latestLedger,
        events: (_sim$events$map = (_sim$events = sim.events) === null || _sim$events === void 0 ? void 0 : _sim$events.map(function(evt) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
        })) !== null && _sim$events$map !== void 0 ? _sim$events$map : []
      };
      if (typeof sim.error === "string") {
        return _objectSpread(_objectSpread({}, base), {}, {
          error: sim.error
        });
      }
      return parseSuccessful(sim, base);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/transaction.js
var require_transaction6 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assembleTransaction = assembleTransaction;
    var _stellarBase = require_lib3();
    var _api = require_api3();
    var _parsers = require_parsers3();
    function isSorobanTransaction(tx) {
      if (tx.operations.length !== 1) {
        return false;
      }
      switch (tx.operations[0].type) {
        case "invokeHostFunction":
        case "extendFootprintTtl":
        case "restoreFootprint":
          return true;
        default:
          return false;
      }
    }
    function assembleTransaction(raw, simulation) {
      if ("innerTransaction" in raw) {
        return assembleTransaction(raw.innerTransaction, simulation);
      }
      if (!isSorobanTransaction(raw)) {
        throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
      }
      var success = (0, _parsers.parseRawSimulation)(simulation);
      if (!_api.Api.isSimulationSuccess(success)) {
        throw new Error("simulation incorrect: ".concat(JSON.stringify(success)));
      }
      var classicFeeNum = parseInt(raw.fee) || 0;
      var minResourceFeeNum = parseInt(success.minResourceFee) || 0;
      var txnBuilder = _stellarBase.TransactionBuilder.cloneFrom(raw, {
        fee: (classicFeeNum + minResourceFeeNum).toString(),
        sorobanData: success.transactionData.build(),
        networkPassphrase: raw.networkPassphrase
      });
      if (raw.operations[0].type === "invokeHostFunction") {
        var _invokeOp$auth;
        txnBuilder.clearOperations();
        var invokeOp = raw.operations[0];
        var existingAuth = (_invokeOp$auth = invokeOp.auth) !== null && _invokeOp$auth !== void 0 ? _invokeOp$auth : [];
        txnBuilder.addOperation(_stellarBase.Operation.invokeHostFunction({
          source: invokeOp.source,
          func: invokeOp.func,
          auth: existingAuth.length > 0 ? existingAuth : success.result.auth
        }));
      }
      return txnBuilder;
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/utils.js
var require_utils5 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Utils = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Utils = exports.Utils = function() {
      function Utils2() {
        _classCallCheck(this, Utils2);
      }
      return _createClass(Utils2, null, [{
        key: "validateTimebounds",
        value: function validateTimebounds(transaction) {
          var gracePeriod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          if (!transaction.timeBounds) {
            return false;
          }
          var now = Math.floor(Date.now() / 1e3);
          var _transaction$timeBoun = transaction.timeBounds, minTime = _transaction$timeBoun.minTime, maxTime = _transaction$timeBoun.maxTime;
          return now >= Number.parseInt(minTime, 10) - gracePeriod && now <= Number.parseInt(maxTime, 10) + gracePeriod;
        }
      }, {
        key: "sleep",
        value: function sleep(ms) {
          return new Promise(function(resolve) {
            return setTimeout(resolve, ms);
          });
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/server.js
var require_server3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SUBMIT_TRANSACTION_TIMEOUT = exports.RpcServer = exports.LinearSleepStrategy = exports.Durability = exports.BasicSleepStrategy = void 0;
    var _urijs = _interopRequireDefault(require_URI());
    var _stellarBase = require_lib3();
    var _axios = _interopRequireDefault(require_axios3());
    var jsonrpc = _interopRequireWildcard(require_jsonrpc3());
    var _api = require_api3();
    var _transaction = require_transaction6();
    var _parsers = require_parsers3();
    var _utils = require_utils5();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SUBMIT_TRANSACTION_TIMEOUT = exports.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
    var Durability2 = exports.Durability = function(Durability3) {
      Durability3["Temporary"] = "temporary";
      Durability3["Persistent"] = "persistent";
      return Durability3;
    }({});
    var DEFAULT_GET_TRANSACTION_TIMEOUT = 30;
    var BasicSleepStrategy = exports.BasicSleepStrategy = function BasicSleepStrategy2(_iter) {
      return 1e3;
    };
    var LinearSleepStrategy = exports.LinearSleepStrategy = function LinearSleepStrategy2(iter) {
      return 1e3 * iter;
    };
    function findCreatedAccountSequenceInTransactionMeta(meta) {
      var _operations$flatMap$f;
      var operations = [];
      switch (meta.switch()) {
        case 0:
          operations = meta.operations();
          break;
        case 1:
        case 2:
        case 3:
          operations = meta.value().operations();
          break;
        default:
          throw new Error("Unexpected transaction meta switch value");
      }
      var sequenceNumber = (_operations$flatMap$f = operations.flatMap(function(op) {
        return op.changes();
      }).find(function(c) {
        return c.switch() === _stellarBase.xdr.LedgerEntryChangeType.ledgerEntryCreated() && c.created().data().switch() === _stellarBase.xdr.LedgerEntryType.account();
      })) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.created()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.data()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.account()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.seqNum()) === null || _operations$flatMap$f === void 0 ? void 0 : _operations$flatMap$f.toString();
      if (sequenceNumber) {
        return sequenceNumber;
      }
      throw new Error("No account created in transaction");
    }
    var RpcServer = exports.RpcServer = function() {
      function RpcServer2(serverURL) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, RpcServer2);
        this.serverURL = (0, _urijs.default)(serverURL);
        if (opts.headers && Object.keys(opts.headers).length !== 0) {
          _axios.default.interceptors.request.use(function(config) {
            config.headers = Object.assign(config.headers, opts.headers);
            return config;
          });
        }
        if (this.serverURL.protocol() !== "https" && !opts.allowHttp) {
          throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
        }
      }
      return _createClass(RpcServer2, [{
        key: "getAccount",
        value: function() {
          var _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(address) {
            var ledgerKey, resp, accountEntry;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  ledgerKey = _stellarBase.xdr.LedgerKey.account(new _stellarBase.xdr.LedgerKeyAccount({
                    accountId: _stellarBase.Keypair.fromPublicKey(address).xdrPublicKey()
                  }));
                  _context.next = 3;
                  return this.getLedgerEntries(ledgerKey);
                case 3:
                  resp = _context.sent;
                  if (!(resp.entries.length === 0)) {
                    _context.next = 6;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Account not found: ".concat(address)
                  }));
                case 6:
                  accountEntry = resp.entries[0].val.account();
                  return _context.abrupt("return", new _stellarBase.Account(address, accountEntry.seqNum().toString()));
                case 8:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function getAccount(_x) {
            return _getAccount.apply(this, arguments);
          }
          return getAccount;
        }()
      }, {
        key: "getHealth",
        value: function() {
          var _getHealth = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getHealth"));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function getHealth() {
            return _getHealth.apply(this, arguments);
          }
          return getHealth;
        }()
      }, {
        key: "getContractData",
        value: function() {
          var _getContractData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(contract, key) {
            var durability, scAddress, xdrDurability, contractKey, _args3 = arguments;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  durability = _args3.length > 2 && _args3[2] !== void 0 ? _args3[2] : Durability2.Persistent;
                  if (!(typeof contract === "string")) {
                    _context3.next = 5;
                    break;
                  }
                  scAddress = new _stellarBase.Contract(contract).address().toScAddress();
                  _context3.next = 14;
                  break;
                case 5:
                  if (!(contract instanceof _stellarBase.Address)) {
                    _context3.next = 9;
                    break;
                  }
                  scAddress = contract.toScAddress();
                  _context3.next = 14;
                  break;
                case 9:
                  if (!(contract instanceof _stellarBase.Contract)) {
                    _context3.next = 13;
                    break;
                  }
                  scAddress = contract.address().toScAddress();
                  _context3.next = 14;
                  break;
                case 13:
                  throw new TypeError("unknown contract type: ".concat(contract));
                case 14:
                  _context3.t0 = durability;
                  _context3.next = _context3.t0 === Durability2.Temporary ? 17 : _context3.t0 === Durability2.Persistent ? 19 : 21;
                  break;
                case 17:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.temporary();
                  return _context3.abrupt("break", 22);
                case 19:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.persistent();
                  return _context3.abrupt("break", 22);
                case 21:
                  throw new TypeError("invalid durability: ".concat(durability));
                case 22:
                  contractKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    key,
                    contract: scAddress,
                    durability: xdrDurability
                  }));
                  return _context3.abrupt("return", this.getLedgerEntries(contractKey).then(function(r) {
                    if (r.entries.length === 0) {
                      return Promise.reject({
                        code: 404,
                        message: "Contract data not found. Contract: ".concat(_stellarBase.Address.fromScAddress(scAddress).toString(), ", Key: ").concat(key.toXDR("base64"), ", Durability: ").concat(durability)
                      });
                    }
                    return r.entries[0];
                  }));
                case 24:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this);
          }));
          function getContractData(_x2, _x3) {
            return _getContractData.apply(this, arguments);
          }
          return getContractData;
        }()
      }, {
        key: "getContractWasmByContractId",
        value: function() {
          var _getContractWasmByContractId = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(contractId) {
            var _response$entries$;
            var contractLedgerKey, response, wasmHash;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  contractLedgerKey = new _stellarBase.Contract(contractId).getFootprint();
                  _context4.next = 3;
                  return this.getLedgerEntries(contractLedgerKey);
                case 3:
                  response = _context4.sent;
                  if (!(!response.entries.length || !((_response$entries$ = response.entries[0]) !== null && _response$entries$ !== void 0 && _response$entries$.val))) {
                    _context4.next = 6;
                    break;
                  }
                  return _context4.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract hash from server"
                  }));
                case 6:
                  wasmHash = response.entries[0].val.contractData().val().instance().executable().wasmHash();
                  return _context4.abrupt("return", this.getContractWasmByHash(wasmHash));
                case 8:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));
          function getContractWasmByContractId(_x4) {
            return _getContractWasmByContractId.apply(this, arguments);
          }
          return getContractWasmByContractId;
        }()
      }, {
        key: "getContractWasmByHash",
        value: function() {
          var _getContractWasmByHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasmHash) {
            var _responseWasm$entries;
            var format, wasmHashBuffer, ledgerKeyWasmHash, responseWasm, wasmBuffer, _args5 = arguments;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  format = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : void 0;
                  wasmHashBuffer = typeof wasmHash === "string" ? Buffer.from(wasmHash, format) : wasmHash;
                  ledgerKeyWasmHash = _stellarBase.xdr.LedgerKey.contractCode(new _stellarBase.xdr.LedgerKeyContractCode({
                    hash: wasmHashBuffer
                  }));
                  _context5.next = 5;
                  return this.getLedgerEntries(ledgerKeyWasmHash);
                case 5:
                  responseWasm = _context5.sent;
                  if (!(!responseWasm.entries.length || !((_responseWasm$entries = responseWasm.entries[0]) !== null && _responseWasm$entries !== void 0 && _responseWasm$entries.val))) {
                    _context5.next = 8;
                    break;
                  }
                  return _context5.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract wasm from server"
                  }));
                case 8:
                  wasmBuffer = responseWasm.entries[0].val.contractCode().code();
                  return _context5.abrupt("return", wasmBuffer);
                case 10:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function getContractWasmByHash(_x5) {
            return _getContractWasmByHash.apply(this, arguments);
          }
          return getContractWasmByHash;
        }()
      }, {
        key: "getLedgerEntries",
        value: function() {
          var _getLedgerEntries2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
            var _args6 = arguments;
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  return _context6.abrupt("return", this._getLedgerEntries.apply(this, _args6).then(_parsers.parseRawLedgerEntries));
                case 1:
                case "end":
                  return _context6.stop();
              }
            }, _callee6, this);
          }));
          function getLedgerEntries() {
            return _getLedgerEntries2.apply(this, arguments);
          }
          return getLedgerEntries;
        }()
      }, {
        key: "_getLedgerEntries",
        value: function() {
          var _getLedgerEntries3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var _len, keys, _key, _args7 = arguments;
            return _regeneratorRuntime().wrap(function _callee7$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  for (_len = _args7.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
                    keys[_key] = _args7[_key];
                  }
                  return _context7.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLedgerEntries", {
                    keys: keys.map(function(k) {
                      return k.toXDR("base64");
                    })
                  }));
                case 2:
                case "end":
                  return _context7.stop();
              }
            }, _callee7, this);
          }));
          function _getLedgerEntries() {
            return _getLedgerEntries3.apply(this, arguments);
          }
          return _getLedgerEntries;
        }()
      }, {
        key: "pollTransaction",
        value: function() {
          var _pollTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(hash2, opts) {
            var _opts$attempts, _opts$attempts2;
            var maxAttempts, foundInfo, attempt, _opts$sleepStrategy;
            return _regeneratorRuntime().wrap(function _callee8$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  maxAttempts = ((_opts$attempts = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts !== void 0 ? _opts$attempts : 0) < 1 ? DEFAULT_GET_TRANSACTION_TIMEOUT : (_opts$attempts2 = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts2 !== void 0 ? _opts$attempts2 : DEFAULT_GET_TRANSACTION_TIMEOUT;
                  attempt = 1;
                case 2:
                  if (!(attempt < maxAttempts)) {
                    _context8.next = 13;
                    break;
                  }
                  _context8.next = 5;
                  return this.getTransaction(hash2);
                case 5:
                  foundInfo = _context8.sent;
                  if (!(foundInfo.status !== _api.Api.GetTransactionStatus.NOT_FOUND)) {
                    _context8.next = 8;
                    break;
                  }
                  return _context8.abrupt("return", foundInfo);
                case 8:
                  _context8.next = 10;
                  return _utils.Utils.sleep(((_opts$sleepStrategy = opts === null || opts === void 0 ? void 0 : opts.sleepStrategy) !== null && _opts$sleepStrategy !== void 0 ? _opts$sleepStrategy : BasicSleepStrategy)(attempt));
                case 10:
                  attempt++;
                  _context8.next = 2;
                  break;
                case 13:
                  return _context8.abrupt("return", foundInfo);
                case 14:
                case "end":
                  return _context8.stop();
              }
            }, _callee8, this);
          }));
          function pollTransaction(_x6, _x7) {
            return _pollTransaction.apply(this, arguments);
          }
          return pollTransaction;
        }()
      }, {
        key: "getTransaction",
        value: function() {
          var _getTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(hash2) {
            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  return _context9.abrupt("return", this._getTransaction(hash2).then(function(raw) {
                    var foundInfo = {};
                    if (raw.status !== _api.Api.GetTransactionStatus.NOT_FOUND) {
                      Object.assign(foundInfo, (0, _parsers.parseTransactionInfo)(raw));
                    }
                    var result = _objectSpread({
                      status: raw.status,
                      txHash: hash2,
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTime: raw.latestLedgerCloseTime,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTime: raw.oldestLedgerCloseTime
                    }, foundInfo);
                    return result;
                  }));
                case 1:
                case "end":
                  return _context9.stop();
              }
            }, _callee9, this);
          }));
          function getTransaction(_x8) {
            return _getTransaction2.apply(this, arguments);
          }
          return getTransaction;
        }()
      }, {
        key: "_getTransaction",
        value: function() {
          var _getTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(hash2) {
            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  return _context10.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransaction", {
                    hash: hash2
                  }));
                case 1:
                case "end":
                  return _context10.stop();
              }
            }, _callee10, this);
          }));
          function _getTransaction(_x9) {
            return _getTransaction3.apply(this, arguments);
          }
          return _getTransaction;
        }()
      }, {
        key: "getTransactions",
        value: function() {
          var _getTransactions2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(request) {
            return _regeneratorRuntime().wrap(function _callee11$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  return _context11.abrupt("return", this._getTransactions(request).then(function(raw) {
                    var result = {
                      transactions: (raw.transactions || []).map(_parsers.parseRawTransactions),
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTimestamp: raw.latestLedgerCloseTimestamp,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTimestamp: raw.oldestLedgerCloseTimestamp,
                      cursor: raw.cursor
                    };
                    return result;
                  }));
                case 1:
                case "end":
                  return _context11.stop();
              }
            }, _callee11, this);
          }));
          function getTransactions(_x10) {
            return _getTransactions2.apply(this, arguments);
          }
          return getTransactions;
        }()
      }, {
        key: "_getTransactions",
        value: function() {
          var _getTransactions3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee12(request) {
            return _regeneratorRuntime().wrap(function _callee12$(_context12) {
              while (1) switch (_context12.prev = _context12.next) {
                case 0:
                  return _context12.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransactions", request));
                case 1:
                case "end":
                  return _context12.stop();
              }
            }, _callee12, this);
          }));
          function _getTransactions(_x11) {
            return _getTransactions3.apply(this, arguments);
          }
          return _getTransactions;
        }()
      }, {
        key: "getEvents",
        value: function() {
          var _getEvents2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee13(request) {
            return _regeneratorRuntime().wrap(function _callee13$(_context13) {
              while (1) switch (_context13.prev = _context13.next) {
                case 0:
                  return _context13.abrupt("return", this._getEvents(request).then(_parsers.parseRawEvents));
                case 1:
                case "end":
                  return _context13.stop();
              }
            }, _callee13, this);
          }));
          function getEvents(_x12) {
            return _getEvents2.apply(this, arguments);
          }
          return getEvents;
        }()
      }, {
        key: "_getEvents",
        value: function() {
          var _getEvents3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee14(request) {
            var _request$filters;
            return _regeneratorRuntime().wrap(function _callee14$(_context14) {
              while (1) switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getEvents", _objectSpread(_objectSpread({
                    filters: (_request$filters = request.filters) !== null && _request$filters !== void 0 ? _request$filters : [],
                    pagination: _objectSpread(_objectSpread({}, request.cursor && {
                      cursor: request.cursor
                    }), request.limit && {
                      limit: request.limit
                    })
                  }, request.startLedger && {
                    startLedger: request.startLedger
                  }), request.endLedger && {
                    endLedger: request.endLedger
                  })));
                case 1:
                case "end":
                  return _context14.stop();
              }
            }, _callee14, this);
          }));
          function _getEvents(_x13) {
            return _getEvents3.apply(this, arguments);
          }
          return _getEvents;
        }()
      }, {
        key: "getNetwork",
        value: function() {
          var _getNetwork = _asyncToGenerator(_regeneratorRuntime().mark(function _callee15() {
            return _regeneratorRuntime().wrap(function _callee15$(_context15) {
              while (1) switch (_context15.prev = _context15.next) {
                case 0:
                  return _context15.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getNetwork"));
                case 1:
                case "end":
                  return _context15.stop();
              }
            }, _callee15, this);
          }));
          function getNetwork() {
            return _getNetwork.apply(this, arguments);
          }
          return getNetwork;
        }()
      }, {
        key: "getLatestLedger",
        value: function() {
          var _getLatestLedger = _asyncToGenerator(_regeneratorRuntime().mark(function _callee16() {
            return _regeneratorRuntime().wrap(function _callee16$(_context16) {
              while (1) switch (_context16.prev = _context16.next) {
                case 0:
                  return _context16.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLatestLedger"));
                case 1:
                case "end":
                  return _context16.stop();
              }
            }, _callee16, this);
          }));
          function getLatestLedger() {
            return _getLatestLedger.apply(this, arguments);
          }
          return getLatestLedger;
        }()
      }, {
        key: "simulateTransaction",
        value: function() {
          var _simulateTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee17(tx, addlResources) {
            return _regeneratorRuntime().wrap(function _callee17$(_context17) {
              while (1) switch (_context17.prev = _context17.next) {
                case 0:
                  return _context17.abrupt("return", this._simulateTransaction(tx, addlResources).then(_parsers.parseRawSimulation));
                case 1:
                case "end":
                  return _context17.stop();
              }
            }, _callee17, this);
          }));
          function simulateTransaction(_x14, _x15) {
            return _simulateTransaction2.apply(this, arguments);
          }
          return simulateTransaction;
        }()
      }, {
        key: "_simulateTransaction",
        value: function() {
          var _simulateTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee18(transaction, addlResources) {
            return _regeneratorRuntime().wrap(function _callee18$(_context18) {
              while (1) switch (_context18.prev = _context18.next) {
                case 0:
                  return _context18.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "simulateTransaction", _objectSpread({
                    transaction: transaction.toXDR()
                  }, addlResources !== void 0 && {
                    resourceConfig: {
                      instructionLeeway: addlResources.cpuInstructions
                    }
                  })));
                case 1:
                case "end":
                  return _context18.stop();
              }
            }, _callee18, this);
          }));
          function _simulateTransaction(_x16, _x17) {
            return _simulateTransaction3.apply(this, arguments);
          }
          return _simulateTransaction;
        }()
      }, {
        key: "prepareTransaction",
        value: function() {
          var _prepareTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee19(tx) {
            var simResponse;
            return _regeneratorRuntime().wrap(function _callee19$(_context19) {
              while (1) switch (_context19.prev = _context19.next) {
                case 0:
                  _context19.next = 2;
                  return this.simulateTransaction(tx);
                case 2:
                  simResponse = _context19.sent;
                  if (!_api.Api.isSimulationError(simResponse)) {
                    _context19.next = 5;
                    break;
                  }
                  throw new Error(simResponse.error);
                case 5:
                  return _context19.abrupt("return", (0, _transaction.assembleTransaction)(tx, simResponse).build());
                case 6:
                case "end":
                  return _context19.stop();
              }
            }, _callee19, this);
          }));
          function prepareTransaction(_x18) {
            return _prepareTransaction.apply(this, arguments);
          }
          return prepareTransaction;
        }()
      }, {
        key: "sendTransaction",
        value: function() {
          var _sendTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee20(transaction) {
            return _regeneratorRuntime().wrap(function _callee20$(_context20) {
              while (1) switch (_context20.prev = _context20.next) {
                case 0:
                  return _context20.abrupt("return", this._sendTransaction(transaction).then(_parsers.parseRawSendTransaction));
                case 1:
                case "end":
                  return _context20.stop();
              }
            }, _callee20, this);
          }));
          function sendTransaction(_x19) {
            return _sendTransaction2.apply(this, arguments);
          }
          return sendTransaction;
        }()
      }, {
        key: "_sendTransaction",
        value: function() {
          var _sendTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee21(transaction) {
            return _regeneratorRuntime().wrap(function _callee21$(_context21) {
              while (1) switch (_context21.prev = _context21.next) {
                case 0:
                  return _context21.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "sendTransaction", {
                    transaction: transaction.toXDR()
                  }));
                case 1:
                case "end":
                  return _context21.stop();
              }
            }, _callee21, this);
          }));
          function _sendTransaction(_x20) {
            return _sendTransaction3.apply(this, arguments);
          }
          return _sendTransaction;
        }()
      }, {
        key: "requestAirdrop",
        value: function() {
          var _requestAirdrop = _asyncToGenerator(_regeneratorRuntime().mark(function _callee22(address, friendbotUrl) {
            var account, response, meta, txMeta, sequence, _error$response, _error$response$detai;
            return _regeneratorRuntime().wrap(function _callee22$(_context22) {
              while (1) switch (_context22.prev = _context22.next) {
                case 0:
                  account = typeof address === "string" ? address : address.accountId();
                  _context22.t0 = friendbotUrl;
                  if (_context22.t0) {
                    _context22.next = 6;
                    break;
                  }
                  _context22.next = 5;
                  return this.getNetwork();
                case 5:
                  _context22.t0 = _context22.sent.friendbotUrl;
                case 6:
                  friendbotUrl = _context22.t0;
                  if (friendbotUrl) {
                    _context22.next = 9;
                    break;
                  }
                  throw new Error("No friendbot URL configured for current network");
                case 9:
                  _context22.prev = 9;
                  _context22.next = 12;
                  return _axios.default.post("".concat(friendbotUrl, "?addr=").concat(encodeURIComponent(account)));
                case 12:
                  response = _context22.sent;
                  if (response.data.result_meta_xdr) {
                    _context22.next = 22;
                    break;
                  }
                  _context22.next = 16;
                  return this.getTransaction(response.data.hash);
                case 16:
                  txMeta = _context22.sent;
                  if (!(txMeta.status !== _api.Api.GetTransactionStatus.SUCCESS)) {
                    _context22.next = 19;
                    break;
                  }
                  throw new Error("Funding account ".concat(address, " failed"));
                case 19:
                  meta = txMeta.resultMetaXdr;
                  _context22.next = 23;
                  break;
                case 22:
                  meta = _stellarBase.xdr.TransactionMeta.fromXDR(response.data.result_meta_xdr, "base64");
                case 23:
                  sequence = findCreatedAccountSequenceInTransactionMeta(meta);
                  return _context22.abrupt("return", new _stellarBase.Account(account, sequence));
                case 27:
                  _context22.prev = 27;
                  _context22.t1 = _context22["catch"](9);
                  if (!(((_error$response = _context22.t1.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 400)) {
                    _context22.next = 32;
                    break;
                  }
                  if (!((_error$response$detai = _context22.t1.response.detail) !== null && _error$response$detai !== void 0 && _error$response$detai.includes("createAccountAlreadyExist"))) {
                    _context22.next = 32;
                    break;
                  }
                  return _context22.abrupt("return", this.getAccount(account));
                case 32:
                  throw _context22.t1;
                case 33:
                case "end":
                  return _context22.stop();
              }
            }, _callee22, this, [[9, 27]]);
          }));
          function requestAirdrop(_x21, _x22) {
            return _requestAirdrop.apply(this, arguments);
          }
          return requestAirdrop;
        }()
      }, {
        key: "getFeeStats",
        value: function() {
          var _getFeeStats = _asyncToGenerator(_regeneratorRuntime().mark(function _callee23() {
            return _regeneratorRuntime().wrap(function _callee23$(_context23) {
              while (1) switch (_context23.prev = _context23.next) {
                case 0:
                  return _context23.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getFeeStats"));
                case 1:
                case "end":
                  return _context23.stop();
              }
            }, _callee23, this);
          }));
          function getFeeStats() {
            return _getFeeStats.apply(this, arguments);
          }
          return getFeeStats;
        }()
      }, {
        key: "getVersionInfo",
        value: function() {
          var _getVersionInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee24() {
            return _regeneratorRuntime().wrap(function _callee24$(_context24) {
              while (1) switch (_context24.prev = _context24.next) {
                case 0:
                  return _context24.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getVersionInfo"));
                case 1:
                case "end":
                  return _context24.stop();
              }
            }, _callee24, this);
          }));
          function getVersionInfo() {
            return _getVersionInfo.apply(this, arguments);
          }
          return getVersionInfo;
        }()
      }, {
        key: "getSACBalance",
        value: function() {
          var _getSACBalance = _asyncToGenerator(_regeneratorRuntime().mark(function _callee25(contractId, sac, networkPassphrase) {
            var passphrase, sacId, key, ledgerKey, response, _response$entries$2, lastModifiedLedgerSeq, liveUntilLedgerSeq, val, entry;
            return _regeneratorRuntime().wrap(function _callee25$(_context25) {
              while (1) switch (_context25.prev = _context25.next) {
                case 0:
                  if (_stellarBase.StrKey.isValidContract(contractId)) {
                    _context25.next = 2;
                    break;
                  }
                  throw new TypeError("expected contract ID, got ".concat(contractId));
                case 2:
                  if (!(networkPassphrase !== null && networkPassphrase !== void 0)) {
                    _context25.next = 6;
                    break;
                  }
                  _context25.t0 = networkPassphrase;
                  _context25.next = 9;
                  break;
                case 6:
                  _context25.next = 8;
                  return this.getNetwork().then(function(n) {
                    return n.passphrase;
                  });
                case 8:
                  _context25.t0 = _context25.sent;
                case 9:
                  passphrase = _context25.t0;
                  sacId = sac.contractId(passphrase);
                  key = _stellarBase.xdr.ScVal.scvVec([(0, _stellarBase.nativeToScVal)("Balance", {
                    type: "symbol"
                  }), (0, _stellarBase.nativeToScVal)(contractId, {
                    type: "address"
                  })]);
                  ledgerKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    contract: new _stellarBase.Address(sacId).toScAddress(),
                    durability: _stellarBase.xdr.ContractDataDurability.persistent(),
                    key
                  }));
                  _context25.next = 15;
                  return this.getLedgerEntries(ledgerKey);
                case 15:
                  response = _context25.sent;
                  if (!(response.entries.length === 0)) {
                    _context25.next = 18;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 18:
                  _response$entries$2 = response.entries[0], lastModifiedLedgerSeq = _response$entries$2.lastModifiedLedgerSeq, liveUntilLedgerSeq = _response$entries$2.liveUntilLedgerSeq, val = _response$entries$2.val;
                  if (!(val.switch().value !== _stellarBase.xdr.LedgerEntryType.contractData().value)) {
                    _context25.next = 21;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 21:
                  entry = (0, _stellarBase.scValToNative)(val.contractData().val());
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger,
                    balanceEntry: {
                      liveUntilLedgerSeq,
                      lastModifiedLedgerSeq,
                      amount: entry.amount.toString(),
                      authorized: entry.authorized,
                      clawback: entry.clawback
                    }
                  });
                case 23:
                case "end":
                  return _context25.stop();
              }
            }, _callee25, this);
          }));
          function getSACBalance(_x23, _x24, _x25) {
            return _getSACBalance.apply(this, arguments);
          }
          return getSACBalance;
        }()
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/index.js
var require_rpc3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/rpc/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      Server: true,
      BasicSleepStrategy: true,
      LinearSleepStrategy: true,
      Durability: true,
      AxiosClient: true,
      parseRawSimulation: true,
      parseRawEvents: true
    };
    Object.defineProperty(exports, "AxiosClient", {
      enumerable: true,
      get: function get() {
        return _axios.default;
      }
    });
    Object.defineProperty(exports, "BasicSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.BasicSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Durability", {
      enumerable: true,
      get: function get() {
        return _server.Durability;
      }
    });
    Object.defineProperty(exports, "LinearSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.LinearSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Server", {
      enumerable: true,
      get: function get() {
        return _server.RpcServer;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "parseRawEvents", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawEvents;
      }
    });
    Object.defineProperty(exports, "parseRawSimulation", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawSimulation;
      }
    });
    var _api = require_api3();
    Object.keys(_api).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _api[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _api[key];
        }
      });
    });
    var _server = require_server3();
    var _axios = _interopRequireDefault(require_axios3());
    var _parsers = require_parsers3();
    var _transaction = require_transaction6();
    Object.keys(_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _transaction[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var _default = exports.default = module.exports;
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/rust_result.js
var require_rust_result3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/rust_result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Ok = exports.Err = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Ok = exports.Ok = function() {
      function Ok2(value) {
        _classCallCheck(this, Ok2);
        this.value = value;
      }
      return _createClass(Ok2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          throw new Error("No error");
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          return this.value;
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return true;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return false;
        }
      }]);
    }();
    var Err = exports.Err = function() {
      function Err2(error) {
        _classCallCheck(this, Err2);
        this.error = error;
      }
      return _createClass(Err2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          return this.error;
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          throw new Error(this.error.message);
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return false;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return true;
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/types.js
var require_types6 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NULL_ACCOUNT = exports.DEFAULT_TIMEOUT = void 0;
    var _stellarBase = require_lib3();
    var DEFAULT_TIMEOUT = exports.DEFAULT_TIMEOUT = 5 * 60;
    var NULL_ACCOUNT = exports.NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/utils.js
var require_utils6 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contractErrorPattern = void 0;
    exports.getAccount = getAccount;
    exports.implementsToString = implementsToString;
    exports.processSpecEntryStream = processSpecEntryStream;
    exports.withExponentialBackoff = withExponentialBackoff;
    var _stellarBase = require_lib3();
    var _types = require_types6();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function withExponentialBackoff(_x, _x2, _x3) {
      return _withExponentialBackoff.apply(this, arguments);
    }
    function _withExponentialBackoff() {
      _withExponentialBackoff = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(fn, keepWaitingIf, timeoutInSeconds) {
        var exponentialFactor, verbose, attempts, count, waitUntil, waitTime, totalWaitTime, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              exponentialFactor = _args.length > 3 && _args[3] !== void 0 ? _args[3] : 1.5;
              verbose = _args.length > 4 && _args[4] !== void 0 ? _args[4] : false;
              attempts = [];
              count = 0;
              _context.t0 = attempts;
              _context.next = 7;
              return fn();
            case 7:
              _context.t1 = _context.sent;
              _context.t0.push.call(_context.t0, _context.t1);
              if (keepWaitingIf(attempts[attempts.length - 1])) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", attempts);
            case 11:
              waitUntil = new Date(Date.now() + timeoutInSeconds * 1e3).valueOf();
              waitTime = 1e3;
              totalWaitTime = waitTime;
            case 14:
              if (!(Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1]))) {
                _context.next = 30;
                break;
              }
              count += 1;
              if (verbose) {
                console.info("Waiting ".concat(waitTime, "ms before trying again (bringing the total wait time to ").concat(totalWaitTime, "ms so far, of total ").concat(timeoutInSeconds * 1e3, "ms)"));
              }
              _context.next = 19;
              return new Promise(function(res) {
                return setTimeout(res, waitTime);
              });
            case 19:
              waitTime *= exponentialFactor;
              if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
                waitTime = waitUntil - Date.now();
                if (verbose) {
                  console.info("was gonna wait too long; new waitTime: ".concat(waitTime, "ms"));
                }
              }
              totalWaitTime = waitTime + totalWaitTime;
              _context.t2 = attempts;
              _context.next = 25;
              return fn(attempts[attempts.length - 1]);
            case 25:
              _context.t3 = _context.sent;
              _context.t2.push.call(_context.t2, _context.t3);
              if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {
                console.info("".concat(count, ". Called ").concat(fn, "; ").concat(attempts.length, " prev attempts. Most recent: ").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));
              }
              _context.next = 14;
              break;
            case 30:
              return _context.abrupt("return", attempts);
            case 31:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _withExponentialBackoff.apply(this, arguments);
    }
    var contractErrorPattern = exports.contractErrorPattern = /Error\(Contract, #(\d+)\)/;
    function implementsToString(obj) {
      return _typeof(obj) === "object" && obj !== null && "toString" in obj;
    }
    function processSpecEntryStream(buffer) {
      var reader = new _stellarBase.cereal.XdrReader(buffer);
      var res = [];
      while (!reader.eof) {
        res.push(_stellarBase.xdr.ScSpecEntry.read(reader));
      }
      return res;
    }
    function getAccount(_x4, _x5) {
      return _getAccount.apply(this, arguments);
    }
    function _getAccount() {
      _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(options, server) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", options.publicKey ? server.getAccount(options.publicKey) : new _stellarBase.Account(_types.NULL_ACCOUNT, "0"));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _getAccount.apply(this, arguments);
    }
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/sent_transaction.js
var require_sent_transaction3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/sent_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SentTransaction = void 0;
    var _rpc = require_rpc3();
    var _api = require_api3();
    var _utils = require_utils6();
    var _types = require_types6();
    var _SentTransaction;
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SentTransaction = exports.SentTransaction = function() {
      function SentTransaction2(assembled) {
        var _this = this, _this$assembled$optio2;
        _classCallCheck(this, SentTransaction2);
        _defineProperty(this, "send", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _this$assembled$optio;
          var hash2, timeoutInSeconds;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.server.sendTransaction(_this.assembled.signed);
              case 2:
                _this.sendTransactionResponse = _context.sent;
                if (!(_this.sendTransactionResponse.status !== "PENDING")) {
                  _context.next = 5;
                  break;
                }
                throw new SentTransaction2.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(_this.sendTransactionResponse, null, 2)));
              case 5:
                hash2 = _this.sendTransactionResponse.hash;
                timeoutInSeconds = (_this$assembled$optio = _this.assembled.options.timeoutInSeconds) !== null && _this$assembled$optio !== void 0 ? _this$assembled$optio : _types.DEFAULT_TIMEOUT;
                _context.next = 9;
                return (0, _utils.withExponentialBackoff)(function() {
                  return _this.server.getTransaction(hash2);
                }, function(resp) {
                  return resp.status === _api.Api.GetTransactionStatus.NOT_FOUND;
                }, timeoutInSeconds);
              case 9:
                _this.getTransactionResponseAll = _context.sent;
                _this.getTransactionResponse = _this.getTransactionResponseAll[_this.getTransactionResponseAll.length - 1];
                if (!(_this.getTransactionResponse.status === _api.Api.GetTransactionStatus.NOT_FOUND)) {
                  _context.next = 13;
                  break;
                }
                throw new SentTransaction2.Errors.TransactionStillPending("Waited ".concat(timeoutInSeconds, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(_this.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(_this.getTransactionResponseAll, null, 2)));
              case 13:
                return _context.abrupt("return", _this);
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        this.assembled = assembled;
        this.server = new _rpc.Server(this.assembled.options.rpcUrl, {
          allowHttp: (_this$assembled$optio2 = this.assembled.options.allowHttp) !== null && _this$assembled$optio2 !== void 0 ? _this$assembled$optio2 : false
        });
      }
      return _createClass(SentTransaction2, [{
        key: "result",
        get: function get() {
          if ("getTransactionResponse" in this && this.getTransactionResponse) {
            if ("returnValue" in this.getTransactionResponse) {
              return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
            }
            throw new Error("Transaction failed! Cannot parse result.");
          }
          if (this.sendTransactionResponse) {
            var _this$sendTransaction;
            var errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();
            if (errorResult) {
              throw new SentTransaction2.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(errorResult));
            }
            throw new SentTransaction2.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
          }
          throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
        }
      }]);
    }();
    _SentTransaction = SentTransaction;
    _defineProperty(SentTransaction, "Errors", {
      SendFailed: function(_Error) {
        function SendFailedError() {
          _classCallCheck(this, SendFailedError);
          return _callSuper(this, SendFailedError, arguments);
        }
        _inherits(SendFailedError, _Error);
        return _createClass(SendFailedError);
      }(_wrapNativeSuper(Error)),
      SendResultOnly: function(_Error2) {
        function SendResultOnlyError() {
          _classCallCheck(this, SendResultOnlyError);
          return _callSuper(this, SendResultOnlyError, arguments);
        }
        _inherits(SendResultOnlyError, _Error2);
        return _createClass(SendResultOnlyError);
      }(_wrapNativeSuper(Error)),
      TransactionStillPending: function(_Error3) {
        function TransactionStillPendingError() {
          _classCallCheck(this, TransactionStillPendingError);
          return _callSuper(this, TransactionStillPendingError, arguments);
        }
        _inherits(TransactionStillPendingError, _Error3);
        return _createClass(TransactionStillPendingError);
      }(_wrapNativeSuper(Error))
    });
    _defineProperty(SentTransaction, "init", function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(assembled) {
        var tx, sent;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              tx = new _SentTransaction(assembled);
              _context2.next = 3;
              return tx.send();
            case 3:
              sent = _context2.sent;
              return _context2.abrupt("return", sent);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/assembled_transaction.js
var require_assembled_transaction3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/assembled_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AssembledTransaction = void 0;
    var _stellarBase = require_lib3();
    var _rpc = require_rpc3();
    var _api = require_api3();
    var _transaction = require_transaction6();
    var _rust_result = require_rust_result3();
    var _utils = require_utils6();
    var _types = require_types6();
    var _sent_transaction = require_sent_transaction3();
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var AssembledTransaction5 = exports.AssembledTransaction = function() {
      function AssembledTransaction6(options) {
        var _this = this, _this$options$simulat, _this$options$allowHt;
        _classCallCheck(this, AssembledTransaction6);
        _defineProperty(this, "simulate", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _ref2, restore, account, result, _this$options$fee, _this$options$args, _this$options$timeout, contract, _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, restore = _ref2.restore;
                if (_this.built) {
                  _context.next = 5;
                  break;
                }
                if (_this.raw) {
                  _context.next = 4;
                  break;
                }
                throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
              case 4:
                _this.built = _this.raw.build();
              case 5:
                restore = restore !== null && restore !== void 0 ? restore : _this.options.restore;
                delete _this.simulationResult;
                delete _this.simulationTransactionData;
                _context.next = 10;
                return _this.server.simulateTransaction(_this.built);
              case 10:
                _this.simulation = _context.sent;
                if (!(restore && _api.Api.isSimulationRestore(_this.simulation))) {
                  _context.next = 25;
                  break;
                }
                _context.next = 14;
                return (0, _utils.getAccount)(_this.options, _this.server);
              case 14:
                account = _context.sent;
                _context.next = 17;
                return _this.restoreFootprint(_this.simulation.restorePreamble, account);
              case 17:
                result = _context.sent;
                if (!(result.status === _api.Api.GetTransactionStatus.SUCCESS)) {
                  _context.next = 24;
                  break;
                }
                contract = new _stellarBase.Contract(_this.options.contractId);
                _this.raw = new _stellarBase.TransactionBuilder(account, {
                  fee: (_this$options$fee = _this.options.fee) !== null && _this$options$fee !== void 0 ? _this$options$fee : _stellarBase.BASE_FEE,
                  networkPassphrase: _this.options.networkPassphrase
                }).addOperation(contract.call.apply(contract, [_this.options.method].concat(_toConsumableArray((_this$options$args = _this.options.args) !== null && _this$options$args !== void 0 ? _this$options$args : [])))).setTimeout((_this$options$timeout = _this.options.timeoutInSeconds) !== null && _this$options$timeout !== void 0 ? _this$options$timeout : _types.DEFAULT_TIMEOUT);
                _context.next = 23;
                return _this.simulate();
              case 23:
                return _context.abrupt("return", _this);
              case 24:
                throw new AssembledTransaction6.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(result)));
              case 25:
                if (_api.Api.isSimulationSuccess(_this.simulation)) {
                  _this.built = (0, _transaction.assembleTransaction)(_this.built, _this.simulation).build();
                }
                return _context.abrupt("return", _this);
              case 27:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        _defineProperty(this, "sign", _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
          var _this$options$timeout2;
          var _ref4, _ref4$force, force, _ref4$signTransaction, signTransaction, sigsNeeded, timeoutInSeconds, signOpts, _yield$signTransactio, signature, error, _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _ref4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref4$force = _ref4.force, force = _ref4$force === void 0 ? false : _ref4$force, _ref4$signTransaction = _ref4.signTransaction, signTransaction = _ref4$signTransaction === void 0 ? _this.options.signTransaction : _ref4$signTransaction;
                if (_this.built) {
                  _context2.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been simulated");
              case 3:
                if (!(!force && _this.isReadCall)) {
                  _context2.next = 5;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
              case 5:
                if (signTransaction) {
                  _context2.next = 7;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
              case 7:
                sigsNeeded = _this.needsNonInvokerSigningBy().filter(function(id) {
                  return !id.startsWith("C");
                });
                if (!sigsNeeded.length) {
                  _context2.next = 10;
                  break;
                }
                throw new AssembledTransaction6.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(sigsNeeded, ". ") + "See `needsNonInvokerSigningBy` for details.");
              case 10:
                timeoutInSeconds = (_this$options$timeout2 = _this.options.timeoutInSeconds) !== null && _this$options$timeout2 !== void 0 ? _this$options$timeout2 : _types.DEFAULT_TIMEOUT;
                _this.built = _stellarBase.TransactionBuilder.cloneFrom(_this.built, {
                  fee: _this.built.fee,
                  timebounds: void 0,
                  sorobanData: _this.simulationData.transactionData
                }).setTimeout(timeoutInSeconds).build();
                signOpts = {
                  networkPassphrase: _this.options.networkPassphrase
                };
                if (_this.options.address) signOpts.address = _this.options.address;
                if (_this.options.submit !== void 0) signOpts.submit = _this.options.submit;
                if (_this.options.submitUrl) signOpts.submitUrl = _this.options.submitUrl;
                _context2.next = 18;
                return signTransaction(_this.built.toXDR(), signOpts);
              case 18:
                _yield$signTransactio = _context2.sent;
                signature = _yield$signTransactio.signedTxXdr;
                error = _yield$signTransactio.error;
                _this.handleWalletError(error);
                _this.signed = _stellarBase.TransactionBuilder.fromXDR(signature, _this.options.networkPassphrase);
              case 23:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        })));
        _defineProperty(this, "signAndSend", _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
          var _ref6, _ref6$force, force, _ref6$signTransaction, signTransaction, originalSubmit, _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _ref6 = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {}, _ref6$force = _ref6.force, force = _ref6$force === void 0 ? false : _ref6$force, _ref6$signTransaction = _ref6.signTransaction, signTransaction = _ref6$signTransaction === void 0 ? _this.options.signTransaction : _ref6$signTransaction;
                if (_this.signed) {
                  _context3.next = 10;
                  break;
                }
                originalSubmit = _this.options.submit;
                if (_this.options.submit) {
                  _this.options.submit = false;
                }
                _context3.prev = 4;
                _context3.next = 7;
                return _this.sign({
                  force,
                  signTransaction
                });
              case 7:
                _context3.prev = 7;
                _this.options.submit = originalSubmit;
                return _context3.finish(7);
              case 10:
                return _context3.abrupt("return", _this.send());
              case 11:
              case "end":
                return _context3.stop();
            }
          }, _callee3, null, [[4, , 7, 10]]);
        })));
        _defineProperty(this, "needsNonInvokerSigningBy", function() {
          var _rawInvokeHostFunctio;
          var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$includeAlreadyS = _ref7.includeAlreadySigned, includeAlreadySigned = _ref7$includeAlreadyS === void 0 ? false : _ref7$includeAlreadyS;
          if (!_this.built) {
            throw new Error("Transaction has not yet been simulated");
          }
          if (!("operations" in _this.built)) {
            throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(_this.built)));
          }
          var rawInvokeHostFunctionOp = _this.built.operations[0];
          return _toConsumableArray(new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(function(entry) {
            return entry.credentials().switch() === _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === "scvVoid");
          }).map(function(entry) {
            return _stellarBase.Address.fromScAddress(entry.credentials().address().address()).toString();
          })));
        });
        _defineProperty(this, "signAuthEntries", _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
          var _rawInvokeHostFunctio2;
          var _ref9, _ref9$expiration, expiration, _ref9$signAuthEntry, signAuthEntry, _ref9$address, address, _ref9$authorizeEntry, authorizeEntry, needsNonInvokerSigningBy, rawInvokeHostFunctionOp, authEntries, _iterator, _step, _loop, _ret, _args7 = arguments;
          return _regeneratorRuntime().wrap(function _callee6$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _ref9 = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {}, _ref9$expiration = _ref9.expiration, expiration = _ref9$expiration === void 0 ? _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _this.server.getLatestLedger();
                      case 2:
                        _context4.t0 = _context4.sent.sequence;
                        return _context4.abrupt("return", _context4.t0 + 100);
                      case 4:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }))() : _ref9$expiration, _ref9$signAuthEntry = _ref9.signAuthEntry, signAuthEntry = _ref9$signAuthEntry === void 0 ? _this.options.signAuthEntry : _ref9$signAuthEntry, _ref9$address = _ref9.address, address = _ref9$address === void 0 ? _this.options.publicKey : _ref9$address, _ref9$authorizeEntry = _ref9.authorizeEntry, authorizeEntry = _ref9$authorizeEntry === void 0 ? _stellarBase.authorizeEntry : _ref9$authorizeEntry;
                if (_this.built) {
                  _context7.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been assembled or simulated");
              case 3:
                if (!(authorizeEntry === _stellarBase.authorizeEntry)) {
                  _context7.next = 11;
                  break;
                }
                needsNonInvokerSigningBy = _this.needsNonInvokerSigningBy();
                if (!(needsNonInvokerSigningBy.length === 0)) {
                  _context7.next = 7;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
              case 7:
                if (!(needsNonInvokerSigningBy.indexOf(address !== null && address !== void 0 ? address : "") === -1)) {
                  _context7.next = 9;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(address, '"'));
              case 9:
                if (signAuthEntry) {
                  _context7.next = 11;
                  break;
                }
                throw new AssembledTransaction6.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
              case 11:
                rawInvokeHostFunctionOp = _this.built.operations[0];
                authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];
                _iterator = _createForOfIteratorHelper(authEntries.entries());
                _context7.prev = 14;
                _loop = _regeneratorRuntime().mark(function _loop2() {
                  var _step$value, i, entry, credentials, authEntryAddress, sign;
                  return _regeneratorRuntime().wrap(function _loop$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _step$value = _slicedToArray(_step.value, 2), i = _step$value[0], entry = _step$value[1];
                        credentials = _stellarBase.xdr.SorobanCredentials.fromXDR(entry.credentials().toXDR());
                        if (!(credentials.switch() !== _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress())) {
                          _context6.next = 4;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 4:
                        authEntryAddress = _stellarBase.Address.fromScAddress(credentials.address().address()).toString();
                        if (!(authEntryAddress !== address)) {
                          _context6.next = 7;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 7:
                        sign = signAuthEntry !== null && signAuthEntry !== void 0 ? signAuthEntry : Promise.resolve;
                        _context6.t0 = authorizeEntry;
                        _context6.t1 = entry;
                        _context6.t2 = function() {
                          var _ref11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(preimage) {
                            var _yield$sign, signedAuthEntry, error;
                            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                              while (1) switch (_context5.prev = _context5.next) {
                                case 0:
                                  _context5.next = 2;
                                  return sign(preimage.toXDR("base64"), {
                                    address
                                  });
                                case 2:
                                  _yield$sign = _context5.sent;
                                  signedAuthEntry = _yield$sign.signedAuthEntry;
                                  error = _yield$sign.error;
                                  _this.handleWalletError(error);
                                  return _context5.abrupt("return", Buffer.from(signedAuthEntry, "base64"));
                                case 7:
                                case "end":
                                  return _context5.stop();
                              }
                            }, _callee5);
                          }));
                          return function(_x) {
                            return _ref11.apply(this, arguments);
                          };
                        }();
                        _context6.next = 13;
                        return expiration;
                      case 13:
                        _context6.t3 = _context6.sent;
                        _context6.t4 = _this.options.networkPassphrase;
                        _context6.next = 17;
                        return (0, _context6.t0)(_context6.t1, _context6.t2, _context6.t3, _context6.t4);
                      case 17:
                        authEntries[i] = _context6.sent;
                      case 18:
                      case "end":
                        return _context6.stop();
                    }
                  }, _loop2);
                });
                _iterator.s();
              case 17:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 24;
                  break;
                }
                return _context7.delegateYield(_loop(), "t0", 19);
              case 19:
                _ret = _context7.t0;
                if (!(_ret === 0)) {
                  _context7.next = 22;
                  break;
                }
                return _context7.abrupt("continue", 22);
              case 22:
                _context7.next = 17;
                break;
              case 24:
                _context7.next = 29;
                break;
              case 26:
                _context7.prev = 26;
                _context7.t1 = _context7["catch"](14);
                _iterator.e(_context7.t1);
              case 29:
                _context7.prev = 29;
                _iterator.f();
                return _context7.finish(29);
              case 32:
              case "end":
                return _context7.stop();
            }
          }, _callee6, null, [[14, 26, 29, 32]]);
        })));
        this.options = options;
        this.options.simulate = (_this$options$simulat = this.options.simulate) !== null && _this$options$simulat !== void 0 ? _this$options$simulat : true;
        this.server = new _rpc.Server(this.options.rpcUrl, {
          allowHttp: (_this$options$allowHt = this.options.allowHttp) !== null && _this$options$allowHt !== void 0 ? _this$options$allowHt : false
        });
      }
      return _createClass(AssembledTransaction6, [{
        key: "toJSON",
        value: function toJSON() {
          var _this$built;
          return JSON.stringify({
            method: this.options.method,
            tx: (_this$built = this.built) === null || _this$built === void 0 ? void 0 : _this$built.toXDR(),
            simulationResult: {
              auth: this.simulationData.result.auth.map(function(a) {
                return a.toXDR("base64");
              }),
              retval: this.simulationData.result.retval.toXDR("base64")
            },
            simulationTransactionData: this.simulationData.transactionData.toXDR("base64")
          });
        }
      }, {
        key: "toXDR",
        value: function toXDR() {
          var _this$built2;
          if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
          return (_this$built2 = this.built) === null || _this$built2 === void 0 ? void 0 : _this$built2.toEnvelope().toXDR("base64");
        }
      }, {
        key: "handleWalletError",
        value: function handleWalletError(error) {
          if (!error) return;
          var message = error.message, code = error.code;
          var fullMessage = "".concat(message).concat(error.ext ? " (".concat(error.ext.join(", "), ")") : "");
          switch (code) {
            case -1:
              throw new AssembledTransaction6.Errors.InternalWalletError(fullMessage);
            case -2:
              throw new AssembledTransaction6.Errors.ExternalServiceError(fullMessage);
            case -3:
              throw new AssembledTransaction6.Errors.InvalidClientRequest(fullMessage);
            case -4:
              throw new AssembledTransaction6.Errors.UserRejected(fullMessage);
            default:
              throw new Error("Unhandled error: ".concat(fullMessage));
          }
        }
      }, {
        key: "simulationData",
        get: function get() {
          var _simulation$result;
          if (this.simulationResult && this.simulationTransactionData) {
            return {
              result: this.simulationResult,
              transactionData: this.simulationTransactionData
            };
          }
          var simulation = this.simulation;
          if (!simulation) {
            throw new AssembledTransaction6.Errors.NotYetSimulated("Transaction has not yet been simulated");
          }
          if (_api.Api.isSimulationError(simulation)) {
            throw new AssembledTransaction6.Errors.SimulationFailed('Transaction simulation failed: "'.concat(simulation.error, '"'));
          }
          if (_api.Api.isSimulationRestore(simulation)) {
            throw new AssembledTransaction6.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
          }
          this.simulationResult = (_simulation$result = simulation.result) !== null && _simulation$result !== void 0 ? _simulation$result : {
            auth: [],
            retval: _stellarBase.xdr.ScVal.scvVoid()
          };
          this.simulationTransactionData = simulation.transactionData.build();
          return {
            result: this.simulationResult,
            transactionData: this.simulationTransactionData
          };
        }
      }, {
        key: "result",
        get: function get() {
          try {
            if (!this.simulationData.result) {
              throw new Error("No simulation result!");
            }
            return this.options.parseResultXdr(this.simulationData.result.retval);
          } catch (e) {
            if (!(0, _utils.implementsToString)(e)) throw e;
            var err = this.parseError(e.toString());
            if (err) return err;
            throw e;
          }
        }
      }, {
        key: "parseError",
        value: function parseError(errorMessage) {
          if (!this.options.errorTypes) return void 0;
          var match = errorMessage.match(_utils.contractErrorPattern);
          if (!match) return void 0;
          var i = parseInt(match[1], 10);
          var err = this.options.errorTypes[i];
          if (!err) return void 0;
          return new _rust_result.Err(err);
        }
      }, {
        key: "send",
        value: function() {
          var _send = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var sent;
            return _regeneratorRuntime().wrap(function _callee7$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  if (this.signed) {
                    _context8.next = 2;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 2:
                  _context8.next = 4;
                  return _sent_transaction.SentTransaction.init(this);
                case 4:
                  sent = _context8.sent;
                  return _context8.abrupt("return", sent);
                case 6:
                case "end":
                  return _context8.stop();
              }
            }, _callee7, this);
          }));
          function send() {
            return _send.apply(this, arguments);
          }
          return send;
        }()
      }, {
        key: "isReadCall",
        get: function get() {
          var authsCount = this.simulationData.result.auth.length;
          var writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;
          return authsCount === 0 && writeLength === 0;
        }
      }, {
        key: "restoreFootprint",
        value: function() {
          var _restoreFootprint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(restorePreamble, account) {
            var restoreTx, sentTransaction;
            return _regeneratorRuntime().wrap(function _callee8$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  if (this.options.signTransaction) {
                    _context9.next = 2;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 2:
                  if (!(account !== null && account !== void 0)) {
                    _context9.next = 6;
                    break;
                  }
                  _context9.t0 = account;
                  _context9.next = 9;
                  break;
                case 6:
                  _context9.next = 8;
                  return (0, _utils.getAccount)(this.options, this.server);
                case 8:
                  _context9.t0 = _context9.sent;
                case 9:
                  account = _context9.t0;
                  _context9.next = 12;
                  return AssembledTransaction6.buildFootprintRestoreTransaction(_objectSpread({}, this.options), restorePreamble.transactionData, account, restorePreamble.minResourceFee);
                case 12:
                  restoreTx = _context9.sent;
                  _context9.next = 15;
                  return restoreTx.signAndSend();
                case 15:
                  sentTransaction = _context9.sent;
                  if (sentTransaction.getTransactionResponse) {
                    _context9.next = 18;
                    break;
                  }
                  throw new AssembledTransaction6.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(sentTransaction)));
                case 18:
                  return _context9.abrupt("return", sentTransaction.getTransactionResponse);
                case 19:
                case "end":
                  return _context9.stop();
              }
            }, _callee8, this);
          }));
          function restoreFootprint(_x2, _x3) {
            return _restoreFootprint.apply(this, arguments);
          }
          return restoreFootprint;
        }()
      }], [{
        key: "fromJSON",
        value: function fromJSON(options, _ref12) {
          var tx = _ref12.tx, simulationResult = _ref12.simulationResult, simulationTransactionData = _ref12.simulationTransactionData;
          var txn = new AssembledTransaction6(options);
          txn.built = _stellarBase.TransactionBuilder.fromXDR(tx, options.networkPassphrase);
          txn.simulationResult = {
            auth: simulationResult.auth.map(function(a) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
            }),
            retval: _stellarBase.xdr.ScVal.fromXDR(simulationResult.retval, "base64")
          };
          txn.simulationTransactionData = _stellarBase.xdr.SorobanTransactionData.fromXDR(simulationTransactionData, "base64");
          return txn;
        }
      }, {
        key: "fromXDR",
        value: function fromXDR(options, encodedXDR, spec) {
          var _operation$func;
          var envelope = _stellarBase.xdr.TransactionEnvelope.fromXDR(encodedXDR, "base64");
          var built = _stellarBase.TransactionBuilder.fromXDR(envelope, options.networkPassphrase);
          var operation = built.operations[0];
          if (!(operation !== null && operation !== void 0 && (_operation$func = operation.func) !== null && _operation$func !== void 0 && _operation$func.value) || typeof operation.func.value !== "function") {
            throw new Error("Could not extract the method from the transaction envelope.");
          }
          var invokeContractArgs = operation.func.value();
          if (!(invokeContractArgs !== null && invokeContractArgs !== void 0 && invokeContractArgs.functionName)) {
            throw new Error("Could not extract the method name from the transaction envelope.");
          }
          var method = invokeContractArgs.functionName().toString("utf-8");
          var txn = new AssembledTransaction6(_objectSpread(_objectSpread({}, options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return spec.funcResToNative(method, result);
            }
          }));
          txn.built = built;
          return txn;
        }
      }, {
        key: "build",
        value: function build(options) {
          var _options$args;
          var contract = new _stellarBase.Contract(options.contractId);
          return AssembledTransaction6.buildWithOp(contract.call.apply(contract, [options.method].concat(_toConsumableArray((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))), options);
        }
      }, {
        key: "buildWithOp",
        value: function() {
          var _buildWithOp = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(operation, options) {
            var _options$fee, _options$timeoutInSec;
            var tx, account;
            return _regeneratorRuntime().wrap(function _callee9$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  tx = new AssembledTransaction6(options);
                  _context10.next = 3;
                  return (0, _utils.getAccount)(options, tx.server);
                case 3:
                  account = _context10.sent;
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee: (_options$fee = options.fee) !== null && _options$fee !== void 0 ? _options$fee : _stellarBase.BASE_FEE,
                    networkPassphrase: options.networkPassphrase
                  }).setTimeout((_options$timeoutInSec = options.timeoutInSeconds) !== null && _options$timeoutInSec !== void 0 ? _options$timeoutInSec : _types.DEFAULT_TIMEOUT).addOperation(operation);
                  if (!options.simulate) {
                    _context10.next = 8;
                    break;
                  }
                  _context10.next = 8;
                  return tx.simulate();
                case 8:
                  return _context10.abrupt("return", tx);
                case 9:
                case "end":
                  return _context10.stop();
              }
            }, _callee9);
          }));
          function buildWithOp(_x4, _x5) {
            return _buildWithOp.apply(this, arguments);
          }
          return buildWithOp;
        }()
      }, {
        key: "buildFootprintRestoreTransaction",
        value: function() {
          var _buildFootprintRestoreTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(options, sorobanData, account, fee) {
            var _options$timeoutInSec2;
            var tx;
            return _regeneratorRuntime().wrap(function _callee10$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  tx = new AssembledTransaction6(options);
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee,
                    networkPassphrase: options.networkPassphrase
                  }).setSorobanData(sorobanData instanceof _stellarBase.SorobanDataBuilder ? sorobanData.build() : sorobanData).addOperation(_stellarBase.Operation.restoreFootprint({})).setTimeout((_options$timeoutInSec2 = options.timeoutInSeconds) !== null && _options$timeoutInSec2 !== void 0 ? _options$timeoutInSec2 : _types.DEFAULT_TIMEOUT);
                  _context11.next = 4;
                  return tx.simulate({
                    restore: false
                  });
                case 4:
                  return _context11.abrupt("return", tx);
                case 5:
                case "end":
                  return _context11.stop();
              }
            }, _callee10);
          }));
          function buildFootprintRestoreTransaction(_x6, _x7, _x8, _x9) {
            return _buildFootprintRestoreTransaction.apply(this, arguments);
          }
          return buildFootprintRestoreTransaction;
        }()
      }]);
    }();
    _defineProperty(AssembledTransaction5, "Errors", {
      ExpiredState: function(_Error) {
        function ExpiredStateError() {
          _classCallCheck(this, ExpiredStateError);
          return _callSuper(this, ExpiredStateError, arguments);
        }
        _inherits(ExpiredStateError, _Error);
        return _createClass(ExpiredStateError);
      }(_wrapNativeSuper(Error)),
      RestorationFailure: function(_Error2) {
        function RestoreFailureError() {
          _classCallCheck(this, RestoreFailureError);
          return _callSuper(this, RestoreFailureError, arguments);
        }
        _inherits(RestoreFailureError, _Error2);
        return _createClass(RestoreFailureError);
      }(_wrapNativeSuper(Error)),
      NeedsMoreSignatures: function(_Error3) {
        function NeedsMoreSignaturesError() {
          _classCallCheck(this, NeedsMoreSignaturesError);
          return _callSuper(this, NeedsMoreSignaturesError, arguments);
        }
        _inherits(NeedsMoreSignaturesError, _Error3);
        return _createClass(NeedsMoreSignaturesError);
      }(_wrapNativeSuper(Error)),
      NoSignatureNeeded: function(_Error4) {
        function NoSignatureNeededError() {
          _classCallCheck(this, NoSignatureNeededError);
          return _callSuper(this, NoSignatureNeededError, arguments);
        }
        _inherits(NoSignatureNeededError, _Error4);
        return _createClass(NoSignatureNeededError);
      }(_wrapNativeSuper(Error)),
      NoUnsignedNonInvokerAuthEntries: function(_Error5) {
        function NoUnsignedNonInvokerAuthEntriesError() {
          _classCallCheck(this, NoUnsignedNonInvokerAuthEntriesError);
          return _callSuper(this, NoUnsignedNonInvokerAuthEntriesError, arguments);
        }
        _inherits(NoUnsignedNonInvokerAuthEntriesError, _Error5);
        return _createClass(NoUnsignedNonInvokerAuthEntriesError);
      }(_wrapNativeSuper(Error)),
      NoSigner: function(_Error6) {
        function NoSignerError() {
          _classCallCheck(this, NoSignerError);
          return _callSuper(this, NoSignerError, arguments);
        }
        _inherits(NoSignerError, _Error6);
        return _createClass(NoSignerError);
      }(_wrapNativeSuper(Error)),
      NotYetSimulated: function(_Error7) {
        function NotYetSimulatedError() {
          _classCallCheck(this, NotYetSimulatedError);
          return _callSuper(this, NotYetSimulatedError, arguments);
        }
        _inherits(NotYetSimulatedError, _Error7);
        return _createClass(NotYetSimulatedError);
      }(_wrapNativeSuper(Error)),
      FakeAccount: function(_Error8) {
        function FakeAccountError() {
          _classCallCheck(this, FakeAccountError);
          return _callSuper(this, FakeAccountError, arguments);
        }
        _inherits(FakeAccountError, _Error8);
        return _createClass(FakeAccountError);
      }(_wrapNativeSuper(Error)),
      SimulationFailed: function(_Error9) {
        function SimulationFailedError() {
          _classCallCheck(this, SimulationFailedError);
          return _callSuper(this, SimulationFailedError, arguments);
        }
        _inherits(SimulationFailedError, _Error9);
        return _createClass(SimulationFailedError);
      }(_wrapNativeSuper(Error)),
      InternalWalletError: function(_Error10) {
        function InternalWalletError() {
          _classCallCheck(this, InternalWalletError);
          return _callSuper(this, InternalWalletError, arguments);
        }
        _inherits(InternalWalletError, _Error10);
        return _createClass(InternalWalletError);
      }(_wrapNativeSuper(Error)),
      ExternalServiceError: function(_Error11) {
        function ExternalServiceError() {
          _classCallCheck(this, ExternalServiceError);
          return _callSuper(this, ExternalServiceError, arguments);
        }
        _inherits(ExternalServiceError, _Error11);
        return _createClass(ExternalServiceError);
      }(_wrapNativeSuper(Error)),
      InvalidClientRequest: function(_Error12) {
        function InvalidClientRequestError() {
          _classCallCheck(this, InvalidClientRequestError);
          return _callSuper(this, InvalidClientRequestError, arguments);
        }
        _inherits(InvalidClientRequestError, _Error12);
        return _createClass(InvalidClientRequestError);
      }(_wrapNativeSuper(Error)),
      UserRejected: function(_Error13) {
        function UserRejectedError() {
          _classCallCheck(this, UserRejectedError);
          return _callSuper(this, UserRejectedError, arguments);
        }
        _inherits(UserRejectedError, _Error13);
        return _createClass(UserRejectedError);
      }(_wrapNativeSuper(Error))
    });
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/basic_node_signer.js
var require_basic_node_signer3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/basic_node_signer.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.basicNodeSigner = void 0;
    var _stellarBase = require_lib3();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var basicNodeSigner2 = exports.basicNodeSigner = function basicNodeSigner3(keypair, networkPassphrase) {
      return {
        signTransaction: function() {
          var _signTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(xdr3, opts) {
            var t;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  t = _stellarBase.TransactionBuilder.fromXDR(xdr3, (opts === null || opts === void 0 ? void 0 : opts.networkPassphrase) || networkPassphrase);
                  t.sign(keypair);
                  return _context.abrupt("return", {
                    signedTxXdr: t.toXDR(),
                    signerAddress: keypair.publicKey()
                  });
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function signTransaction(_x, _x2) {
            return _signTransaction.apply(this, arguments);
          }
          return signTransaction;
        }(),
        signAuthEntry: function() {
          var _signAuthEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(authEntry) {
            var signedAuthEntry;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  signedAuthEntry = keypair.sign((0, _stellarBase.hash)(Buffer.from(authEntry, "base64"))).toString("base64");
                  return _context2.abrupt("return", {
                    signedAuthEntry,
                    signerAddress: keypair.publicKey()
                  });
                case 2:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function signAuthEntry(_x3) {
            return _signAuthEntry.apply(this, arguments);
          }
          return signAuthEntry;
        }()
      };
    };
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/spec.js
var require_spec3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/spec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Spec = void 0;
    var _stellarBase = require_lib3();
    var _rust_result = require_rust_result3();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function enumToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        var title = aCase.name().toString();
        var desc = aCase.doc().toString();
        oneOf.push({
          description: desc,
          title,
          enum: [aCase.value()],
          type: "number"
        });
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    function isNumeric(field) {
      return /^\d+$/.test(field.name().toString());
    }
    function readObj(args, input) {
      var inputName = input.name().toString();
      var entry = Object.entries(args).find(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), name = _ref2[0];
        return name === inputName;
      });
      if (!entry) {
        throw new Error("Missing field ".concat(inputName));
      }
      return entry[1];
    }
    function findCase(name) {
      return function matches(entry) {
        switch (entry.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var tuple = entry.tupleCase();
            return tuple.name().toString() === name;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var voidCase = entry.voidCase();
            return voidCase.name().toString() === name;
          }
          default:
            return false;
        }
      };
    }
    function stringToScVal(str, ty) {
      switch (ty.value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value:
          return _stellarBase.xdr.ScVal.scvString(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value:
          return _stellarBase.xdr.ScVal.scvSymbol(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value:
          return _stellarBase.Address.fromString(str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
          return new _stellarBase.XdrLargeInt("u64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
          return new _stellarBase.XdrLargeInt("i64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
          return new _stellarBase.XdrLargeInt("u128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
          return new _stellarBase.XdrLargeInt("i128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
          return new _stellarBase.XdrLargeInt("u256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
          return new _stellarBase.XdrLargeInt("i256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value:
          return _stellarBase.xdr.ScVal.scvBytes(Buffer.from(str, "base64"));
        default:
          throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
      }
    }
    var PRIMITIVE_DEFINITONS = {
      U32: {
        type: "integer",
        minimum: 0,
        maximum: 4294967295
      },
      I32: {
        type: "integer",
        minimum: -2147483648,
        maximum: 2147483647
      },
      U64: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      I64: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 21
      },
      U128: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 39
      },
      I128: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 40
      },
      U256: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 78
      },
      I256: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 79
      },
      Address: {
        type: "string",
        format: "address",
        description: "Address can be a public key or contract id"
      },
      ScString: {
        type: "string",
        description: "ScString is a string"
      },
      ScSymbol: {
        type: "string",
        description: "ScSymbol is a string"
      },
      DataUrl: {
        type: "string",
        pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$"
      }
    };
    function typeRef(typeDef) {
      var t = typeDef.switch();
      var value = t.value;
      var ref;
      switch (value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal().value: {
          ref = "Val";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool().value: {
          return {
            type: "boolean"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value: {
          return {
            type: "null"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeError().value: {
          ref = "Error";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value: {
          ref = "U32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value: {
          ref = "I32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value: {
          ref = "U64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value: {
          ref = "I64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value: {
          throw new Error("Timepoint type not supported");
          ref = "Timepoint";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
          throw new Error("Duration not supported");
          ref = "Duration";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value: {
          ref = "U128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value: {
          ref = "I128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value: {
          ref = "U256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
          ref = "I256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value: {
          ref = "DataUrl";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value: {
          ref = "ScString";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value: {
          ref = "ScSymbol";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value: {
          ref = "Address";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value: {
          var opt = typeDef.option();
          return typeRef(opt.valueType());
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult().value: {
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
          var arr = typeDef.vec();
          var reference = typeRef(arr.elementType());
          return {
            type: "array",
            items: reference
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
          var map = typeDef.map();
          var items = [typeRef(map.keyType()), typeRef(map.valueType())];
          return {
            type: "array",
            items: {
              type: "array",
              items,
              minItems: 2,
              maxItems: 2
            }
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
          var tuple = typeDef.tuple();
          var minItems = tuple.valueTypes().length;
          var maxItems = minItems;
          var _items = tuple.valueTypes().map(typeRef);
          return {
            type: "array",
            items: _items,
            minItems,
            maxItems
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
          var _arr = typeDef.bytesN();
          return {
            $ref: "#/definitions/DataUrl",
            maxLength: _arr.n()
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value: {
          var udt = typeDef.udt();
          ref = udt.name().toString();
          break;
        }
      }
      return {
        $ref: "#/definitions/".concat(ref)
      };
    }
    function isRequired(typeDef) {
      return typeDef.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeOption().value;
    }
    function argsAndRequired(input) {
      var properties = {};
      var required = [];
      input.forEach(function(arg) {
        var aType = arg.type();
        var name = arg.name().toString();
        properties[name] = typeRef(aType);
        if (isRequired(aType)) {
          required.push(name);
        }
      });
      var res = {
        properties
      };
      if (required.length > 0) {
        res.required = required;
      }
      return res;
    }
    function structToJsonSchema(udt) {
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error("mixed numeric and non-numeric field names are not allowed");
        }
        var items = fields.map(function(_, i) {
          return typeRef(fields[i].type());
        });
        return {
          type: "array",
          items,
          minItems: fields.length,
          maxItems: fields.length
        };
      }
      var description = udt.doc().toString();
      var _argsAndRequired = argsAndRequired(fields), properties = _argsAndRequired.properties, required = _argsAndRequired.required;
      properties.additionalProperties = false;
      return {
        description,
        properties,
        required,
        type: "object"
      };
    }
    function functionToJsonSchema(func) {
      var _argsAndRequired2 = argsAndRequired(func.inputs()), properties = _argsAndRequired2.properties, required = _argsAndRequired2.required;
      var args = {
        additionalProperties: false,
        properties,
        type: "object"
      };
      if ((required === null || required === void 0 ? void 0 : required.length) > 0) {
        args.required = required;
      }
      var input = {
        properties: {
          args
        }
      };
      var outputs = func.outputs();
      var output = outputs.length > 0 ? typeRef(outputs[0]) : typeRef(_stellarBase.xdr.ScSpecTypeDef.scSpecTypeVoid());
      var description = func.doc().toString();
      if (description.length > 0) {
        input.description = description;
      }
      input.additionalProperties = false;
      output.additionalProperties = false;
      return {
        input,
        output
      };
    }
    function unionToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        switch (aCase.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var c = aCase.voidCase();
            var title = c.name().toString();
            oneOf.push({
              type: "object",
              title,
              properties: {
                tag: title
              },
              additionalProperties: false,
              required: ["tag"]
            });
            break;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var _c = aCase.tupleCase();
            var _title = _c.name().toString();
            oneOf.push({
              type: "object",
              title: _title,
              properties: {
                tag: _title,
                values: {
                  type: "array",
                  items: _c.type().map(typeRef)
                }
              },
              required: ["tag", "values"],
              additionalProperties: false
            });
          }
        }
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    var Spec = exports.Spec = function() {
      function Spec2(entries) {
        _classCallCheck(this, Spec2);
        _defineProperty(this, "entries", []);
        if (entries.length === 0) {
          throw new Error("Contract spec must have at least one entry");
        }
        var entry = entries[0];
        if (typeof entry === "string") {
          this.entries = entries.map(function(s) {
            return _stellarBase.xdr.ScSpecEntry.fromXDR(s, "base64");
          });
        } else {
          this.entries = entries;
        }
      }
      return _createClass(Spec2, [{
        key: "funcs",
        value: function funcs() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(entry) {
            return entry.functionV0();
          });
        }
      }, {
        key: "getFunc",
        value: function getFunc(name) {
          var entry = this.findEntry(name);
          if (entry.switch().value !== _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
            throw new Error("".concat(name, " is not a function"));
          }
          return entry.functionV0();
        }
      }, {
        key: "funcArgsToScVals",
        value: function funcArgsToScVals(name, args) {
          var _this = this;
          var fn = this.getFunc(name);
          return fn.inputs().map(function(input) {
            return _this.nativeToScVal(readObj(args, input), input.type());
          });
        }
      }, {
        key: "funcResToNative",
        value: function funcResToNative(name, val_or_base64) {
          var val = typeof val_or_base64 === "string" ? _stellarBase.xdr.ScVal.fromXDR(val_or_base64, "base64") : val_or_base64;
          var func = this.getFunc(name);
          var outputs = func.outputs();
          if (outputs.length === 0) {
            var type = val.switch();
            if (type.value !== _stellarBase.xdr.ScValType.scvVoid().value) {
              throw new Error("Expected void, got ".concat(type.name));
            }
            return null;
          }
          if (outputs.length > 1) {
            throw new Error("Multiple outputs not supported");
          }
          var output = outputs[0];
          if (output.switch().value === _stellarBase.xdr.ScSpecType.scSpecTypeResult().value) {
            return new _rust_result.Ok(this.scValToNative(val, output.result().okType()));
          }
          return this.scValToNative(val, output);
        }
      }, {
        key: "findEntry",
        value: function findEntry(name) {
          var entry = this.entries.find(function(e) {
            return e.value().name().toString() === name;
          });
          if (!entry) {
            throw new Error("no such entry: ".concat(name));
          }
          return entry;
        }
      }, {
        key: "nativeToScVal",
        value: function nativeToScVal(val, ty) {
          var _this2 = this;
          var t = ty.switch();
          var value = t.value;
          if (t.value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            var udt = ty.udt();
            return this.nativeToUdt(val, udt.name().toString());
          }
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
            var opt = ty.option();
            if (val === void 0) {
              return _stellarBase.xdr.ScVal.scvVoid();
            }
            return this.nativeToScVal(val, opt.valueType());
          }
          switch (_typeof(val)) {
            case "object": {
              var _val$constructor$name, _val$constructor;
              if (val === null) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                    return _stellarBase.xdr.ScVal.scvVoid();
                  default:
                    throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
                }
              }
              if (val instanceof _stellarBase.xdr.ScVal) {
                return val;
              }
              if (val instanceof _stellarBase.Address) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.toScVal();
              }
              if (val instanceof _stellarBase.Contract) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.address().toScVal();
              }
              if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
                var copy = Uint8Array.from(val);
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
                    var bytesN = ty.bytesN();
                    if (copy.length !== bytesN.n()) {
                      throw new TypeError("expected ".concat(bytesN.n(), " bytes, but got ").concat(copy.length));
                    }
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  default:
                    throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(val)) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
                    var vec = ty.vec();
                    var elementType = vec.elementType();
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2) {
                      return _this2.nativeToScVal(v2, elementType);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
                    var tup = ty.tuple();
                    var valTypes = tup.valueTypes();
                    if (val.length !== valTypes.length) {
                      throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                    }
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2, i) {
                      return _this2.nativeToScVal(v2, valTypes[i]);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
                    var map = ty.map();
                    var keyType = map.keyType();
                    var valueType = map.valueType();
                    return _stellarBase.xdr.ScVal.scvMap(val.map(function(entry) {
                      var key2 = _this2.nativeToScVal(entry[0], keyType);
                      var mapVal = _this2.nativeToScVal(entry[1], valueType);
                      return new _stellarBase.xdr.ScMapEntry({
                        key: key2,
                        val: mapVal
                      });
                    }));
                  }
                  default:
                    throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
                }
              }
              if (val.constructor === Map) {
                if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                  throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
                }
                var scMap = ty.map();
                var _map = val;
                var entries = [];
                var values = _map.entries();
                var res = values.next();
                while (!res.done) {
                  var _res$value = _slicedToArray(res.value, 2), k = _res$value[0], v = _res$value[1];
                  var key = this.nativeToScVal(k, scMap.keyType());
                  var mapval = this.nativeToScVal(v, scMap.valueType());
                  entries.push(new _stellarBase.xdr.ScMapEntry({
                    key,
                    val: mapval
                  }));
                  res = values.next();
                }
                return _stellarBase.xdr.ScVal.scvMap(entries);
              }
              if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
                var _val$constructor2;
                throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
              }
              throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
            }
            case "number":
            case "bigint": {
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value:
                  return _stellarBase.xdr.ScVal.scvU32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value:
                  return _stellarBase.xdr.ScVal.scvI32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
                  var intType = t.name.substring(10).toLowerCase();
                  return new _stellarBase.XdrLargeInt(intType, val).toScVal();
                }
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
              }
            }
            case "string":
              return stringToScVal(val, t);
            case "boolean": {
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeBool().value) {
                throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
              }
              return _stellarBase.xdr.ScVal.scvBool(val);
            }
            case "undefined": {
              if (!ty) {
                return _stellarBase.xdr.ScVal.scvVoid();
              }
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value:
                  return _stellarBase.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
              }
            }
            case "function":
              return this.nativeToScVal(val(), ty);
            default:
              throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
          }
        }
      }, {
        key: "nativeToUdt",
        value: function nativeToUdt(val, name) {
          var entry = this.findEntry(name);
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if (typeof val !== "number") {
                throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(_typeof(val)));
              }
              return this.nativeToEnum(val, entry.udtEnumV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(val, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(val, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(name));
          }
        }
      }, {
        key: "nativeToUnion",
        value: function nativeToUnion(val, union_) {
          var _this3 = this;
          var entryName = val.tag;
          var caseFound = union_.cases().find(function(entry) {
            var caseN = entry.value().name().toString();
            return caseN === entryName;
          });
          if (!caseFound) {
            throw new TypeError("no such enum entry: ".concat(entryName, " in ").concat(union_));
          }
          var key = _stellarBase.xdr.ScVal.scvSymbol(entryName);
          switch (caseFound.switch()) {
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0(): {
              return _stellarBase.xdr.ScVal.scvVec([key]);
            }
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0(): {
              var types = caseFound.tupleCase().type();
              if (Array.isArray(val.values)) {
                if (val.values.length !== types.length) {
                  throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
                }
                var scvals = val.values.map(function(v, i) {
                  return _this3.nativeToScVal(v, types[i]);
                });
                scvals.unshift(key);
                return _stellarBase.xdr.ScVal.scvVec(scvals);
              }
              throw new Error("failed to parse union case ".concat(caseFound, " with ").concat(val));
            }
            default:
              throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
          }
        }
      }, {
        key: "nativeToStruct",
        value: function nativeToStruct(val, struct) {
          var _this4 = this;
          var fields = struct.fields();
          if (fields.some(isNumeric)) {
            if (!fields.every(isNumeric)) {
              throw new Error("mixed numeric and non-numeric field names are not allowed");
            }
            return _stellarBase.xdr.ScVal.scvVec(fields.map(function(_, i) {
              return _this4.nativeToScVal(val[i], fields[i].type());
            }));
          }
          return _stellarBase.xdr.ScVal.scvMap(fields.map(function(field) {
            var name = field.name().toString();
            return new _stellarBase.xdr.ScMapEntry({
              key: _this4.nativeToScVal(name, _stellarBase.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
              val: _this4.nativeToScVal(val[name], field.type())
            });
          }));
        }
      }, {
        key: "nativeToEnum",
        value: function nativeToEnum(val, enum_) {
          if (enum_.cases().some(function(entry) {
            return entry.value() === val;
          })) {
            return _stellarBase.xdr.ScVal.scvU32(val);
          }
          throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
        }
      }, {
        key: "scValStrToNative",
        value: function scValStrToNative(scv, typeDef) {
          return this.scValToNative(_stellarBase.xdr.ScVal.fromXDR(scv, "base64"), typeDef);
        }
      }, {
        key: "scValToNative",
        value: function scValToNative(scv, typeDef) {
          var _this5 = this;
          var t = typeDef.switch();
          var value = t.value;
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            return this.scValUdtToNative(scv, typeDef.udt());
          }
          switch (scv.switch().value) {
            case _stellarBase.xdr.ScValType.scvVoid().value:
              return void 0;
            case _stellarBase.xdr.ScValType.scvU64().value:
            case _stellarBase.xdr.ScValType.scvI64().value:
            case _stellarBase.xdr.ScValType.scvU128().value:
            case _stellarBase.xdr.ScValType.scvI128().value:
            case _stellarBase.xdr.ScValType.scvU256().value:
            case _stellarBase.xdr.ScValType.scvI256().value:
              return (0, _stellarBase.scValToBigInt)(scv);
            case _stellarBase.xdr.ScValType.scvVec().value: {
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeVec().value) {
                var _scv$vec;
                var vec = typeDef.vec();
                return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function(elm) {
                  return _this5.scValToNative(elm, vec.elementType());
                });
              }
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value) {
                var _scv$vec2;
                var tuple = typeDef.tuple();
                var valTypes = tuple.valueTypes();
                return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function(elm, i) {
                  return _this5.scValToNative(elm, valTypes[i]);
                });
              }
              throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
            }
            case _stellarBase.xdr.ScValType.scvAddress().value:
              return _stellarBase.Address.fromScVal(scv).toString();
            case _stellarBase.xdr.ScValType.scvMap().value: {
              var _scv$map;
              var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                var typed = typeDef.map();
                var keyType = typed.keyType();
                var valueType = typed.valueType();
                var res = map.map(function(entry) {
                  return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
                });
                return res;
              }
              throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            case _stellarBase.xdr.ScValType.scvBool().value:
            case _stellarBase.xdr.ScValType.scvU32().value:
            case _stellarBase.xdr.ScValType.scvI32().value:
            case _stellarBase.xdr.ScValType.scvBytes().value:
              return scv.value();
            case _stellarBase.xdr.ScValType.scvString().value:
            case _stellarBase.xdr.ScValType.scvSymbol().value: {
              var _scv$value;
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeString().value && value !== _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value) {
                throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
              }
              return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
            }
            case _stellarBase.xdr.ScValType.scvTimepoint().value:
            case _stellarBase.xdr.ScValType.scvDuration().value:
              return (0, _stellarBase.scValToBigInt)(_stellarBase.xdr.ScVal.scvU64(scv.u64()));
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
          }
        }
      }, {
        key: "scValUdtToNative",
        value: function scValUdtToNative(scv, udt) {
          var entry = this.findEntry(udt.name().toString());
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(scv);
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(scv, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(scv, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
          }
        }
      }, {
        key: "unionToNative",
        value: function unionToNative(val, udt) {
          var _this6 = this;
          var vec = val.vec();
          if (!vec) {
            throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
          }
          if (vec.length === 0 && udt.cases.length !== 0) {
            throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
          }
          var name = vec[0].sym().toString();
          if (vec[0].switch().value !== _stellarBase.xdr.ScValType.scvSymbol().value) {
            throw new Error("{vec[0]} is not a symbol");
          }
          var entry = udt.cases().find(findCase(name));
          if (!entry) {
            throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
          }
          var res = {
            tag: name
          };
          if (entry.switch().value === _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var tuple = entry.tupleCase();
            var ty = tuple.type();
            var values = ty.map(function(e, i) {
              return _this6.scValToNative(vec[i + 1], e);
            });
            res.values = values;
          }
          return res;
        }
      }, {
        key: "structToNative",
        value: function structToNative(val, udt) {
          var _this7 = this, _val$map;
          var res = {};
          var fields = udt.fields();
          if (fields.some(isNumeric)) {
            var _val$vec;
            var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function(entry, i) {
              return _this7.scValToNative(entry, fields[i].type());
            });
            return r;
          }
          (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function(entry, i) {
            var field = fields[i];
            res[field.name().toString()] = _this7.scValToNative(entry.val(), field.type());
          });
          return res;
        }
      }, {
        key: "enumToNative",
        value: function enumToNative(scv) {
          if (scv.switch().value !== _stellarBase.xdr.ScValType.scvU32().value) {
            throw new Error("Enum must have a u32 value");
          }
          var num = scv.u32();
          return num;
        }
      }, {
        key: "errorCases",
        value: function errorCases() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(entry) {
            return entry.value().cases();
          });
        }
      }, {
        key: "jsonSchema",
        value: function jsonSchema(funcName) {
          var definitions = {};
          this.entries.forEach(function(entry) {
            switch (entry.switch().value) {
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value: {
                var udt = entry.udtEnumV0();
                definitions[udt.name().toString()] = enumToJsonSchema(udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value: {
                var _udt = entry.udtStructV0();
                definitions[_udt.name().toString()] = structToJsonSchema(_udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value: {
                var _udt2 = entry.udtUnionV0();
                definitions[_udt2.name().toString()] = unionToJsonSchema(_udt2);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value: {
                var fn = entry.functionV0();
                var fnName = fn.name().toString();
                var _functionToJsonSchema = functionToJsonSchema(fn), input = _functionToJsonSchema.input;
                definitions[fnName] = input;
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value: {
              }
            }
          });
          var res = {
            $schema: "http://json-schema.org/draft-07/schema#",
            definitions: _objectSpread(_objectSpread({}, PRIMITIVE_DEFINITONS), definitions)
          };
          if (funcName) {
            res.$ref = "#/definitions/".concat(funcName);
          }
          return res;
        }
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/client.js
var require_client3 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/client.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _stellarBase = require_lib3();
    var _spec = require_spec3();
    var _rpc = require_rpc3();
    var _assembled_transaction = require_assembled_transaction3();
    var _utils = require_utils6();
    var _excluded = ["method"];
    var _excluded2 = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o, r, i = _objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var CONSTRUCTOR_FUNC = "__constructor";
    function specFromWasm(_x) {
      return _specFromWasm.apply(this, arguments);
    }
    function _specFromWasm() {
      _specFromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasm) {
        var xdrSections, wasmModule, customData, bufferSection, specEntryArray, spec;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return WebAssembly.compile(wasm);
            case 3:
              wasmModule = _context5.sent;
              xdrSections = WebAssembly.Module.customSections(wasmModule, "contractspecv0");
              _context5.next = 11;
              break;
            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](0);
              customData = parseWasmCustomSections(wasm);
              xdrSections = customData.get("contractspecv0");
            case 11:
              if (!(!xdrSections || xdrSections.length === 0)) {
                _context5.next = 13;
                break;
              }
              throw new Error("Could not obtain contract spec from wasm");
            case 13:
              bufferSection = Buffer.from(xdrSections[0]);
              specEntryArray = (0, _utils.processSpecEntryStream)(bufferSection);
              spec = new _spec.Spec(specEntryArray);
              return _context5.abrupt("return", spec);
            case 17:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 7]]);
      }));
      return _specFromWasm.apply(this, arguments);
    }
    function parseWasmCustomSections(buffer) {
      var sections = /* @__PURE__ */ new Map();
      var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
      var offset = 0;
      var read = function read2(length) {
        if (offset + length > buffer.byteLength) throw new Error("Buffer overflow");
        var bytes = new Uint8Array(arrayBuffer, offset, length);
        offset += length;
        return bytes;
      };
      if (_toConsumableArray(read(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
      if (_toConsumableArray(read(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
      while (offset < buffer.byteLength) {
        var sectionId = read(1)[0];
        var sectionLength = readVarUint32();
        var start = offset;
        if (sectionId === 0) {
          var nameLen = readVarUint32();
          if (nameLen === 0 || offset + nameLen > start + sectionLength) continue;
          var nameBytes = read(nameLen);
          var payload = read(sectionLength - (offset - start));
          try {
            var name = new TextDecoder("utf-8", {
              fatal: true
            }).decode(nameBytes);
            if (payload.length > 0) {
              sections.set(name, (sections.get(name) || []).concat(payload));
            }
          } catch (_unused) {
          }
        } else {
          offset += sectionLength;
        }
      }
      function readVarUint32() {
        var value = 0, shift = 0;
        while (true) {
          var byte = read(1)[0];
          value |= (byte & 127) << shift;
          if ((byte & 128) === 0) break;
          if ((shift += 7) >= 32) throw new Error("Invalid WASM value");
        }
        return value >>> 0;
      }
      return sections;
    }
    function specFromWasmHash(_x2, _x3) {
      return _specFromWasmHash.apply(this, arguments);
    }
    function _specFromWasmHash() {
      _specFromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(wasmHash, options) {
        var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              format = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : "hex";
              if (!(!options || !options.rpcUrl)) {
                _context6.next = 3;
                break;
              }
              throw new TypeError("options must contain rpcUrl");
            case 3:
              rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
              serverOpts = {
                allowHttp
              };
              server = new _rpc.Server(rpcUrl, serverOpts);
              _context6.next = 8;
              return server.getContractWasmByHash(wasmHash, format);
            case 8:
              wasm = _context6.sent;
              return _context6.abrupt("return", specFromWasm(wasm));
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return _specFromWasmHash.apply(this, arguments);
    }
    var Client3 = exports.Client = function() {
      function Client4(spec, options) {
        var _this = this;
        _classCallCheck(this, Client4);
        _defineProperty(this, "txFromJSON", function(json) {
          var _JSON$parse = JSON.parse(json), method = _JSON$parse.method, tx = _objectWithoutProperties(_JSON$parse, _excluded);
          return _assembled_transaction.AssembledTransaction.fromJSON(_objectSpread(_objectSpread({}, _this.options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return _this.spec.funcResToNative(method, result);
            }
          }), tx);
        });
        _defineProperty(this, "txFromXDR", function(xdrBase64) {
          return _assembled_transaction.AssembledTransaction.fromXDR(_this.options, xdrBase64, _this.spec);
        });
        this.spec = spec;
        this.options = options;
        this.spec.funcs().forEach(function(xdrFn) {
          var method = xdrFn.name().toString();
          if (method === CONSTRUCTOR_FUNC) {
            return;
          }
          var assembleTransaction = function assembleTransaction2(args, methodOptions) {
            return _assembled_transaction.AssembledTransaction.build(_objectSpread(_objectSpread(_objectSpread({
              method,
              args: args && spec.funcArgsToScVals(method, args)
            }, options), methodOptions), {}, {
              errorTypes: spec.errorCases().reduce(function(acc, curr) {
                return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, curr.value(), {
                  message: curr.doc().toString()
                }));
              }, {}),
              parseResultXdr: function parseResultXdr(result) {
                return spec.funcResToNative(method, result);
              }
            }));
          };
          _this[method] = spec.getFunc(method).inputs().length === 0 ? function(opts) {
            return assembleTransaction(void 0, opts);
          } : assembleTransaction;
        });
      }
      return _createClass(Client4, null, [{
        key: "deploy",
        value: function() {
          var _deploy = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(args, options) {
            var wasmHash, salt, format, fee, timeoutInSeconds, simulate, clientOptions, spec, operation;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  wasmHash = options.wasmHash, salt = options.salt, format = options.format, fee = options.fee, timeoutInSeconds = options.timeoutInSeconds, simulate = options.simulate, clientOptions = _objectWithoutProperties(options, _excluded2);
                  _context.next = 3;
                  return specFromWasmHash(wasmHash, clientOptions, format);
                case 3:
                  spec = _context.sent;
                  operation = _stellarBase.Operation.createCustomContract({
                    address: new _stellarBase.Address(options.address || options.publicKey),
                    wasmHash: typeof wasmHash === "string" ? Buffer.from(wasmHash, format !== null && format !== void 0 ? format : "hex") : wasmHash,
                    salt,
                    constructorArgs: args ? spec.funcArgsToScVals(CONSTRUCTOR_FUNC, args) : []
                  });
                  return _context.abrupt("return", _assembled_transaction.AssembledTransaction.buildWithOp(operation, _objectSpread(_objectSpread({
                    fee,
                    timeoutInSeconds,
                    simulate
                  }, clientOptions), {}, {
                    contractId: "ignored",
                    method: CONSTRUCTOR_FUNC,
                    parseResultXdr: function parseResultXdr(result) {
                      return new Client4(spec, _objectSpread(_objectSpread({}, clientOptions), {}, {
                        contractId: _stellarBase.Address.fromScVal(result).toString()
                      }));
                    }
                  })));
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function deploy(_x4, _x5) {
            return _deploy.apply(this, arguments);
          }
          return deploy;
        }()
      }, {
        key: "fromWasmHash",
        value: function() {
          var _fromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(wasmHash, options) {
            var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args2 = arguments;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  format = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : "hex";
                  if (!(!options || !options.rpcUrl)) {
                    _context2.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context2.next = 8;
                  return server.getContractWasmByHash(wasmHash, format);
                case 8:
                  wasm = _context2.sent;
                  return _context2.abrupt("return", Client4.fromWasm(wasm, options));
                case 10:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function fromWasmHash(_x6, _x7) {
            return _fromWasmHash.apply(this, arguments);
          }
          return fromWasmHash;
        }()
      }, {
        key: "fromWasm",
        value: function() {
          var _fromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(wasm, options) {
            var spec;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return specFromWasm(wasm);
                case 2:
                  spec = _context3.sent;
                  return _context3.abrupt("return", new Client4(spec, options));
                case 4:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function fromWasm(_x8, _x9) {
            return _fromWasm.apply(this, arguments);
          }
          return fromWasm;
        }()
      }, {
        key: "from",
        value: function() {
          var _from = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(options) {
            var rpcUrl, contractId, allowHttp, serverOpts, server, wasm;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  if (!(!options || !options.rpcUrl || !options.contractId)) {
                    _context4.next = 2;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 2:
                  rpcUrl = options.rpcUrl, contractId = options.contractId, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context4.next = 7;
                  return server.getContractWasmByContractId(contractId);
                case 7:
                  wasm = _context4.sent;
                  return _context4.abrupt("return", Client4.fromWasm(wasm, options));
                case 9:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }));
          function from(_x10) {
            return _from.apply(this, arguments);
          }
          return from;
        }()
      }]);
    }();
  }
});

// node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/index.js
var require_contract6 = __commonJS({
  "node_modules/sac-sdk/node_modules/@stellar/stellar-sdk/lib/minimal/contract/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _assembled_transaction = require_assembled_transaction3();
    Object.keys(_assembled_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _assembled_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _assembled_transaction[key];
        }
      });
    });
    var _basic_node_signer = require_basic_node_signer3();
    Object.keys(_basic_node_signer).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _basic_node_signer[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _basic_node_signer[key];
        }
      });
    });
    var _client = require_client3();
    Object.keys(_client).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _client[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _client[key];
        }
      });
    });
    var _rust_result = require_rust_result3();
    Object.keys(_rust_result).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _rust_result[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _rust_result[key];
        }
      });
    });
    var _sent_transaction = require_sent_transaction3();
    Object.keys(_sent_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _sent_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sent_transaction[key];
        }
      });
    });
    var _spec = require_spec3();
    Object.keys(_spec).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _spec[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _spec[key];
        }
      });
    });
    var _types = require_types6();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
  }
});

// node_modules/passkey-kit/src/types.ts
var SignerKey = class _SignerKey {
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  static Policy(policy) {
    return new _SignerKey("Policy", policy);
  }
  static Ed25519(publicKey) {
    return new _SignerKey("Ed25519", publicKey);
  }
  static Secp256r1(id) {
    return new _SignerKey("Secp256r1", id);
  }
};
var SignerStore = /* @__PURE__ */ ((SignerStore2) => {
  SignerStore2["Persistent"] = "Persistent";
  SignerStore2["Temporary"] = "Temporary";
  return SignerStore2;
})(SignerStore || {});

// node_modules/passkey-kit-sdk/src/index.ts
var import_buffer = __toESM(require_buffer());
var import_contract = __toESM(require_contract2());
if (typeof window !== "undefined") {
  window.Buffer = window.Buffer || import_buffer.Buffer;
}
var Client = class extends import_contract.Client {
  constructor(options) {
    super(
      new import_contract.Spec([
        "AAAABAAAAAAAAAAAAAAABUVycm9yAAAAAAAACQAAAAAAAAAITm90Rm91bmQAAAABAAAAAAAAAA1BbHJlYWR5RXhpc3RzAAAAAAAAAgAAAAAAAAAOTWlzc2luZ0NvbnRleHQAAAAAAAMAAAAAAAAADVNpZ25lckV4cGlyZWQAAAAAAAAEAAAAAAAAABJGYWlsZWRTaWduZXJMaW1pdHMAAAAAAAUAAAAAAAAAGEZhaWxlZFBvbGljeVNpZ25lckxpbWl0cwAAAAYAAAAAAAAAGVNpZ25hdHVyZUtleVZhbHVlTWlzbWF0Y2gAAAAAAAAHAAAAAAAAACBDbGllbnREYXRhSnNvbkNoYWxsZW5nZUluY29ycmVjdAAAAAgAAAAAAAAADkpzb25QYXJzZUVycm9yAAAAAAAJ",
        "AAAAAQAAAAAAAAAAAAAAEFNpZ25lckV4cGlyYXRpb24AAAABAAAAAAAAAAEwAAAAAAAD6AAAAAQ=",
        "AAAAAQAAAAAAAAAAAAAADFNpZ25lckxpbWl0cwAAAAEAAAAAAAAAATAAAAAAAAPoAAAD7AAAABMAAAPoAAAD6gAAB9AAAAAJU2lnbmVyS2V5AAAA",
        "AAAAAgAAAAAAAAAAAAAADVNpZ25lclN0b3JhZ2UAAAAAAAACAAAAAAAAAAAAAAAKUGVyc2lzdGVudAAAAAAAAAAAAAAAAAAJVGVtcG9yYXJ5AAAA",
        "AAAAAgAAAAAAAAAAAAAABlNpZ25lcgAAAAAAAwAAAAEAAAAAAAAABlBvbGljeQAAAAAABAAAABMAAAfQAAAAEFNpZ25lckV4cGlyYXRpb24AAAfQAAAADFNpZ25lckxpbWl0cwAAB9AAAAANU2lnbmVyU3RvcmFnZQAAAAAAAAEAAAAAAAAAB0VkMjU1MTkAAAAABAAAA+4AAAAgAAAH0AAAABBTaWduZXJFeHBpcmF0aW9uAAAH0AAAAAxTaWduZXJMaW1pdHMAAAfQAAAADVNpZ25lclN0b3JhZ2UAAAAAAAABAAAAAAAAAAlTZWNwMjU2cjEAAAAAAAAFAAAADgAAA+4AAABBAAAH0AAAABBTaWduZXJFeHBpcmF0aW9uAAAH0AAAAAxTaWduZXJMaW1pdHMAAAfQAAAADVNpZ25lclN0b3JhZ2UAAAA=",
        "AAAAAgAAAAAAAAAAAAAACVNpZ25lcktleQAAAAAAAAMAAAABAAAAAAAAAAZQb2xpY3kAAAAAAAEAAAATAAAAAQAAAAAAAAAHRWQyNTUxOQAAAAABAAAD7gAAACAAAAABAAAAAAAAAAlTZWNwMjU2cjEAAAAAAAABAAAADg==",
        "AAAAAgAAAAAAAAAAAAAACVNpZ25lclZhbAAAAAAAAAMAAAABAAAAAAAAAAZQb2xpY3kAAAAAAAIAAAfQAAAAEFNpZ25lckV4cGlyYXRpb24AAAfQAAAADFNpZ25lckxpbWl0cwAAAAEAAAAAAAAAB0VkMjU1MTkAAAAAAgAAB9AAAAAQU2lnbmVyRXhwaXJhdGlvbgAAB9AAAAAMU2lnbmVyTGltaXRzAAAAAQAAAAAAAAAJU2VjcDI1NnIxAAAAAAAAAwAAA+4AAABBAAAH0AAAABBTaWduZXJFeHBpcmF0aW9uAAAH0AAAAAxTaWduZXJMaW1pdHM=",
        "AAAAAQAAAAAAAAAAAAAAElNlY3AyNTZyMVNpZ25hdHVyZQAAAAAAAwAAAAAAAAASYXV0aGVudGljYXRvcl9kYXRhAAAAAAAOAAAAAAAAABBjbGllbnRfZGF0YV9qc29uAAAADgAAAAAAAAAJc2lnbmF0dXJlAAAAAAAD7gAAAEA=",
        "AAAAAgAAAAAAAAAAAAAACVNpZ25hdHVyZQAAAAAAAAMAAAAAAAAAAAAAAAZQb2xpY3kAAAAAAAEAAAAAAAAAB0VkMjU1MTkAAAAAAQAAA+4AAABAAAAAAQAAAAAAAAAJU2VjcDI1NnIxAAAAAAAAAQAAB9AAAAASU2VjcDI1NnIxU2lnbmF0dXJlAAA=",
        "AAAAAQAAAAAAAAAAAAAAClNpZ25hdHVyZXMAAAAAAAEAAAAAAAAAATAAAAAAAAPsAAAH0AAAAAlTaWduZXJLZXkAAAAAAAfQAAAACVNpZ25hdHVyZQAAAA==",
        "AAAAAAAAAAAAAAANX19jb25zdHJ1Y3RvcgAAAAAAAAEAAAAAAAAABnNpZ25lcgAAAAAH0AAAAAZTaWduZXIAAAAAAAA=",
        "AAAAAAAAAAAAAAAKYWRkX3NpZ25lcgAAAAAAAQAAAAAAAAAGc2lnbmVyAAAAAAfQAAAABlNpZ25lcgAAAAAAAA==",
        "AAAAAAAAAAAAAAANdXBkYXRlX3NpZ25lcgAAAAAAAAEAAAAAAAAABnNpZ25lcgAAAAAH0AAAAAZTaWduZXIAAAAAAAA=",
        "AAAAAAAAAAAAAAANcmVtb3ZlX3NpZ25lcgAAAAAAAAEAAAAAAAAACnNpZ25lcl9rZXkAAAAAB9AAAAAJU2lnbmVyS2V5AAAAAAAAAA==",
        "AAAAAAAAAAAAAAAUdXBkYXRlX2NvbnRyYWN0X2NvZGUAAAABAAAAAAAAAARoYXNoAAAD7gAAACAAAAAA",
        "AAAAAAAAAAAAAAAMX19jaGVja19hdXRoAAAAAwAAAAAAAAARc2lnbmF0dXJlX3BheWxvYWQAAAAAAAPuAAAAIAAAAAAAAAAKc2lnbmF0dXJlcwAAAAAH0AAAAApTaWduYXR1cmVzAAAAAAAAAAAADWF1dGhfY29udGV4dHMAAAAAAAPqAAAH0AAAAAdDb250ZXh0AAAAAAEAAAPpAAAD7QAAAAAAAAAD"
      ]),
      options
    );
    this.options = options;
    __publicField(this, "fromJSON", {
      add_signer: this.txFromJSON,
      update_signer: this.txFromJSON,
      remove_signer: this.txFromJSON,
      update_contract_code: this.txFromJSON
    });
  }
  static async deploy({ signer }, options) {
    return import_contract.Client.deploy({ signer }, options);
  }
};

// node_modules/passkey-kit/src/kit.ts
var import_minimal = __toESM(require_stellar_sdk_minimal_min(), 1);

// node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js
function bufferToBase64URLString(buffer) {
  const bytes = new Uint8Array(buffer);
  let str = "";
  for (const charCode of bytes) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

// node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js
function base64URLStringToBuffer(base64URLString) {
  const base64 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
  const padLength = (4 - base64.length % 4) % 4;
  const padded = base64.padEnd(base64.length + padLength, "=");
  const binary = atob(padded);
  const buffer = new ArrayBuffer(binary.length);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}

// node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js
function browserSupportsWebAuthn() {
  return _browserSupportsWebAuthnInternals.stubThis((globalThis == null ? void 0 : globalThis.PublicKeyCredential) !== void 0 && typeof globalThis.PublicKeyCredential === "function");
}
var _browserSupportsWebAuthnInternals = {
  stubThis: (value) => value
};

// node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js
function toPublicKeyCredentialDescriptor(descriptor) {
  const { id } = descriptor;
  return {
    ...descriptor,
    id: base64URLStringToBuffer(id),
    /**
     * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer
     * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports
     * are fine to pass to WebAuthn since browsers will recognize the new value.
     */
    transports: descriptor.transports
  };
}

// node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}

// node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js
var WebAuthnError = class extends Error {
  constructor({ message, code, cause, name }) {
    super(message, { cause });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name ?? cause.name;
    this.code = code;
  }
};

// node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js
function identifyRegistrationError({ error, options }) {
  var _a, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "ConstraintError") {
    if (((_a = publicKey.authenticatorSelection) == null ? void 0 : _a.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) == null ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error
      });
    } else if (((_c = publicKey.authenticatorSelection) == null ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error
      });
    }
  } else if (error.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error
    });
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = globalThis.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${globalThis.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return error;
}

// node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js
var BaseWebAuthnAbortService = class {
  constructor() {
    Object.defineProperty(this, "controller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
};
var WebAuthnAbortService = new BaseWebAuthnAbortService();

// node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js
var attachments = ["cross-platform", "platform"];
function toAuthenticatorAttachment(attachment) {
  if (!attachment) {
    return;
  }
  if (attachments.indexOf(attachment) < 0) {
    return;
  }
  return attachment;
}

// node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js
async function startRegistration(options) {
  var _a;
  if (!options.optionsJSON && options.challenge) {
    console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
    options = { optionsJSON: options };
  }
  const { optionsJSON, useAutoRegister = false } = options;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  const publicKey = {
    ...optionsJSON,
    challenge: base64URLStringToBuffer(optionsJSON.challenge),
    user: {
      ...optionsJSON.user,
      id: base64URLStringToBuffer(optionsJSON.user.id)
    },
    excludeCredentials: (_a = optionsJSON.excludeCredentials) == null ? void 0 : _a.map(toPublicKeyCredentialDescriptor)
  };
  const createOptions = {};
  if (useAutoRegister) {
    createOptions.mediation = "conditional";
  }
  createOptions.publicKey = publicKey;
  createOptions.signal = WebAuthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.create(createOptions);
  } catch (err) {
    throw identifyRegistrationError({ error: err, options: createOptions });
  }
  if (!credential) {
    throw new Error("Registration was not completed");
  }
  const { id, rawId, response, type } = credential;
  let transports = void 0;
  if (typeof response.getTransports === "function") {
    transports = response.getTransports();
  }
  let responsePublicKeyAlgorithm = void 0;
  if (typeof response.getPublicKeyAlgorithm === "function") {
    try {
      responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();
    } catch (error) {
      warnOnBrokenImplementation("getPublicKeyAlgorithm()", error);
    }
  }
  let responsePublicKey = void 0;
  if (typeof response.getPublicKey === "function") {
    try {
      const _publicKey = response.getPublicKey();
      if (_publicKey !== null) {
        responsePublicKey = bufferToBase64URLString(_publicKey);
      }
    } catch (error) {
      warnOnBrokenImplementation("getPublicKey()", error);
    }
  }
  let responseAuthenticatorData;
  if (typeof response.getAuthenticatorData === "function") {
    try {
      responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());
    } catch (error) {
      warnOnBrokenImplementation("getAuthenticatorData()", error);
    }
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      attestationObject: bufferToBase64URLString(response.attestationObject),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      transports,
      publicKeyAlgorithm: responsePublicKeyAlgorithm,
      publicKey: responsePublicKey,
      authenticatorData: responseAuthenticatorData
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
  };
}
function warnOnBrokenImplementation(methodName, cause) {
  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.
`, cause);
}

// node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js
function browserSupportsWebAuthnAutofill() {
  if (!browserSupportsWebAuthn()) {
    return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
  }
  const globalPublicKeyCredential = globalThis.PublicKeyCredential;
  if ((globalPublicKeyCredential == null ? void 0 : globalPublicKeyCredential.isConditionalMediationAvailable) === void 0) {
    return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
  }
  return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());
}
var _browserSupportsWebAuthnAutofillInternals = {
  stubThis: (value) => value
};

// node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js
function identifyAuthenticationError({ error, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = globalThis.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${globalThis.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return error;
}

// node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js
async function startAuthentication(options) {
  var _a, _b;
  if (!options.optionsJSON && options.challenge) {
    console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
    options = { optionsJSON: options };
  }
  const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true } = options;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  let allowCredentials;
  if (((_a = optionsJSON.allowCredentials) == null ? void 0 : _a.length) !== 0) {
    allowCredentials = (_b = optionsJSON.allowCredentials) == null ? void 0 : _b.map(toPublicKeyCredentialDescriptor);
  }
  const publicKey = {
    ...optionsJSON,
    challenge: base64URLStringToBuffer(optionsJSON.challenge),
    allowCredentials
  };
  const getOptions = {};
  if (useBrowserAutofill) {
    if (!await browserSupportsWebAuthnAutofill()) {
      throw Error("Browser does not support WebAuthn autofill");
    }
    const eligibleInputs = document.querySelectorAll("input[autocomplete$='webauthn']");
    if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {
      throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');
    }
    getOptions.mediation = "conditional";
    publicKey.allowCredentials = [];
  }
  getOptions.publicKey = publicKey;
  getOptions.signal = WebAuthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.get(getOptions);
  } catch (err) {
    throw identifyAuthenticationError({ error: err, options: getOptions });
  }
  if (!credential) {
    throw new Error("Authentication was not completed");
  }
  const { id, rawId, response, type } = credential;
  let userHandle = void 0;
  if (response.userHandle) {
    userHandle = bufferToBase64URLString(response.userHandle);
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      authenticatorData: bufferToBase64URLString(response.authenticatorData),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      signature: bufferToBase64URLString(response.signature),
      userHandle
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
  };
}

// node_modules/passkey-kit/src/kit.ts
var import_buffer2 = __toESM(require_buffer(), 1);
var import_base64url = __toESM(require_base64url2(), 1);

// node_modules/passkey-kit/src/base.ts
var import_rpc = __toESM(require_rpc2(), 1);
var PasskeyBase = class {
  constructor(rpcUrl) {
    __publicField(this, "rpcUrl");
    __publicField(this, "rpc");
    if (rpcUrl) {
      this.rpcUrl = rpcUrl;
      this.rpc = new import_rpc.Server(rpcUrl);
    }
  }
};

// node_modules/passkey-kit/src/kit.ts
var import_contract2 = __toESM(require_contract4(), 1);
var PasskeyKit = class extends PasskeyBase {
  constructor(options) {
    const { rpcUrl, networkPassphrase, walletWasmHash, WebAuthn } = options;
    super(rpcUrl);
    __publicField(this, "walletKeypair");
    __publicField(this, "walletPublicKey");
    __publicField(this, "walletWasmHash");
    __publicField(this, "timeoutInSeconds");
    __publicField(this, "WebAuthn");
    __publicField(this, "keyId");
    __publicField(this, "networkPassphrase");
    __publicField(this, "wallet");
    this.networkPassphrase = networkPassphrase;
    this.walletKeypair = import_minimal.Keypair.fromRawEd25519Seed((0, import_minimal.hash)(import_buffer2.Buffer.from("kalepail")));
    this.walletPublicKey = this.walletKeypair.publicKey();
    this.walletWasmHash = walletWasmHash;
    this.timeoutInSeconds = options.timeoutInSeconds || 30;
    this.WebAuthn = WebAuthn || { startRegistration, startAuthentication };
  }
  async createWallet(app, user) {
    const { rawResponse, keyId, keyIdBase64, publicKey } = await this.createKey(app, user);
    const at = await Client.deploy(
      {
        signer: {
          tag: "Secp256r1",
          values: [
            keyId,
            publicKey,
            [void 0],
            [void 0],
            { tag: "Persistent", values: void 0 }
          ]
        }
      },
      {
        rpcUrl: this.rpcUrl,
        wasmHash: this.walletWasmHash,
        networkPassphrase: this.networkPassphrase,
        publicKey: this.walletPublicKey,
        salt: (0, import_minimal.hash)(keyId),
        timeoutInSeconds: this.timeoutInSeconds
      }
    );
    const contractId = at.result.options.contractId;
    this.wallet = new Client({
      contractId,
      networkPassphrase: this.networkPassphrase,
      rpcUrl: this.rpcUrl
    });
    await at.sign({
      signTransaction: (0, import_contract2.basicNodeSigner)(this.walletKeypair, this.networkPassphrase).signTransaction
    });
    return {
      rawResponse,
      keyId,
      keyIdBase64,
      contractId,
      signedTx: at.signed
    };
  }
  async createKey(app, user, settings) {
    const now = /* @__PURE__ */ new Date();
    const displayName = `${user}  ${now.toLocaleString()}`;
    const { rpId, authenticatorSelection = {
      residentKey: "preferred",
      userVerification: "preferred"
    } } = settings || {};
    const rawResponse = await this.WebAuthn.startRegistration({
      optionsJSON: {
        challenge: (0, import_base64url.default)("stellaristhebetterblockchain"),
        rp: {
          id: rpId,
          name: app
        },
        user: {
          id: (0, import_base64url.default)(`${user}:${now.getTime()}:${Math.random()}`),
          name: displayName,
          displayName
        },
        authenticatorSelection,
        pubKeyCredParams: [{ alg: -7, type: "public-key" }]
      }
    });
    const { id, response } = rawResponse;
    if (!this.keyId)
      this.keyId = id;
    return {
      rawResponse,
      keyId: import_base64url.default.toBuffer(id),
      keyIdBase64: id,
      publicKey: await this.getPublicKey(response)
    };
  }
  async connectWallet(opts) {
    let { rpId, keyId, getContractId, walletPublicKey } = opts || {};
    let keyIdBuffer;
    let rawResponse;
    if (!keyId) {
      rawResponse = await this.WebAuthn.startAuthentication({
        optionsJSON: {
          challenge: (0, import_base64url.default)("stellaristhebetterblockchain"),
          rpId,
          userVerification: "preferred"
        }
      });
      keyId = rawResponse.id;
    }
    if (keyId instanceof Uint8Array) {
      keyIdBuffer = import_buffer2.Buffer.from(keyId);
      keyId = (0, import_base64url.default)(keyIdBuffer);
    } else {
      keyIdBuffer = import_base64url.default.toBuffer(keyId);
    }
    if (!this.keyId)
      this.keyId = keyId;
    let contractId = this.encodeContract(this.walletPublicKey, keyIdBuffer);
    try {
      await this.rpc.getContractData(contractId, import_minimal.xdr.ScVal.scvLedgerKeyContractInstance());
    } catch {
      contractId = getContractId && await getContractId(keyId);
    }
    if (!contractId && walletPublicKey) {
      contractId = this.encodeContract(walletPublicKey, keyIdBuffer);
      try {
        await this.rpc.getContractData(contractId, import_minimal.xdr.ScVal.scvLedgerKeyContractInstance());
      } catch {
        contractId = void 0;
      }
    }
    if (!contractId)
      throw new Error("Failed to connect wallet");
    this.wallet = new Client({
      contractId,
      rpcUrl: this.rpcUrl,
      networkPassphrase: this.networkPassphrase
    });
    return {
      rawResponse,
      keyId: keyIdBuffer,
      keyIdBase64: keyId,
      contractId
    };
  }
  async signAuthEntry(entry, options) {
    var _a, _b, _c, _d;
    let { rpId, keyId, keypair, policy, expiration } = options || {};
    if ([keyId, keypair, policy].filter((arg) => !!arg).length > 1)
      throw new Error("Exactly one of `options.keyId`, `options.keypair`, or `options.policy` must be provided.");
    const credentials = entry.credentials().address();
    if (!expiration) {
      expiration = credentials.signatureExpirationLedger();
      if (!expiration) {
        const { sequence } = await this.rpc.getLatestLedger();
        expiration = sequence + this.timeoutInSeconds / 5;
      }
    }
    credentials.signatureExpirationLedger(expiration);
    const preimage = import_minimal.xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(
      new import_minimal.xdr.HashIdPreimageSorobanAuthorization({
        networkId: (0, import_minimal.hash)(import_buffer2.Buffer.from(this.networkPassphrase)),
        nonce: credentials.nonce(),
        signatureExpirationLedger: credentials.signatureExpirationLedger(),
        invocation: entry.rootInvocation()
      })
    );
    const payload = (0, import_minimal.hash)(preimage.toXDR());
    let key;
    let val;
    if (policy) {
      key = {
        tag: "Policy",
        values: [policy]
      };
      val = {
        tag: "Policy",
        values: void 0
      };
    } else if (keypair) {
      const signature = keypair.sign(payload);
      key = {
        tag: "Ed25519",
        values: [keypair.rawPublicKey()]
      };
      val = {
        tag: "Ed25519",
        values: [signature]
      };
    } else {
      const authenticationResponse = await this.WebAuthn.startAuthentication({
        optionsJSON: keyId === "any" || !keyId && !this.keyId ? {
          challenge: (0, import_base64url.default)(payload),
          rpId,
          userVerification: "preferred"
        } : {
          challenge: (0, import_base64url.default)(payload),
          rpId,
          allowCredentials: [
            {
              id: keyId instanceof Uint8Array ? (0, import_base64url.default)(import_buffer2.Buffer.from(keyId)) : keyId || this.keyId,
              type: "public-key"
            }
          ],
          userVerification: "preferred"
        }
      });
      key = {
        tag: "Secp256r1",
        values: [import_base64url.default.toBuffer(authenticationResponse.id)]
      };
      val = {
        tag: "Secp256r1",
        values: [
          {
            authenticator_data: import_base64url.default.toBuffer(
              authenticationResponse.response.authenticatorData
            ),
            client_data_json: import_base64url.default.toBuffer(
              authenticationResponse.response.clientDataJSON
            ),
            signature: this.compactSignature(
              import_base64url.default.toBuffer(authenticationResponse.response.signature)
            )
          }
        ]
      };
    }
    const scKeyType = import_minimal.xdr.ScSpecTypeDef.scSpecTypeUdt(
      new import_minimal.xdr.ScSpecTypeUdt({ name: "SignerKey" })
    );
    const scValType = import_minimal.xdr.ScSpecTypeDef.scSpecTypeUdt(
      new import_minimal.xdr.ScSpecTypeUdt({ name: "Signature" })
    );
    const scKey = this.wallet.spec.nativeToScVal(key, scKeyType);
    const scVal = val ? this.wallet.spec.nativeToScVal(val, scValType) : import_minimal.xdr.ScVal.scvVoid();
    const scEntry = new import_minimal.xdr.ScMapEntry({
      key: scKey,
      val: scVal
    });
    switch (credentials.signature().switch().name) {
      case "scvVoid":
        credentials.signature(import_minimal.xdr.ScVal.scvVec([
          import_minimal.xdr.ScVal.scvMap([scEntry])
        ]));
        break;
      case "scvVec":
        (_b = (_a = credentials.signature().vec()) == null ? void 0 : _a[0].map()) == null ? void 0 : _b.push(scEntry);
        (_d = (_c = credentials.signature().vec()) == null ? void 0 : _c[0].map()) == null ? void 0 : _d.sort((a, b) => {
          return (a.key().vec()[0].sym() + a.key().vec()[1].toXDR().join("")).localeCompare(
            b.key().vec()[0].sym() + b.key().vec()[1].toXDR().join("")
          );
        });
        break;
      default:
        throw new Error("Unsupported signature");
    }
    return entry;
  }
  async sign(txn, options) {
    if (!(txn instanceof import_contract2.AssembledTransaction)) {
      try {
        txn = import_contract2.AssembledTransaction.fromXDR(this.wallet.options, typeof txn === "string" ? txn : txn.toXDR(), this.wallet.spec);
      } catch {
        if (!(txn instanceof import_contract2.AssembledTransaction)) {
          const built = import_minimal.TransactionBuilder.fromXDR(typeof txn === "string" ? txn : txn.toXDR(), this.networkPassphrase);
          const operation = built.operations[0];
          txn = await import_contract2.AssembledTransaction.buildWithOp(
            import_minimal.Operation.invokeHostFunction({ func: operation.func }),
            this.wallet.options
          );
        }
      }
    }
    await txn.signAuthEntries({
      address: this.wallet.options.contractId,
      authorizeEntry: (entry) => {
        const clone = import_minimal.xdr.SorobanAuthorizationEntry.fromXDR(entry.toXDR());
        return this.signAuthEntry(clone, options);
      }
    });
    return txn;
  }
  addSecp256r1(keyId, publicKey, limits, store, expiration) {
    return this.secp256r1(keyId, publicKey, limits, store, "add_signer", expiration);
  }
  addEd25519(publicKey, limits, store, expiration) {
    return this.ed25519(publicKey, limits, store, "add_signer", expiration);
  }
  addPolicy(policy, limits, store, expiration) {
    return this.policy(policy, limits, store, "add_signer", expiration);
  }
  updateSecp256r1(keyId, publicKey, limits, store, expiration) {
    return this.secp256r1(keyId, publicKey, limits, store, "update_signer", expiration);
  }
  updateEd25519(publicKey, limits, store, expiration) {
    return this.ed25519(publicKey, limits, store, "update_signer", expiration);
  }
  updatePolicy(policy, limits, store, expiration) {
    return this.policy(policy, limits, store, "update_signer", expiration);
  }
  remove(signer) {
    return this.wallet.remove_signer({
      signer_key: this.getSignerKey(signer)
    }, {
      timeoutInSeconds: this.timeoutInSeconds
    });
  }
  secp256r1(keyId, publicKey, limits, store, fn, expiration) {
    keyId = typeof keyId === "string" ? import_base64url.default.toBuffer(keyId) : keyId;
    publicKey = typeof publicKey === "string" ? import_base64url.default.toBuffer(publicKey) : publicKey;
    return this.wallet[fn]({
      signer: {
        tag: "Secp256r1",
        values: [
          import_buffer2.Buffer.from(keyId),
          import_buffer2.Buffer.from(publicKey),
          [expiration],
          this.getSignerLimits(limits),
          { tag: store, values: void 0 }
        ]
      }
    }, {
      timeoutInSeconds: this.timeoutInSeconds
    });
  }
  ed25519(publicKey, limits, store, fn, expiration) {
    return this.wallet[fn]({
      signer: {
        tag: "Ed25519",
        values: [
          import_minimal.Keypair.fromPublicKey(publicKey).rawPublicKey(),
          [expiration],
          this.getSignerLimits(limits),
          { tag: store, values: void 0 }
        ]
      }
    }, {
      timeoutInSeconds: this.timeoutInSeconds
    });
  }
  policy(policy, limits, store, fn, expiration) {
    return this.wallet[fn]({
      signer: {
        tag: "Policy",
        values: [
          policy,
          [expiration],
          this.getSignerLimits(limits),
          { tag: store, values: void 0 }
        ]
      }
    }, {
      timeoutInSeconds: this.timeoutInSeconds
    });
  }
  /* LATER 
      - Add a getKeyInfo action to get info about a specific passkey
          Specifically looking for name, type, etc. data so a user could grok what signer mapped to what passkey
  */
  getSignerLimits(limits) {
    var _a;
    if (!limits)
      return [void 0];
    const sdk_limits = [/* @__PURE__ */ new Map()];
    for (const [contract, signer_keys] of limits.entries()) {
      let sdk_signer_keys;
      if (signer_keys == null ? void 0 : signer_keys.length) {
        sdk_signer_keys = [];
        for (const signer_key of signer_keys) {
          sdk_signer_keys.push(
            this.getSignerKey(signer_key)
          );
        }
      }
      (_a = sdk_limits[0]) == null ? void 0 : _a.set(contract, sdk_signer_keys);
    }
    return sdk_limits;
  }
  getSignerKey({ key: tag, value }) {
    let signer_key;
    switch (tag) {
      case "Policy":
        signer_key = {
          tag,
          values: [value]
        };
        break;
      case "Ed25519":
        signer_key = {
          tag,
          values: [import_minimal.Keypair.fromPublicKey(value).rawPublicKey()]
        };
        break;
      case "Secp256r1":
        signer_key = {
          tag,
          values: [import_base64url.default.toBuffer(value)]
        };
        break;
    }
    return signer_key;
  }
  encodeContract(walletPublicKey, keyIdBuffer) {
    let contractId = import_minimal.StrKey.encodeContract((0, import_minimal.hash)(import_minimal.xdr.HashIdPreimage.envelopeTypeContractId(
      new import_minimal.xdr.HashIdPreimageContractId({
        networkId: (0, import_minimal.hash)(import_buffer2.Buffer.from(this.networkPassphrase)),
        contractIdPreimage: import_minimal.xdr.ContractIdPreimage.contractIdPreimageFromAddress(
          new import_minimal.xdr.ContractIdPreimageFromAddress({
            address: import_minimal.Address.fromString(walletPublicKey).toScAddress(),
            salt: (0, import_minimal.hash)(keyIdBuffer)
          })
        )
      })
    ).toXDR()));
    return contractId;
  }
  async getPublicKey(response) {
    let publicKey;
    if (response.publicKey) {
      publicKey = import_base64url.default.toBuffer(response.publicKey);
      publicKey = publicKey == null ? void 0 : publicKey.slice(publicKey.length - 65);
    }
    if (!publicKey || publicKey[0] !== 4 || publicKey.length !== 65) {
      let x;
      let y;
      if (response.authenticatorData) {
        const authenticatorData = import_base64url.default.toBuffer(response.authenticatorData);
        const credentialIdLength = authenticatorData[53] << 8 | authenticatorData[54];
        x = authenticatorData.slice(65 + credentialIdLength, 97 + credentialIdLength);
        y = authenticatorData.slice(100 + credentialIdLength, 132 + credentialIdLength);
      } else {
        const attestationObject = import_base64url.default.toBuffer(response.attestationObject);
        let publicKeykPrefixSlice = import_buffer2.Buffer.from([165, 1, 2, 3, 38, 32, 1, 33, 88, 32]);
        let startIndex = attestationObject.indexOf(publicKeykPrefixSlice);
        startIndex = startIndex + publicKeykPrefixSlice.length;
        x = attestationObject.slice(startIndex, 32 + startIndex);
        y = attestationObject.slice(35 + startIndex, 67 + startIndex);
      }
      publicKey = import_buffer2.Buffer.from([
        4,
        // (0x04 prefix) https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm
        ...x,
        ...y
      ]);
    }
    return publicKey;
  }
  compactSignature(signature) {
    let offset = 2;
    const rLength = signature[offset + 1];
    const r = signature.slice(offset + 2, offset + 2 + rLength);
    offset += 2 + rLength;
    const sLength = signature[offset + 1];
    const s = signature.slice(offset + 2, offset + 2 + sLength);
    const rBigInt = BigInt("0x" + r.toString("hex"));
    let sBigInt = BigInt("0x" + s.toString("hex"));
    const n = BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551");
    const halfN = n / 2n;
    if (sBigInt > halfN)
      sBigInt = n - sBigInt;
    const rPadded = import_buffer2.Buffer.from(rBigInt.toString(16).padStart(64, "0"), "hex");
    const sLowS = import_buffer2.Buffer.from(sBigInt.toString(16).padStart(64, "0"), "hex");
    const concatSignature = import_buffer2.Buffer.concat([rPadded, sLowS]);
    return concatSignature;
  }
};

// node_modules/passkey-kit/src/server.ts
var import_minimal2 = __toESM(require_stellar_sdk_minimal_min(), 1);
var import_base64url2 = __toESM(require_base64url2(), 1);
var import_contract3 = __toESM(require_contract4(), 1);
var import_rpc2 = __toESM(require_rpc2(), 1);

// node_modules/passkey-kit/package.json
var version = "0.10.24";

// node_modules/passkey-kit/src/server.ts
var PasskeyServer = class extends PasskeyBase {
  constructor(options) {
    const {
      rpcUrl,
      launchtubeUrl,
      launchtubeJwt,
      launchtubeHeaders,
      mercuryProjectName,
      mercuryUrl,
      mercuryJwt,
      mercuryKey
    } = options;
    super(rpcUrl);
    __publicField(this, "launchtubeJwt");
    __publicField(this, "mercuryJwt");
    __publicField(this, "mercuryKey");
    __publicField(this, "launchtubeUrl");
    __publicField(this, "launchtubeHeaders");
    __publicField(this, "mercuryProjectName");
    __publicField(this, "mercuryUrl");
    if (launchtubeUrl)
      this.launchtubeUrl = launchtubeUrl;
    if (launchtubeJwt)
      this.launchtubeJwt = launchtubeJwt;
    if (launchtubeHeaders)
      this.launchtubeHeaders = launchtubeHeaders;
    if (mercuryProjectName)
      this.mercuryProjectName = mercuryProjectName;
    if (mercuryUrl)
      this.mercuryUrl = mercuryUrl;
    if (mercuryJwt)
      this.mercuryJwt = mercuryJwt;
    if (mercuryKey)
      this.mercuryKey = mercuryKey;
  }
  async getSigners(contractId) {
    if (!this.rpc || !this.mercuryProjectName || !this.mercuryUrl || !this.mercuryJwt && !this.mercuryKey)
      throw new Error("Mercury service not configured");
    const signers = await fetch(`${this.mercuryUrl}/zephyr/execute`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: this.mercuryJwt ? `Bearer ${this.mercuryJwt}` : this.mercuryKey
      },
      body: JSON.stringify({
        project_name: this.mercuryProjectName,
        mode: {
          Function: {
            fname: "get_signers_by_address",
            arguments: JSON.stringify({
              address: contractId
            })
          }
        }
      })
    }).then(async (res) => {
      if (res.ok)
        return res.json();
      throw await res.json();
    });
    for (const signer of signers) {
      if (signer.storage === "Temporary") {
        try {
          await this.rpc.getContractData(contractId, import_minimal2.xdr.ScVal.scvBytes(import_base64url2.default.toBuffer(signer.key)), import_rpc2.Durability.Temporary);
        } catch {
          signer.evicted = true;
        }
      }
    }
    return signers;
  }
  async getContractId(options, index = 0) {
    if (!this.mercuryProjectName || !this.mercuryUrl || !this.mercuryJwt && !this.mercuryKey)
      throw new Error("Mercury service not configured");
    let { keyId, publicKey, policy } = options || {};
    if ([keyId, publicKey, policy].filter((arg) => !!arg).length > 1)
      throw new Error("Exactly one of `options.keyId`, `options.publicKey`, or `options.policy` must be provided.");
    let args;
    if (keyId)
      args = { key: keyId, kind: "Secp256r1" };
    else if (publicKey)
      args = { key: publicKey, kind: "Ed25519" };
    else if (policy)
      args = { key: policy, kind: "Policy" };
    const res = await fetch(`${this.mercuryUrl}/zephyr/execute`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: this.mercuryJwt ? `Bearer ${this.mercuryJwt}` : this.mercuryKey
      },
      body: JSON.stringify({
        project_name: this.mercuryProjectName,
        mode: {
          Function: {
            fname: "get_addresses_by_signer",
            arguments: JSON.stringify(args)
          }
        }
      })
    }).then(async (res2) => {
      if (res2.ok)
        return await res2.json();
      throw await res2.json();
    });
    return res[index];
  }
  /* LATER
      - Add a method for getting a paginated or filtered list of all a wallet's events
  */
  async send(txn, fee) {
    if (!this.launchtubeUrl)
      throw new Error("Launchtube service not configured");
    const data = new FormData();
    if (txn instanceof import_contract3.AssembledTransaction) {
      txn = txn.built.toXDR();
    } else if (typeof txn !== "string") {
      txn = txn.toXDR();
    }
    data.set("xdr", txn);
    if (fee)
      data.set("fee", fee.toString());
    let lt_headers = Object.assign({
      "X-Client-Name": "passkey-kit",
      "X-Client-Version": version
    }, this.launchtubeHeaders);
    if (this.launchtubeJwt)
      lt_headers.authorization = `Bearer ${this.launchtubeJwt}`;
    return fetch(this.launchtubeUrl, {
      method: "POST",
      headers: lt_headers,
      body: data
    }).then(async (res) => {
      if (res.ok)
        return res.json();
      else throw await res.json();
    });
  }
};

// node_modules/sac-sdk/src/index.ts
var import_buffer3 = __toESM(require_buffer());
var import_contract4 = __toESM(require_contract6());
if (typeof window !== "undefined") {
  window.Buffer = window.Buffer || import_buffer3.Buffer;
}
var Client2 = class extends import_contract4.Client {
  constructor(options) {
    super(
      new import_contract4.Spec([
        "AAAAAAAAAYpSZXR1cm5zIHRoZSBhbGxvd2FuY2UgZm9yIGBzcGVuZGVyYCB0byB0cmFuc2ZlciBmcm9tIGBmcm9tYC4KClRoZSBhbW91bnQgcmV0dXJuZWQgaXMgdGhlIGFtb3VudCB0aGF0IHNwZW5kZXIgaXMgYWxsb3dlZCB0byB0cmFuc2ZlcgpvdXQgb2YgZnJvbSdzIGJhbGFuY2UuIFdoZW4gdGhlIHNwZW5kZXIgdHJhbnNmZXJzIGFtb3VudHMsIHRoZSBhbGxvd2FuY2UKd2lsbCBiZSByZWR1Y2VkIGJ5IHRoZSBhbW91bnQgdHJhbnNmZXJyZWQuCgojIEFyZ3VtZW50cwoKKiBgZnJvbWAgLSBUaGUgYWRkcmVzcyBob2xkaW5nIHRoZSBiYWxhbmNlIG9mIHRva2VucyB0byBiZSBkcmF3biBmcm9tLgoqIGBzcGVuZGVyYCAtIFRoZSBhZGRyZXNzIHNwZW5kaW5nIHRoZSB0b2tlbnMgaGVsZCBieSBgZnJvbWAuAAAAAAAJYWxsb3dhbmNlAAAAAAAAAgAAAAAAAAAEZnJvbQAAABMAAAAAAAAAB3NwZW5kZXIAAAAAEwAAAAEAAAAL",
        "AAAAAAAAAIlSZXR1cm5zIHRydWUgaWYgYGlkYCBpcyBhdXRob3JpemVkIHRvIHVzZSBpdHMgYmFsYW5jZS4KCiMgQXJndW1lbnRzCgoqIGBpZGAgLSBUaGUgYWRkcmVzcyBmb3Igd2hpY2ggdG9rZW4gYXV0aG9yaXphdGlvbiBpcyBiZWluZyBjaGVja2VkLgAAAAAAAAphdXRob3JpemVkAAAAAAABAAAAAAAAAAJpZAAAAAAAEwAAAAEAAAAB",
        "AAAAAAAAA59TZXQgdGhlIGFsbG93YW5jZSBieSBgYW1vdW50YCBmb3IgYHNwZW5kZXJgIHRvIHRyYW5zZmVyL2J1cm4gZnJvbQpgZnJvbWAuCgpUaGUgYW1vdW50IHNldCBpcyB0aGUgYW1vdW50IHRoYXQgc3BlbmRlciBpcyBhcHByb3ZlZCB0byB0cmFuc2ZlciBvdXQgb2YKZnJvbSdzIGJhbGFuY2UuIFRoZSBzcGVuZGVyIHdpbGwgYmUgYWxsb3dlZCB0byB0cmFuc2ZlciBhbW91bnRzLCBhbmQKd2hlbiBhbiBhbW91bnQgaXMgdHJhbnNmZXJyZWQgdGhlIGFsbG93YW5jZSB3aWxsIGJlIHJlZHVjZWQgYnkgdGhlCmFtb3VudCB0cmFuc2ZlcnJlZC4KCiMgQXJndW1lbnRzCgoqIGBmcm9tYCAtIFRoZSBhZGRyZXNzIGhvbGRpbmcgdGhlIGJhbGFuY2Ugb2YgdG9rZW5zIHRvIGJlIGRyYXduIGZyb20uCiogYHNwZW5kZXJgIC0gVGhlIGFkZHJlc3MgYmVpbmcgYXV0aG9yaXplZCB0byBzcGVuZCB0aGUgdG9rZW5zIGhlbGQgYnkKYGZyb21gLgoqIGBhbW91bnRgIC0gVGhlIHRva2VucyB0byBiZSBtYWRlIGF2YWlsYWJsZSB0byBgc3BlbmRlcmAuCiogYGV4cGlyYXRpb25fbGVkZ2VyYCAtIFRoZSBsZWRnZXIgbnVtYmVyIHdoZXJlIHRoaXMgYWxsb3dhbmNlIGV4cGlyZXMuIENhbm5vdApiZSBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgbGVkZ2VyIG51bWJlciB1bmxlc3MgdGhlIGFtb3VudCBpcyBiZWluZyBzZXQgdG8gMC4KQW4gZXhwaXJlZCBlbnRyeSAod2hlcmUgZXhwaXJhdGlvbl9sZWRnZXIgPCB0aGUgY3VycmVudCBsZWRnZXIgbnVtYmVyKQpzaG91bGQgYmUgdHJlYXRlZCBhcyBhIDAgYW1vdW50IGFsbG93YW5jZS4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJhcHByb3ZlIiwgZnJvbTogQWRkcmVzcywKc3BlbmRlcjogQWRkcmVzc10sIGRhdGEgPSBbYW1vdW50OiBpMTI4LCBleHBpcmF0aW9uX2xlZGdlcjogdTMyXWAAAAAAB2FwcHJvdmUAAAAABAAAAAAAAAAEZnJvbQAAABMAAAAAAAAAB3NwZW5kZXIAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAAAAABFleHBpcmF0aW9uX2xlZGdlcgAAAAAAAAQAAAAA",
        "AAAAAAAAAJhSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIGBpZGAuCgojIEFyZ3VtZW50cwoKKiBgaWRgIC0gVGhlIGFkZHJlc3MgZm9yIHdoaWNoIGEgYmFsYW5jZSBpcyBiZWluZyBxdWVyaWVkLiBJZiB0aGUKYWRkcmVzcyBoYXMgbm8gZXhpc3RpbmcgYmFsYW5jZSwgcmV0dXJucyAwLgAAAAdiYWxhbmNlAAAAAAEAAAAAAAAAAmlkAAAAAAATAAAAAQAAAAs=",
        "AAAAAAAAAWJCdXJuIGBhbW91bnRgIGZyb20gYGZyb21gLgoKUmVkdWNlcyBmcm9tJ3MgYmFsYW5jZSBieSB0aGUgYW1vdW50LCB3aXRob3V0IHRyYW5zZmVycmluZyB0aGUgYmFsYW5jZQp0byBhbm90aGVyIGhvbGRlcidzIGJhbGFuY2UuCgojIEFyZ3VtZW50cwoKKiBgZnJvbWAgLSBUaGUgYWRkcmVzcyBob2xkaW5nIHRoZSBiYWxhbmNlIG9mIHRva2VucyB3aGljaCB3aWxsIGJlCmJ1cm5lZCBmcm9tLgoqIGBhbW91bnRgIC0gVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gYmUgYnVybmVkLgoKIyBFdmVudHMKCkVtaXRzIGFuIGV2ZW50IHdpdGggdG9waWNzIGBbImJ1cm4iLCBmcm9tOiBBZGRyZXNzXSwgZGF0YSA9IGFtb3VudDoKaTEyOGAAAAAAAARidXJuAAAAAgAAAAAAAAAEZnJvbQAAABMAAAAAAAAABmFtb3VudAAAAAAACwAAAAA=",
        "AAAAAAAAAtpCdXJuIGBhbW91bnRgIGZyb20gYGZyb21gLCBjb25zdW1pbmcgdGhlIGFsbG93YW5jZSBvZiBgc3BlbmRlcmAuCgpSZWR1Y2VzIGZyb20ncyBiYWxhbmNlIGJ5IHRoZSBhbW91bnQsIHdpdGhvdXQgdHJhbnNmZXJyaW5nIHRoZSBiYWxhbmNlCnRvIGFub3RoZXIgaG9sZGVyJ3MgYmFsYW5jZS4KClRoZSBzcGVuZGVyIHdpbGwgYmUgYWxsb3dlZCB0byBidXJuIHRoZSBhbW91bnQgZnJvbSBmcm9tJ3MgYmFsYW5jZSwgaWYKdGhlIGFtb3VudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGFsbG93YW5jZSB0aGF0IHRoZSBzcGVuZGVyIGhhcwpvbiB0aGUgZnJvbSdzIGJhbGFuY2UuIFRoZSBzcGVuZGVyJ3MgYWxsb3dhbmNlIG9uIGZyb20ncyBiYWxhbmNlIHdpbGwgYmUKcmVkdWNlZCBieSB0aGUgYW1vdW50LgoKIyBBcmd1bWVudHMKCiogYHNwZW5kZXJgIC0gVGhlIGFkZHJlc3MgYXV0aG9yaXppbmcgdGhlIGJ1cm4sIGFuZCBoYXZpbmcgaXRzIGFsbG93YW5jZQpjb25zdW1lZCBkdXJpbmcgdGhlIGJ1cm4uCiogYGZyb21gIC0gVGhlIGFkZHJlc3MgaG9sZGluZyB0aGUgYmFsYW5jZSBvZiB0b2tlbnMgd2hpY2ggd2lsbCBiZQpidXJuZWQgZnJvbS4KKiBgYW1vdW50YCAtIFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIGJlIGJ1cm5lZC4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJidXJuIiwgZnJvbTogQWRkcmVzc10sIGRhdGEgPSBhbW91bnQ6CmkxMjhgAAAAAAAJYnVybl9mcm9tAAAAAAAAAwAAAAAAAAAHc3BlbmRlcgAAAAATAAAAAAAAAARmcm9tAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA==",
        "AAAAAAAAAVFDbGF3YmFjayBgYW1vdW50YCBmcm9tIGBmcm9tYCBhY2NvdW50LiBgYW1vdW50YCBpcyBidXJuZWQgaW4gdGhlCmNsYXdiYWNrIHByb2Nlc3MuCgojIEFyZ3VtZW50cwoKKiBgZnJvbWAgLSBUaGUgYWRkcmVzcyBob2xkaW5nIHRoZSBiYWxhbmNlIGZyb20gd2hpY2ggdGhlIGNsYXdiYWNrIHdpbGwKdGFrZSB0b2tlbnMuCiogYGFtb3VudGAgLSBUaGUgYW1vdW50IG9mIHRva2VucyB0byBiZSBjbGF3ZWQgYmFjay4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJjbGF3YmFjayIsIGFkbWluOiBBZGRyZXNzLCB0bzogQWRkcmVzc10sCmRhdGEgPSBhbW91bnQ6IGkxMjhgAAAAAAAACGNsYXdiYWNrAAAAAgAAAAAAAAAEZnJvbQAAABMAAAAAAAAABmFtb3VudAAAAAAACwAAAAA=",
        "AAAAAAAAAIBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdXNlZCB0byByZXByZXNlbnQgYW1vdW50cyBvZiB0aGlzIHRva2VuLgoKIyBQYW5pY3MKCklmIHRoZSBjb250cmFjdCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLgAAAAhkZWNpbWFscwAAAAAAAAABAAAABA==",
        "AAAAAAAAAPNNaW50cyBgYW1vdW50YCB0byBgdG9gLgoKIyBBcmd1bWVudHMKCiogYHRvYCAtIFRoZSBhZGRyZXNzIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgbWludGVkIHRva2Vucy4KKiBgYW1vdW50YCAtIFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIGJlIG1pbnRlZC4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJtaW50IiwgYWRtaW46IEFkZHJlc3MsIHRvOiBBZGRyZXNzXSwgZGF0YQo9IGFtb3VudDogaTEyOGAAAAAABG1pbnQAAAACAAAAAAAAAAJ0bwAAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA==",
        "AAAAAAAAAFlSZXR1cm5zIHRoZSBuYW1lIGZvciB0aGlzIHRva2VuLgoKIyBQYW5pY3MKCklmIHRoZSBjb250cmFjdCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLgAAAAAAAARuYW1lAAAAAAAAAAEAAAAQ",
        "AAAAAAAAAQxTZXRzIHRoZSBhZG1pbmlzdHJhdG9yIHRvIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBgbmV3X2FkbWluYC4KCiMgQXJndW1lbnRzCgoqIGBuZXdfYWRtaW5gIC0gVGhlIGFkZHJlc3Mgd2hpY2ggd2lsbCBoZW5jZWZvcnRoIGJlIHRoZSBhZG1pbmlzdHJhdG9yCm9mIHRoaXMgdG9rZW4gY29udHJhY3QuCgojIEV2ZW50cwoKRW1pdHMgYW4gZXZlbnQgd2l0aCB0b3BpY3MgYFsic2V0X2FkbWluIiwgYWRtaW46IEFkZHJlc3NdLCBkYXRhID0KW25ld19hZG1pbjogQWRkcmVzc11gAAAACXNldF9hZG1pbgAAAAAAAAEAAAAAAAAACW5ld19hZG1pbgAAAAAAABMAAAAA",
        "AAAAAAAAAEZSZXR1cm5zIHRoZSBhZG1pbiBvZiB0aGUgY29udHJhY3QuCgojIFBhbmljcwoKSWYgdGhlIGFkbWluIGlzIG5vdCBzZXQuAAAAAAAFYWRtaW4AAAAAAAAAAAAAAQAAABM=",
        "AAAAAAAAAVBTZXRzIHdoZXRoZXIgdGhlIGFjY291bnQgaXMgYXV0aG9yaXplZCB0byB1c2UgaXRzIGJhbGFuY2UuIElmCmBhdXRob3JpemVkYCBpcyB0cnVlLCBgaWRgIHNob3VsZCBiZSBhYmxlIHRvIHVzZSBpdHMgYmFsYW5jZS4KCiMgQXJndW1lbnRzCgoqIGBpZGAgLSBUaGUgYWRkcmVzcyBiZWluZyAoZGUtKWF1dGhvcml6ZWQuCiogYGF1dGhvcml6ZWAgLSBXaGV0aGVyIG9yIG5vdCBgaWRgIGNhbiB1c2UgaXRzIGJhbGFuY2UuCgojIEV2ZW50cwoKRW1pdHMgYW4gZXZlbnQgd2l0aCB0b3BpY3MgYFsic2V0X2F1dGhvcml6ZWQiLCBpZDogQWRkcmVzc10sIGRhdGEgPQpbYXV0aG9yaXplOiBib29sXWAAAAAOc2V0X2F1dGhvcml6ZWQAAAAAAAIAAAAAAAAAAmlkAAAAAAATAAAAAAAAAAlhdXRob3JpemUAAAAAAAABAAAAAA==",
        "AAAAAAAAAFtSZXR1cm5zIHRoZSBzeW1ib2wgZm9yIHRoaXMgdG9rZW4uCgojIFBhbmljcwoKSWYgdGhlIGNvbnRyYWN0IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuAAAAAAZzeW1ib2wAAAAAAAAAAAABAAAAEA==",
        "AAAAAAAAAWJUcmFuc2ZlciBgYW1vdW50YCBmcm9tIGBmcm9tYCB0byBgdG9gLgoKIyBBcmd1bWVudHMKCiogYGZyb21gIC0gVGhlIGFkZHJlc3MgaG9sZGluZyB0aGUgYmFsYW5jZSBvZiB0b2tlbnMgd2hpY2ggd2lsbCBiZQp3aXRoZHJhd24gZnJvbS4KKiBgdG9gIC0gVGhlIGFkZHJlc3Mgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSB0cmFuc2ZlcnJlZCB0b2tlbnMuCiogYGFtb3VudGAgLSBUaGUgYW1vdW50IG9mIHRva2VucyB0byBiZSB0cmFuc2ZlcnJlZC4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJ0cmFuc2ZlciIsIGZyb206IEFkZHJlc3MsIHRvOiBBZGRyZXNzXSwKZGF0YSA9IGFtb3VudDogaTEyOGAAAAAAAAh0cmFuc2ZlcgAAAAMAAAAAAAAABGZyb20AAAATAAAAAAAAAAJ0bwAAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA==",
        "AAAAAAAAAzFUcmFuc2ZlciBgYW1vdW50YCBmcm9tIGBmcm9tYCB0byBgdG9gLCBjb25zdW1pbmcgdGhlIGFsbG93YW5jZSB0aGF0CmBzcGVuZGVyYCBoYXMgb24gYGZyb21gJ3MgYmFsYW5jZS4gQXV0aG9yaXplZCBieSBzcGVuZGVyCihgc3BlbmRlci5yZXF1aXJlX2F1dGgoKWApLgoKVGhlIHNwZW5kZXIgd2lsbCBiZSBhbGxvd2VkIHRvIHRyYW5zZmVyIHRoZSBhbW91bnQgZnJvbSBmcm9tJ3MgYmFsYW5jZQppZiB0aGUgYW1vdW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgYWxsb3dhbmNlIHRoYXQgdGhlIHNwZW5kZXIKaGFzIG9uIHRoZSBmcm9tJ3MgYmFsYW5jZS4gVGhlIHNwZW5kZXIncyBhbGxvd2FuY2Ugb24gZnJvbSdzIGJhbGFuY2UKd2lsbCBiZSByZWR1Y2VkIGJ5IHRoZSBhbW91bnQuCgojIEFyZ3VtZW50cwoKKiBgc3BlbmRlcmAgLSBUaGUgYWRkcmVzcyBhdXRob3JpemluZyB0aGUgdHJhbnNmZXIsIGFuZCBoYXZpbmcgaXRzCmFsbG93YW5jZSBjb25zdW1lZCBkdXJpbmcgdGhlIHRyYW5zZmVyLgoqIGBmcm9tYCAtIFRoZSBhZGRyZXNzIGhvbGRpbmcgdGhlIGJhbGFuY2Ugb2YgdG9rZW5zIHdoaWNoIHdpbGwgYmUKd2l0aGRyYXduIGZyb20uCiogYHRvYCAtIFRoZSBhZGRyZXNzIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgdHJhbnNmZXJyZWQgdG9rZW5zLgoqIGBhbW91bnRgIC0gVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gYmUgdHJhbnNmZXJyZWQuCgojIEV2ZW50cwoKRW1pdHMgYW4gZXZlbnQgd2l0aCB0b3BpY3MgYFsidHJhbnNmZXIiLCBmcm9tOiBBZGRyZXNzLCB0bzogQWRkcmVzc10sCmRhdGEgPSBhbW91bnQ6IGkxMjhgAAAAAAAADXRyYW5zZmVyX2Zyb20AAAAAAAAEAAAAAAAAAAdzcGVuZGVyAAAAABMAAAAAAAAABGZyb20AAAATAAAAAAAAAAJ0bwAAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA=="
      ]),
      options
    );
    this.options = options;
    __publicField(this, "fromJSON", {
      allowance: this.txFromJSON,
      authorized: this.txFromJSON,
      approve: this.txFromJSON,
      balance: this.txFromJSON,
      burn: this.txFromJSON,
      burn_from: this.txFromJSON,
      clawback: this.txFromJSON,
      decimals: this.txFromJSON,
      mint: this.txFromJSON,
      name: this.txFromJSON,
      set_admin: this.txFromJSON,
      admin: this.txFromJSON,
      set_authorized: this.txFromJSON,
      symbol: this.txFromJSON,
      transfer: this.txFromJSON,
      transfer_from: this.txFromJSON
    });
  }
  static async deploy(options) {
    return import_contract4.Client.deploy(null, options);
  }
};

// node_modules/passkey-kit/src/sac.ts
var SACClient = class extends PasskeyBase {
  constructor(options) {
    const { networkPassphrase, rpcUrl } = options;
    super(rpcUrl);
    __publicField(this, "networkPassphrase");
    this.networkPassphrase = networkPassphrase;
  }
  getSACClient(SACContractId) {
    return new Client2({
      contractId: SACContractId,
      networkPassphrase: this.networkPassphrase,
      rpcUrl: this.rpcUrl
    });
  }
};
export {
  Client as PasskeyClient,
  PasskeyKit,
  PasskeyServer,
  SACClient,
  SignerKey,
  SignerStore
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@stellar/js-xdr/dist/xdr.js:
  (*! For license information please see xdr.js.LICENSE.txt *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@stellar/stellar-base/lib/auth.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

urijs/src/punycode.js:
  (*! https://mths.be/punycode v1.4.0 by @mathias *)

urijs/src/IPv6.js:
  (*!
   * URI.js - Mutating URLs
   * IPv6 Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/SecondLevelDomains.js:
  (*!
   * URI.js - Mutating URLs
   * Second Level Domain (SLD) Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/URI.js:
  (*!
   * URI.js - Mutating URLs
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

@stellar/stellar-sdk/dist/stellar-sdk-minimal.min.js:
  (*! For license information please see stellar-sdk-minimal.min.js.LICENSE.txt *)

@stellar/stellar-base/lib/auth.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@stellar/stellar-base/lib/auth.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=passkey-kit.js.map
