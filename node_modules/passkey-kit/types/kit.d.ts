import { Client as PasskeyClient } from 'passkey-kit-sdk';
import { xdr, Keypair } from '@stellar/stellar-sdk/minimal';
import type { AuthenticationResponseJSON, AuthenticatorSelectionCriteria } from "@simplewebauthn/types";
import { startRegistration, startAuthentication } from "@simplewebauthn/browser";
import { Buffer } from 'buffer';
import type { SignerKey, SignerLimits, SignerStore } from './types';
import { PasskeyBase } from './base';
import { AssembledTransaction, type Tx } from '@stellar/stellar-sdk/minimal/contract';
import type { Server } from '@stellar/stellar-sdk/minimal/rpc';
export declare class PasskeyKit extends PasskeyBase {
    rpc: Server;
    rpcUrl: string;
    private walletKeypair;
    private walletPublicKey;
    private walletWasmHash;
    private timeoutInSeconds;
    private WebAuthn;
    keyId: string | undefined;
    networkPassphrase: string;
    wallet: PasskeyClient | undefined;
    constructor(options: {
        rpcUrl: string;
        networkPassphrase: string;
        walletWasmHash: string;
        timeoutInSeconds?: number;
        WebAuthn?: {
            startRegistration: typeof startRegistration;
            startAuthentication: typeof startAuthentication;
        };
    });
    createWallet(app: string, user: string): Promise<{
        rawResponse: import("@simplewebauthn/browser").RegistrationResponseJSON;
        keyId: Buffer<ArrayBufferLike>;
        keyIdBase64: string;
        contractId: string;
        signedTx: Tx;
    }>;
    createKey(app: string, user: string, settings?: {
        rpId?: string;
        authenticatorSelection?: AuthenticatorSelectionCriteria;
    }): Promise<{
        rawResponse: import("@simplewebauthn/browser").RegistrationResponseJSON;
        keyId: Buffer<ArrayBufferLike>;
        keyIdBase64: string;
        publicKey: Buffer<ArrayBufferLike>;
    }>;
    connectWallet(opts?: {
        rpId?: string;
        keyId?: string | Uint8Array;
        getContractId?: (keyId: string) => Promise<string | undefined>;
        walletPublicKey?: string;
    }): Promise<{
        rawResponse: AuthenticationResponseJSON | undefined;
        keyId: Buffer<ArrayBufferLike>;
        keyIdBase64: string;
        contractId: string;
    }>;
    signAuthEntry(entry: xdr.SorobanAuthorizationEntry, options?: {
        rpId?: string;
        keyId?: 'any' | string | Uint8Array;
        keypair?: Keypair;
        policy?: string;
        expiration?: number;
    }): Promise<xdr.SorobanAuthorizationEntry>;
    sign<T>(txn: AssembledTransaction<T> | Tx | string, options?: {
        rpId?: string;
        keyId?: 'any' | string | Uint8Array;
        keypair?: Keypair;
        policy?: string;
        expiration?: number;
    }): Promise<AssembledTransaction<T>>;
    addSecp256r1(keyId: string | Uint8Array, publicKey: string | Uint8Array, limits: SignerLimits, store: SignerStore, expiration?: number): Promise<AssembledTransaction<null>>;
    addEd25519(publicKey: string, limits: SignerLimits, store: SignerStore, expiration?: number): Promise<AssembledTransaction<null>>;
    addPolicy(policy: string, limits: SignerLimits, store: SignerStore, expiration?: number): Promise<AssembledTransaction<null>>;
    updateSecp256r1(keyId: string | Uint8Array, publicKey: string | Uint8Array, limits: SignerLimits, store: SignerStore, expiration?: number): Promise<AssembledTransaction<null>>;
    updateEd25519(publicKey: string, limits: SignerLimits, store: SignerStore, expiration?: number): Promise<AssembledTransaction<null>>;
    updatePolicy(policy: string, limits: SignerLimits, store: SignerStore, expiration?: number): Promise<AssembledTransaction<null>>;
    remove(signer: SignerKey): Promise<AssembledTransaction<null>>;
    private secp256r1;
    private ed25519;
    private policy;
    private getSignerLimits;
    private getSignerKey;
    private encodeContract;
    private getPublicKey;
    private compactSignature;
}
